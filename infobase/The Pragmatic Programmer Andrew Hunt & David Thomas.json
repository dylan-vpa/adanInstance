{
  "title": "The Pragmatic Programmer Andrew Hunt & David Thomas",
  "source": "Libros/The Pragmatic Programmer Andrew Hunt & David Thomas.pdf",
  "content": "Hunt, Thomas The Pragmatic Programme r 2 Fron t Matter Table of Contents Abou t the Author Pragm atic Programm er, The: From Journeym an to Master Andrew Hunt David Thomas Publisher: Addison Weley s First Edition O ctober 13, 1999 ISBN: 0-201-61622-X, 352 pa ges Buy Print Ve rsion Straight from the programming trenches, The Pragmatic Pr ogramme r cuts through the increasing specializatio n and technicalities of m odern software development to examine the core proces s--taking a requirement and produ cing work ing, maintainable co de that delights its u sers. It covers topics rang ing from personal responsibility an d career devel opment to a rchitectural techniques for keepi ng your c ode flexible a nd easy t o adapt and reuse. Read this boo k, and you’ ll lear n how to: Fight so ftware rot; Avoid the trap of duplicatin g knowledge; Write flex ible, dynamic, an d adaptable code; Avoid programming by coincidence; Bullet-p roof your cod e with contracts, asse rtions, and e xceptions; Capture real requirements; Test ruthlessly and effectively; Delight your users; Build team s of pragmatic programmers; an d Make your developments more precise with automation. Written as a series of sel f-contained sectio ns and filled with en tertain ing anecdo tes, thoughtful examples, an d interestin g analogies, The Pragma tic Prog rammer illustrates the best practices an d major pitfalls of many different aspe cts of software devel opment. Whet her you’re a ne w coder, an experienced programmer, or a manager responsible for software proj ects, u se these lesson s daily, an d you ’ll quickly see i mprovemen ts in personal productivity, accurac y, and job satisfaction. You’ll learn skills and de velop habits and attitudes that form the foundatio n for long-term success in your career. You’ll becom e a Pra gmatic Programmer. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 2 Hunt, Thomas The Pragmatic Programme r 3 Foreword As a review er I got an early opportunity to read the book you are holding. It was great, even in draft form. Dave Thom as and Andy Hunt have som ething to say, and they know how to say it. I saw what they were doing and I knew it would work. I as ked to w rite this foreword so that I could explain why. Simply put, this book tells you how to program in a way that you can follow. You wouldn' t think that that would be a hard thing to do, but it is. Why? For one thing, not all programm ing books are written by programm ers. Many are com piled by langua ge designers, or the journalists who work with them to prom ote their creat ions. Those books tell you how to talk in a programming language—which is certainly im porta nt, but that is only a sm all pa rt of what a programmer does. What does a programm er do besides talk in program ming language? Well, that is a deeper issue. Most prog rammers would have troub le explainin g what they do. Programm ing is a job filled with details, and keeping track of thos e details requires focus. Hours dr ift by and the code appears. You look up and there are all of thos e statem ents. If you don' t think carefully, you m ight think that programm ing is just typing statem ents in a pr ogramming language. You would be wrong, of course, but you wouldn' t be able to tell by looking around the programm ing section of the bookstore. In The Pragmatic Programmer Dave and Andy tell us how to program in a way that we can follow. How did they get so sm art? Aren' t they just as focused on details as other programm ers? The answer is tha t they paid attentio n to what th ey were doi ng while the y were doin g it—and th en they tried to do it be tter. Imagine that you are sitting in a m eeting. Maybe you are thinking that the m eeting could go on forever and that you would rather be programm ing. Dave and Andy would be thinking about why they were having the m eeting, and w ondering if ther e is som ething else they could do that would take the place of the m eeting, and deciding if that som ething could be autom ated so that the work of the m eeting just happens in the future. Then they would do it. That is just the way Dave and Andy think. That meeting wasn' t som ething keeping them from programm ing. It was programm ing. And it was programm ing that could be im proved. I know they think th is way because it is tip num ber two: Thin k About Your W ork. So im agine that these guys are thinking this way for a few ye ars. Pretty soon they would have a colle ction of solution s. Now im agine them using their so lution s in the ir work for a few more years, and discarding the ones that are too hard or don' t always produce results. Well, that approach just about defines pragmatic. Now i magine them taking a year o r two more to write their s olutions down. You m ight think, That inform ation would be a gold mine. And you would be right. The authors tell us how they program . And they te ll us in a w ay that we c an follow. But the re is more to this second statem ent than you m ight think. Let m e explain. The authors have been careful to avoid proposing a theory of software developm ent. This is fortunate, because if they had they would be oblig ed to warp each chap ter to defend th eir theory. Such warping is the tradition in, say, the physical sciences, where th eories eventually becom e laws or are quietly discarded. Program ming on the other hand has few (i f any) laws. So programm ing _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 3 Hunt, Thomas The Pragmatic Programme r 4 advice shaped around wanna-be laws m ay sound good in writing, but it f ails to satisf y in practice. This is what goes wrong with so m any m ethodology books. I've studied this problem for a dozen years a nd found the m ost prom ise in a device called a pattern language. In short, a pattern is a solution, and a pattern languag e is a system of solutions that reinforce each other. A whole community has form ed around the search for these system s. This book is m ore than a collection of tips. It is a pattern language in sheep' s clothing. I say that because each tip is d rawn from experience, told as concrete advice, and related to o thers to form a system . These are the characterist ics that allow us to learn an d follow a pattern language. They work the sam e way here. You can follow the advice in th is boo k because it is concrete. You won' t find vague ab straction s. Dave and Andy write d irectly for yo u, as if each tip was a v ital strategy for energ izing your programm ing career. They m ake it simple, they te ll a story, they use a light touch, and then they follow that up with answers to questi ons that will com e up when you try. And there is m ore. After you read ten or fifteen tips you will begin to see an extra dimension to the work. W e som etimes call it QWAN, short for the quality without a name. The book has a philosophy that will ooze into you r consciousness and m ix with your own . It doesn' t preach. It ju st tells what works. But in the telling more com es through. Th at's the beauty of th e book: It em bodies its philosophy, and it does so unpretentiously. So here it is: an easy to read—and use—book a bout the whole practice of programm ing. I' ve gone on and on about why it works. You probably on ly car e that it does work. It does. You will see. —Ward Cunningham _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 4 Hunt, Thomas The Pragmatic Programme r 5 Preface This book will h elp you beco me a better programm er. It doesn' t matter whether you are a lone developer, a member of a large projec t team , or a consultant working with m any clients at on ce. This book will help you, as an ind ividual, to do better work. This book isn' t theoretical—we concentrate on pract ical topics, on using y our experience to m ake more informed decisions. The word pragmatic comes from the Latin pragmaticus— \"skilled in business \"—which its elf is derived from the Greek , meaning \"to do.\" This is a book about doing. Programm ing is a craft. At its sim plest, it com es down to getting a com puter to do what you want it to do (or what your user wants it to do). As a programm er, you are pa rt listener, part advisor, part interpreter, and part dictator. Y ou try to capture elusiv e requirem ents and find a way of expressing them so that a m ere machine can do them justice. You try to docum ent your work so that others can understand it, and you try to engineer your work so that others can build on it. W hat's more, you try to do all this agains t the relen tless tic king of the project clock. You work sm all m iracles every day. It's a difficult job. There are many people offering you help. Tool vendor s tout the m iracles their products perform . Methodology gurus prom ise that their techniques guarantee results. Everyone claim s that their programm ing language is the best, a nd every operating system is the answer to all conceivable ills. Of course, none of this is true. There are no easy answers. There is no such thing as a best solu tion, be it a tool, a language, or an opera ting system . There can only be sy stem s that are more appropriate in a particu lar set of circum stances. This is where pragm atism com es in. You shouldn' t be wedded to any particular technology, but have a broad enough background and experience ba se to allow you to choose good solutions in particular situations. Your background stem s from an understanding of the basic principles of computer science, and your experience com es from a wide range of practical projects. Theory and practice combine to m ake you strong. You adjust your approach to su it the current circum stances and e nvironm ent. You judge the relative importance of all the factors affecting a projec t and use your experience to produce appropriate solutions. And you do this continuously as the work progresses. Pragm atic Programmers get the job done, and do it well. Who Should Read This Book ? This book is aim ed at people who want to becom e more effective and m ore productive programm ers. Perhaps you feel frustrated that you don' t seem to be achieving your potential. Perhaps you look at colleagues who seem to be us ing tools to m ake them selves m ore productive than you. Maybe your current job uses older technologies, and you want to know how newer ideas can be applied to what you do. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 5 Hunt, Thomas The Pragmatic Programme r 6 We don' t pretend to have all (or even m ost) of the answers, nor are all o f our ideas a pplicab le in all situations. A ll we can say is that if you follo w our approach, you' ll gain experience rapidly, your productivity will in creas e, and you' ll have a better unders tanding of the en tire develop ment process. And you' ll write better software. What Mak es a Pragmatic Programmer? Each developer is unique, with individual strength s and weaknesses, preferen ces and dislikes. Over time, each will craft his o r her own pe rsonal en vironm ent. That environm ent will reflec t the programm er's individuality just as forcefully as his or her hobbies, clothing, or haircut. However, if you're a Pragm atic Programm er, you' ll shar e many of the following characteristics: • Early adopter/fast adapter. You have an instinct for technologies and tech niques, and you love tr ying things out. When given som ething new, you can grasp it quickly and integrate it with the rest of your knowledge. Your confidence is born of experience. • Inquisitive. You tend to ask questions. That's neat—how did you do t hat? Did you have problems with that library? What's this BeOS I've heard about? How are symbolic links implemented? You are a pack rat for little facts, each of which m ay affect som e decision years from now. • Critica l thinker. You rarely take thing s as given with out first getting the facts . When colleagues say \"b ecause that's the way it' s done,\" or a vendor prom ises the solution to all your problem s, you s mell a challenge. • Realist ic. You try to u nderstand th e underly ing nature of each problem you face. This realism gives you a good feel for how difficult th ings are, and h ow long thin gs will take. Understanding for yourself that a process should be difficult or will take a w hile to com plete gives you the stam ina to keep at it. • Jack of all trades. You try hard to be fam iliar with a b road range of technologies and environ ments, and you work to keep abreast of new developm ents. Although your current job may require you to be a specialist, you will always be able to move on to new areas and new challenges. We've left the m ost basic chara cteristics un til last. All Pragm atic Prog ramm ers share them . They' re basic enough to state as tips: Tip 1 _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 6 Hunt, Thomas The Pragmatic Programme r 7 Care About Your Craft We feel that there is no point in developi ng software unless you care about doing it well. Tip 2 Think! About Your W ork In order to be a Pragm atic Programmer, we' re challenging you to think about what you' re doing while you' re doing it. This isn' t a one-tim e aud it of current practices—it' s an ongoing critical appraisal of every decision you m ake, every day, and on every development. Never run on auto- pilot. Cons tantly be think ing, critiqu ing your work in real time. The old IBM corporate m otto, THINK!, is the Pragm atic Programmer' s mantra. If this sounds like hard work to you, then you' re exhibiting the realistic characteristic. This is going to take up som e of your valuable time—tim e that is probably alre ady under trem endous pressure. The reward is a m ore active involvem ent with a job you love, a feeli ng of m astery over an increasing range of subjects, and pleasure in a feeling of cont inuous im provem ent. Over the long term, your tim e invest ment will b e repaid as you a nd your team becom e more efficient, write cod e that's easier to m aintain, and spend le ss tim e in meeting s. Individual Pragmatists, Lar ge Teams Some people feel that there is no room for i ndividuality on large team s or com plex projects. \"Software construction is an engin eering discipline,\" they say, \"tha t breaks down if individual team members make decision s for them selves.\" We disagree. The construction of software should be an engineering discipline. However, this doesn' t preclude individual craftsm anship. Think about the large ca thedrals built in Europe during the Middle Ages. Each took th ousands of person-years of effort, spread over m any decades. Lessons learned were passed down to the next set of builders, who advanced the state of stru ctural engineering with their accom plishm ents. But the carpen ters, stonecu tters, carv ers, and glass workers were all craftspeop le, interpreting the engin eering requ irements to produce a whole that tr anscended the purely mechanical side of the construction. It was thei r belief in their indivi dual contributions that sustained the projects: We who cut mere stones must al ways be envisioning cathedrals. —Quarry w orker's creed Within the overall structure of a project there is always room for individuality and crafts manship. This is particularly true give n the current state of software engineering. One hundred years from _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 7 Hunt, Thomas The Pragmatic Programme r 8 now, our engineering may seem as archaic as the techniques used by m edieval cathed ral bu ilders seem to today' s civil engineers, whil e our craftsm anship will still b e honored. It's a Continuous Process A tourist visiting England's Eton College asked the gardener how he got the lawns so perfect. \"That's easy,\" he replied , \"You just b rush o ff the dew every m orning, mow them every other day, and roll them once a week.\" \"Is that all?\" asked the tourist. \"Absolutely,\" replied the gardener. \"Do that for 500 years and you'll have a nice lawn, too.\" Great lawns need sm all amounts of daily care , and so do great programmers. Managem ent consultants like to drop the word kaizen in conversations. \"Kaizen\" is a Japanese term that captures the concept of continuously m aking many small im prove ments. It was considered to be one of the main reasons for the dram atic gains in productivity and quality in Japanese manufacturing and was widely copied throughout the world. Kaizen applie s to individuals, too. E very day, work to refine the skills you have and to add new tools to your re pertoire. Unlike the Eton lawns, you' ll start seeing results in a m atter of days. Over the years, you' ll be am azed at how your experien ce has blossom ed and your skills have grown. How the Book Is Organiz ed This book is written as a collection of short sections. Each section is self-contained, and addresses a particular topic. You' ll find num erous cross references, which help put each topic in context. Feel free to read the sections in any order—this isn't a book you need to read front-to-back. Occasionally you' ll come across a b ox labeled Tip nn (such as Tip 1, \"C are About Your Craft\" on page xix). A s well as em phasizing points in the te xt, we feel the tips have a life of their own—we live by them daily. You' ll find a summ ary of all the tips on a pull-ou t card inside the back cover. Appendix A contains a set of resources: the book' s bib liography, a list of URLs to W eb resources, and a list of recomm ended periodicals, books, an d professional organiza tions. Throughout the book you'll find references to the bibliogra phy and to the list of URLs—such as [ KP99 ] and [URL 18], respec tively. We've inclu ded exercises and challenges where a ppropriate. Exercises norm ally have relatively straightforward answers, while the challenges are m ore open-ended. To give you an idea of our thinking, we' ve included our an swers to the exercises in Appendix B , but very few have a single correct solution. The challenges m ight form the basis of group discussions or essay work in advanced programm ing courses. What's in a Name? \"When I use a word,\" Humpty Dumpty said, in rath er a scornful tone, \"it means just what I choose it to mean—neither more nor less.\" _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 8 Hunt, Thomas The Pragmatic Programme r 9 Lewis Carroll, Through the Looking-Glass Scattered throughout the book you' ll find various bits of jargo n—either perfectly good English words that h ave been co rrupted to m ean som ething technical, or horrendous m ade-up words that have been assigned m eanings by computer scientis ts with a grudge against the language. The first time we use each of these jargon words, we try to define it, o r at least g ive a hint to its m eaning. However, we' re sure that som e have falle n through the cracks, and others, such as object and relational database, are in comm on enough usage that adding a definition would be boring. If you do com e across a term you haven' t seen before, pleas e don' t just skip over it. Take tim e to look it up, perhaps on the W eb, or m aybe in a com puter scien ce textbook. And, if you get a chance, drop us an e-mail and com plain, so we can a dd a definition to the next edition. Having said all this, we decided to get revenge against the computer scientists. Som etimes, there are perfectly go od jargon w ords for con cepts, words that we' ve decided to ig nore. W hy? Because the existing jargon is norm ally restricted to a particul ar problem dom ain, or to a particular phase of developm ent. However, one of the basic philosophies of this book is that m ost of the techniques we're recomm ending are universal: modularity app lies to code, designs, docum entation, and team organization, for instance. W hen we wanted to use the conventional jar gon word in a broader context, it got confusing—we couldn' t seem to ove rcom e the baggage the original term brought with it. W hen this happened, we contributed to the de cline of the language by i nventing our own term s. Source Code and Other Resources Most of the code shown in this book is extracted from com pilable source files, available for download from our W eb site: http://www.pragm aticprogramm er.com There you' ll also find links to resources we find useful, along with updates to the book and news of other Pragm atic Programmer developm ents. Send Us Fe edback We'd appreciate hearing from you. Comm ents, sugges tions, errors in the text , and problem s in the exam ples are all welcome. E-m ail us at ppbook@pragm aticprogramm er.com Acknow ledgments When we started writing this book, we had no id ea how m uch of a team effort it would end up being. Addison-W esley has been brilliant, taking a couple of wet-behind-the-ears hackers and walking us through the whole book-production process, from id ea to camera-ready copy. Many thanks to John Wait and Meera Ravindiran for thei r initial support, Mike Hendrickson, our enthusiastic editor (and a mean cover designer!), Lorraine Ferrier and John Fuller for thei r help with production, and the indefatigable Julie DeBaggis for keeping us all together. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 9 Hunt, Thomas The Pragmatic Programme r 10 Then there were the reviewers: Greg Andress, Mark Cheers, Chris Cleeland, Alistair Cockburn, Ward Cunningham , Mar tin Fowler, Thanh T. Gia ng, Robert L. Glass, Scott Henninger, Michael Hunter, Brian Kirby, John Lakos, Pete McBreen, Carey P. Morris, Jared R ichardson, K evin Ruland, Eric Starr, E ric Vought, Chris Van Wyk, and Debo rra Zukowski. W ithout their careful comm ents and valuable insights, this book w ould be less readable, less accura te, and twice as long. Thank you all for your tim e and wisdom . The second printing of this book benefited greatly fr om the eagle eyes of our readers. Many thanks to Brian Blank, Paul Boal, Tom Ekberg, Brent Fulgham , Louis Paul Hebert, Henk-Jan Olde Loohuis, Alan Lund, Gareth McCaughan, Yoshiki Sh ibata, and Volker Wurst, both for finding the mistakes and for having the gra ce to point them out gently. Over the years, we have worked with a large num ber of progressive clients, where we gained and refined the experience we write about here. Recently, we' ve been fortunate to work with Peter Gehrke on several large projects. His support and enthusiasm for our techniques are much appreciated. This book was produced using LATEX, pic, Perl , dvips, ghostview, ispell, GNU make, CVS, Emacs, XEm acs, EGCS, GCC, Java, iContract, and Sm allEiffel, using the Bash and zsh shells under Linux. The staggering thing is that all of this trem endous software is freely available. We owe a huge \"thank you\" to the thousands of Pragm atic Programm ers worldwide who have contributed these and other works to us all. W e'd particular ly like to thank Reto Kram er for his help with iContract. Last, but in no way least, we owe a huge debt to our fa milies. Not only have they put up with late night typing, huge telephone bills, and our perm anen t air of distraction, but they' ve had the grace to read what w e've written, time after tim e. Thank you f or lettin g us dream . Andy Hunt Dave Thomas _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 10 Hunt, Thomas The Pragmatic Programme r 11 Chapter 1. A Pragmatic Philosophy What distinguishes Pragm atic Programmers? We f eel it' s an attitude, a style, a philosophy of approaching problem s and their solutions. They th ink beyond the imm ediate problem , always trying to place it in its larger context, always trying to be aware of the bigger picture. After all, without this larger context, how can you be pragm atic? How can you m ake intelligent com promises and inform ed de cisions? Another key to their success is that they take responsibility f or everything they do, which we discuss in The Cat Ate My Source Code. Being responsible, Pragm atic Programm ers won' t sit idly by and watch their projects fall apart through neglect. In Software Entropy, we tell you how to keep your projects pristine. Most people find change difficult to accept, so metim es for good reasons, som etimes because of plain old inertia. In Stone Soup and Boiled Frogs, we look at a strategy f or instigating change and (in the interests of balance) pres ent th e cautionary tale of an amphibian that ignored the dangers of gradual change. One of the benefits of understand ing the context in which you work is that it becom es easier to know just how good your software has to be. Som etimes near-perfection is the only option, but often there are trade-offs i nvolved. We explore this in Good-Enough Software. Of course, you need to have a broad base of know ledge and experience to pull all of this off. Learning is a continuous and ongoing process. In Your Knowledge Portfolio, we discu ss som e strategies for keeping the m omentum up. Finally, none of us works in a vacuum. W e all spe nd a large amount of tim e interacting with others. Communicate! lists ways we can do this better. Pragm atic programm ing stem s from a philosophy of pragm atic thinking. This chapter sets the basis for that philosophy. The Cat Ate My Source Code The greatest of all weaknesses is the fear of appearing weak. J. B. Bossuet, Politics fr om Holy Wr it, 1709 One of the cornerstones of the pr agmatic philosophy is th e idea of taking respons ibility for yourself and your actions in term s of your career advancem ent, your project, and your day-to-day work. A Pragm atic Programm er takes charge of his or her ow n career, and isn' t afraid to adm it ignorance or error. It' s not the m ost pleasant aspect of pr ogramm ing, to be sure, but it will happen —even on the best of projects. Despite t horough testing, good docum entation, and solid autom ation, things go wrong. Deliveries are late. Unfore seen technical problem s com e up. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 11 These things happen, and we try to deal with them as professionally as we can. This means being honest and direct. W e can be proud of our ab ilities, but we m ust be honest about our shortcom ings—our ignorance as well as our m istakes. Hunt, Thomas The Pragmatic Programme r 12 Take Responsibility Responsibility is som ething you actively agree to . You m ake a comm itment to ensure that something is done righ t, but you don't necessarily have direct contro l over ev ery asp ect of it. In addition to doing your own persona l best, you must analyze the situ ation for risks that are beyond your control. You have the right not to take on a responsib ility for an im possible situation, or one in which the risks are too great. You' ll have to m ake the call based on your own ethics and judgm ent. When you do accept the responsib ility for an outcom e, you s hould expect to be held accountable for it. W hen you m ake a m istake (as we all do) or an error in judgm ent, adm it it honestly and try to offer options. Don' t blame som eone or som ething else, or m ake up an excuse. Don' t blam e all the problem s on a vendor, a programm ing language, m anagem ent, or your coworkers. Any and all of these m ay play a role, bu t it is up to you to provide solutions, not excuses. If there was a risk that the vendor wouldn' t com e through for you, then you should have had a contingency plan. If the disk cr ashes—taking all of your source c ode with it—and you don' t have a backup, it' s your fault. T elling your boss \"the cat ate m y source code\" just won' t cut it. Tip 3 Provide Options, Don' t Make Lam e Excuses Before you approach anyone to tell them why som ething can't be done, is late , or is broken, stop and listen to yourself. Talk to the rubber duck on your monitor, or the cat. Does your excuse sound reasonable, or stupid? How' s it going to sound to your boss? Run through the convers ation in your mind. W hat is the o ther person likely to say ? Will they ask, \"Have you tried this…\" or \"Didn' t you consider that?\" How will you res pond? Before you go and tell them the bad news, is there anythi ng else you can try? Som etimes, you just know what they are going to say, so save them the trouble. Instead of excuses, provide options. D on't say it can' t be done; explain w hat can be done to salvage the situation. Does code have to be thrown out? Educate them on the va lue of refacto ring (s ee Refactoring ). Do you need to spend tim e prototyping to determ ine the best way to pro ceed (see Prototypes and Post-it Notes )? Do you need to intr oduce better te sting (see Code That' s Easy to Test and Ruthles s Testing ) or autom ation (see Ubiquito us Autom ation) to prevent it from happening again? Perhaps you need additional resources. Don' t be afraid to ask, or to adm it that you need help. Try to flush out the lam e excuses bef ore voicing them aloud. If you m ust, tell your cat f irst. After all, if little T iddles is going to take the blam e…. Related sec tions include : • Prototypes and Post-it Notes _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 12 Hunt, Thomas The Pragmatic Programme r 13 • Refactoring • Code That' s Easy to Test • Ubiquitous Autom ation • Ruthless Te sting Challeng es • How do you react when som eone—s uch as a bank teller, an auto m echanic, or a clerk — comes to you with a lam e excuse? What do you th ink of them and their company as a result? Software Entropy While sof tware deve lopment is immune f rom almost all phy sical laws, entropy hits us hard. Entropy is a term from physics that refers to the am ount of \"disorder\" in a system . Unfortunately, the laws of therm odynam ics guarantee that the entropy in th e universe tends toward a m aximum. When disorder increases in software, pr ogrammers call it \"software rot.\" There are many factors that can con tribute to softwa re rot. The m ost important one seem s to be the psychology, or culture, at work on a project. Even if you are a team of one, your project' s psychology can be a very delicate th ing. Despite the best laid plans and the best people, a project can still exp erience ru in and decay d uring its lifetim e. Yet there a re othe r projec ts that, despite enorm ous dif ficulties an d constan t setbacks, su ccessf ully f ight natu re's tendency towa rd disord er and m anage to com e out pretty well. What m akes the difference? In inner cities, som e buildings are b eautiful and clean, while others are rotting hulks. Why? Researchers in the field o f crim e and urban decay discovered a fascinating trigg er mechanism , one that very quickly turns a clean, intact, inhabited building into a smashed and abandoned derelict [WK82 ]. A broken window. One broken window, left unrepaired for any substantial length of tim e, instills in th e inhabitan ts of the building a sense of abandonm ent—a sense that th e powers that be don' t care about the building. So another window gets broken. Peop le start littering. Gra ffiti appears. Serious structural dam age begins. In a relatively short spac e of tim e, the building becom es dam aged beyond the owner' s desire to fix it, and the sense of abandonm ent becom es reality. The \"Broken W indow Theory\" has in spired police departm ents in New York and other m ajor cities to crack down on the sm all stuff in order to keep out the big stuff. It works: keeping on top of broken wind ows, graf fiti, and other s mall inf ractions has redu ced the s erious crim e lev el. Tip 4 Don' t Live with Broken W indows _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 13 Hunt, Thomas The Pragmatic Programme r 14 Don' t leave \"broken windows\" (bad designs, wr ong decisions, or poor code) unrepaired. Fix each one as soon as it is discovered. If there is insufficient tim e to fix it properly, then board it up. Perhaps you can comm ent out the offending code, or display a \"Not Im plem ented\" message, or substitute dummy data instead. Take some action to prevent further dam age and to show that you' re on top of the situation. We've seen clean, functional systems deteriorate pretty quickly once windows start breaking. There are other factors that can contribut e to software rot, and we' ll touch on som e of the m elsewhere, but neglect accelerates the rot faster than any other f actor. You m ay be thinking that no one has the tim e to go around cleaning up all the broken glass of a project. If you continue to thi nk like that, then you' d better plan on getting a dum pster, or m oving to another neighborhood. Don' t let entropy win. Putting Out Fires By contrast, there' s the story of an obscenel y rich acquaintance of Andy' s. His house was immaculate, beautif ul, lo aded with pr iceless an tiques, objets d'art, and so on. One day, a tapestry that was han ging a little too close to h is living room fireplace caught on fire. The fire d epartm ent rushed in to save the day—and his house. But be fore they dragged their big, dirty hoses into the house, they stopped—with the fire raging—to roll out a mat between the f ront door and the source of the fire. They didn' t want to m ess up the carpet. A pretty extrem e case, to be sure, but that' s the way it m ust be with software. One broken window— a badly designed piece o f code, a poor m anage ment decision that the team must live with for the duration of the project— is all it takes to start the decline. If you find yourself working on a project with quite a few broken windows, it' s all too easy to slip into the m indset of \"All the rest of this code is c rap, I'll just f ollow suit.\" I t doesn' t matter if the project has been fine up to this point. In the original experim ent leading to the \"B roken W indow Theory,\" an abandoned car sat for a week untouched. But once a single window was broken, th e car was stripped and turned upside down within hours. By the sam e token, if you find yourself on a team and a project where the code is pristinely beautiful—cleanly written, well des igned, and elegan t—you will likely take ex tra special care no t to mess it up, just like the f irefighters. Even if there' s a fire raging (d eadline, release date, trade show demo, etc.), you don' t want to be the first one to m ake a m ess. Related sections include: • Stone Soup and Boiled Frogs • Refactoring • Pragm atic Team s Challenges _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 14 Hunt, Thomas The Pragmatic Programme r 15 • Help strengthen your team by surveying your computing \"neighborhood.\" Choose two or three \"broken windows\" and discuss with your colleagues what the problem s are and what could be done to fix them. • Can you tell when a window first gets broken ? What is you r reaction ? If it was the result of someone else' s decision, or a m anagem ent edict, what can you do about it? Stone Soup and Boiled Frogs The three soldiers returning home from war were hungry. When they saw the village ahead their spirits lifted —they were sure the villagers would give th em a meal. But when they go t there, they found the do ors locked a nd the wind ows closed. After m any years of war, the vi llagers were short of food, and hoarded what they had. Undeterred, the sold iers boile d a pot of water and care fully placed thre e stones into it. The amazed villagers came out to watch. \"This is stone soup,\" the soldiers explained. \"Is that all you put in it ?\" asked the villagers. \"Absolutely—although s ome say it ta stes even bett er with a few carrots…. \" A villag er ran off, returning in no time with a bas ket of carrots from his hoard. A couple of minutes la ter, the villag ers again asked \"Is tha t it?\" \"Well,\" said the soldiers, \"a couple of potatoes give it body.\" O ff ran another villager. Over the next hour, the soldiers lis ted more ingredients that woul d enhance the soup: beef, leeks, salt, and herbs. Each tim e a different villager would run off to raid their personal stores. Eventually they had produced a large pot of st eaming soup. The soldiers removed the stones, and they sat down with the entire village to enjoy the first square meal any of them had eaten in months. There are a couple of morals in the stone soup st ory. The villagers are tricked by the soldiers, who use the villagers' curiosity to get food from them. But m ore importan tly, th e soldiers a ct as a catalyst, bringing the village together so they can jointly produce som ething that they couldn' t have done by them selves—a synergistic re sult. Eventually everyone wins. Every now and then, you m ight want to em ulate the soldiers. You m ay be in a situation where you know exactly what needs doing and how to do it. The entire system just appears before your eyes—you know it' s right. B ut ask perm ission to tackle the whole thing and yo u'll be m et with delay s and blank stares. People will form committees, b udgets will need approv al, and th ings will get co mplicat ed. E veryone will guard their own resources. Sometimes this is c alled \"sta rt-up f atigue.\" It's time to bring out the stones. W ork out what you can reasonably ask for. Develop it well. Once you've got it, show people, and let them m arvel. Then say \"of course, it would be better if we added….\" P retend it' s not im portant. Sit back an d wait for them to start asking you to add the functionality you origin ally wanted. P eople find it easier to join an ongoin g success. S how them a glimpse of the future and you' ll get them to rally around.[1] _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 15 Hunt, Thomas The Pragmatic Programme r 16 [1] Whi le doing this, you m ay be c omforted by the line attributed to R ear Admiral Dr. Grace Hoppe r: \"It's e asier to a sk forgiveness than it is to get permission.\" Tip 5 Be a Catalyst for Change The Village rs' Side On the other hand, the stone soup sto ry is also about gentle and gradual d eception. It' s about focusing too tightly. The villagers think about the st ones and f orget about the rest of the world. W e all fall for it, every day. Things just creep up on us. We've all seen the sym ptoms. Projects slowly and in exorably get totally out of hand. Most software disasters start out too small to notice, and m ost project overruns happen a day at a time. System s drift from their spe cifications f eature by feature, while patch after patch gets added to a piece of code until there' s nothing of the or iginal lef t. It's often the acc umulation o f small thing s that b reaks morale and team s. Tip 6 Rem ember the Big Pictu re We've never tried this— honest. But they say that if you take a frog and drop it in to bo iling water, it will jum p straight back o ut again. Ho wever, if you place the frog in a pan of cold water, then gradually he at it, the f rog won' t notice the s low increas e in te mperature a nd will stay put until cooked. Note that the frog' s problem is different from the broken windows issue discussed in Section 2 . In the Broken W indow Theory, people lose the will to fight en tropy because they perceive that no o ne else cares. T he frog just doesn' t notice the change. Don' t be like the frog. Keep an eye on the big pi cture. Constantly review what' s happening around you, not just what you personally are doing. Related sec tions include : • Software Entropy • Programm ing by Coincidence • Refactoring • The Requirem ents Pit • Pragm atic Team s Challeng es _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 16 Hunt, Thomas The Pragmatic Programme r 17 • While reviewing a draft of this book, John Lakos raised the following issue: The soldiers progressively deceive th e villagers, but the ch ange they catalyze does th em all good. However, by progressively deceiving the frog, you' re doing it harm . Can you determ ine whether you' re making stone soup or frog soup when you try to catalyze change? Is the decis ion sub jective or ob jective? Good-Enough Software Striving to better, oft we mar what's well. King Lear 1.4 There' s an old(ish) joke about a U.S. com pany th at places an order for 100,000 integrated circuits with a Japanese m anufac turer. Part of the spec ification was the defect rate: one chip in 10,000. A few weeks later the order arrive d: one large box containing thousa nds of ICs, and a sm all one containing just ten. Attached to the sm all box wa s a label that read: \"These are the faulty ones.\" If only we really had this kind of control over qu ality. But the real world just won' t let us produce much that' s truly perfect, part icularly not bug-free software. Ti me, technology, and temperam ent all conspire against us. However, this doesn' t have to be frustrati ng. As E d Yourdon described in an article in IEEE Software [You95 ], you can discipline yourself to wr ite software that' s good enough—good enough for your users, for future m aintainers, for your own peace of m ind. You' ll find that yo u are m ore productive and your users are happier. And you may well find that your program s are actually better for their shorter incubation. Before we go any further, we need to qualify what we' re about to say. The phrase \"good enough\" does not im ply sloppy or poorly produced code. All sy stem s must m eet their users' requirem ents to be successful. W e are simply advocating that user s be given an opportunity to participate in the process of deciding when what you've produced is good enough. Involve Your Users in the Trade-Off Normally you' re writing software for other people. Often you' ll remember to get requirem ents from them .[2] But how often do you ask them how good they want their sof tware to be ? Sometimes there' ll be no choice. If you' re working on pacem akers, the sp ace shu ttle, or a low-leve l library that will be widely diss eminated, the requirem ents will be more stringen t and your options m ore lim ited. However, if you' re working on a brand new pr oduct, you' ll have differe nt constraints. The marketing people will have prom ises to keep, the eventual end users m ay have m ade plans based on a deliv ery schedule, and your com pany will certainl y have cash-flow constraints. It w ould be unprofessional to ignore these users' requirem ents sim ply to add new features to the program , or to polish up the code just one m ore time. W e're not advocating panic: it is equally unprofessional to prom ise im possible tim e scales and to cut bas ic engineering co rners to m eet a dead line. [2] That was sup posed to be a joke ! _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 17 The scope and quality of the system you produce s hould be specified as part of that system' s requirem ents. Hunt, Thomas The Pragmatic Programme r 18 Tip 7 Make Quality a Requirem ents Issue Often you' ll be in situations where trade-offs are involved. Surprisingly, many users would rather use software with som e rough edges today than wait a y ear for the m ultimedia vers ion. Many IT departm ents with tight budgets would agree. Great software today is often preferable to perfect software to morrow. If you give your users som ething to play with early, th eir feedback will often lead you to a better ev entual solution (see Tracer Bullets ). Know Whe n to Stop In som e ways, programming is like painting. You start with a blank canvas and certain basic raw materials. Y ou use a combination of science, art, and craf t to determ ine wh at to do with them . You sketch ou t an overall shape, paint the underly ing environm ent, then f ill in the details. You constantly step back with a cr itical eye to view what you' ve done. Every now and then you' ll throw a canvas aw ay and start again. But artists w ill tell you that all the h ard work is ruined if you don' t know when to stop . If you add layer upon layer, detail over detail, the painting becomes lost in the paint. Don' t spoil a perfectly good program by overem bellishm ent and over-refinem ent. Move on, and let your code stand in its own right for a while. It ma y not be perfect. Don' t worry: it could never be perfect. (In Chapter 6 , we'll discuss philosophies for develo ping code in an im perfect world.) Related sec tions include : • Tracer Bullets • The Requirem ents Pit • Pragm atic Team s • Great Expectations Challeng es • Look at the m anufacturers of the software t ools and operating system s that you use. Can you find any evidence that these com panies are comf ortable shipping software they know is not perfect? As a user, would you rather (1) wait fo r them to get all the bugs out, (2) have complex software and accept som e bugs, or (3) opt for sim pler software with fewer defects? • Consider th e effect of modular izatio n on the delivery of software. W ill it take m ore or less time to get a monolithic block of software to the required qu ality com pared with a system designed in modules? Can you find commercial exam ples? Your Knowledge Portfolio An investment in knowledge always pays the best interest. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 18 Hunt, Thomas The Pragmatic Programme r 19 Benjamin Franklin Ah, good old Ben Franklin—never at a loss for a pit hy hom ily. W hy, if we could just be early to bed and early to rise, we'd be great programm ers—right? The early bird m ight get the worm , but what happens to the early wor m? In this case, though, Ben really hit the nail on the head. Your know ledge and experience are your most im portant professional assets. Unfortunately, they' re expiring assets.[3] Your knowledge becom es out of date as new techniques, languages, and environm ents are developed. Cha nging m arket forces m ay render your experience obsolete or irrelevant. Given the speed at which Web-years fly by, this can happen pretty quickly. [3] An expiring asset is som ething w hose value diminishe s over time. Examples include a warehouse full o f bananas and a ticket to a ball game. As the value of your knowledge declines, so does your value to your com pany or client. W e want to prevent this from ever happening. Your Knowledge Port folio We like to think of all the facts programm ers k now about com puting, the a pplication dom ains they work in, and all their exp erience as th eir Knowled ge Portfo lios. Managing a knowledge portfolio is very sim ilar to m anaging a financial portfolio: 1. Serious investors invest regularly—as a habit. 2. Diversification is the k ey to long-term success. 3. Smart investors balance their portfolios be tween conservative and high-risk, high-reward investm ents. 4. Investors try to buy low and se ll high for m aximum return. 5. Portfolios should be reviewed and rebalanced periodically. To be successful in your caree r, you must m anage your knowledge portfolio using these sam e guidelines. Building Your Portfolio • Invest regularly. Just as in financial investing, you m ust invest in your knowledge portfolio regularly. Even if it's just a sm all am ount, the habit itself is as important as the sum s. A fe w sam ple goals are listed in the next section. • Diversify. The m ore differ ent things you know, the m ore valuable you are. As a baseline, you need to know the ins and outs of the particular techno logy you are working w ith currently. But don' t stop there. T he face of com puting ch anges rapidly—hot tech nology today m ay well be close _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 19 Hunt, Thomas The Pragmatic Programme r 20 to useless (or at leas t not in dem and) tom orrow. The m ore technologies you are com fortable with, the better you will be ab le to adjust to change. • Manage risk. Technology exists along a spectrum from risky, pot entially high-reward to low-risk, low- reward standards. It' s not a good idea to invest all of your m oney in high-risk stocks that might collapse suddenly, nor should you invest all of it conservatively and m iss out on possible opportunities. Don' t put all y our technical eggs in one basket. • Buy low , sell high. Learning an em erging technology before it becom es popular can be just as hard as finding an undervalued stock, but the payoff can be just as rewarding. Learning Java when it first came out m ay have been risky, but it paid o ff handsom ely for the early adopters who are now at the top of that field. • Review and rebalance. This is a very dynam ic industry. That hot t echnology you started investigating last m onth might be stone cold by now. Maybe you need to brush up on that databa se technology that you haven' t used in a wh ile. Or perhaps you could be better po sition ed for that new job opening if you tried out that other language…. Of all these guidelines, the m ost important one is the sim plest to do: Tip 8 Invest Regularly in Your Knowledge Portfolio Goals Now that you have som e guidelines on what and wh en to add to your knowledge portf olio, what' s the best way to go about acquiring intellectual capita l with which to fund your portfolio? Here are a few suggestions. • Learn at least one new language every year. Different languages solve the sam e problem s in different ways. By learning several different approaches, you can help broaden your thin king and avoid getting stuck in a rut. Additionally, learning many languages is far easi er now, thanks to the wealth of freely available sof tware on the Internet (see page 267). • Read a technical book each quarter. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 20 Hunt, Thomas The Pragmatic Programme r 21 Bookstores are full of technical books on interesting topics rela ted to your current project. Once you' re in the habit, read a book a m onth. After you' ve mastered the technologies you' re currently using, branch out and study som e that don't relate to your project. • Read nontechnical books, too. It is im portant to rem ember that computers are used by people —people whose needs you are trying to satisfy. Don' t forget the human side of the equation. • Take classes. Look for interesting courses at your local community college or university, or perhaps at the next trade show that comes to town. • Partic ipate in local us er groups. Don' t just go and listen, but activ ely participate. Isolation can be deadly to your career; find out what people are working on outside of your com pany. • Experiment w ith different environ ments. If you' ve worked only in W indows , play with Unix at hom e (the freely available Linux is perfect for this). If you' ve used only makefiles and an editor, try an IDE, and vice versa. • Stay curren t. Subscribe to trade m agazines and other jour nals (see page 262 for recomm endations). Choose some that cover technology different from that of your current project. • Get w ired. Want to know the ins and outs of a new la nguage or other technology? Newsgroups are a great way to find out what expe riences other people are having with it, the particular jargon they use, and so on. Surf the W eb for papers , com mercial sites, and any other sources of inform ation you can find. It's important to continue inve sting. Once you feel com fortable with som e new language or bit of technology, move on. Learn another one. It doesn' t matter whether you ever use any of thes e technologies on a project , or even whether you put them on your resum e. The proces s of learni ng will expand your think ing, opening you to new possibilities and new ways of doing things. The c ross-po llination of ideas is im portant; try to apply the lessons you' ve learned to your current project. Even if your proj ect doesn' t use that technology, perhaps you can borrow som e ideas. Get fa miliar w ith object orien tation, for instance, and you' ll write plain C program s differently. Opportunities for Learning _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 21 Hunt, Thomas The Pragmatic Programme r 22 So you' re reading voraciously, you' re on top of all the latest breaking deve lopm ents in your field (not an easy thing to do), and som ebody asks you a question. You don' t have th e faintest idea what the answer is, and freely adm it as much. Don't let it s top ther e. Take it as a personal challenge to find the answer. Ask a guru. (If you don' t have a guru in your office, you should be able to find one on the Intern et: see the box on on the facing page. ) Search the Web. Go to the library.[4] [4] In this era of the Web, many people seem to ha ve forgot ten about re al live libraries filled with research material and sta ff. If you can' t find the answer yourself, find out who can. Don' t let it rest. Talking to other people will help build your personal networ k, and you m ay surprise yourself by finding solutions to other, unrelated problem s along the way. And that ol d portfolio just keeps getting bigger…. All of this reading and research ing takes tim e, and tim e is already in short supply. So you need to plan ahead. Always have som ething to read in an otherwise dead m oment. Tim e spent waiting for doctors and dentists can be a gr eat opportunity to catch up on your reading—but be sure to bring your own magazine with you, or you m ight find y ourself thum bing through a dog-eared 1973 article about Papua New Guinea. Critica l Thinking The last im portan t point is to th ink critically about what you read and hear . You need to ensure that the knowledge in your portfolio is accurate and unswayed by either vendor or m edia hype. Beware of the zealo ts who insist th at their do gma provides the only answer—it m ay or m ay not be applicable to you and your project. Never underestim ate the power of commercialism. Just because a W eb search engine lists a hit first doesn' t mean that it' s the best m atch; the content provider can pay to get t op billing. Just because a bookstore features a book prom inently doesn' t mean it' s a good book, or even popular; they m ay have been p aid to p lace it th ere. Tip 9 Critically Analyze W hat You Read and Hear Unfortunately, there are very few simple answers anym ore. But with your extensive portfolio, and by applying som e critica l analy sis to the Care and Cultivation of Gurus With the global adoption of the Internet , gurus suddenly are as close as your Enter key. So, how do you find one, and how do you get one to talk with you? We find there are som e simple tricks. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 22 Hunt, Thomas The Pragmatic Programme r 23 • Know exactly what you want to ask, and be as specific as you can be. • Fram e your question carefully and politel y. Remem ber that you' re asking a favor; don't seem to be dem anding an answ er. • Once you' ve framed your questioned, stop a nd look again for the answer. Pick out some keywords and search the web. Look for appropriate F AQs (lists of frequently asked questions with answers). • Decide if you want to ask publicly or privately. U senet news-groups are wonderful meeting places for experts on ju st about any top ic, but som e people are wary of these groups' public nature. Alterna tively, you can always e-m ail your guru directly. Either way, use a m eaningful subject line. (\" Need Help!!! \" doesn' t cut it.) • Sit back and be patient. People are b usy, and it m ay take days to get a specific answer. Finally, please be sure to thank anyone who responds you. And if you see people asking questions you can answer, play your part and participate. torren t of technical publications you will read, yo u can unders tand the complex answers. Challeng es • Start lea rning a new lang uage this week. Always programm ed in C++ ? Try Sm alltalk [ URL 13] or Squeak [ URL 14]. Doing Java? Try E iffel [ URL 10] or TOM [ URL 15 ]. See page 267 for sources of other free com pilers and environm ents. • Start reading a new book (but finish this one first' ) If you are doing very detailed implementation and coding, read a book on desi gn and architecture. If you are doing high- level design, read a book on coding techniques. • Get out and talk technology with people who aren' t Involved in your current project, or who don't work for the sam e com pany. Network in your com pany cafeteria, or m aybe seek out fellow enthusiasts at a local user' s group m eeting. Communi cate! I believe tha t it is better to be looked over than it is to be o verlooked. Mae West, Belle of the Nineties, 1934 Maybe we can learn a lesson from Ms. West. It' s not just what you' ve got, but also how you package it. Having th e best ideas, the f inest co de, or the most pragm atic think ing is ultim ately s terile un less you can communicate with other people. A good idea is an orphan without effective communication. As developers, we have to communicate on m any le vels. W e spend hours in m eetings, listening and talking. W e work with end users, trying to understand their needs. W e write code, which communicates our intentions to a m achine and do cuments our thinking for future generations of developers. We write proposals and m emos requesti ng and justifying resource s, reporting our status, and suggesting new approaches. And we work daily within our team s to a dvocate our ideas, m odify _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 23 Hunt, Thomas The Pragmatic Programme r 24 existing practices, and suggest new ones. A large part of our day is spent communicating, so we need to do it well. We've put together a list of ideas that we find useful. Know What You Want to Say Probably the m ost difficult part of the m ore for mal styles of co mmunication used in business is working out exactly what it is you want to say. F iction writers plot out their books in detail before they start, but people writing technical docum ents are often happy to sit down at a keyboard, enter \"1. Introduction,\" and start typing what ever com es into their heads next. Plan what y ou want to s ay. W rite an outlin e. Then ask yourself, \"Does this get across whatever I'm trying to say ?\" Ref ine it until it doe s. This approach is not just app licable to writing do cuments. When you' re faced with an important meeting or a phone call with a m ajor client, jot do wn the ideas you want to communicate, and plan a couple of strategies for getting them across. Know Your Audience You' re communicating only if you' re conveying inform ation. To do that, you need to understand the needs, interests, and cap abilities of your audience. We've all sat in m eetings where a developm ent geek glazes over the eyes of the vice president of m arketing with a long monologue on the m erits of some arcane technology. This isn' t communica ting: it' s just talking, and it' s annoying.[5] [5] The wo rd annoy comes from the Old French enui, which also mean s \"to bore.\" Form a strong m ental picture of your a udience. T he acrostic wisdom , shown in Figure 1.1 on the following page, m ay help. Figure 1.1. The wisdom acrostic—understanding an audience Say you want to suggest a W eb-based system to allow your end users to subm it bug reports. You can pres ent this system in m any diffe rent ways, d epending on your audien ce. End users will appreciate that they can subm it bug reports 24 hours a day without wai ting on the phone. Your marketing departm ent will b e able to use this fact to boost sales. Managers in the supp ort departm ent will have two reasons to be happy: fewer staff will be needed, and problem reporting will be au tomated. Finally, develop ers may enjoy getting ex perien ce with W eb-base d clien t-server technologies and a new database engine. By m aking the appropriate pitch to each group, you' ll get them all excited about your project. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 24 Hunt, Thomas The Pragmatic Programme r 25 Choose Your Moment It's six o' clock on Friday afternoon, following a week when the auditors have been in. Your boss's youngest is in the hospital, it' s pour ing rain outside, and the commute home is guaranteed to be a nightm are. This probably isn' t a good tim e to ask her for a m emory upgrade for your PC. As part of understanding what your audience needs to hear, you ne ed to work out what their priorities are. Catch a m anager who' s just been given a hard tim e by her boss because som e source code got lo st, and you' ll have a m ore recep tive lis tener to your ideas on so urce code repositories. Make what you' re saying relevant in tim e, as well as in content. Som etimes al l it takes is the sim ple question \"Is this a good tim e to talk about…? \" Choose a Style Adjust the style of your delivery to suit your audien ce. Som e people want a for mal \"just the facts\" briefing. Others like a long, wide -ranging chat before getting down to business. W hen it com es to written docum ents, som e like to receive large bound reports, while others expe ct a simple me mo or e-mail. If in doubt, ask. Remember, however, that you are half of the communi cation transaction. If so meone says they need a paragraph describing som ething and you can' t see any way of doing it in less than several pages, tell them so. Re member, that kind of f eedback is a for m of communication, too. Make It Look Good Your ideas are im portant. They deserve a good-lo oking vehicle to convey them to your audience. Too m any developers (and their m anagers) concen trate solely on content when producing written docum ents. We think this is a m istake. Any chef will tell you that you can slave in the kitchen for hours only to ruin your efforts with poor presentation. There is no excuse today for producing poor-looki ng printed docum ents. Modern word processors (along with layout system s such as LaTeX and troff) can produce stunning output. You need to learn just a few basic commands. If your word processor supports style sheets, use them . (Your company may already have define d style sheets that you can use.) Learn how to set page headers and footers. Look at the sam ple docum ents include d with your package to get ideas on style and layout. Check the spellin g, first autom atically and then by ha nd. After awl, their are spelling m iss steaks that the chequer can knot ketch. Involve Your Audience We often find that the docum ents we produce end up being less im portant than the process we go through to produce them. If possible, involve your readers with early drafts of your docum ent. Get their feedback, and pick their brains. You' ll build a good working relationship, and you' ll probably produce a better docum ent in th e pro cess. Be a Listener _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 25 Hunt, Thomas The Pragmatic Programme r 26 There' s one technique that you m ust use if you want people to listen to you: listen to them. Even if this is a situation where you have all the inform ation, even if this is a form al meeting with you standing in front of 20 suits—if you don' t listen to them , they won' t listen to you. Encourage people to talk by asking questions, or have them summ arize what you tell them . Turn t he meeting into a dialog, and you' ll make your point more effectively. W ho knows, you m ight even learn som ething. Get Back to People If you ask som eone a question, you f eel th ey're impolite if th ey don' t respond. But how often do you fail to get back to people when they send you an e-m ail or a mem o asking for infor mation or requesting som e action? In the rush of everyday li fe, it' s easy to forget. Always respond to e-m ails and voice m ails, even if the response is sim ply \"I' ll get back to you later.\" Keeping people informed makes the m far m ore forgiving of the occasion al slip, and m akes them feel that you hav en't forgotten them . Tip 10 It's Both W hat You Say and the W ay You Say It Unless you work in a vacuum , you need to be able to comm unicate. The more effective that communication, the m ore influential you becom e. E-Mail Communication Everything we' ve said about comm unicating in writing applies equally to electronic m ail. E-mail has evolved to the point where it is main-stay of intra- and intercorporate communications. E-m ail is used to discuss contract s, to settle disputes , and as eviden ce in court. But for som e reason, people who would never send out a shabby paper docum ent are happy to fling nasty-l ooking e-m ail around the world. Our e-m ail tips are sim ple: • Proofread before you hit . • Check the spelling. • Keep the form at simple. Som e people read e-m ail using proportional fonts, so the ASCII art pictures you labori ously created will look to them like hen-scratchings. • Use rich-text or HTML form atted m ail onl y if you know that a ll your recipients can read it. Plain text is universal. • Try to keep quoting to a m inimum. No one likes to recieve back their own 100- line e -mail with \"I ag ree\" tacked on . • If you' re quoting other people' s e-m ail, be sure to attribute it, and quote it inline (rath er than as an attach ment). • Don' t flame unless you want it to come back and haunt you later. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 26 Hunt, Thomas The Pragmatic Programme r 27 • Check your list of recipients before sending. A recent Wall Street Journal article described an em ployee who took to di stributing criticism s of his boss over departm ental e-m ail. without realizin g that his boss was included on the distribution list. • Archive and organize yo ur e-m ail–both the im port stuff you receive and the m ail you send. As various m icrosoft and Netscape employees discovered during the 1999 Departm ent of Justice investigation, e- mail is forever. Try to give the same attention and care to e-m ail as you would to any written m emo or report. Summary • Know what you want to say. • Know your audience. • Choose your m oment. • Choose a style. • Make it look good. • Involve your audience. • Be a lis tener . • Get back to people. Related sections include: • Prototypes and Post-it Notes • Pragm atic Team s Challenges • There are several good books that contain sections on communi cations within developm ent team s [Bro95 , McC95 , DL99 ]. Make it a po int to try to r ead all three ov er the nex t 18 months. In addition, the book Dinosaur Brains [Ber96 ] discusses the emotional baggage we all bring to the work environm ent. • The next time you have to give a pres entation, or write a m emo advocatin g som e position, try working through the wisdom acrostic before you start. See if it helps you understand how to position what you say. If appropriate, talk to your a udience afterward and see how accurate you r asses sment of their needs was. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 27 Hunt, Thomas The Pragmatic Programme r 28 _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 28 Hunt, Thomas The Pragmatic Programme r 29 Chapter 2. A Pragmatic Approach There are certain tip s and tricks that apply at all levels of software developm ent, ideas that are almost axiom atic, and processes th at are virtually universal. Howeve r, these appro aches are rarely docum ented as such; yo u'll mostly find them written down as odd sentences in dis cussions of design, project m anagem ent, or coding. In this chapter we' ll brin g these ideas and processes together. The first tw o sections, The Evils o f Duplication and Orthogonality, are closely related. The first warns you not to duplicate knowledge throughout your system s, the secon d not to sp lit any one piece of knowledge acro ss multiple sys tem components. As the pace of change in creas es, it b ecom es harder and harder to keep ou r application s relev ant. In Reversib ility, we'll look at som e techniques that help insulate your projects from their changing environm ent. The next tw o sections are also related. In Tracer Bullets, we talk about a style of developm ent that allows you to gather requirem ents, test designs, and im plement code at the sam e time. If this sounds too good to be true, it is: tracer bullet developm ents are not always applicable. W hen they' re not, Prototypes and Post-it Notes shows you how to use prototyping to test architectures, algorithm s, interfaces, and ideas. As com puter science slowly m atures, designers are producing incr easingly higher-level languages. While the co mpiler th at accepts \"m ake it so\" hasn' t yet been in vented, in Domain Languages we present some m ore modest suggestions that you can im plement for yourself. Finally, we all work in a world of limited tim e and resources. You can survive both of these scarcities better (and keep your bosses happier) if you get good at working out how long things will take, which we cover in Estimating. By keeping these fundamental principles in m ind during developm ent, you can write code that' s better, faster, and stronger. You can even m ake it look easy. The Evils of Duplication Giving a co mputer two contrad ictory pieces of k nowledge was Captain J ames T. Kirk' s preferred way of disabling a m arauding artif icial in telligen ce. Unf ortunately, the sa me principle can be effective in bringing down your code. As programm ers, we collect, organize, m aintain, and harness knowledge. We docum ent knowledge in specifications, we m ake it com e alive in runni ng code, and we use it to provide the checks needed during testing. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 29 Unfortunately, knowledge isn' t stable. It chan ges—often rapidly. Your understanding of a requirem ent may change following a m eeting with the client. The governm ent changes a regulation and som e business logic gets out dated. Tests m ay show that the chosen algorithm won' t work. All this in stability m eans that we spend a large p art of our tim e in m aintenance m ode, reorganizing and reexpressing the knowledge in our system s. Hunt, Thomas The Pragmatic Programme r 30 Most people assum e that m aintenance begins when an application is released, that m aintenance means fixing bugs and enhancing features. W e think these people are wrong. Programmers are constantly in m aintenance m ode. Our understanding changes day by day. New requirem ents arrive as we' re designing or coding. Perhaps the environm ent changes. W hatever the reason, m aintenance is not a d iscrete activity, but a routine part of the entire developm ent process. When we perform maintenance, we have to find and change the representations of things—those capsules of knowledge embedded in the application. The problem is that it' s easy to duplicate knowledge in the specifications, processes, and pr ogram s that we develop, and when we do so, we invite a m aintenance nightm are—one that st arts well before the application ships. We feel that the only way to develop software re liably, and to m ake our developm ents easier to understand and m aintain, is to follow what we call the DRY principle: Every piece of knowledge m ust have a single, unambiguous, authoritative repres entation within a system . Why do we call it DRY? Tip 11 DRY —Don't Repeat Yourself The alternative is to h ave the sam e thing expr essed in two or more places. If you change one, you have to remem ber to change the o thers, or, lik e the alien computers, you r program will be brough t to its knees by a contradiction. It isn't a question of whether you' ll remember: it' s a question of when you'll forget. You' ll find the DRY principle popping up tim e and tim e again throughout this book, often in contexts that have nothing to do with coding. W e feel that it is one of the mo st im portant tools in the Pragm atic Programm er's tool box. In this section we' ll outline the problem s of duplication and suggest general strategies for dealing with it. How Does Duplication Arise? Most of the duplica tion we see f alls in to one of the following categories: • Imposed duplication. Developers feel they have no choice—the enviro nment seems to require duplication. • Inadvertent duplication . Developers don' t realize that th ey are duplicating inform ation. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 30 Hunt, Thomas The Pragmatic Programme r 31 • Impatient duplication. Developers get lazy and duplic ate because it seem s easier. • Interdevelo per duplica tion. Multip le people on a team (or on different team s) duplicate a piece of inform ation. Let's look at these four i's of duplication in m ore detail. Imposed Duplication Sometimes, duplication seem s to be forced on us. Project standards m ay require docum ents that contain dup licated inform ation, or docum ents that duplicate inform ation in the cod e. Multip le target platform s each require th eir own prog ramm ing langua ges, libraries, and d evelopm ent environm ents, which m akes us duplicate shared definitions a nd procedures. Programm ing languages them selves require certain structures that dup licate inform ation. W e have all work ed in situations where we felt powerless to avoid duplication. And ye t often there are ways of keep ing each piece of knowledge in one place, h onoring th e DRY principle, and m aking our lives easier at the sam e time. Here are so me techniques: Multiple representatio ns of information. At the coding level, we often need to have the same infor mation represented in different form s. Maybe we' re writing a client-serve r application, using different la nguages on the client and server, and need to repres ent so me shared structure on both. Perhaps we need a class whose attributes mirror the schem a of a database table. Maybe yo u're writing a book and want to include excerpts of program s that you also will com pile and tes t. With a bit of ingenuity you can normally rem ove the need for duplication. Of ten the answer is to write a s imple filter or code generator. Structur es in m ultiple languages can be built from a common metadata representation using a sim ple code gen erator each tim e the software is built (an exam ple of this is sho wn in Figure 3.4 ). Class def inition s can be gener ated autom atically f rom the online database schem a, or from the m etadata used to build the schem a in the first place. The code extracts in this bo ok are ins erted by a prepro cessor each tim e we f ormat the text. T he trick is to make the process active: th is cann ot be a one-tim e conversion, or we' re back in a po sition of dup licating data. Documentation in code. Programm ers are taught to comm ent their code: g ood code has lots of comments. Unfortunately, they are nev er taugh t why code needs comments: bad code requires lots of comm ents. The DRY principle tells u s to keep the low-leve l knowledge in the code, w here it belongs, and reserve the comm ents for other, high-level expl anations. Otherwise, we 're duplicating knowledge, and every ch ange m eans changing bo th the cod e and the comm ents. The comments will inevitab ly becom e out of date, and untrustworthy comment s are worse th an no comments at all. (See It's All Writing, for more information on comments.) _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 31 Hunt, Thomas The Pragmatic Programme r 32 Documentation and code. You write docum entation, then you write co de. Som ething changes, and you am end t he docum entation and update the code. The docum entation and code both contai n representations of the sam e knowledge. And we all know that in the h eat of the mom ent, with deadlines loom ing and important clients clam oring, we tend to defer the updating of docum entation. Dave once worked on an inte rnation al telex switc h. Quite understandably, the client dem anded an exhaustive test specification and required that th e software p ass all tests on each delivery. To ensure that the tests accurately reflected the specification , the team gene rated them programm atically from the docum ent itself. W hen the client am ended their specification, th e test suite changed autom atically. Once the team convinced the c lient that the procedure was sound, generating acceptance tests typ ically took only a few seconds. Language issues. Many languages im pose considerable duplication in the sou rce. Often this com es about when the language separates a m odule' s interf ace from its im plementation. C and C++ have header files that duplicate the nam es and type information of exported variables, functions, a nd (for C++) classes. Object Pascal even duplicates this infor mation in the sam e file. If you are using rem ote procedure calls or CORBA [ URL 29 ], you' ll duplicate in terface info rmation between the in terface specification and the cod e that im plem ents it. There is no easy technique for overcom ing th e requirem ents of a language. W hile som e developm ent environm ents hide the need for he ader files by generating them autom atically, and Object Pascal allows yo u to abbrev iate repeated function declarations, you are generally stuck with what you' re given. At least with m ost language-based issues, a header file that disagrees with the implem entation will g enerate som e form of compila tion or linkage er ror. You can still get th ings wrong, but at least you' ll be told about it fairly early on. Think also about comm ents in header and im plementation files. There is ab solutely no point in duplicating a function or class he ader comment between the two f iles. Use the head er files to docum ent interface issue s, and the implem entatio n files to do cument the nitty -gritty d etails th at users of your code don' t need to know. Inadvertent Duplicatio n Sometimes, duplication com es about as th e result of m istakes in the design. Let's look at an exam ple from the distribution in dustry. Say our analysis reveals that, am ong other attributes, a truck has a type, a license num ber, and a driver. Sim ilarly, a delivery route is a combination of a route, a truck, and a driver. W e code up some classes based on this understanding. But what happens when Sally calls in sick and w e have to change drivers? Both Truck and DeliveryRoute contain a driver. W hich one do we ch ange? Clearly this duplication is bad. Normalize it accord ing to the underlying business m odel— does a tru ck really h ave a driver as part of its underlying attribute set? Does a route? Or m aybe there needs to be a third object that knits _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 32 Hunt, Thomas The Pragmatic Programme r 33 together a driver, a truck, and a route. W hatever the eventual solution, avoid this kind of unnorm alized data. There is a slightly less o bvious kind of unnor malized data that occurs when we have multip le data elem ents that are m utually dependent. Le t's look at a class representing a line: class Line { public: Point start; Point end; double length; }; At first sigh t, this class m ight appear reason able. A line clearly has a s tart and end, an d will always have a length (even if it' s zero). But we have duplication. The length is de fined by the start and end points: change one of the points a nd the length changes. It' s bette r to m ake the length a calculated field: class ne { Li public: Point start; Point end; double length() { return start.distanceTo(end); } }; Later on in the developm ent process, you m ay choose to violate the DRY principle for perform ance reasons. Frequently this occurs when you need to cache data to avoid rep eating exp ensive operations. The trick is to locali ze the im pact. The violation is not exposed to the outside world: only the m ethods within the class have to worry about keeping things straight. class Line { private: bool changed; double length; Point start; Point end; public: void setStart(Point p) { start = p; changed = true; } void setEnd(Point p) { end = p; changed = true; } Point getStart( void) { return start; } Point getEnd( void) { return end; } double getLength() { if (changed) { length = start.distanceTo(end); changed = false; } return length; } }; _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 33 Hunt, Thomas The Pragmatic Programme r 34 This exam ple also illu strates an im portan t issu e for object-o riented languages such as Java and C+ +. Where possible, always use accessor functions to read and write the at tributes of objects.[1] It will make it easier to add fun ctionality, such as cach ing, in the future. [1] The use of acces sor functions ties in with Meyer 's Unifo rm Access princ iple |Mey97b], which states that \"All services offered by a module should be available through a uniform nota tion, which doe s not betray whether they are Implemented throu gh storage or through computation.\" Impatien t Duplication Every project has tim e pressures—forces that can dr ive the best of us to take shortcuts. Need a routin e sim ilar to one yo u've written ? You' ll be tem pted to copy the original and m ake a few changes. Need a value to repres ent th e maximum num ber of points? If I change the header file, the whole project will get rebuilt. M aybe I should ju st use a literal num ber here; and here; and here. Need a clas s like one in the Java run time? The sour ce is available, so why not just copy it and m ake the changes you need (license provisions notwithstanding)? If you feel this tem ptation, rem ember the hackne yed aphorism \"shortcuts m ake for long delays.\" You m ay we ll save som e seconds now, but at th e potential loss of hours later. Think about the issues surrounding the Y2K fiasco. Many were caused by the laziness of developers not param eterizing the size of date fields or im plementing cen tralized lib raries of date serv ices. Impatient du plica tion is a n easy f orm to dete ct and handle, but it takes discipline and a willingn ess to spend time up front to save pain later. Interdevelo per Duplication On the other hand, perhaps the hardest type of du plication to detect a nd handle occurs between different developers on a project. Entire sets of functiona lity m ay be inadvertently duplicated, and that duplication could go undetected for years, leading to m aintenance problem s. We heard firsthand of a U.S. state whose governm ental computer system s were surveyed for Y2K compliance. The audit tu rned up m ore than 10,00 0 program s, each contain ing its own version of Social Security num ber validation. At a high level, deal with the problem by having a clear design, a strong t echnical project leader (see Pragm atic Team s), and a well-understood division of responsibilities within the design. However, at the m odule level, the problem is more ins idious. Commonly needed functionality o r data that doesn' t fall into an obvious area of re sponsibility can get im plemented m any tim es over. We feel that the best way to deal with this is to encourage active and frequent comm unication between developers. Set up forum s to discuss com mon problem s. (On past projects, we have set up private Usenet newsgroups to allow developers to exchange ideas and ask questions. This provides a nonintrusive way of comm unicating—even across multiple sites—while retain ing a perm anent history of everything said.) Appoi nt a team member as the proj ect librarian, whose job is to facilitate the exchange of knowledge. Have a central place in the source tree where utility routines and scripts can be deposited. And m ake a point of reading other people' s source code and docum entation, either infor mally or during c ode reviews. You' re not snooping—you're learning from them. And rem ember, the access is recip rocal—don' t get twisted ab out other people poring (pawing? ) through your code, either. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 34 Hunt, Thomas The Pragmatic Programme r 35 Tip 12 Make It E asy to Reuse What you' re trying to do is foster an environm ent where it' s easier to find and reuse existing stuff than to write it yourself. If it isn't easy, people won't do it. And if you fail to reuse, you risk duplicating knowledge. Related sec tions include : • Orthogonality • Text Manipulation • Code Generators • Refactoring • Pragm atic Team s • Ubiquitous Autom ation • It's All W riting Orthogonality Orthogonality is a critical concept if you want to produce system s that are easy to design, build, test, and extend. However, the concept of orthogonality is rarely taught directly. Often it is an im plicit feature of various other m ethods and techniques you learn. T his is a mistake. Once you learn to apply the principle of orthogonality directly, you'll notice an immediate improvem ent in the quality of system s you produce. What Is Orthogonality? \"Orthogonality\" is a term borrowed from geom etry. Tw o lines are orthogonal if they m eet at right angles, such as the axes on a graph. In vector term s, the two lines are independent. Move along one of the lines, and your po sition p rojected onto the other doesn' t change. In com puting, the term has com e to signify a ki nd of independence or decoupling. Two or m ore things are orthogonal if changes in one do not aff ect any of the others. In a well-designed system , _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 35 Hunt, Thomas The Pragmatic Programme r 36 the database code will b e orthogonal to the us er interface: yo u can chang e the in terface without affecting the database, and swap databa ses with out changin g the in terface. Before we look at the benefits of orthogonal syst ems, let' s first look at a system that isn' t orthogonal. A No northogonal System You' re on a helicopter to ur of the Grand Canyon when the pilot, who m ade the obvious m istake of eating fish f or lunch, suddenly groans and faints . Fortunately, he left you hovering 100 feet above the ground. You rationalize that the collective pitch lever[2] controls ov erall lift, so lowering it slightly will start a gentle de scent to the ground. However, when you try it, you discover that life isn't that simple. The helicopter' s nose drops, and you start to spiral down to the left. Suddenly you discover that you' re flying a system where every cont rol input has secondary e ffects. Lower the left- hand lever and you need to add compensating backwa rd movement to the right-hand stick and push the right ped al. But then each of these changes affects all of the other controls again. Suddenly you're juggling an unbelievably com plex system , where every change im pacts all the other inputs. Your workload is phenom enal: your hands and feet are constantly m oving, tr ying to balance all the interacting forces. [2] Helicopters have four basic controls. The cyclic is the stick you hold in your right hand. Move it, and the helicopter moves in the corresponding direction. Your le ft hand holds the collective pitch lever. Pull u p on this and you increase the pitch on a ll the blades, generating lift. At th e end of the pitch lever is the throttle. Finally you ha ve two foo t pedals, which vary the amount of ta il rot or thrust and so he lp turn the helicopter. Helicopter controls are decidedly not orthogonal. Benefits of Orthogonality As the helicopter exam ple illu strates, nonorthogonal sy stem s are inherently m ore complex to change and control. W hen com pone nts of any syst em are highly interdependent, there is no such thing as a lo cal fix. Tip 13 Elim inate Ef fects Betwe en Unrela ted Things We want to design com ponents that are self-contained: independent, and with a single, well-defined purpose (what Yourdon and Constantine call cohesion [YC86 ]). W hen components are isolated from one another, you know that you can change one without having to worry about the rest. As long as you don' t change that com ponent' s extern al interfaces, you can be comfortable that you won' t cause problem s that ripple through the entire system . You get two m ajor benefits if you write orthogonal system s: incr eased productivity and reduced risk. Gain Producti vity _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 36 Hunt, Thomas The Pragmatic Programme r 37 • Changes are localized, so development tim e and te sting tim e are reduced . It is eas ier to write relatively sm all, self-contained components th an a single large block of code. Sim ple components can be designed, coded, unit teste d, and then forgotten—there is no need to keep changing existing code as you add new code. • An orthogonal approach also prom otes reuse. If com ponents have specific, well-defined responsibilities, they can be com bined with new com ponents in ways that were not envisioned by their original im plem entors. The m ore loosely coupled your system s, the easier they are to rec onfigure and reengineer. • There is a fairly subtle gain in produc tivity when you com bine orthogonal com ponents. Assum e that one com ponent does M distinct things and another does N things. If they are orthogonal and you combine them , the result does M × N things. However, if the two components are not o rthogonal, there will be overlap, and the result will do less. You g et more functionality per unit effort by com bining orthogonal components. Reduce Risk An orthogonal approach reduces the ri sks inherent in any developm ent. • Diseased sections of co de are is olated. If a m odule is sick, it is les s likely to spread the symptoms around the rest of the system . It is also easier to slice it out and transplant in something new and healthy. • The resultin g system is less fragile. Make sm all changes and fixes to a particular area, and any problem s you generate will be restricted to that area. • An orthogonal system will prob ably b e better te sted, because it will be easier to des ign and run tests on its com ponents. • You will not be as tightly tied to a p articul ar ven dor, product, or platform, because th e interfaces to these third -party com ponents will be isolated to sm aller parts of the overall developm ent. Let's look at som e of the ways you can apply the principle of orthogonality to your w ork. Project Tea ms Have you noticed how som e project team s are effi cient, with everyone knowing what to do and contributing fully, while the m embers of other team s are constantly bickering and don' t seem able to get out of each other' s way? Often this is an orthogonality i ssue. When team s are organized w ith lots of overlap, m embers are confused about responsibilities. Ev ery change needs a m eeting of th e entire team , bec ause any one of them might be affected. How do you organize team s into groups with well -defined responsibilitie s and m inimal overlap? There' s no simple answer. It depends partly on the project and your analysis of the areas of potential change. It also depends on the people you have ava ilable. Our preference is to start by separating infrastructure from application. Each m ajor infrastruc ture com ponent (database, communications interface, m iddleware layer, and so on) gets its o wn subteam . Each obvio us division o f application functionality is sim ilarly divided. Then we look at the people we have (or plan to have) and adjust the group ings accord ingly. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 37 Hunt, Thomas The Pragmatic Programme r 38 You can get an inform al measure of the orthogonalit y of a project team 's structure. S imply see how many peopl e need to be involved in discus sing each change that is requested. The larger the number, the less orthogonal the grou p. Clearly, an orthogonal team is more efficient. (Having said this, we also encourage s ubteam s to co mmunicate constan tly with each o ther.) Design Most developers are familiar w ith the need to design orthogonal system s, although they m ay use words such as modular, component-based, and layered to describe the process. System s should be composed of a set of cooperating modules, each of which implem ents functi onality independent of the others. S ometimes these com ponents are orga nized into layers, each providing a level of abstraction. This layered approach is a powerful way to design orthogonal system s. Be cause each layer us es only the ab straction s prov ided by th e layers below it, you have great flex ibility in changing underlying implem entations without affecting code. Layeri ng also reduces the risk of runaway dependencies between m odules. You' ll often see layering expressed in diagram s such as Figure 2.1 on the next page. Figure 2.1. Typical layer di agram There is an easy test for orthogonal design. Once you have your com pone nts m apped out, ask yourself: If I dramatically change the requirement s behind a particular function, how many modules are affected? In an orthogonal system , the answer should be \"one.\"[3] Moving a button on a GUI panel should not require a change in the da tabase schema. Adding context-sensitive help should not change the b illing sub system . [3] In reality, this is naive. Unle ss you are rema rkably lucky, most real-world re quirements changes will a ffect multiple func tions in t he system. However, if you analyze the change in terms of functions, each functional change should still ideally affect just one module . Let's consider a com plex system for monitoring and controlling a heating plant. The original requirem ent called for a graphical us er interface, but the requirem ents were changed to add a voice response system with touchtone telephone control of the plant. In an orthogonally designed system , you would need to change only those modules associat ed with the user interf ace to handle this: the underly ing logic of controlling the plant would re main unchanged. In fact, if you structure your system carefully, you should be able to support both interfaces with the sam e underlying code base. It's Just a View , talks about writing decoupled code using the Model-View-Controller (MVC) paradigm , which works well in this situation. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 38 Hunt, Thomas The Pragmatic Programme r 39 Also ask yourself how decoupled your design is from changes in the real world. Are you using a telephone num ber as a custom er identifier? W hat happens w hen the phone com pany reassigns area codes? Don't rely on the properties of things you can't control. Toolkits an d Libraries Be careful to preserve the ort hogonality of your system as you intr oduce third-party toolkits and libraries. Choose your technologies wisely. We once worked on a project that required that a certain body of Java code run both locally on a server m achine and remotely on a client m achine. The altern atives for dist ributing classes this w ay were RMI and CORBA. If a class w ere made remo tely accessible u sing RMI, every call to a remote method in that class could potentially throw an exception, which m eans that a naive implem entation would require us to handle the exception whenever our remote classes were used. Using RMI here is clearly not orthogonal: code calling our rem ote classes shou ld not have to be aware of their locations. T he alternative—using CORBA—did not im pose that restriction: we could write code that was unaware of our classes' locations. When you bring in a toolkit (or even a library from other m embers of your team ), ask yourself whether it imposes changes on your code that shouldn' t be there. If an object persistence schem e is transparen t, then it' s orthogonal. If it requires you to create o r access ob jects in a sp ecial way, then it's not. Keeping such details isolated from your c ode has the added benefit of m aking it easier to change vendors in the future. The Enterprise Java Beans (EJB) system is an interesting example of orthogonality. In m ost transaction-orien ted sys tems, the application co de has to delineate the start and end of each transaction. W ith EJB, t his inform ation is expres sed declaratively as m etadata, outside any code. The sam e application code can run in different EJB transaction envi ronm ents with no change. This is likely to be a m odel for m any future environm ents. Another interesting twis t on orthogonality is Aspect-Oriente d Programm ing (AOP), a research project at X erox Parc ([ KLM+97] and [URL 49]). AOP lets you express in one place behavior that would otherwise be distributed throughout your source code. Fo r exam ple, log m essages are norm ally generated by sprinkling ex plicit calls to som e log func tion throughout your source. W ith AOP, you i mplem ent logging orthogonally to the thi ngs being logged. Using the Java version of AOP, you c ould write a log m essage wh en entering any m ethod of class Fred by coding the aspect: aspect Trace { advise * Fred.*(..) { static before { Log.write(\"-> Entering \" + thisJoinPoint.methodName); } } } If you weave this aspect into your code, trace m essage s will be generated. If you don' t, you' ll see no messages. Either way, your or iginal source is unchanged. Coding _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 39 Hunt, Thomas The Pragmatic Programme r 40 Every tim e you write co de you run the risk of re ducing the o rthogonality of your application. Unless you constantly m onitor not just what you are doing but also the larger cont ext of the application, you m ight unintentionally duplicate functionality in som e other module, or express existing knowledge twice. There are several techniques you can use to m aintain orthogonality: • Keep your code decoupled. Write shy code—m odule s that don' t reveal any thing unnecessary to o ther modules and that don't rely on other m odules' implementations. Try the Law of De meter [LH89 ], which we discuss in Decoupling and the Law of De meter. If you need to change an object' s state, get the object to do it for you. This way your code remains isolated from the other code' s implementation and increases the chan ces that you' ll rem ain orthogonal. • Avoid global data. Every tim e your code references global data, it ties itself into the other components that share that data. Even globals that you intend only to read can l ead to trouble (for exam ple, if you suddenly need to change your code to be multi threaded). In general, your code is easier to unders tand and m aintain if you ex plicitly p ass any required context into your m odules. In object-oriented applications, contex t is often passed as parameters to objects' constructors. In other code, you can create struct ures containing the context a nd pass around references to them . The Singleton pattern in Design Patterns [GHJV95 ] is a way of ensuring that there is only one instance of an object of a particular cl ass. Many people use these singleton objects as a kind of global variable (particu larly in languages, such as Ja va, that otherwise do not support the concept of globals). Be careful with singletons—they can also lead to unnecessary linkage. • Avoid similar function s. Often you' ll com e across a set of functions th at all look sim ilar—m aybe they share common code at the s tart and end, but each has a diffe rent central algorithm . Duplicate code is a symptom of structural problem s. Have a look at the Strategy pattern in Design Patterns for a better im plem entation. Get into the habit of being consta ntly critical of your code. Look for any opportunities to reorganize it to im prove its structure and ort hogonality. This process is called refac toring, and it' s so im portant that we' ve dedicated a section to it (s ee Refactoring ). Testing An orthogonally designed and im plem ented system is easier to test. Because the interactions between the system' s components ar e formalized and lim ited, m ore of the system testing can be perform ed at the individ ual module level. This is good news, because m odule lev el (or unit) testin g is considerably easier to specify and perform than integration te sting. In f act, we suggest that every _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 40 Hunt, Thomas The Pragmatic Programme r 41 module have its own un it test bu ilt into its code, a nd that thes e tests be perform ed autom atically as part of the regular build process (see Code That' s Easy to Test ). Building unit tests is itself an in teresting test of orthogonality. What does it take to build and link a unit test? Do you have to drag in a large percentage of the rest of th e system just to get a test to compile or link? If so, you' ve found a module that is not well decoupled from the rest of the system. Bug fixing is also a good tim e to assess the orthogona lity of the system as a whole. When you com e across a problem , assess how localized the fix is . Do you change just one module, or are the changes scattered throughout the en tire system ? When you m ake a cha nge, does it fix everything, or do other problem s mysteriously ar ise? This is a good opportunity to bring autom ation to bear. If you use a source code contro l system (and you will af ter reading Source Code Control ), tag bug fixes when you check the code back in after testing. You can then run m onthly reports analyzing trends in the num ber of source files affected b y each bug fix. Documentation Perhaps surprisingly, orthogonal ity also applies to docum entation. The axes are content and presentation. W ith truly orthogona l docum entation, you should be able to change the appearance dram atically without changing th e content. Modern word proce ssors provide style sheets and macros that help (see It's All W riting). Living w ith Orthogonality Orthogonality is clos ely related to the DRY principle introduced on page 27. W ith DRY, you' re looking to m inimize duplication within a syst em, whereas with orthogonality you reduce the interdependency am ong the system' s com ponents. It may be a clum sy wor d, but if you use the principle of orthogonality, co mbined closely with the DRY principle, you' ll find that the system s you develop are m ore flexible, m ore understandab le, and easier to debug, test, and m aintain. If you' re brought into a project wh ere people are desperat ely struggling to m ake changes, and where every change seem s to cause four other things to go wrong, rem ember the nightm are with the helicopter. T he project probably is not orthogonal ly designed and coded. It' s time to refactor. And, if you' re a helicopter pilot, don' t eat the fish…. Related sec tions include : • The Evils of Duplication • Source Code Control • Design by Contract • Decoupling and the Law of De meter • Metaprogramming • It's Just a View • Refactoring • Code That' s Easy to Test • Evil W izards • Pragm atic Team s _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 41 Hunt, Thomas The Pragmatic Programme r 42 • It's All W riting Challeng es • Consider the difference between large GU I-oriented tools typically found on W indows system s and sm all but combinable co mmand line utilities used at she ll pro mpts. W hich set is more orthogonal, and why? Which is easier to use for exactly the purpose for which it was intended ? Which se t is e asier to com bine with o ther too ls to m eet new challeng es? • C++ supports m ultiple in heritance, an d Java allo ws a clas s to implem ent multip le interfaces. What im pact does using these facilities ha ve on o rthogonality ? Is there a d ifference in impact between using m ultiple inh eritanc e and multip le interfaces? Is the re a differenc e between using delegation and using inheritance? Exercises 1. You are writing a class called Sp lit, which splits input lines into fields . Which of the following two Java class signatures is the m ore orthogonal design? class Split1 { public Split1(InputStreamReader rdr) { ... public void readNextLine() throws IOException { ... public int numFields() { ... public String getField( int fieldNo) { ... } class Split2 { public Split2(String line) { ... public int numFields() { ... public String getField( int fieldNo) { ... } 2. Which will lead to a m ore orthogonal design: m odeless o r modal dialog b oxes? 3. How about procedural languages versus object technology? Which results in a m ore orthogonal system ? Reversib ility Nothing is m ore dangerous than an idea if it's the only one you have. Emil-Auguste Chartier, Propos sur la religion, 1938 Engineers prefer sim ple, single solutions to problem s. Math tests that allow you to proclaim with great confidence that x = 2 are m uch m ore comfortab le than fuzzy, warm essays abou t the m yriad causes of the French Revolution. Managem ent tends to agree with the engineers: single, easy answers fit n icely on spread sheets and project plan s. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 42 Hunt, Thomas The Pragmatic Programme r 43 If only the real world w ould cooperate! Unfortunately, while x is 2 today, it m ay need to be 5 tomorrow, a nd 3 next week. Nothing is foreve r—and if you rely heavily on som e fact, you can almost guarantee that it will chang e. There is alw ays m ore than one way to im plement som ething, and there is usually m ore than one vendor available to provide a third-party product. If you go into a project ham pered by the m yopic notion that there is only one way to do it, you may be in for an unpleasant surprise. Many project team s have their eyes forcibly opened as the future unfolds: \"But you said we'd use database XYZ! We are 85% done coding the project, we can't change now!\" the programmer protested. \"Sorry, but our company decided to standardize on database PDQ instead—for all pr ojects. It's out of my hands. We'll just have to recode. All of you will b e working weekends un til furth er notice.\" Changes don' t have to be that Draconian, or ev en that imm ediate. But as tim e goes by, and your project progresses, you m ay find your self stuck in an untenable pos ition. W ith every critical decision, the project team comm its to a sm aller targ et—a narrower version of reality that has fewer options. By the tim e many critica l decisions h ave been m ade, the targe t becom es so sm all that if it moves, or the wind changes direction, or a butterf ly in Tokyo flaps its wings, you m iss.[4] And you m ay miss by a huge amount. [4] Take a nonline ar, or chaotic, system and apply a small cha nge to one of it s inputs. You m ay get a large and ofte n unpredictable result. The clichéd butte rfly flapping its w ings in Tokyo could be the start of a chain of events tha t ends up generating a torna do in Texas. Does this sound like any projects you kn ow? The problem is that critical d ecisions aren' t easily revers ible. Once you decide to use this vendor' s database, or th at architectural pattern, or a certain deploym ent model (clien t-server v ersus standalon e, for inst ance), you are comm itted to a course o f action that cannot be undone, except at great expense. Reversibilit y Many of the topics in this book are geared to producing flexible, ad aptable software. By sticking to their recom mendations—especially the DRY principle (page 26), decoup ling (page 138), and use of metadata (page 144)—we don' t have to m ake as m any critical, irreversible de cisions. This is a good thing, because we don' t always m ake the best decisions the first tim e around. W e comm it to a certain tech nology only to discov er we can' t hire enough people with the necessary sk ills. W e lock in a certain third-party v endor jus t before they g et bought ou t by their co mpetitor. Requirem ents, users, and hardware change faster th an we can get the software developed. Suppose you decide, early in the project, to use a re lational database from vendor A. Much later, during perform ance testing, you discover that the data base is sim ply too slow, but that the object database from vendor B is faster. W ith m ost conven tional projects, you' d be out of luck. Most of the time, calls to third-party products are entangled throughout the code. But if you really abstracted the idea of a database out—to the point where it simp ly provides persistence as a service—then you have the f lexibility to ch ange horses in m idstream. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 43 Hunt, Thomas The Pragmatic Programme r 44 Similarly, suppose the project begins as a client-server m odel, but then, late in the game, m arketing decides that servers are too expe nsive for som e clients, and they want a stand-alone version. How hard would that be for you? Since it's just a deploym ent issue, it shouldn't take more than a few days. If it w ould take longer, then you haven' t thought about reversibility. The other direction is even m ore interesting. What if the stand-alone product you are m aking need s to be deployed in a client-server or n-tier fas hion? That shouldn't be hard either. The m istake lies in assu ming that any decis ion is cast in stone—and in not preparing for the contingencies that m ight arise. In stead of carving decisions in stone , think of them more as being written in the sand at the beach. A big wave can com e along and wipe them out at any tim e. Tip 14 There Are No Final Decisions Flexible Architecture While m any people try to keep their code flexible, you also need to think about m aintaining flexibility in the areas of architecture, deploym ent, and vendor integration. Technologies such as C ORBA can help insulate por tions of a project from changes in development language or platform . Is the perform ance of Java on that platf orm not up to expectations? Recode the client in C++, and nothing else needs to change. Is the rules e ngine in C++ not flexible enough? Switch over to a Sm alltalk version. W ith a CORBA ar chitecture, you hav e to tak e a hit only for th e component you are replacing; the other components shouldn' t be affected. Are you developing for Unix? Which one? Do you have all of the portability concerns addressed? Are you developing for a particular versi on of W indows? Which one—3.1, 95, 98, NT, CE, or 2000? How hard will it be to support other versions? If you keep decisions soft and pliable, it won' t be hard at all. If you have poor encapsulation, high coupling, and hard-coded logic or param eters in the code, it m ight be i mpossible. Not sure how m arketing wants to deploy the sy stem ? Think about it up front and you can support a stand-alone, client-server, or n-tier m odel just by changing a c onfiguration file. W e've written program s that do just that. Normally, y ou can sim ply hide a th ird-party p roduct behind a well-defined, abstract interface. In fact, we' ve always been able to do so on any project we' ve worked on. But suppose you couldn' t isolate it that cleanly. What if you had to sprinkle certain statem ents liberally throughout the code? Put that requ irement in metada ta, and use som e autom atic m echanism , such as Aspects (see pag e 39) or Perl, to insert the necessary statem ents into the code itself. W hatever m echanism you use, make it reversible. If som ething is added automatic ally, it can be taken out autom atically as well. No one knows what the future m ay hold, especially not us! So enable your c ode to rock-n-roll: to \"rock on\" w hen it can, to roll with the punches when it m ust. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 44 Hunt, Thomas The Pragmatic Programme r 45 Related sec tions include : • Decoupling and the Law of De meter • Metaprogramming • It's Just a View Challeng es • Time for a little quantum mechanics with Schrödinger' s cat. Suppose you have a cat in a closed box, along with a radioac tive particle. The particle ha s exactly a 50% chance of fissioning in to two. If it does, the c at will be k illed. If it doesn 't, the cat will be okay. S o, is the cat dead or alive? According to Schrödinger, the correct answer is both. Every tim e a sub-nuclear reaction takes place that has two possible outcom es, the universe is cloned. In one, the event occurred, in the other it didn' t. Th e cat' s alive in one unive rse, dead in another. Only when you open the box do you know which universe you are in. No wonder coding for the future is difficult. But think of code evolution along the sam e lines as a box full of Schrödinger' s cats: every decision results in a different version of th e future. How m any possible f utures can your code support? Which ones are m ore likely? How hard will it be to support them when the time com es? Dare you open the box? Tracer Bu llets Ready, fire, aim… There are tw o ways to fire a m achine gun in the dark.[5] You can find out exactly where your target is (range, elevation, and azim uth). You can dete rmine the environm ental conditions (tem perature, humidity, air pressure, wind, and so on). You can determ ine the precise specifications of the cartridges and bullets you are us ing, and their interactions w ith the actual gun you are firing. You can then us e tables or a f iring com puter to calcula te the exact bearing and elevation of the barrel. If everything works exactly as specifi ed, your tables are correct, and the environm ent doesn' t change, your bullets should land cl ose to their target. [5] To be pedantic, there are many ways of fir ing a machine gun in t he dark, including closing your eyes and spra ying out bullets. But this i s an analogy, and we 're allowe d to take liberties. Or you could use tracer bullets. Tracer bu llets are loaded at in tervals on the a mmo belt alongs ide regu lar ammunition. When they' re fired, their phosphorus ignites and leaves a pyrotechnic trail from the gun to whatever they hit. If the trace rs are hitting the targe t, then so are th e regular bu llets. Not surprisingly, tracer bulle ts are p referred to the labor of calc ulation. T he feedback is imm ediate, and because they operate in the s ame environm ent as the real ammuniti on, extern al effects are minimized. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 45 Hunt, Thomas The Pragmatic Programme r 46 The analogy m ight be violent, bu t it applies to new projects, pa rticularly when you' re building something that hasn' t been built before. Like the gunners, you' re trying to hit a target in the dark. Because you r users h ave never seen a system like this before, their requirem ents m ay be vague. Because you may be usin g algorithm s, techniqu es, languages, or lib raries y ou aren' t familiar with, you face a large num ber of unknowns. And because proj ects take tim e to com plete, you can pretty much guarantee th e environm ent you' re working in will chang e before you 're done. The classic response is to specify the system to death. Produce ream s of pa per item izing every requirem ent, tying down every unknown, and constraini ng the environm ent. Fire the gun using dead reckoning. One big calculation up front, then shoot and hope. Pragm atic Programm ers, however, tend to prefer usi ng tracer bulle ts. Code That Glow s in the Dark Tracer bu llets work because they ope rate in the sam e environm ent a nd under the s ame constraints as the real bullets. They get to the target fast, so the gunner gets imm ediate feedback. And from a practical standpoint they' re a relatively cheap solution. To get the sam e effect in code, we' re looking for som ething that gets us f rom a requirem ent to som e aspect of the final system qui ckly, visibly, and repeatably. Tip 15 Use Tracer Bullets to Find the Target We once undertook a complex client-ser ver database m arketing project. Part of its requirem ent was the ability to specify and execute temporal queri es. The servers were a range of relational and specialized databas es. The client GUI, written in Object Pascal, used a set of C libraries to provide an interface to the s ervers. The user' s query was s tored on the server in a Lisp-like no tation before being converted to optim ized SQL j ust prio r to execution. There were m any unknowns and m any different environm ents, and no one was too sure how the GUI should behave. This was a g reat oppo rtunity to use tracer cod e. We developed the fram ework for the front end, libraries for representing the queri es, and a structure for converting a stored query into a database- specific query. Then we put it all tog ether and ch ecked tha t it worked. For tha t initia l build, a ll we could do was subm it a query that listed all the rows in a table, but it proved that the UI could talk to the libraries, the libraries could serialize and unserialize a query, a nd the server could generate SQL from the result. Over the following months we gra dually fleshed out this ba sic structure, adding new functionality by augm enting each co mponent of the tr acer co de in parallel. W hen the UI added a new query type, the library grew and the SQ L generation w as made m ore sophisticated. Tracer code is not disposable: you wr ite it for keeps. It con tains all the error check ing, structuring, docum entation, and self-checking that any piece of production code has. It sim ply is not fully functional. However, once you have achieved an end-to-end connection am ong the com ponents of _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 46 Hunt, Thomas The Pragmatic Programme r 47 your system , you can check how close to the targ et you are, adjusting if necessary. Once you' re on target, adding functionality is easy. Tracer d evelopm ent is co nsisten t with the idea that a pro ject is never finish ed: there will always be changes required and functions to ad d. It is an increm ental approach. The conventional alternativ e is a kind of heavy engineering appr oach: code is divided into m odules, which are coded in a vacuum . Modules are com bined into subassem blies, which are then further combined, until on e day you have a com plete app lication. Only then can the application as a whole be presented to the user and tested. The tracer code approach has m any advantages: • Users get to see something w orking early. If you have successfully communicated what yo u are doing (see Grea t Expecta tions ), your users will know they are seeing som ething imm ature. They won' t be disappointed by a lack of functionality ; they' ll be ecstatic to see som e visible p rogres s toward the ir system. They also get to contribute as th e project progresses, increasing their buy-in. These sam e users will likely b e the peop le who' ll tell y ou how close to the targ et each ite ration is. • Developers build a stru cture to w ork in. The m ost daunting piece of paper is the one with nothing written on it. If you have worked out all the end-to-end in teractions of your application, and have em bodied them in code, then your team won' t need to pull as much out of thin air. This m akes everyone m ore productive, and encourages consistency. • You have an integration platform. As the system is connected end-to-end, you have an environm ent to which you can add new pieces of co de once they have been u nit-tes ted. Rather than attem pting a big-bang integration, you' ll be integrating every day (oft en m any tim es a day). The im pact of each new change is m ore apparent, and the inte ractions are m ore lim ited, so debugging and testing are faster and m ore accu rate. • You have something to demonstra te. Project sponsors and top bra ss have a tendency to want to see dem os at the m ost inconvenient tim es. W ith tracer code, you' ll always have som ething to show them . • You have a better feel for progress. In a tracer code developm ent, developers ta ckle use cases one by one. When one is done, they m ove to the next. It is far easier to m easure perform ance and to dem onstrate progress to your user. B ecause each individu al developm ent is sm aller, y ou avoid creating those monolithic b locks of code that are re ported as 95 % com plete week af ter week. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 47 Hunt, Thomas The Pragmatic Programme r 48 Tracer Bullets Don't Alw ays Hit Their Target Tracer bu llets show what you' re hitting. This m ay not always be the target. You then adjust you r aim until the y're on targe t. That' s the point. It's the sam e with tracer code. Y ou use the technique in situations where y ou're not 100% certain o f where you' re going. You shouldn' t be surprised if your first couple of attem pts miss: the user says \"that' s not w hat I m eant,\" or data you need is n't available when you need it, or perform ance problem s seem likely. Work out how to change what you've got to bring it near er the target, and be thankful that you' ve used a lean developm ent m ethodology. A sm all body of code has low inertia— it is easy and quick to change. You' ll be able to gather feedback on your a pplication and generate a new, m ore accurate version faster an d at less co st than with any other m ethod. And because every major application com ponent is re presented in your tracer code, your users can be confident that what they' re seeing is based on real ity, not just a paper specification. Tracer Code versus Prototyping You m ight think that this tracer code concept is nothing m ore than prototyping under an aggressive name. There is a difference. W ith a prototype, you' re aim ing to explore sp ecific asp ects of the final system . With a true p rototype, you will th row away whatever you lash ed together when try ing out the concept, and recode it properl y using the lessons you' ve learned. For exam ple, say you' re producing an application that helps shippers determ ine how to pack odd- sized boxes into con tainers. Am ong other prob lems, the user interface needs to be intuitiv e and th e algorithm s you use to determ ine optim al packing are very complex. You could prototype a user inte rface for your end users in a GUI tool. You code only enough to make the interface respo nsive to user action s. Once they' ve agreed to the layout, you m ight throw it away and recode it, this tim e with the business logic behind it, usi ng the target language. Sim ilarly, you m ight want to prototype a num ber of algorit hms that perform the actual packing. You m ight code functional tests in a high- level, forgiving language such as Perl, and code low-level perform ance tests in som ething closer to the m achine. In any case, once you' d made your decision, you'd start again and code the algorithm s in their final environm ent, interfacing to the real world. This is prototyping, and it is very useful. The tracer code approach addre sses a different problem . You need to know how the application as a whole hangs together. You want to s how your users how the interactions will work in practice, an d you want to give your developers an architectural skeleton on which to hang code. In this case, you might construct a tracer consisting of a trivial implem entatio n of the c ontainer packing algorithm (maybe something like first-com e, first-served) a nd a sim ple but working user interface. Once you have all the com ponents in the application plum bed together, you have a fram ework to show your users and your developers. Over tim e, you add to this fram ework with new functionality, completing stubbed rou tines. But th e framework stays in tact, and you know the system will continue to behave the way it did w hen your first tracer code was com pleted. The distinction is im portant enough to warrant re peating. P rototyping generates disposable code. Tracer code is lean but com plete, an d for ms part of the skeleton of the final system . Think of _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 48 Hunt, Thomas The Pragmatic Programme r 49 prototyp ing as the r econ naissanc e and inte lligence gathering that tak es place bef ore a s ingle trac er bulle t is fired. Related sec tions include : • Good-Enough Software • Prototypes and Post-it Notes • The Specification Trap • Great Expectations Prototype s and Post -it Notes Many different industries use prototypes to try out sp ecific ideas; prototyping is m uch cheaper than full-scale production. Car m akers, for exam ple, m ay build many different prototypes of a new car design. Each one is designed to test a specifi c aspect of the car—the aerodynam ics, styling, structural ch aracteristics, and so on. Perhaps a clay m odel wi ll be bu ilt fo r wind tunnel tes ting, maybe a balsa wood and duct tape model will do for the art departm ent, and so on. Som e car companies take this a step further, and now do a great deal of m odeling work on the com puter, reducing costs even further. In this w ay, risky or uncertain elem ents can be tried out without comm itting to build ing the rea l item . We build software prototypes in the sam e fashion, and for the sam e reasons—to analyze and expose risk, and to offer chances for correction at a greatly reduced cost. Like the car m akers, we can target a prototype to test one or m ore specif ic aspects of a project. We tend to think of prototypes as code-based, but th ey don' t always have to be. Like the car m akers, we can build prototypes out of different m aterials. Post-it notes are great for prototyping dynam ic things such as workflow and application logic. A user in terface can be pr ototyped as a drawing on a whiteboard, as a nonfunctional m ock-up drawn with a pain t program , or with an interface build er. Prototypes are designed to answer just a few questions, so they are m uch cheaper and f aster to develop than applications th at go into production. The code can ignore unim portant details— unim portant to you at the m oment , but probably very im portant to the user later on. If you are prototyping a GUI, for instance, you can get away w ith inco rrect resu lts or data. On the other hand, if you' re just investigating com putational or perform ance aspects, you can get away with a pretty poor GUI, or perhaps even no GUI at all. But if you find yourself in an environm ent where you cannot give up the details, then you need to ask yourself if you are really building a prototype at all. Perhaps a tracer bullet style of developm ent would be more appropri ate in this case (see Tracer Bulle ts). Things to Prototype What sorts of things m ight you choose to investig ate with a prototype? Anyt hing that carries risk. Anything that hasn' t been tried before, or that is absolutely c ritical to the final system . Anything unproven, experim ental, or doubtful. Anything you ar en't comfortable with. You can prototype • Architecture _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 49 Hunt, Thomas The Pragmatic Programme r 50 • New functionality in an existing system • Structu re or contents of external data • Third-party tools or components • Perform ance issues • User interface design Prototyping is a learning experien ce. Its value lies not in the c ode produced, but in the lessons learned. That' s really the point of prototyping. Tip 16 Prototype to Learn How to Use Prototypes When building a prototype, what details can you ignore? • Correctness . You m ay be able to use dumm y data where appropriate. • Completene ss. The prototype m ay function only in a very lim ited sense, perhap s with only one preselected piece of inp ut data and one m enu item . • Robustness. Error checking is likely to be incom plete or m issing entirely. If you stray from the predefined path, the prototype m ay crash and burn in a glorious display of pyrotechnics. That' s okay. • Style. It is p ainful to adm it this in prin t, but prot otype code probably doesn' t have m uch in the way of comm ents or docum entation. You m ay produ ce ream s of docum entation as a result of your experience with the prototype, but com paratively very little on the prototype system itself. Since a prototype should gloss over details, and focus in on specific aspects of the system being considered, you m ay wa nt to im plement prototypes using a very high-level language—higher than the rest of the project (m aybe a language such as Perl, Python, or Tcl) . A high-level scripting language lets you defer m any details (including specifying data types) and still produce a functional (albeit inco mplete or s low) piece of code.[6] If you need to prototype user interfaces, investig ate to ols such as Tcl/Tk, Visual Basic, Powerbuilder, or Delphi. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 50 Hunt, Thomas The Pragmatic Programme r 51 [6] If you are inve stigating absolute (instead of re lative) performance, you will ne ed to stic k to a language that is close in pe rformance to the target language. Scripting languages work well as the \"glue\" to combine low-level pieces into new combinations. Under W indows, Visual Basic can glue togeth er COM controls. More generally, you can use languages such as Perl and Python to bind toge ther low-level C libra ries—either by hand, or autom atically with tools such as the f reely available SW IG [URL 28 ]. Using this approach, you can rapidly assemble existing com ponents into ne w configurations to see how things work. Prototyping Architecture Many prototypes are constructed to model the en tire system under consideration. As opposed to tracer bullets, none of the individual modules in the prototype system need to be particularly functional. In fact, you m ay not even need to code in order to prot otype architecture—you can prototype on a whiteboard, with Post-it notes or index cards. Wh at you are looking for is how the system hangs together as a whol e, again deferring details. Here are som e specific areas you m ay want to look for in the architectural prototype: • Are the responsibilities of the m ajor com ponents well defined and appropriate? • Are the collaborations between m ajor com ponents well defined? • Is coupling m inimized? • Can you identify potential sources of duplication? • Are interface definitions a nd constraints acceptable? • Does every module have an access path to the d ata it needs during execution ? Does it have that access when it need s it? This las t item tends to g enerate the most su rprises and the m ost valu able results from the prototyping experience. How Not to Use Prototypes Before you em bark on any code-based prototyping, m ake sure that everyone understands that you are writing disposable code. Prototypes can be deceptively attractive to people who don' t know that they are just prototyp es. You m ust make it very clear that this code is d isposable, inco mplete, and unable to be com pleted. It's easy to b ecom e misled by the app arent com pleteness of a dem onstrated prototype, and project sponsors or m anage ment may insist on deploying the prototype (or its progeny) if you don' t set the right expectations. Rem ind them that you can build a great prototype of a ne w car out of balsa wood and duct tape, but you wouldn' t try to drive it in rush-hour traffic! If you feel there is a strong possibi lity in your environm ent or cult ure that the purpose of prototype code m ay be misinterpreted, you m ay be better off with the tracer bu llet approach. You' ll end up with a solid fra mework on which to base future developm ent. When used properly, a prototype can save you hu ge am ounts of tim e, money, pain, and suffering by identifying and correcting potential problem spot s early in th e developm ent cycle—th e tim e when fixing m istakes is both cheap and easy. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 51 Hunt, Thomas The Pragmatic Programme r 52 Related sec tions include : • The Cat Ate My Source Code • Communicate! • Tracer Bullets • Great Expectations Exercises 4. Marketing would like to sit down and brainstorm a few We b-page designs with you. They are thinking of clickable im age m aps to take you to other pages, and so on. But they can' t decide on a model for the im age—m aybe it' s a car, or a phone , or a house. You have a list of target pages and content; they' d like to see a few protot ypes. Oh, by the way, you have 15 m inutes. W hat tools m ight you use? Domain Languages The limits of language are th e limits of one's world. Ludw ig Von Wittgens tein Com puter languages influence how you think about a problem, and how you think about communicating. Every language com es with a list of features—buzzwords such as static versus dynam ic typing, early versus late b inding, inherita nce m odels (single, m ultiple, or non e)—all of which m ay suggest or ob scure certain solution s. Designing a s olution with Lisp in m ind will produce different results than a solution based on C-style thinking, and vice versa. Conversely, and we think m ore im portantly, the language of the problem dom ain may also suggest a programm ing solution. We always try to write code using the vocabulary of the application domain (see The Requirem ents Pit, where w e suggest using a project glossary). In som e cases, we can go to the next level and actually program using the vocabulary, syntax, and sem antics—the language—of the dom ain. When you listen to users of a proposed system , they m ight be able to tell you exactly how the system should work: Listen for transactions defined by ABC Regulation 12.3 on a set of X.25 lines, translate them to XYZ Co mpany's format 43B, retrans mit them on the satellite uplink, and store for future analysis. If your users have a number of such well-bounde d statem ents, you can invent a m ini-language tailored to th e applicatio n dom ain that expresses exactly what they want: From X25LINE1 (Format=ABC123) { Put TELSTAR1 (Format=XYZ43B); Store DB; _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 52 } Hunt, Thomas The Pragmatic Programme r 53 This language need not be executable. Initially, it could be simply a way of capturing the user' s requirem ents—a specification. However, you may want to consider taking this a step further and actually im plem enting the language. Your sp ecification has becom e executable code. After you' ve written the applica tion, the users give you a new re quirem ent: transactions with negative balances shouldn' t be stored, and should be sent back on the X.25 lines in the original format: From X25LINE1 (Format=ABC123) { if (ABC123.balance < 0) { Put X25LINE1 (Format=ABC123); } else { Put TELSTAR1 (Format=XYZ43B); Store DB; } } That was easy, wasn' t it? With the p roper suppo rt in place, y ou can program much closer to the application dom ain. W e're not sugge sting that your end users actua lly program in these languages. Instead, you' re giving yourself a tool that lets you work closer to their dom ain. Tip 17 Program Close to the Problem dom ain Whether it' s a sim ple language to configure and c ontrol an application program , or a more com plex language to specify rules or pro cedures, we think you should consid er ways of m oving your project closer to the problem dom ain. By coding at a higher level of abst raction, you are free to concentrate on solving dom ain problem s, and can ignore petty im plementation details. Remember that there are m any users of an app lication. There' s the end user, who understands the business rules and the required ou tputs. There are also second ary users: op erations s taff, configuration and test managers, support and m aintenance programm ers, and future generations of developers. Each of these us ers has their own problem dom ain, and you can generate m ini- environm ents and languages for all of them . _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 53 Domain-Specific Errors If you are writing in the problem dom ain, you c an also perform dom ain-specific validation, reporting problem s in term s your users can understand. Take our switching application on on the facing page. S uppose the user m isspelled the form at nam e: From X25LINE1 (Format=AB123) If this ha ppened in a s tandard , general- purpose programm ing language, you m ight Hunt, Thomas The Pragmatic Programme r 54 receive a standard, genera l-purpose error m essage: Syntax error: undeclared identifier But with a m ini-launguage, you would instead be able to issue an error m essage using the vocabulary of the dom ain: \"AB123\" is not a format. known formats are ABC123, XYZ43B, PDQB, and 42. Implementing a Mini-L anguage At its sim plest, a m ini-language m ay be in a line -oriented, easily parsed form at. In practice, we probably use this form more than any other. It can be parsed sim ply using switch statem ents, or using regular expressions in scri pting languages such as Perl. The answer to Exercise 5 on page 281 shows a simple im plem entation in C. You can also im plement a m ore complex language, with a more form al syntax. The trick here is to define the syntax first us ing a notation such as BNF.[7] Once you have your gramm ar specified, it is norm ally trivial to conver t it into the input syntax for a pars er generator. C and C++ programm ers have been using yacc (or its f reely availab le implem entation, bison [URL 27]) for y ears. These program s are docum ented in detail in the book Lex and Yacc [LMB92 ]. Java program mers can try javaCC, which can be f ound at [ URL 26]. The answer to Exercise 7 on page 282 shows a parser written usin g bison. As it shows, once you know the syntax, it' s really not a lot of work to write simple mini-languages. [7] BNF, or B ackus-Naur Form , lets you spe cify context-free grammars recursive ly. Any good b ook on c ompiler construction o r parsing will c over BNF in ( exhaustive) detail. There' s another way of implem enting a m ini-lan guage: extend an existing one. For exam ple, you could integrate applicat ion-level functionality with (say) Python [ URL 9] and write so mething like[8] [8] Thanks to Eric Vought for this example. record = X25LINE1.get(format=ABC123) if (record.balance < 0): X25LINE1.put(record, format=ABC123) else: TELSTAR1.put(record, format=XYZ43B) DB.store(record) Data Languages and Im pera tive Languages The languages you im plem ent can be used in two different ways. Data languages produce som e form of data structure us ed by an application. These languages are often used to represent configuration inform ation. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 54 Hunt, Thomas The Pragmatic Programme r 55 For exam ple, the sendmail program is used throughout the world for routing e-m ail over the Internet. It has m any excellent features and benef its, which are cont rolled by a thousand-line configuration file , written using sendmail 's own configuration language: Mlocal, P=/usr/bin/procmail, F=lsDFMAw5 :/|@qSPfhn9, S=10/30, R=20/40, T=DNS/RFC822/X-Unix, A=procmail -Y -a $h -d $u Obviously, r eadability is not one of sendmail 's strengths. For years, Microsoft has been usin g a data language that can desc ribe menus, widgets, dialog boxes, and other W indows resources. Figure 2.2 on the next page shows an ex cerpt from a typical resou rce file. This is far eas er to read than the sendmail exam ple, but it is u sed in exactly the s ame way—it is com piled to generate a data structure. Figure 2. 2. Window s .rc fi le Imperative languages take this a ste p further. Here th e language is actually executed, and so can contain statem ents, control c onstructs, and the like (such as the script on page 58). You can also use your own i mperative languages to ease program maintenance. For exam ple, you may be asked to integrate inform ation from a leg acy application into your new GUI developm ent. A common wa y of achieving this is by screen scrap ing; your application conn ects to the mainfram e application as if it were a regular hum an user, issuing keystrokes and \"reading\" the responses it gets back. You could script the inte raction using a m ini-language.[9] [9] In fact, you can buy tools that support just this kind of scripting. You can also investigate open-source packages such as Expect, whic h provide similar capabilities [URL 2 4]. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 55 locate prompt \"SSN:\" Hunt, Thomas The Pragmatic Programme r 56 type \"%s\" social_security_number type enter waitfor keyboardunlock if text_at(10,14) is \"INVALID SSN\" return bad_ssn if text_at(10,14) is \"DUPLICATE SSN\" return dup_ssn # etc... When the application determ ines it is tim e to enter a Social Security num ber, it invokes the interpreter on this script, which then controls the tran saction. If the interpre ter is em bedded within the application, the two can even share data dire ctly (for example, via a callback m echanism ). Here you' re programm ing in the m aintenan ce programm er's dom ain. W hen the m ainfram e application changes, and the fi elds move around, the programmer can simply update your high-level description, rather than groveling around in the details of C code. Stand -Alone and Embe dded Lan guages A mini-language doesn' t have to be used directly by the application to be useful. Many tim es we may use a s pecification language to create artifacts (including m etadata) that are com piled, read-in, or otherwise used by the program itself (see Metaprogramm ing). For exam ple, on page 100 we describe a system in which we used Perl to generate a large num ber of derivations from an original schem a specifi cation. W e invented a com mon language to express the database schem a, and then generated all the form s of it we needed—S QL, C, Web pages, XML, and others. The application didn' t use the specifica tion directly, but it reli ed on the output produced from it. It is comm on to em bed high-level imperative languages directly into your application, so that they execute when your code runs. This is clearl y a powerful capability; you can change your application' s behavior by changing th e scrip ts it reads, all without com piling. This can significan tly simplify maintenance in a dynam ic application dom ain. Easy Development or Easy Main tenance? We've looked at several different grammars, ranging from simple line-oriented form ats to m ore complex grammars that look like real languages. Si nce it takes extra effort to im plement, why would you choose a m ore com plex gramm ar? The trade -off is extendib ility and m aintenance. W hile the code for parsing a \"real\" language m ay be harder to write, it will be m uch easier for people to understand, and to extend in the future with new features and functionality. Language s that are too sim ple may be eas y to parse, but can be cryptic— much like th e sendmail exam ple on page 60. Given that most applications ex ceed their expect ed lifetim es, you' re probably better o ff biting the bullet and adopting the more com plex and readable language up front. The initial effort will be repaid m any tim es in reduced support and m aintenance costs. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 56 Hunt, Thomas The Pragmatic Programme r 57 Related sec tions include : • Metaprogramming Challeng es • Could som e of the requirem ents of your curr ent project be expressed in a dom ain-specific language? Would it be possible to write a compiler or translator that could generate m ost of the code req uired? • If you decide to adopt m ini-languages as a way of programm ing clos er to the problem domain, you' re accepting that som e effort will be required to implem ent them . Can you see ways in which the fram ework you develop fo r one project can be reused in others? Exercises 5. We want to im plement a m ini-language to contro l a sim ple drawing package (perh aps a turtle- graphics system ). The language consists of single-letter comm ands. Some comm ands are followed by a single number. For example, th e following input would draw a rectangle . P 2 # select pen 2 D # pen down W 2 # draw west 2cm N 1 # then north 1 E 2 # then east 2 S 1 # then back south U # pen up Implement the code that parses this language. It should be designe d so that it is sim ple to add new comm ands. 6. Design a BNF gra mmar to parse a tim e specifica tion. All of the following exam ples should be accepted . 4pm, 7:38pm, 23:42, 3:16, 3:16am 7. Implement a parser for the BNF grammar in Exercise 6 using yacc, bison, or a sim ilar parser-generator . 8. Implement the tim e parser using Perl. [Hin t: Regular expressions m ake good parsers.] Estimating Quick! How long will it take to send War and Peace over a 56k m odem line? How m uch disk space will you need for a m illion nam es and addresses ? How long does a 1,000-byte block take to pass through a ro uter? How m any months will it take to deliver y our project? _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 57 Hunt, Thomas The Pragmatic Programme r 58 At one level, these are all m eaningless questio ns—they are all m issing infor mation. And yet they can all be answered, as long as you are com fortabl e estim ating. And, in the process of producing an estim ate, you' ll com e to understand more about the world your program s inhabit. By learning to estim ate, and by developing this skill to the po int where yo u have an in tuitive f eel for the m agnitudes of things , you will be able to sho w an apparent m agical abili ty to determ ine their feasibility. When som eone says \"w e'll send the bac kup over an ISDN line to the central site,\" you' ll be able to know intuitively wh ether this is practical. W hen you' re coding, you' ll be able to know which subsystem s need optim izing and which ones can be left alone. Tip 18 Estim ate to Avoid Surpr ises As a bonus, at the end of this section we' ll reveal the single correct answer to give whenever anyone asks you for an estim ate. How Accurate Is Accu rate Enough? To som e extent, all answ ers are es timates. It' s just that som e are m ore accurate than others. So the first question you have to ask yourself when someone asks you for an estim ate is the context in which your answer will be taken. Do they need high accu racy, or are they looking for a ballp ark figure? • If your gran dmother ask s when you will arriv e, she's probably wondering whether to m ake you lunch or dinner. On the other hand, a dive r trapped underwater and running out of air is probably interested in an answer down to the second. • What' s the value of p? If you' re wondering how much edging to buy to put around a circular flower bed, then \"3\" is probably good enough.[10] If you' re in school, then m aybe \"22/7\" is a good approx imation. If you' re in NASA, then m aybe 12 decim al places will do. [10] \"3\" i s also apparently good enough if you are a legisla tor. In 1 897, Indiana State Legisla ture House Bill No. 2 46 attempted to de cree that henceforth p should have the value of \"3\". The Bill was tabled inde finitely at its se cond re ading when a mathem atics pro fessor pointed out that their powers did not quite extend to pa ssing la ws of nature. One of the interesting things a bout estim ating is that the units you use make a difference in the interpretatio n of the resu lt. If you say that som ething will take about 130 working day s, then peop le will be exp ecting it to co me in pretty close. Howe ver, if you s ay \"Oh, about six m onths,\" then they know to look for it any tim e between five and seve n months fr om now. Both num bers represent the same duration, but \"130 days\" probably im plies a higher d egree of accuracy than you feel. W e recomm end that you scale tim e estimates as follows: Duration Quote es timate in 1-15 days days 3-8 wee ks weeks 8-30 weeks months 30+ weeks think hard before giving an estimate _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 58 Hunt, Thomas The Pragmatic Programme r 59 So, if after doing all the necessary work, you decide that a pr oject will take 125 working days (25 weeks), you m ight want to deliver an estim ate of \"about six m onths.\" The sam e concepts app ly to estim ates of any quan tity: choose the units of your answer to reflect th e accuracy yo u intend to convey. Where Do Estimates Come From? All estim ates are based on m odels of the problem. Bu t before we get too deeply into the techniques of building models, we have to m ention a basic estim ating trick that always gives good answers: ask someone who' s already d one it. Before you get too comm itted to m odel building, cast around for someone who' s been in a sim ilar situ ation in the past. See how their problem got solved. It' s unlikely you'll ever find an exact m atch, but you' d be surprised ho w many times you can successfully draw on oth er's experien ces. Unders tand What's Bein g Asked The first part of any estim ation exercise is build ing an understanding of what' s being asked. As well as the accuracy issues discussed above, you need to have a grasp of the scope of the dom ain. Often this is im plicit in the question, but you need to m ake it a habit to think about the scope before starting to guess. Often, the scope you choose wi ll form part of the answer you give: \"Assum ing there are no traffic accid ents a nd there' s gas in the car, I shou ld be there in 20 m inutes.\" Build a Model of the Sy stem This is the fun part of estim ating. From your understanding of the question being asked, build a rough and ready bare-bones m ental model. If you're estim ating response tim es, your model m ay involve a server and some kind of arriving traffic. For a project, the m odel m ay be the steps that your organization uses during deve lopm ent, along with a very r ough picture of how the system might be i mplem ented. Model building can be both creativ e and useful in the long term . Often, the process of building the model leads to discoveries of underl ying patterns and processes that weren' t apparent on the surface. You m ay even want to reexam ine the orig inal question: \"You asked for an estim ate to do X. However, it looks like Y, a variant of X, could be done in about half the tim e, and you lose only one feature.\" Building th e model intro duces ina ccuracies in to the estimating process. This is inevitable, and also beneficial. You are trad ing off m odel sim plicity for accuracy. Doubling the effort on the m odel m ay give you only a sligh t increas e in accuracy. Your experience will tell you when to stop refining. Break the Model into Com ponents Once you have a m odel, you can decom pose it into com pone nts. You' ll need to discover the mathematical rules that describe how these com ponents interact. Som etimes a com pone nt contributes a single valu e that is add ed into the result. Som e com ponents m ay supply multiply ing factors, while others m ay be m ore complicated (such as those that s imulate the a rrival of traffic at a node). _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 59 Hunt, Thomas The Pragmatic Programme r 60 You' ll find that each co mponent will typically h ave param eters that affect how it co ntribu tes to the overall m odel. At this stage, simply identify each param eter. Give E ach Parameter a Val ue Once you have the param eters broken out, you can go throu gh and assig n each one a value. You expect to introduce som e errors in this step. The trick is to work out which param eters have the most im pact on the result, and concentrate on getti ng them about right. Typi cally, param eters whose values are added into a result are less significan t than those th at are m ultiplied o r divid ed. Doublin g a line speed m ay double the am ount of data received in an hour, while addi ng a 5 m s transit delay will have no notice able e ffect. You should have a justif iable way of calculating th ese critical param eters. For the queuing exam ple, you m ight want to m easure the actual transaction arrival rate of the ex isting system , or find a sim ilar system to measure. Sim ilarly, you could m easure the current tim e taken to se rve a request, or com e up with an estim ate using the techniques described in this section. In fact , you' ll often find yourself basing an es timate on other subes timates. This is where your largest errors will creep in. Calculate the Answers Only in the sim plest of cases will an estim ate ha ve a single answer. You m ight be happy to say \"I can walk five cross-town blocks in 15 m inutes.\" However, as the system s get m ore complex, you' ll want to hed ge your ans wers. Run multip le calcu lations, vary ing the valu es of the critical param eters, until you wo rk out which ones really driv e the m odel. A spreadsheet can b e a big help. Then couch your answer in term s of t hese param eters. \"The response tim e is roughly three quarters of a second if the system has a SCSI bus and 64MB m emory, and one second with 48MB m emory.\" (Notice how \"three quarters of a second\" conveys a different feeling of accuracy than 750 m s.) During the calculation phase, you may start getting an swers that seem strange. Don' t be too quick to dism iss them. If your arithm etic is correct, your understanding of the problem or your m odel is probably wrong. This is valuable inform ation. Keep Tr ack of Your Estim ating Prowess We think it' s a great idea to reco rd your estim ates so you can see how close you were. If an overall estim ate involved calculating subestim ates, keep track of these as well. Often you' ll find your estim ates are pretty good—in fact, afte r a while, you' ll com e to expect this. When an estim ate turns out wrong, don' t just shr ug and walk away. Find out why it differed from your guess. Maybe you chose som e param eters that didn' t match the reality of the problem . Maybe your m odel was wrong. Whatever the reason, take some time to uncover what happened. If you do, your next es timate will b e better. Estimating Project Schedules The norm al rules of estim ating can break down in th e face o f the com plexities and vagaries of a sizable application developm ent. W e find that of ten the only way to dete rmine the timetable f or a project is by gaining experience on that sam e project. This needn' t be a paradox if you practice increm ental developm ent, repe ating the following steps. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 60 Hunt, Thomas The Pragmatic Programme r 61 • Check requirem ents • Analyze risk • Design, im plem ent, integrate • Validate with the users Initially, yo u may have only a vague idea of how many iterations will be required, o r how long they may be. Som e methods require you to nail this down as part of the initial plan, but for all but the most trivial of projects this is a mistake. Unless you are doing an a pplication sim ilar to a previous one, with the sam e team and the sam e technology, you' d just be guessing. So you complete the coding and testing of the initia l functionality and m ark this as the end of the first increm ent. Based on that experience, you can refine your initial guess on the num ber of iterations an d what can b e includ ed in each. The refinem ent gets better an d better each time, and confidence in the schedu le grows along with it. Tip 19 Iterate the S chedule with the Code This m ay not be popular with m anagem ent, who t ypically want a single, hard-and-fast num ber before the project even starts. You' ll have to he lp them understand that the team , their productivity, and the env ironm ent will dete rmine the schedule. By formalizing this, and refining th e schedule as part of each iteration, yo u'll be givin g them the most accurate scheduling estim ates y ou can. What to Say When Asked for an Estimate You say \" I'll get back to you. \" You alm ost always get better re sults if you slow the process down and spend som e time going through the steps we describe in this section. Estim ates given at the coffee machine will (like the coffee) come back to haunt you. Related sec tions include : • Algorithm Speed Challeng es • Start k eepin g a log of your estim ates. For eac h, track how accurate you turned out to b e. If your error was greater than 50%, try to find out wher e your estim ate went wrong. Exercises 9. You are asked \"W hich has a higher bandwidth : a 1Mbps communications line or a person i Wh ?\"k ihi 4GBllfhi b lki ill _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 61 Hunt, Thomas The Pragmatic Programme r 62 you put on your answer to ensure that the scope of your response is co rrect? (For exam ple, you might say that the tim e taken to access the tape is ignored.) 10. So, which has the higher bandwidth? _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 62 Hunt, Thomas The Pragmatic Programme r 63 _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 63 Hunt, Thomas The Pragmatic Programme r 64 Chapter 3. The Basic Tools Every craftsm an starts his or her journey with a basic set of good-quality tools. A woodworker might need rules, gauges, a couple of saws, so me good planes, fine chisels, drills and b races, mallets, and clam ps. These tools will be loving ly chos en, will be built to la st, will p erform specif ic jobs with little overlap w ith other tools, and, perh aps m ost importantly, will feel right in the budding woodworker' s hands. Then begins a process of learn ing an d adapta tion. Each tool will have its own personality and quirks, and will need its own special handling. E ach m ust be sharpene d in a unique way, or held ju st so. Over tim e, each will wear acco rding to use, u ntil the grip looks lik e a mo ld of the woodworker' s hands and th e cutting surface aligns p erfectly with the angle at which the to ol is held. At this po int, the tools becom e conduits from the craftsm an's brain to the finished product—they have becom e extensions of his or her hands. Over tim e, the woodworker will add new tools, such as biscuit cutters, laser-guided m iter saws, dovetail jig s—all wonderful pieces of tech nology. But you can bet that he o r she will be h appiest with one of those origin al too ls in hand, f eeling the plane sing as it slides through the wood. Tools am plify your talent. The bett er your tools, and the better you know how to use them , the m ore productive you can be. Start with a basic set of ge nerally applicable tools. As you gain experience, and as you com e across special requirem ents, you'll add to this basic set. Like the craftsm an, expect to add to your toolbox regularly. Always be on the lookout f or better ways of doing things. If you come across a situation where you feel your current tools can' t cut it, m ake a note to look for something different or more powerful that woul d have helped. Let need drive your acquisitions. Many new programm ers make the m istake of adopti ng a single power tool, such as a particular integrated developm ent environm ent (IDE), and neve r leave its cozy interf ace. This re ally is a mistake. W e need to be com fortable beyond the lim its im posed by an IDE. The only way to do this is to keep the basic tool set sharp and ready to use. In this chapter we' ll talk about investing in your own basic toolbox. As w ith any good discussion on tools, we' ll start (in The Power of Plain Text ) by looking at your raw m aterials, the stuff you' ll be shaping. From there we' ll move to the workbenc h, or in our case the computer. How can you use your com puter to get the most out of th e tools you use? We'll discuss this in Shell Games. Now that we have m aterial and a bench to work on, we' ll turn to the tool you' ll probably use m ore than any other, your editor. In Power Editing, we'll suggest ways of making you more efficient. To ensure that we never lose any of our precious work, we should always use a Source Code Control system —even for things such as our pe rsonal address book! And, since Mr. Murphy was really an optim ist after all, you can' t be a gr eat programm er until you b ecome highly skilled at Debugging. You' ll need som e glue to bind m uch of the m agic together. We discuss som e possibilities, such as awk, Perl, and Python, in Text Manipulation. Just as wood workers so metimes build jigs to guide the constructi on of complex pieces, programm ers can write code that itsel f writes cod e. We discus s this in Code Generators. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 64 Hunt, Thomas The Pragmatic Programme r 65 Spend tim e learning to use these tools, and at som e point you' ll be surprised to discover your fingers moving over the keyboard, m anipulating text with out conscious thought. T he tools will have becom e extensions of your hands. The Power of Plain Text As Pragm atic Programmers, our base m aterial isn't wood or iron, it' s knowledge. W e gather requirem ents as knowledge, and then express that knowledge in our designs, im plementations, tests, and docum ents. And we believe that the best form at for storing knowledge persistently is plain text. With plain text, we give ourselves the ab ility to m anipulate knowledge, both m anually and programm atically, using virtually every tool at our disposal. What Is Plain Text? Plain text is m ade up of printable charac ters in a for m that can be r ead and understood directly by people. For exam ple, although the following snippe t is m ade up of printable characters, it is meaningless. Fieldl9=467abe The reader h as no idea w hat the significance of 467abe may be. A better choice would be to m ake it understandable to hum ans. DrawingType=UMLActivityDrawing Plain text doesn' t mean that th e text is unstructured; XML, SG ML, and HTML are great exam ples of plain text that has a well-defined structure. You can do everything with plain text that you could do with some binary form at, including versioning. Plain text tends to be at a highe r level than a straight binary encoding, which is usually derived directly from the im plem entation. Suppose you wanted to store a property called uses_menus that can be either TRUE or FALSE. Using text, you m ight write this as myprop.uses_menus=FALSE Contrast this with 0010010101110101. The problem with m ost binary formats is that the contex t necessary to understand the data is separate from the data itself. You are artificially divorcing the data from its m eaning. The data m ay as well be encrypted; it is absolu tely m eaningless without the app lication logic to parse it. W ith plain text, however, you can achieve a self-describ ing data stream that is independent of the application that created it. Tip 20 Keep Knowledge in Plain Text _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 65 Hunt, Thomas The Pragmatic Programme r 66 Drawback s There are tw o major drawbacks to u sing plain tex t: (1) It m ay take m ore space to s tore than a compressed binary format, and (2) it m ay be com putationally m ore expens ive to inte rpret and process a p lain tex t file. Depending on your application, eith er or both of these situations m ay be unacceptable—for exam ple, when storing satellite te lemetry da ta, or as the inte rnal format of a relation al databas e. But even in these s ituations, it m ay be accep table to sto re metadata about the raw data in plain text (see Metaprogramm ing). Some developers m ay worry that by putting m etadata in plain text, they' re exposing it to the system' s users. This fear is m isplaced . Binary data may be more obscure than plain text, but it is n o more secure. If you worry about users seeing pa sswords, encrypt them . If you don' t want them changing configuration param eters, include a secure hash[1] of all the pa rameter valu es in th e file as a checksum . [1] MD5 is o ften used for this purpose. For an excellent intr oduction to the wonderful w orld of cryptography, see [Sch95]. The Pow er of Text Since larger and slower aren' t the most frequently requested features from users, why bother with plain text? What are the benefits? • Insurance ag ainst obso lescence • Leverage • Easier tes ting Insur ance Against Obsolescence Hum an-read able f orms of data, and s elf-desc ribing data, will outliv e all other f orms of data and the applications that created them . Period. As long as the data survives, you will have a chan ce to be able to use it— potentially long after the origin al app lication tha t wrote it is defunct. You can parse such a file with only partial know ledge of its f ormat; with most binary files, you must know all the details of the entire for mat in orde r to parse it successfully. Consider a data file from som e legacy system[2] that you are given. You know little abo ut the original application; all th at's important to you is that it m aintain ed a list of clients' Social Security numbers, which you need to find and extract. Among the data, you see [2] All software becomes legacy as soon a s it's w ritten. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 66 Hunt, Thomas The Pragmatic Programme r 67 <FIELD10>123-45-6789</FIELD10> ... <FIELD10>567-89-0123</FIELD10> ... <FIELD10>901-23-4567</FIELD10> Recognizing the form at of a Social S ecurity number, you can quickly write a sm all program to extract that data—even if you have no info rmation on anything else in the file. But im agine if the f ile ha d been f ormatted this wa y inste ad: AC27123456789B11P ... XY43567890123QTYL ... 6T2190123456788AM You m ay not have recognized the significance of the num bers quite as easily. This is the difference between human readable and human understandable. While we' re at it, FIELD10 doesn' t help m uch either. Som ething like <SSNO>123-45-6789</SSNO> makes the exercis e a no- braine r—an d ensures th at the data will ou tlive an y projec t that created it. Leverage Virtually every tool in the com puting universe, f rom source code m anagem ent system s to com piler environm ents to editors a nd stand-a lone filters, ca n operate on plain text. The Unix Philosophy Unix is famous for being designed around th e philosophy of sm all, sharp tools, each intended to do one thing well. This philos phy is enabled by using a common underlying format—the line-oriented, plain text file. Databases used for system adm inistration (users and passwords, networking configur ation, and so on) are all kept as plain text files. (som e system s, such as Solaris, also m aintain a binary form s of certain databases as a perform ance optim izatio n. The plain text versi on is kept as an interface to the binary version.) When a system crashes, you m ay be faced with only a m inimal environment to resto re it (You m ay not be able to access g raphics drivers, for instance), Situations such as th is can really m ake you appreciate the sim plicity of plain text. For instance, suppose you have a pr oduction deploym ent of a large a pplication with a com plex site- specific con figuration file ( sendmail com es to mind). If this file is in plain text, you could place it under a source code control system (see Source C ode Control ), so that you autom atically keep a _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 67 Hunt, Thomas The Pragmatic Programme r 68 history of all changes. File com parison tools such as diff and fc allow you to see at a glance what changes have been m ade, while sum allows you to generate a check sum to m onitor the file for acciden tal (or m alicious) m odification. Easier Testing If you use plain text to create synthe tic data to drive system tests, then it is a sim ple matter to add, update, or m odify the test data witho ut having to create an y special tools to do so. Similarly, plain text output from regression tests can be tr ivially analyzed (with diff, for instance) or subjected to more thorough scrutiny with Perl, P ython, or som e other scripting tool. Low est Common Denominator Even in the f uture of XML-based intelligen t agents that tra vel the wild and dangerous Internet autonom ously, negotiating data in terchange am ong them selves, the ub iquitous text file will s till be there. In fact, in heterogeneous environm ents the advantages of pl ain text can outweigh all of the drawbacks. You need to ensure that all parties can communicat e using a comm on standard. Plain text is that standard. Related sec tions include : • Source Code Control • Code Generators • Metaprogramming • Blackboards • Ubiquitous Autom ation • It's All W riting Challeng es • Design a small address book database (n ame, phone num ber, and so on) using a straightforward binary representation in your la nguage of choice. Do th is before reading the rest of this challenge. 1. Translate th at form at into a plain text form at using XML. 2. For each version, add a n ew, variab le-leng th field called directions in which you might enter directions to each person 's house. What issues com e up regarding versioning a nd extensib ility? Which form was easie r to modify? What about co nverting existing data? Shell Gam es Every woodworker need s a good, solid, reliab le wor kbench, som ewhere to hold work pieces at a convenient height while he or she w orks them . The workbench becom es the center of the wood shop, the crafts man returning to it tim e and ti me again as a p iece takes sh ape. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 68 For a programmer m anipulating files of text, that workbench is the comm and shell. From the shell prom pt, you can invoke your full repe rtoire of tools, using pipes to com bine them in ways never dream t of by their original de velopers. From the shell, you ca n launch applications, debuggers, Hunt, Thomas The Pragmatic Programme r 69 browsers, ed itors, and utilities. You c an sear ch for files, que ry the status of the system , and f ilter output. And by programm ing the shell, you can build com plex m acro commands for activities you perform often. For program mers raised on GUI interfaces and inte grated developm ent environm ents (IDEs), this might see m an extrem e position. After all, can 't you do everything equally well by pointing and click ing? The sim ple answer is \"n o.\" GUI interfaces are wonderful, an d they can b e faster and more convenient for som e simple operations. Moving f iles, reading MIME-encoded e-m ail, and typing letters are all things that you might want to do in a graphical e nvironm ent. But if you do all your work using GUIs, you are m issing out on the full cap abilities of your envir onment. You won' t be able to autom ate common tasks, or use the full power of the tools avai lable to you. And you won' t be able to combine your tools to create custom ized macro tools . A benefit of GUIs is WYSI WYG— what you see is what you get. The di sadvantage is W YSIAYG—what you see is all you get. GUI environm ents are norm ally lim ited to the capabil ities that their designer s intended. If you need to go beyond the m odel the designer provided, you are usually out of luck —and m ore often than not, you do need to go beyond the model. Pragm atic Programmers don' t just cut code, or develop object m odels, or write docum entation, or autom ate the build process—w e do all of these things. The scope of any one tool is usually lim ited to the tasks that the tool is ex pected to perform . For instance, suppose you need to integrate a code pr eprocessor (to im plement design-by-contract, or multi-p rocessing pragm as, or som e such) in to yo ur IDE. Unless the de signer of the I DE explicitly provided hooks for this capability, you can' t do it. You m ay already be comfortable working from the comm and prom pt, in which case you can safely skip this section. Otherwise, you m ay need to be convinced that the shell is your friend. As a Pragm atic Prog ramm er, you will constantly want to perf orm ad hoc operations —things that the GUI m ay not support. T he comm and line is better suited when you want to quickly com bine a couple of commands to perform a query or so me other task. Here are a few exam ples. Find all .c files mod ified more rec ently than your Makefile. Shell… find . -name ' *.c' -newer Makefile -print GUI….. Open the Explorer, navigate to the correct directory, click on the Makefile, and note the modification time. Then bring up Tools/Find, and enter *.c for th e file sp ecificatio n. Select the date tab , and enter the date yo u noted for th e Makefile in the first date fiel d. Then hit OK. Construct a zip/tar archive of my source. Shell… zip archive.zip *.h *.c - or- tar cvf archive.tar *.h *.c GUI….. Bring up a ZIP u tility (su ch as th e shareware WinZip [URL 41 ], select \"Create New Arc hive,\" e nter its name, select th e source d irectory in the add dialog, set th e filter to \"* .c\", click \"Add ,\" set t he filter to \"* .h\", click \"Add,\" then close the archive. ¨ Which Java files have n ot been cha nged in the last week? _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 69 Hunt, Thomas The Pragmatic Programme r 70 Shell… find . -name '*.java' -mtime +7 -print GUI….. Click and navigate to \"Find files,\" click the \"Nam ed\" fiel d and type in \"*.ja va\", select the \"Date Modifie d\" tab. Then select \"B etween .\" Click on the starting d ate an d type in the starting date of the beginning of the project . Click on the ending date and type in the date of a week ago today (be sure to have a cal endar handy). Click on \"Find Now.\" Of those file s, which use the awt libraries? Shell… find . -name '*.java' -mtime +7 -print | xargs grep 'java.awt' GUI….. Load each file in the list fro m the previous example into an editor a nd search for th e string \"java.awt\". Write down the nam e of each file containing a match. Clearly the list could go on. The shell comm ands m ay be obsc ure or terse, but they are powerful and concise. An d, because shell comm ands can be com bined into scrip t files (or comm and files under Windows system s), you can build sequences of comm ands to autom ate things you do often. Tip 21 Use the Power of Command Shells Gain fa miliarity with the shell, and y ou'll find your productiv ity soaring. Need to create a list of all the unique package nam es explicitly im ported by your Java code? The followi ng stores it in a file called \"list. \" grep '^import ' *.java | sed -e's/.*import *//' -e's/;.*$//' | sort -u >list If you haven' t spent m uch time exploring the capab ilities of the comm and shell on the system s you use, this m ight appear daunting. However, inv est som e energy in becom ing fam iliar w ith your sh ell and things w ill soon start falling in to place. Play around with y our comm and shell, and you' ll be surprised at how m uch more productive it m akes you. Shell Utilities and Windo ws Systems Although the comm and shells provided with W indows system s are i mproving gradually, W indows command-line utilities are still in ferior to their U nix counterpart s. However, all is not lost. Cygnus Solutions has a p ackage called Cygwin [ URL 31 ]. As well as providing a Unix compatibility layer for W indows, Cygwin com es with a collection of m ore than 120 Unix utilities, including such favorites as 1s, grep, and find. The utilities and libraries m ay be downloaded and used for free, but be sure to read their license.[3] The Cygwin distribution com es with the Bash shell. [3] The GNU G eneral Public Licen se [URL 5 7] is a kind of l egal viru s that Open Source developers use to protect their (and your) rights. You sh ould spend some time reading it. In essence, it sa ys that you can use and m odify GPL'd software, but if y ou di stribute any modifications they m ust be licensed according to the GP L (and marked as such), and you must mak e source av ailable. Th at's the virus _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 70 Hunt, Thomas The Pragmatic Programme r 71 part—w henever you derive a work from a GPL'd work, your de rived work must also be GPL'd. However, it doe s not limit you in a ny way when simply using the tools— the ownership and licensing of software developed using the tools are up to y ou. Using Unix Tools Under Windows We love the availability of high-quality Unix tools under W indows, and use them daily. However, be aware that there are in tegrati on issu es. Unlike th eir Ms-dos counterparts, these u tilitie s are sen sitive to the case of filenames, so ls a*.bat won' t find AUTOEXEC.BAT. You m ay also com e across problem s with filenam es containing spaces, and with dif ferences in path separators. Fi nally, there are in teresting problem s when running Ms-dos program s that expect Ms-DOS -style argum ents under the Unix shells, For exam ples, the Java utilities from JavaSoft use a colon as their CLASSPATH separators under Unix, but use a sem icolon under MS-DOS. As a result, a Bash or ksh scrip t that ru ns on a Unix box will ru n identically under W indows, but the command line it pass es to J ava will b e interpr eted in corre ctly. Alternatively, David Korn (of Korn shell fam e) has put together a package called uwin. This has the same aims as the Cygwin distribution—it is a Unix developm ent environm ent under W indows. UWIN comes with a version of the Korn shell. Comm ercial ve rsions are available from Global Technologies, Ltd. [ URL 30]. In addition, AT&T allows free downloading of the package for evaluation and academ ic use. Again, read th eir license before using. Finally, To m Christians en is (a t the tim e of writing) putting together Perl Power Tools, an attem pt to im plem ent all the f amiliar Unix utilities po rtably, in Perl [ URL 32 ], Related sec tions include : • Ubiquitous Autom ation Challeng es • Are there things that you' re currently doing m anually in a GUI? Do you ever pass instructions to colleagues that involve a num ber of individual \"cli ck this button,\" \"select this item\" steps? Could these be autom ated? • Whenever you m ove to a new environm ent, m ake a point of finding out what shells are available. See if you can bri ng your current shell with you. • Investigate alternatives to your current shell. If you com e across a problem your shell can' t address, s ee if an alternat ive shell would cope better. Power Editing We've talked before about tools being an extensi on of your hand. W ell, this applies to editors m ore than to any other software tool. You need to be ab le to m anipulate text as effortlessly as possib le, because text is the b asic raw m aterial of pr ogramm ing. Let 's look at som e common fea tures and functions th at help you get the m ost from your editing environm ent. One Editor _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 71 Hunt, Thomas The Pragmatic Programme r 72 We think it is better to know one editor very well, and use it for all editing tasks: code, docum entation, m emos, system adm inistration, a nd so on. W ithout a single edito r, you face a potential m odern day Babel of confusion. You may ha ve to use the built-in ed itor in each language' s IDE for coding, and an all-in-one office product for docum entation, and m aybe a different built-in editor for sending e-m ail. Even th e keystrokes you use to edit comma nd lines in th e shell m ay be different.[4] It is difficult to be proficient in any of these environm ents if you have a different set of editing conventions and commands in each. [4] Ideally, the shell you use should ha ve keybindings that match the ones use d by your e ditor. Bash, for i nstance, supports bo th vi and emacs keybindings. You need to be proficient. Sim ply typing linearly and using a mouse to cut and paste is not enough. You just can' t be as effective that way as you can with a powerful editor under your fingers. Typing or ten tim es to m ove the cursor lef t to the beginning of a line isn' t as efficient as typing a single key such as or . Tip 22 Use a Single Editor W ell Choose an editor, know it tho roughly, and use it for a ll editing tasks. If y ou use a sin gle editor (o r set of keybindings) acro ss all tex t editing activities, you don' t have to stop and think to accom plish text m anipulation: the necessary keystrokes will be a reflex. T he editor will be an extension of your hand; the k eys will s ing as they s lice their way th rough tex t and thought. That' s our goal. Make sure that the editor you choose is available on all platform s you use. Em acs, vi, CRiSP, Brief, and others are available across multiple platforms, often in both GUI and non-GUI (text screen) versions. Editor Features Beyond whatever features you find part icularly useful and comfortable, here are som e basic abilities that we think every decent editor should have. If your editor falls short in a ny of these areas, then this m ay be the tim e to consider m oving on to a more advanced one. • Configurable. All aspects of the editor should be configurable to your pref erences, including fonts, colors, window sizes, and keystroke bindings (which keys perform what comm ands). Using only keystrokes for comm on editing operations is m ore efficient than m ouse or m enu-driven commands, because you r hands never leav e the k eyboard. • Extensible. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 72 Hunt, Thomas The Pragmatic Programme r 73 An editor sh ouldn' t be obsolete just because a new programm ing language com es out. It should be able to integrate with whatever com piler environm ent you are using. You should be able to \"teach\" it th e nuances of any new language or text for mat (XML, HTML version 9, and so on). • Programmable. You should be able to program the editor to perform com plex, multistep tasks. This can be done with macros or with a built-in scripti ng programm ing language (Emacs uses a variant of Lisp, for instance). In addition, m any editors support features that ar e specific to a particular programm ing language, such as: • Syntax highlighting • Auto-com pletion • Auto-indentation • Initial code or docum ent boile rplate • Tie-in to help system s • IDE-like features (com pile, debug, and so on) A feature such as syntax highlig hting m ay sound like a frivolous extra, but in reality it can be very useful and enhance your productivity. Once you get us ed to seeing keywords appear in a different color or font, a m istyped keyword that doesn't appear that way jum ps out at you long before you fire up the com piler. Having the ability to com pile and navigate directly to erro rs within the ed itor environm ent is v ery handy on big projects. E macs in particular is adept at this style of interaction. Productivity A surprising num ber of pe ople we' ve met use the W indows notepad utility to edit th eir sou rce co de. This is like using a teaspoon as a shovel—sim ply typing and using basic mouse-based cut and paste is not enough. What sort of things will you need to do that can't be done in this way? Well, there' s cursor m ovem ent, to start with. Sing le keystrokes that m ove you in units of words, lines, blocks, or functions are far m ore efficient than repeatedly typing a keystroke that m oves you character by character o r line by line. Or suppose you are writing Java code. You like to keep your import statem ents in alphabetical order, and som eone else has checked in a few files that don' t adhere to this standard (this m ay sound extrem e, but on a large project it can save you a lot of tim e scanning through a long list of import statem ents). You' d like to go quickly through a few f iles and sort a sm all section of them. In editors such as vi and Em acs you can do this easily (see Figure 3.1 ). Try that in notepad. Figure 3.1. Sorting lines in an editor _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 73 Hunt, Thomas The Pragmatic Programme r 74 Some editors can help stream line common operations. For instance, when you cr eate a new file in a particular language, the ed itor can supply a tem plate for you. It m ight include: • Nam e of the class o r module filled in (deriv ed from the f ilena me) • Your nam e and/or copyright statem ents • Skeletons for constructs in that language (c onstructor and destructor declarations, for exam ple) Another useful feature is auto-indenting. Rather th an having to indent m anually (by using space or tab), the editor autom atically indent s for you at the appropriate tim e (after typing an open brace, f or exam ple). The nice part about this feature is that you can use the editor to provide a consistent indentation style for your project.[5] [5] The Linux kernel is de veloped this way. Here you ha ve geographically dispe rsed developers, many working on t he same pieces of code. There is a publishe d list of se ttings (in t his case, for E macs) that describes the require d indentation sty le. Where to Go from Here This sort of advice is particularly hard to write because virtually ev ery reader is at a different level of comfort and expertise with the editor(s) they are currently using. So, to summarize, and to provide som e guidance on where to go next, find your self in the left-hand co lumn of the chart, and look at the right-hand colum n to see what we think you should do. If this so unds like you… Then think about… I use onl y basic features of many differen t editors. Pick a powerful ed itor and learn it well. I have a favorite editor, but I don't use all of its features. Learn them. Cut dow n the number of keystro kes you need to type. I have a fa vorite ed itor and use it where possible . Try to expand and use it fo r more tasks than you do already. I think you are nuts. Notepad is the best e ditor eve r made . As long as you ar e happy and productive, go for it! But if you find yourself subject to \"editor env y,\" you may need to reev aluate your position. What Editors Are Available? Having reco mmended that you m aster a decen t editor, which o ne do we recomm end? Well, we' re going to duck that question; your choice of edito r is a personal one (som e would even say a religious one!). However, in Appendix A , we list a num ber of popular editors and where to get them . Challeng es • Some editors use full-blown languages for cust omization and scripting. Em acs, for exam ple, uses Lisp. A s one of the new languages you are go ing to learn this year , learn the language _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 74 Hunt, Thomas The Pragmatic Programme r 75 your editor uses. For anything you find yourself doing repeatedly, develop a set of m acros (or equivalent) to handle it. • Do you know everything your editor is capable of doing? Try to stum p your colleagues who use the sam e edito r. Try to accom plish any gi ven editing task in as few keystrokes as possible. Source Code Control Progress, far from consisting in change, depends on retentiveness. Those who cannot remember the past are condemned to repeat it. George San tayana, Life of Reason One of the important th ings we l ook for in a user interface is the key—a single button that forgives us our m istakes . It's even better if the en vironm ent supports m ultiple levels o f undo and redo, so you can go back and recover from som ething that happened a couple of m inutes ago. But what if the m istake happened last week, and you' ve turned your com puter on and off ten tim es since then? Well, that' s one of the m any benefits of using a source code control system : it's a giant key—a project-wide tim e machine that can retu rn you to those halcyon days of last week, when the code actually com piled and ran. Source code control system s, or the more widely scoped configuration m anagement system s, keep track of every change you m ake in your source code and docum entation. Th e better ones can keep track of compiler and OS versions as well. W ith a properly configured sour ce code control system , you can alw ays go back to a prev ious version of your software. But a source code control system (SCCS[6] ) does far m ore than undo m istakes. A good SCCS will let you track changes, answ ering questions such as: W ho m ade cha nges in this line of code? What's the difference between the current version and last week' s? How m any lines of code did we change in this release? Which files get changed m ost ofte n? This kind of infor mation is invaluable for bug- tracking, audit, performan ce, and quality purposes. [6] We u se the uppercase SCCS to refer to generic source co de control systems. There is also a specific system c alled \"sccs,\" originally released with AT& T System V Unix. An SCCS will also let y ou identify releas es of your software. Once identified, you will always be able to go back and regenerate th e release, independent of change s that may have occurred later. We often use an SCCS to m anage branches in the developm ent tree. For exam ple, once you have released som e software, you' ll norma lly want to continue developing for the next release. At the same time, you' ll need to deal with bugs in the current release, shipping fixed versions to clients. You' ll want these bug fixes rolled into the next re lease (if appropriate), bu t you don' t want to ship code under developm ent to clients. W ith an SCCS you can generate branches in the developm ent tree each tim e you gene rate a release. You apply bug fixes to code in th e branch, an d continue developing on the m ain trunk. Since the bug fixes m ay be relevant to the m ain trunk as well, som e system s allow you to m erge selected changes from the branch back into the m ain trunk autom atically. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 75 Hunt, Thomas The Pragmatic Programme r 76 Source code control system s may keep the f iles they m aintain in a cen tral repos itory—a grea t candidate for archiving. Finally, some products m ay allow two or m ore users to be working concurrently on the sam e set of files, even m aking concurren t chan ges in th e sam e file. The system then m anages the m erging of these changes when the files ar e sent back to the repositor y. Although seem ingly risky, such system s work well in practice on projects of all sizes. Tip 23 Always Use Source Code Control Always. Even if you are a single- person team on a one-week project. Even if it' s a \"throw-away\" prototype. Even if the stuff you' re work ing on isn' t source code. Make sure that everything is unde r source code control—docum entation, phone number lists, m emos to vendors, m akefiles, build and release procedures, that little shell script that burns the CD master—everything. W e routinely use source code control on just about ev erything we type (including the te xt of this book). Even if we' re not working on a project, our day-to-d ay work is secured in a repository. Source Code Control a nd Builds There is a trem endous hidden benefit in having an en tire project under the um brella of a source code control system : you can have product builds that are automatic and repeatable. The projec t build m echanism can pull the late st source out of the repository autom atically. It can run in the middle of the night after everyone' s (hopefully) gone hom e. You can run autom atic regression tests to ensure that the day' s coding didn' t break anything. The autom ation of the build ensures consistency—there are no manual procedures, and you won' t need developers rem embering to copy code into som e special build area. The build is repeatable b ecause you can always rebuild th e source as it ex isted on a g iven date. But My Team Isn't Using Sou rce Code Control Shame on them ! Sounds like an opport unity to do som e evangelizi ng! However, while you wait for them to see the light, perhaps you should im plement your ow n private source control. Use one of the freely av ailab le too ls we list in Appendix A , and m ake a point of keeping your personal work safely tucked into a repository (as well as doing whatever your project requires). Although this m ay seem to be duplication of effort, we can pretty much guarantee it will sa ve you grief (and save your project m oney) the first tim e you need to answ er questions such as \"W hat did you do to the xyz module?\" and \"W hat broke the build?\" This appr oach m ay also help convince your m anagem ent that source code control really works. Don' t forget that an SCCS is equally app licable to the things you do outside of work. Source Code Control Products _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 76 Hunt, Thomas The Pragmatic Programme r 77 Appendix A , gives URLs for representative source code control sys tems, som e commercial and others freely available. A nd m any m ore products are available—l ook for pointers to the configuration m anagem ent FAQ. Related sections include: • Orthogonality • The Power of Plain Text • It's All W riting Challenges • Even if you are not able to use an SCCS at work, install RCS or CVS on a personal system . Use it to m anage your pet projects, docum ents you write, and (possi bly) configuration changes app lied to the com puter sys tem itself. • Take a look at som e of the Open Source projec ts for which publicly accessible archives are available on the W eb (such as Mozilla [ URL 51 ], KDE [ URL 54], and the Gi mp [URL 55 ]). How do you get updates of the source? How do you m ake changes—does the project regulate access or arbitrate the inclusion of changes? Debuggin g It is a pa inful thing To look at your own trouble and know That you yourself and no one else has made it Sophocles, Ajax The word bug has been used to describe an \"object of te rror\" ever since the fourteenth century. Rear Adm iral Dr. Grace Hopper, the inven tor of CO BOL, is credited with observing th e first computer bug— literally, a m oth caught in a relay in an earl y com puter system . When asked to explain why the m achine wasn' t behaving as intended, a technici an reported that there was \"a bug in the system,\" and dutifully taped it—wings and all—into the log book. Regrettably, we still have \"bugs\" in the system , albeit not the flying kind. Bu t the fourteenth century meaning—a bogeym an—is perhaps even m ore applic able now than it w as then. Software defects manifest them selves in a variety of ways, fr om misunderstood requirem ents to coding errors. Unfortunately, m odern com puter system s are still lim ited to doing what you tell them to do, not necessarily what you want them to do. No one writes perfect so ftware, so it' s a give n that debugging will take up a m ajor portion of your day. Let' s look at som e of the issues involved in debugging and som e gene ral strategies for finding elusive bugs. Psychology of Debugging _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 77 Hunt, Thomas The Pragmatic Programme r 78 Debugging itself is a sen sitive, em otional subject fo r many developers. Ins tead of attacking it as a puzzle to be solved, you m ay encoun ter denial, finger pointing, lam e excuses, or just plain apathy. Embrace the fact that d ebugging is just problem solving, and attack it as such. Having found som eone e lse's bug, you can spend tim e and energy lay ing blam e on the filthy culprit who created it. In som e workplaces this is part of the culture, and m ay be cathartic. However, in the technical arena, you want to concentrate on fixing the problem, not the blam e. Tip 24 Fix the Prob lem, Not the Blam e It doesn' t really m atter whether the bug is your fa ult or som eone else' s. It is still your problem . A Debugging Mindset The easiest person to deceive is one's self Edw ard Bulw er-Lytton, The Disowned Before you start debugging, it' s important to adopt th e right m indset. You need to turn off many of the defenses you use each day to protect your ego, tune out any project pressures you m ay be unde r, and get yourself comfortable. Above all, remember the first rule of debugging: Tip 25 Don' t Panic It's easy to get into a panic, especially if you are facing a deadline, or have a nervous boss or client breathing down your neck while you are trying to find the cause of the bug. But it is very im portant to step b ack a pace, and actually think about what could be causing the symptom s that you believe indicate a bug. If your first reaction on witne ssing a bug or seeing a bug report is \"that' s impossible,\" you are plainly wrong. Don' t was te a single neuron on the tr ain of thought that begi ns \"but that can' t happen\" because quite clearly it can, and has. Beware of myopia when debugging. Re sist the urge to fix just the sym ptoms you se e: it is m ore likely that the actual fault m ay be several step s removed from what you are observing, and m ay involve a number of other related things. Always try to discover the root cause of a problem , not just this particular appearance of it. Where to Start _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 78 Hunt, Thomas The Pragmatic Programme r 79 Before you start to look at the bug, m ake sure that you ar e working on code that compiled cleanly— without warnings. W e routinely set com piler warni ng levels as high as possi ble. It doesn' t make sense to waste tim e trying to find a problem that the com piler could find for you! W e need to concentrate on the harder problem s at hand. When trying to solve any problem , you need to gather all the relevant data. Unfortunately, bug reporting isn' t an exact science. It' s easy to be misled by coincidences, and you can' t afford to waste time debugging coincidences. You first need to b e accurate in your observ ations. Accuracy in bug reports is further dim inished when they com e through a third party—you m ay actually need to watch the user who reported the bug in action to get a sufficient level of detail. Andy once worked on a large graphics application. N earing release, the test ers reported that the application crashed every tim e they painted a stroke with a pa rticular brush. The programm er responsible argued that there was nothing wrong with it; he had tried painting with it, and it worked just fine. This dialog went b ack and forth for several days, with tem pers rapidly rising. Finally, we got them together in the sam e room . The tester selected the b rush tool and painted a stroke from the upper right corner to the lower le ft corner. The applicatio n exploded. \"Oh,\" said the programm er, in a sm all voice, who then sheepis hly adm itted that he h ad made test str okes only f rom the lower left to the upper righ t, which did not expose the bug. There are tw o points to this story: • You m ay need to interview the user who reported the bug in orde r to gather m ore data than you were initially given. • Artificial tests (such as the program mer's singl e brush stroke from bottom to top) don' t exercise enough of an application. Y ou m ust brutally test both boundary conditions and realistic end -user us age patterns. You need to do this sys tematically (see Ruthless Te sting ). Debugging Strategies Once you think you know what is going on, it' s tim e to find out what the program thinks is going on. Bug Reproduction No, our bugs aren' t really m ultiply ing (although some of them are probably old enou gh to do it legally). W e're talking about a different kind of reproduction. The best way to start fixing a bug is to m ake it reproducible. Afte r all, if you can' t reproduce it, how will you know if it is ever fix ed? But we want m ore than a bug that can be reproduced by following som e long series of steps; we want a bug that can be reproduced with a single command. It's a lot harder to fix a bug if you have to go through 15 steps to get to the point where the bug shows up. Sometimes by forci ng yourself to is olate the circum stances that d isplay the bu g, you'll _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 79 Hunt, Thomas The Pragmatic Programme r 80 even gain an insight on how to fix it. See Ubiquitos Autom ation, for other ideas along these lines. Visualize Yo ur Da ta Often, the easiest way to discern what a program is doing—or what it is going to do—is to get a good look at the data it is operating on. The sim plest exam ple of this is a straightforward \"variable name = data value\" approach, which m ay be implem ented as printed text, or as fields in a G UI dialog box or list. But you can gain a m uch deeper insight into your data by using a debugge r that allows you to visualize your data and all of the inte rrelationships that exist. There are debuggers that can represent your data as a 3D fly-over through a virtual reality landscape, or as a 3D wavefor m plot, or just as simple structural diagram s, as shown in Figure 3.2 on the next page. As you single-step through your program, pictures like these can be worth much m ore than a thousand words, as the bug you' ve been hunting suddenly jum ps out at you. Figure 3.2. Sample debugge r diagram of a circular li nked list. T he arrows represe nt pointers to nodes. Even if your debugger h as lim ited su pport for vis ualizing data, you can still do it you rself—eith er by hand, with paper and pencil, or with external plotting program s. The DDD d ebugger has som e visualization capab ilities, and is freely available (see [ URL 19 ]). It is interesting to note that DDD works with m ultiple la nguages, including Ada, C, C++, Fortran, Java, Modula, Pascal, Perl, and Python (clearly an orthogonal design). Tracing Debuggers generally focus on the state of the program now. Som etimes you need m ore—you need to watch the state of a program or a data struct ure over tim e. Seeing a stack trace can only tell you how you got here directly. It can' t tell you what you were doing prior to this call chain, especially in event-b ased system s. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 80 Tracing statements are those little diagnostic m essages you prin t to the screen or to a file that say things such as \"got he re\" and \"va lue of x = 2.\" It's a prim itive techniqu e compared with IDE-style debuggers, but it is peculiarly effect ive at diagnosing severa l classes of errors th at debuggers can' t. Tracing is invaluable in any system where tim e itself is a facto r: concu rrent proces ses, real-tim e system s, and event-b ased application s. Hunt, Thomas The Pragmatic Programme r 81 You can use tracing statem ents to \"drill down\" into the code. That is, you can add tracing statem ents as you descend the call tree. Trace m essages should b e in a regular, consisten t format; you m ay want to parse th em autom atically. For instance, if you needed to trac k down a resource leak (such as unbalanced file opens/closes), you could trace each open and each close in a log file. By processing the log file with Perl, you could easily identify where the of fending open was occurring. Corrupt Variables? Check Their Neighborhood Sometimes you' ll exam ine a variable, expecting to see a sm all integer value, and instead get som ething like 0x6e69614d. Before you roll up your sleeves for some serious debugging, have a quick look at the m emory ar ound this co rrupted variab le. Often it will give you a clue. In our case, exam ining the surrounding m emory as characters shows us 20333231 6e69614d 2c745320 746f4e0a 1 2 3 M a i n S t , \\n N o t 2c6e776f 2058580a 31323433 00000a33 o w n , \\n x x 3 4 2 1 3\\n\\0\\0 Looks like som eone sprayed a street addre ss over our counter. Now we know where to look. Rubber Ducki ng A very sim ple but particularly useful technique for finding the cau se of a problem is sim ply to explain it to som eone else. The other person s hould look over your shoulder at the screen, and nod his or her head constantly (like a rubber duck bobbing up and down in a bathtub). They do not need to say a word; the sim ple act of explaining, step by step, what the code is supposed to do often causes th e problem to leap off the screen and ann ounce itself.[7] [7] Why \"rubber ducking\"? While an undergraduate at Imperial College in London, Dav e did a lot of work with a research assistant named Greg Pugh, one of the best developers Dave has kno wn. For se veral months Greg carried around a small yellow rubber duck, which he'd place o n his terminal while coding. It was a wh ile before Dav e had the courage to ask.... It sounds simple, but in explaini ng the problem to another person you m ust explicitly state things that you m ay take for granted when going through the code yourself. By having to verbalize som e of these assumptions, you m ay suddenly gain new insight into the problem. Process of Elimina tion In most projects, the code you are debugging m ay be a mixture of application code written by you and others on your project team , third-party produc ts (database, connectivity, graphical libraries, specialized communications or algorithm s, and so on) and the platform environm ent (operating system , system libraries, and com pilers). It is possible that a bug exists in the OS, the compiler, or a third-party produc t—but this should not be your first thought. It is m uch more likely th at the bug exists in th e application code under developm ent. It is generally m ore profitable to assum e that the applica tion code is incorrectly _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 81 Hunt, Thomas The Pragmatic Programme r 82 calling in to a lib rary tha n to assum e that th e library itself is broken. Even if the problem does lie with a th ird party, you' ll still have to elim inate yo ur code befo re subm itting the bug report. We worked on a project where a senior engineer was convinced that the select system call was broken on Solaris. No amount of persuasion or logi c could change his m ind (the fact that every other networking applicati on on the box worked fine was irreleva nt). He spent weeks writing work- arounds, which, for some odd reason, didn' t seem to fix the problem . When finally forced to sit down and read the docum entation on select, he discovered the problem and corrected it in a matter of m inutes. W e now use the phrase \"select is broken\" as a gentle rem inder whe never one of us starts blam ing the system for a fault that is likely to be our own. Tip 26 \"select\" Isn' t Broken Remember, if you see hoof prints, think horses—not zebras. The OS is probably not broken. And the database is probably just fine. If you \"changed only one thing\" and the system stopped working, that one thing was likely to be responsible, directly or indirec tly, no m atter how farf etched it seem s. Sometim es the thing that changed is outside of your control: new versions of the OS, com piler, database, or other third-party software can wreak havoc with previously corr ect code. New bugs m ight show up. Bugs for which you had a work-around get fixed, breaking the work-a round. APIs change, functi onality changes; in short, it' s a whole new ball gam e, and you m ust retes t the sy stem under these new con ditions. So keep a clo se eye on the s chedule when considerin g an upgrad e; you m ay want to wait until after the next release. If, however, you have no obvious place to star t looking, you can always rely on a good old- fashioned binary search. See if the symptom s are pres ent at either of two far away spots in the code. Then look in the m iddle. If the pr oblem is present, then the bug lies between the start and the m iddle point; otherwise, it is between th e middle point and the end. You can continue in this fashion until you narrow down the spot sufficien tly to identify the problem. The Element of Surprise When you fi nd yourself surprised by a bug (perhaps even m uttering \"that' s impossible\" under your breath where we can' t hear you), you m ust reeval uate truths you hold dear . In that linked list routine—the one you knew was bulletproof and c ouldn' t possibly be the cause of this bug—did you test all the b oundary con ditions ? That other piece of code you' ve been using for years —it cou ldn't possibly still have a bug in it. Could it? Of course it can. The amount of surprise you feel when som ething goes wrong is directly proportional to the am ount of trust an d faith you h ave in th e code being run . That' s why, when faced with a \"surprising\" failure, you m ust realize that one or m ore of your assumptions is w rong. Don' t gloss over a routin e or piece of code involved in the bug because you \"kn ow\" it work s. Prove it. Prove it in this context, with this data, with these boundary conditions. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 82 Hunt, Thomas The Pragmatic Programme r 83 Tip 27 Don' t Assum e It—Prove It When you com e across a surprise bug, beyond merely fixing it, you need to determ ine why this failure wasn' t caught earlier. Consid er whether you need to am end the unit or other test s so that they would have caught it. Also, if the bug is the result of bad data that was propagated th rough a couple of levels before causing the explosion, see if better param eter checking in those rout ines would have isolated it earlier (see the discussions on cr ashing early and assertions on pages 120 and 122, respectively). While you' re at it, are there any ot her places in the code that m ay be susc eptible to this sam e bug? Now is the tim e to find and fix them . Make sure that whatever happened, you' ll know if it happens again. If it took a long tim e to fix this bug, ask yourself why. Is there a nything you can do to m ake fixing this bug easier the next tim e around? Perhaps you c ould build in better test ing hooks, or write a log file analy zer. Finally, if the bug is the result of som eone's wrong assum ption, discuss the problem with the whole team : if one person m isunderstands, then it' s possible m any people do. Do all this, and hopefully you won' t be surprised next tim e. Debugging Checklist • Is the problem being reported a direct resu lt of the underlying bug, or m erely a sym ptom? • Is the bug really in the c ompiler? Is it in th e OS? Or is it in your code? • If you explained this problem in deta il to a coworker, what would you say? • If the suspect code passes its unit tests, are the tests com plete enough? What happens if you run the un it test with this data? • Do the conditions that caused this bu g exist anywhere else in the system ? Related sec tions include : • Assertive Programm ing • Programm ing by Coincidence • Ubiquitous Autom ation • Ruthless Te sting Challeng es • Debugging is challenge enough. Text Manipulation _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 83 Hunt, Thomas The Pragmatic Programme r 84 Pragm atic Programm ers manipulate text the sa me way woodworkers shape wood. In previous sections we discussed som e specific tools—sh ells, editors, debuggers—tha t we use. T hese are similar to a wood-worker' s chisels, saws, and plan es—tools specialized to do one or two jobs well. However, every now and then we need to perfor m som e transform ation not readily handled by the basic tool set. W e need a gene ral-purpose text m anipulation tool. Text m anipulation languages are to programm ing what routers[8] are to woodworking. They are noisy, m essy, and som ewhat brute f orce. Make m istakes with them , and entire pieces can be ruined. Some people swear they have no pl ace in the toolbox. But in the right hands, both routers and text manipulation languages can be incredibly powerful and versatile. You can quickly trim som ething into shape, m ake joints, and carve. Used properly, these tools have surprising finesse and subtlety. But they tak e time to m aster. [8] Here route r means the tool that spins cutting bla des very, very fast, not a device for inte rconnecting ne tworks. There is a growing num ber of good text m anipulation languages. Unix developers often like to use the power of their command shells, augm ented with tools such as awk and sed. People who prefer a more structured tool like the obj ect-oriented nature of Python [ URL 9]. Som e people use Tcl [ URL 23] as their tool of choice. We happen to prefer P erl [URL 8 ] for hacking out short scripts. These languages are im portant en abling technologies. Using them , you ca n quickly hack up utilities and prototype ideas—jobs that m ight take five or ten tim es as long using conventional languages. And that m ultiplying factor is crucially im portant to the k ind of experim enting th at we do. Spending 30 m inutes trying out a crazy idea is a whole lot better that spe nding five hours. Spending a day autom ating important co mponents of a project is accep table; spending a week might not be. In th eir book The Practice of Programming [KP99 ], Ker nighan and Pike built the sam e program in five different languages. The Perl vers ion was the shortest (17 lines, co mpared with C' s 150). W ith Perl you can m anipulate text, interact with program s, talk over networks, drive W eb pages, perform arbitrary precision arithm etic, and write program s that look like Snoopy swearing. Tip 28 Learn a Text Manipulation Language To show the wide-ranging applicability of text manipulation languages, here' s a sample of som e applications we' ve developed over the last few years. • Database schema maintenance. A set of Perl scripts took a pl ain text file containing a databa se schem a definition and from it generated: o The SQL statem ents to create the database o Flat data files to populate a data dictionary o C code libraries to acces s the databas e o Scripts to ch eck datab ase integ rity _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 84 o Web pages containing schem a descriptions and diagram s Hunt, Thomas The Pragmatic Programme r 85 o An XML ve rsion of the schem a • Java property access. It is good O O programm ing style to restrict access to an object' s propert ies, forcing external classe s to ge t and se t them via m ethods. Ho wever, in the com mon case where a p roperty is represented inside the class by a sim ple member variable, creating a get and set m ethod for each variable is tedious and m echanical. W e have a Perl s cript that m odifies the source files and inserts the correct m ethod definitions for all appropriately flagged variables. • Test data generation. We had tens of thousands of records of test data, spread over seve ral different files and formats, that needed to b e knitted tog ether and co nverted into a fo rm suitable for loading into a relational database. Perl did it in a couple of hours (a nd in the process found a couple of consistency errors in the original data). • Book w riting. We think it is im portant that any code presen ted in a book should have been tested first. Most of the code in this book has been. However, using the DRY princip le (see The Evils of Duplication ) we didn' t want to copy and paste lines of code from the tested program s into the book. That would have m eant that the code was duplicated, virtually guaranteeing that we'd forget to update an exam ple when th e corresponding program was changed. For som e exam ples, we also didn' t want to bore you with all the fram ework code needed to m ake our exam ple compile and run. W e turned to Perl. A relatively simple script is invoked when we format the book—it extracts a nam ed segm ent of a source file, does syntax highlighting, and converts the result into the typesetting language w e use. • C to Object Pascal interface. A client had a team of developers writing Ob ject Pascal on P Cs. Their code needed to interface to a body of code written in C. W e developed a short Pe rl script that parsed the C header files, extracting the defi nitions of all exported function s and the data structures they used. W e then generated Object Pascal units w ith Pascal records for all the C structu res, and imported procedure definitions for all the C f unctions. This generation process became part of the build, so that when ever th e C header changed, a new Object Pascal unit would be constructed autom atically. • Generating Web documentation. Many project team s are publishing their docum entation to internal W eb sites. W e have written m any Perl prog rams that analyze database schem as, C or C++ source files, makefiles, and other project sources to pr oduce the required HTML docum entation. We also use Perl to wrap the docum ents with standard headers and footers, and to transfer th em to the W eb site. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 85 Hunt, Thomas The Pragmatic Programme r 86 We use text m anipulation language s alm ost every day. Many of th e ideas in this book can be implem ented m ore sim ply in th em than in a ny other language of which we' re aware. These languages m ake it easy to write code ge nerators, which we' ll look at next. Related sections include: • The Evils of Duplication Exercises 11. Your C program uses an enum erated type to re present one of 100 states. You' d like to be able to print out the state as a string (as opposed to a num ber) for debugging purposes. W rite a scrip t that reads from standard input a file containing name state_a state_b : : Produce the file name.h, which contains extern const char * NAME_names[]; typedef enum { state_a, state_b, : : } NAME; and the f ile name.c, which contains const char * NAME_names[] = { \"state_a\", \"state_b\", : : }; 12. Halfway through writin g this book, we realized that we hadn' t put th e use strict directive into m any of our Perl examples. W rite a script that goes through the .p1 flies in a directory and adds a use strict at the end of the initial comm ent block to all flies that don' t already have one. Rem ember to keep a backup of all flies you change . Code Generators When woodworkers are faced with the task of producing the sam e thing over and over, they cheat. They build them selves a jig or a tem plate. If they get the jig right once, th ey can rep roduce a piece of work time af ter tim e. The jig takes away complexity and reduces the chances of making mistakes, leaving the craftsm an free to concentrate on quality. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 86 Hunt, Thomas The Pragmatic Programme r 87 As programm ers, we of ten find ours elves in a similar positio n. W e need to achieve th e sam e functionality, but in different contexts. W e need to repeat inform ation in different places. Sometimes we just need to protect ourselve s from carpal tunnel syndrom e by cutting down on repetitive typing. In the sam e way a woodworker invests the tim e in a jig, a programm er can build a code generator. Once built, it can be us ed throughou t the lif e of the project at virtu ally no cost. Tip 29 Write Code That W rites Code There are tw o main types of code generators: 1. Passive cod e generator s are run once to produce a result. Fr om that point forward, the result becom es freestanding—it is divorced from the code generator. The wizards discussed in Evil Wizards, along with some CASE tools, are ex amples of passive code generators. 2. Active code generators are used each time their results are re quired. The result is a th row- away—it can always be reproduced by the code generator. O ften, active code generators read som e form of script or cont rol file to produc e their results. Passive Code Generators Passive code generators save ty ping. They are basically parameteri zed templates, generating a given output from a set of inputs. Once the result is pro duced, it becom es a full-fledged source file in the project; it will be ed ited, com piled, and placed un der source control just li ke any other file. Its origins will be f orgotten. Passive code generators have m any uses: • Creating new source files. A passive code generator can produce tem plates, source code control directives, copyright not ices, and standard comment bl ocks for each new file in a project. W e have our editors set up to do this whenever we create a n ew file: ed it a n ew Java program , and the new ed itor buf fer will autom atically con tain a comm ent block, packa ge directive, an d the outline class declaration, alread y filled in. • Performing one-off conversions among programm ing languages. W e started writing this book using the troff system , but we s witched to LaTeXafter 15 sections had been completed. We wrote a code generator that read the troff source and conver ted it to LaTeX. It was about 90% accu rate; the res t we did by han d. This is an interesting feature of passive code generators: they don' t have to be totally accurate. You get to choose how much effort you put into the generator, com pared with the energy you spend fixing up its output. • Producing lookup tables and other resources that are expensive to com pute at runtim e. Instead of calculating tri gonom etric functions, many early graphics system s used precom puted tables of sine and cosine valu es. Typically, these tables were produced by a passive code generator and th en copied into the s ource. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 87 Hunt, Thomas The Pragmatic Programme r 88 Active Code Genera tors While passive code generators are simply a conve nience, their active cousin s are a necessity if you want to f ollow the DRY principle. W ith an active code generator, you can take a single representation of som e piece of kno wledge and convert it into a ll the form s your application needs. This is not duplication, b ecause the d erived form s are dispo sable, and are generated as needed by the code gen erator (hen ce the word active). Whenever you find yourself trying to get two dispar ate environm ents to wo rk together, you should consider using active code generators. Perhaps you' re developing a database application. Here, you' re dealing with two environm ents—the database and the programming language you are us ing to access it. You have a schem a, and you need to define low-level structures m irroring the layout of certain database tables. Y ou could just code these directly, but this violates the DRY principle: knowledge of the schem a woul d then be expressed in two places. When the schem a chan ges, you need to rem ember to chang e the corresponding code. If a colum n is rem oved from a table, but the code base is not changed, you might not even get a com pilation error. The first y ou'll know about it is when your tests start failing (or when the user calls ). An altern ative is to us e an active co de generator— take the schem a and use it to gene rate the sou rce code for the structures, as shown in Figure 3.3 . Now, whenever the schema changes, the code used to access it also changes, autom atically. If a colu mn is rem oved, then its correspond ing field in th e struc ture will disapp ear, and any hi gher-level co de that u ses that column will f ail to c ompile. You' ve caught the error at com pile tim e, not in production. Of course, this scheme works only if you m ake the code generation part of the build process itse lf.[9] [9] Just how do y ou go about building code from a da tabase sc hema? There are several ways. If the schema is he ld in a flat file (for example, as create table statements), the n a relatively simple script c an parse it and ge nerate the sourc e. Alte rnatively, if you use a tool t o create the schema directly in the database, then you sh ould be able to extract the information y ou ne ed directly from the database's data dictiona ry. Perl provides libraries that give you access to most major da tabases. Figure 3.3. Active code generator cre ates code from a database sc hema Another example of m elding environm ents usi ng code generators happens when different programm ing languages are used in the sam e applic ation. In order to communi cate, each code base will need so me infor mation in common—data s tructures, m essage form ats, and field n ames, for exam ple. Ra ther than duplicate this infor mation, use a code generator. Som etimes you can parse the inform ation out of the source files of one language and use it to generate code in a second language. Often, though, it is sim pler to express it in a sim pler, language-neutral repr esentation and generate the code for both languages, as show n in Figure 3.4 on the following page. Also see the answer to _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 88 Hunt, Thomas The Pragmatic Programme r 89 Exercise 13 on page 286 for an example of how to sepa rate the parsing of the fl at file representation from code generation. Figure 3.4. Ge nerating code from a lang uage-neutral rep resent ation. In the inpu t file, lines s tarting with 'M' flag the s tart of a messa ge definition, 'F' lines define fields, and 'E' is the e nd of the mess age. Code Generators Need n't Be Complex All this ta lk of active this and passive that m ay leave you with the im pression that code generators are com plex beasts. They needn' t be. Nor mally the most com plex part is th e parser, which analyzes the input file. Keep the input form at simple, and the code generator becom es sim ple. Have a look at the answer to Exercise 13 (page 286): th e actual code generation is basically print statem ents. Code Generators Need n't Generate Code Although many of the exam ples in this section show code generators that produce program source, this needn' t always be the case. You can use code generators to wr ite just about any output: HTML, XML, plain text—any text that might be an input som ewhere else in your project. Related sec tions include : • The Evils of Duplication • The Power of Plain Text • Evil W izards • Ubiquitous Autom ation Exercises 13. Write a code generator that ta kes the input file in Figure 3.4, and generates output in two languages of your choice. Try to m ake it easy to add new languages . _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 89 Hunt, Thomas The Pragmatic Programme r 90 _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 90 Hunt, Thomas The Pragmatic Programme r 91 Chapter 4. Pragmatic Paranoia Tip 30 You Can' t Write Perfect Software Did that hu rt? It shou ldn't. Accept it as an axiom of life. Em brace it. Cele brate it. Becau se perfect software doesn' t exist. No one in the brief histor y of com puting has ever wr itten a piece of perfect software. It' s unlikely th at you' ll be the first. And unless you accept this as a fact, you' ll end up wasting time and energy ch asing an impossible d ream. So, given this depressing reality, how does a Pr agmatic Programmer turn it in to an ad vantage ? That' s the to pic of this c hapter. Everyone knows that they personally are the only good driver on Earth. T he rest of the world is out there to get them , blowing through stop signs, weaving between lanes, not indicating turns, talking on the telephone, reading th e paper, and just generally not livi ng up to our standards. So we drive defensively. We look out for troubl e before it happens, anticipate the unexpected, and never put ourselves into a position from which we can' t extricate ourselv es. The analogy with coding is pre tty obvious. W e are constantly in terfacing with othe r people' s code— code that m ight not live up to our high standards—and dealing with inputs that m ay or m ay not be valid. So we are taught to code defensively. If there' s any doubt, we validate all inform ation we 're given. W e use assertions to detect bad data. W e check for consistency, put constraints on database colum ns, and generally feel pretty good about ourselves. But Pragm atic Program mers take this a step further. They do n't trus t themselves, e ither. Knowing that no one writes perfect code, including them selves, Pragm atic Programmers code in defenses against their own m istakes. W e descri be the first defensive measure in Design by Contract: clients and suppliers m ust agree on rights and responsibilities. In Dead Programs Tell No Lies, we want to ensure that we do no dam age while we' re working the bugs out. So we try to check things often and term inate the program if things go awry. Assertive Programming describes an easy m ethod of check ing along the way—write code that actively verifies your assum ptions. Exceptions, like any other technique, can cause more harm than good if not used properly. W e'll discuss the issues in When to Use Exception s. As your program s get more dynam ic, you' ll find yourself juggling system resources—m emory, files, devices, and the lik e. In How to Balance Resources, we'll suggest ways of ensuring that you don't drop any of the balls. In a world of i mperfect system s, ridiculous time scales, laughable tools, and im possible requirem ents, let' s play it safe. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 91 Hunt, Thomas The Pragmatic Programme r 92 When everybody actually is out to ge t you, paranoia is just good thinking. Woody Alien Design by Contract Nothing astonishes men so much as common sense and plain dealing. Ralph Waldo Emerson, Essays Dealing with com puter system s is hard. Dealing w ith people is even hard er. But as a species, we' ve had longer to figure out issues of hum an interactions. Som e of th e solutions we' ve come up with during th e last few millennia can be applied to writ ing sof tware as well. One of the bes t solutions for ensuring plain dealing is the contract. A contract defines your rights and responsibilities, as well as thos e of the other party. In addition, there is an agreem ent concerning rep ercuss ions if either party fails to abide by the contract. Maybe you have an em ploym ent contract that sp ecifies the hours you' ll wo rk and the rules of conduct you m ust follow. In return, the com pany pays you a salary and other perks. E ach party meets its obligations and everyone benefits. It's an idea used the world over—both for mally a nd inform ally—to help hum ans interact. Can we use the sam e concept to help software modules interact? The answer is \"yes.\" DBC Bertrand M eyer [Mey97b ] developed the concept of Design by Contract for the langu age Eif fel.[1] It is a sim ple yet powerful technique that focu ses on docum enting (and agreeing to) the rights and responsibilities of software m odules to ensure pr ogram correctness. W hat is a correct program ? One that does no more and no less than it claim s to do. Docum enting and verif ying that claim is the heart of Design by Contract (DBC, for short). [1] Based in pa rt on earlier work by Dijkstra, Floy d, Hoare, Wirth, and others. For more information on E iffel itself, see [URL 1 0] and [URL 1 1]. Every function and m ethod in a software system does something. Before it star ts tha t something, the routine m ay have som e expectation of the state of the world, and it m ay be able to m ake a statem ent about the state of the world when it concludes. Me yer describes these expect ations and claim s as follows: • Preconditio ns. What must be true in ord er for the ro utine to be called; the routine' s requirem ents. A routine should never get called when its preconditions would be violated. It is the caller' s responsibility to pass good da ta (see the box on page 115). • Postconditions. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 92 Hunt, Thomas The Pragmatic Programme r 93 What the routine is guaranteed to do; the state of the world w hen the routine is done. The fact that the routine has a postcondition im plies that it will conclude: infinite loops aren' t allowed. • Class invariants. A class ensures that this condi tion is always true from the perspective of a caller. During internal processing of a routin e, the invariant m ay not hold, bu t by the time the rou tine exits and contro l returns to the caller, th e invarian t must be true. (Note th at a class cannot give unrestricted write-access to any data m ember that participates in the invariant.) Let's look at the contract for a r outine that inserts a data value into a unique, ordered list. In iContract, a preprocessor for Java available from [URL 17 ], you' d specify it as /** * @invariant forall Node n in elements() | * n.prev() != null * implies * n.value().compare To(n.prev().value()) > 0 */ public class dbc_list { /** * @pre contains(aNode) == false * @post contains(aNode) == true */ public void insertNode( final Node aNode) { // ... Here we are saying that nodes in th is list m ust always be in increas ing order. W hen you insert a new node, it can' t exist already, and we guarantee that the node will be found after you have inserted it. You write th ese preconditions, pos tconditions, an d invariants in the target programm ing language, perhaps with som e extensions. For exam ple, iContract provides pred icate logic operators— forall, exists, and implies —in addition to norm al Java constructs. Your assertions can query the state of any object that the m ethod can access, but be sure that the query is free from any side effects (see page 124). DBC and Constant Parameters Often, a postcondition w ill us e param eters pa ssed into a m ethod to verify correct behavior. B ut if the routine is allowed to ch ange the param eter that' s passed in, you might be able to circum vent the contract. E iffel doesn' t allow this to happen, but Java does. Here, we use the Java keyword final to indicate our intenti ons that the param eter shouldn' t be changed within the m ethod. This isn' t foolproof–subclasses are free to redeclare the param eter as non-final. Alte rnatively, you can use the iContract syntax variable @pre to get the original value of the va riable as it ex isted on entr y to the method. The contract between a rou tine and any potential calle r can thus be read as _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 93 Hunt, Thomas The Pragmatic Programme r 94 If all the rou tine's preco nditions a re met by the c aller, the ro utine sha ll guarantee that all postconditions a nd invarian ts will be tru e when it co mpletes. If eithe r party fails to liv e up to the term s of the contract, then a rem edy (which was previously agreed to) is invoked—an exception is raised, or the program term inates, for instance. Whatever happens, m ake no m istake that failure to live up to the contract is a bug. It is not som ething that should ever happen, which is why pr econditions should not be used to perfor m things such as user- input validation. Tip 31 Design with Contracts In Orthogonality , we recomm ended writing \"s hy\" code. Here, the em phasis is on \"lazy\" code: be strict in what you will accept be fore you begin, and prom ise as li ttle as p ossible in return. Remember, if your contract ind icates that you' ll accept any thing and promise th e world in return, then you' ve got a lot of code to write! Inheritance and polym orphism are the cornerstones of object-oriented lan guages and an area where contracts can really shine. Suppose you are usin g inheritance to create an \"is-a-kind-of\" relationship, where one class \"is- a-kind-of\" another class. You pr obably want to adhere to the Liskov Substitution Principle [Lis88 ]: Subclasses must be usable through the base cl ass interface without the need for the user to know the difference. In other words, you want to m ake sure that the new subtype you have created really \"is-a-klnd-of\" the base type—that it supports the same methods, and that the m ethods have the sam e meaning. We can do this with contracts. W e need to specify a c ontract only once, in the base class, to have it applied to every future s ubclass au tomatically. A subclass m ay, optionally , accept a wider rang e of input, or m ake stronger guarantees. But it m ust accep t at least as m uch, and guaran tee as m uch, as its parent. For exam ple, consider th e Java bas e class java.awt.Component. You can treat any visual component in AW T or Swing as a Component, without knowing that the ac tual subclass is a button, a canvas, a m enu, or whatever. Each individu al com ponent can provide addition al, specific functionality, but it has to provide at least the bas ic capab ilities defined b y Component. But there 's nothing to prevent you f rom creating a subtype of Component that provides correctly nam ed methods that do the wrong th ing. You can easily create a paint method that doesn' t paint, or a setFont method that doesn' t set the f ont. AWT doesn' t have contract s to catch the fact that you didn' t live u p to the ag reement. Without a contract, all the com piler can do is ensure that a subclass conf orms to a particular m ethod signatu re. B ut if we put a base class contract in place, we can now ensure that any futu re subclass can't alter th e meanings of our m ethods. For instance, you might want to establish a contract for setFont such as the following, which ensures that the font you set is the font you get: _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 94 Hunt, Thomas The Pragmatic Programme r 95 /** * @pre f != null * @post getFont() == f */ public void setFont( final Font f) { // ... Implementing DBC The greatest benefit of using DBC may be that it fo rces the issue of requirem ents and guarantees to the forefront. Sim ply enum erating at design tim e what the input dom ain range is, what the boundary conditions are, and what the routine prom ises to deliver—or, more im portantly, what it doesn't prom ise to deliver—is a huge leap forward in wri ting better software. By not stating these things, you are back to program ming by coincidence , which is where m any projects start, finish, and fail. In languages that do not support DBC in the code, th is might be as far as you can go—and that' s not too bad. DBC is, after all, a design technique. Even without auto matic checking, you can put the contract in the code as comm ents and still get a very real benefit. If nothing else, the commented contracts give you a place to st art looking when trouble strikes. Asserti ons While docum enting these assum ptions is a great st art, you can get m uch greater benefit by having the com piler check your contract for you. You can pa rtially emulate this in som e languages by using assertions (see Assertive Programm ing). Why only partially? Can' t you us e assertions to do everything DBC can do? Unfortunately, the answer is no. To begin with, th ere is no support for prop agating assertions down an inheritance hierarchy. This m eans that if you ove rride a base class m ethod that has a contract, the assertions that im plem ent that contract will not be called co rrectly (unless you duplicate them manually in the new code). You m ust remember to call the c lass invar iant (and all base class invariants) m anually before you exit every m ethod. Th e basic problem is that the contract is not autom atically enforced. Also, there is no built-in concept of \"old\" valu es; that is, valu es as they ex isted a t the e ntry to a method. If you' re using assertions to enforce c ontracts, you m ust add code to the p recondition to save any inf ormation you' ll want to use in the postcondition. Com pare this with iContract, where the postcondition can just reference \"Variable @pre,\" or with Eiffel, which supports \"old expression .\" Finally, the runtim e system and libra ries are not designed to support co ntracts, so these calls are not checked. Th is is a b ig loss, because it is often at the boundary between yo ur code and the libraries it uses that the m ost probl ems are detected (see Dead Program s Tell No Lies for a m ore detailed discussion). Language Suppor t _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 95 Hunt, Thomas The Pragmatic Programme r 96 Languages that feature built-in support of DBC (such as Eiffel and Sather [ URL 12 ]) check pre- and postconditions autom atically in the compiler and runtim e system . You ge t the greatest benefit in this case becaus e all of the code base (libraries, too) must honor their contracts. But what about m ore popular languages such as C, C++, and Java? For these languages, there are preprocessors that process contracts embedded in th e original source cod e as special co mments. The preprocessor expands these comm ents to code that verifies the assertions. For C and C++, you m ay want to investigate Nana [URL 18]. Nana doesn't handle inheritance, but it does use the debugger at runtim e to m onitor assertions in a novel way. For Java, there is iContract [ URL 17 ]. It takes comments (in Java Doc form ) and generates a new source file with the assertion logic included. Preprocessors aren' t as good as a bu ilt-in facility. They can be m essy to integrate into your project, and other libraries you use won' t have contracts. B ut they can still be very helpful; when a problem is discovered this way—es pecially one that you would never have found—it' s alm ost like m agic. DBC and Crashing Early DBC fits in nicely with our concep t of crashing early (see Dead Program s Tell No Lies ). Suppose you have a m ethod that calculates square roots (such as in the Eiffel class DOUBLE ). It needs a precondition that restricts the dom ain to positive num bers. An Eiffe l precondition is d eclared with the keyword require, and a postcondition is declared with ensure, so you could write sqrt: DOUBLE is -- Square root routine require sqrt_arg_must_be_positive: Current >= 0; --- ... --- calculate square root here --- ... ensure ((Result*Result) - Current).abs <= epsilon*Current.abs; -- Result should be within error tolerance end; _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 96 Who's responsible? Who is repondible for cheeking the precondition, the caller or the ro utine being called? when im plemented as part of the language, th e answer is neither: the routine but before the rou tine itself is en tered. Thus if there is any explicit checking of parameters to be done, it m ust be perform ed by the caller,because the rou tine it self will nev er see param eters that violate its precondition. (F or languages without built-in support, you would need to bracket the called routine with a p reamble a nd/or postam ble that checks these as sertions.) Consider a program that reads a num ber from the console, calculate its square root (by callin g sqrt), and prints the resu lt. The sqrtfunction has a preconditio n—its a rgument Hunt, Thomas The Pragmatic Programme r 97 must not be negative. If the user enters a ne gative num ber at the c onsole, it is up to the calling code to ensure that it never gets passed to sqrt. This calling code has m any options: it could term inate, it could issue a warning and read another num ber, or it could make the number postive and append an \" i\" to th e result r eturned by sqrt. Whater its choice, this is definitely not sqrt 's problem . By expressing the dom ain of the square root function in the precondition of the sqrt routine, you shift the burden of correctness to the call— where it belongs. you can then design the sqrt routine secure in the knowledge its input will be in range. If your algorithm for calculating the square root fails (or isn' t within the sp ecified error tolerance), you get an error m essage and a stac k trace to show you the call chain. If you pass sqrt a negative param eter, the E iffel runtim e prints the error \"sqrt_arg_must_be_positive,\" along with a stack trace. T his is better than the alternative in languages such as Java, C, and C++, where passing a negative num ber to sqrt return s the spec ial value NaN (Not a Num ber). It m ay be som e time later in the program that you attem pt to do som e math on NaN, with surprising resu lts. It's much easier to find and di agnose the problem by crashing earl y, at the site of the problem . Other Uses of Invarian ts So far we have discussed pre- a nd postconditions that apply to i ndividual m ethods and invariants that apply to all m ethods within a class, but there are other useful ways to use invariants. Loop Inva riant s Getting the boundary co nditions righ t on a nontrMal l oop can be problem atic. Loops are sub ject to the banana problem (I know how to spell \"banana,\" but I don' t know when to stop), fencepost errors (not knowin g whether to count the fenceposts o r the spaces b etween them ), and the ubiquitous \"off by one\" error [ URL 52 ]. Invariants can help in these situation s: a loop invariant is a s tatem ent of the eventual goal of a loo p, but is generalized so that it is also valid before the loop execu tes and on each iteration through the loop. You can think of it as a kind of m iniature cont ract. The classic exam ple is a routine that finds the m aximum value in an array. int m = arr[0]; // example assumes arr.length > 0 int i = 1; Loop invariant: m = max(arr[0:i-1]) // while (i < arr.length) { m = Math.max(m, arr[i]); i = i + 1; } _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 97 Hunt, Thomas The Pragmatic Programme r 98 (arr[m:n ] is a notational convenience meaning a slice of the array from index m to n.) The invarian t must be true before the loop runs, and the body of th e loop must ensure that it rem ains true as the loop executes. In this way we know that the inva riant also holds when the loop term inates, and therefore that our result is valid. Loop invariants can be coded explic itly as asse rtion s, but they a re also useful as design and docum entation tools. Sema ntic Invaria nts You can use semantic invariants to express inviolate requirem ents, a kind of \"philosophical contract.\" We once wrote a debit card transaction switch. A m ajor requ irement was that the u ser of a debit card should never have the sam e transaction applied to their account twice. In other words, no matter what sort of failure m ode m ight ha ppen, the error should be on the side of not processing a transaction rather than pro cessing a duplicate transaction. This sim ple law, driven direc tly from the requir ements, proved to be very helpful in sorting out complex error recovery scenarios, and guided the detailed design and implem entatio n in m any areas. Be sure not to confuse requirem ents that are fixed , inviolate la ws w ith thos e that are m erely po licies that m ight change with a new m anagem ent regime. That' s why we use the term semantic invar iants— it must be ce ntral to th e very meaning of a thing, and not subject to the whim s of policy (which is w hat more dynam ic business rules are for). When you fi nd a requirem ent that qualifies, m ake sure it becom es a well-known part of whatever docum entation you are producing— whether it is a bu lleted list in the requirem ents docum ent that gets signed in triplicate or just a big note on the comm on whiteboard that everyone sees. Try to state it clearly and unam biguously. For exam ple, in the debit card exam ple, we m ight write ERR I N FAVOR OF THE CONS UMER. This is a clear, concise, unam biguous statem ent th at's applicable in m any different areas of the system . It is our contract with all user s of the system , our guarantee of behavior. Dynamic Contracts an d Agents Until now, we have talk ed about con tracts as fixe d, immutable specifications. But in the landscap e of autonom ous agents, th is doesn' t need to be th e case. By the definition of \"autonom ous,\" agents are free to reject requests that they do not want to honor. They are free to renegotiate the contract— \"I can' t provide that, but if you give m e this, then I m ight provide som ething else.\" Certainly any system that relies on agent technology has a critical dependence on contractual arrangem ents—even if they are dynam ically generated. Imagine: with enough components and agents th at can negotiate their own contracts am ong them selves to achieve a goal, we m ight just solve the software productivity cr isis by letting softw are solve it for us. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 98 Hunt, Thomas The Pragmatic Programme r 99 But if we can' t use contracts by hand, we won' t be able to use them automatic ally. So next tim e you design a piece of software, de sign its contract as well. Related sec tions include : • Orthogonality • Dead Program s Tell No Lies • Assertive Programm ing • How to Balance Resources • Decoupling and the Law of De meter • Temporal Coupling • Programm ing by Coincidence • Code That' s Easy to Test • Pragm atic Team s Challeng es • Points to ponder: If DBC is so powerful, why is n't it used more widely? Is it hard to com e up with the contract? Does it m ake you think about issues you' d rather ignore for now? Does it force you to THINK!? Clearly, this is a dangerous tool! Exercises 14. What m akes a good contract? Anyone can add pr econditions and postcon ditions, b ut will th ey do you any good? Worse yet, will they actually do m ore harm than good? For the example below and for those in E xercises 15 and 16, decide whether the specified contract is good, bad, or ugly, and explain why . First, let' s look at an Eiffel exam ple. Here we have a routine for adding a STRING to a doubly linked, circular list (rem ember that preconditions are labeled with require, and postconditions with ensure). -- Add an item to a doubly linked list, -- and return the newly created NODE. add_item (item : STRING) : NODE is require item /= Void -- '/=' is 'not equal'. deferred -- Abstract base class. ensure result.next.previous = result -- Check the newly result.previous.next = result -- added node's links. find_item(item) = result -- Should find it. end 15. Next, let' s try an exam ple in Java—som ewha t sim ilar to the exam ple in Exercis e 14. insertNumber inserts an integer into an ordered list. Pre-and postc onditions are labeled as in iContract (see [URL 17]) . _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 99 Hunt, Thomas The Pragmatic Programme r 100 private int data[]; /** * @post data[index-1] < data[index] && * data[index] == aValue */ public Node insertNumber ( final int aValue) { int index = findPlaceToInsert(aValue); ... 16. Here' s a fragm ent from a stack cla ss in Java. Is this a good contract? /** * @pre anItem != null // Require real data * @post pop() == anItem // Verify that it's * // on the stack */ public void push(final String anItem) 17. The class ic exam ples of DBC (as in Exercis es 14-16) show an im plementation of an ADT (Abstract Data Type)—typically a stack or queue. But not m any people really write these kinds of low-level classes . So, for this e xercis e, design an inte rface to a kitchen blende r. It will eventu ally be a W eb- based, Internet-enabled, CORBA-fie d blender, but for now we just need the in terface to control it. It has ten speed se ttings (0 m eans off). You can 't operate it em pty, and you can change the speed only one unit at a tim e (that is, from 0 to 1, and from 1 to 2, not from 0 to 2). Here are the m ethods. Add a ppropriate pre- and postconditions and an invariant. int getSpeed() void setSpeed( int x) boolean isFull() void fill() void empty() 18. How m any num bers are in the series 0,5,10,15,…, 100? Dead Programs Tell No Lies Have you noticed that som etimes other people can detect that things aren' t well with you before you're aware of the problem yourself? It's the sam e with other people' s code. If som ething is starting to go awry with one of our program s, som etimes it is a library routine that catches it f irst. Maybe a stray pointer has caused us to overw rite a f ile han dle with so mething m eaningle ss. T he next ca ll to read will catch it. Perhaps a buffer overrun has trashe d a cou nter we' re about to use to determ ine how m uch m emory to alloca te. May be we' ll get a f ailure f rom malloc. A logic error a couple of million instructions ago m eans that the selector f or a cas e statem ent is no longer the expected 1, 2, or 3. W e'll hit th e default case (which is one reason why each and every case/switch statem ent needs to have a default clause—we want to know when the \"im possible\" has happened). _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 100 Hunt, Thomas The Pragmatic Programme r 101 It's easy to f all into th e \"it can' t happ en\" m entalit y. Most of us have written code that didn' t check that a f ile closed succes sfully, or tha t a tra ce state ment got written a s we e xpected. An d all things being equal, it' s likely that we didn' t need to—t he code in question wouldn' t fail under any norm al conditions. But we' re coding defensively. W e're looking for rogue pointers in other parts of our program trashing the stack. W e're checking that th e correct ve rsions of shared lib raries were actually loaded. All errors give you inform ation. You could convi nce yourself that the error can' t happen, and choose to ignore it. Instead, Pragm atic Programmers tell themselves that if there is an error, something very, very bad has happened. Tip 32 Crash Early Crash, Don't Trash One of the benefits of detecti ng problem s as soon as you can is that you can crash earlier. And many times, crashing your program is the best th ing you can do. The alternative m ay be to continue, writing corrupted data to som e vital database or commanding the washing m achine into its twentieth co nsecutive sp in cycle. The Java lan guage and libraries have em braced this philo soph y. W hen som ething unexpected happens within the runtim e syste m, it throws a RuntimeException. If not caught, th is will percolate up to the top level of the program and cause it to halt, displaying a stack trace. You can do the sam e in other languages. If you don't have an exception mechanism , or if your libraries don' t throw exceptions, then m ake sure y ou handle the errors yourself . In C, macros can be very useful for this: #define CHECK(LINE, EXPECTED) \\ { int rc = LINE; \\ if (rc != EXPECTED) \\ ut_abort(__FILE__, __LINE__, #LINE, rc, EXPECTED); } void ut_abort( char *file, int ln, char *line, int rc, int exp) { fprintf(stderr, \"%s line %d\\n'%s': expected %d, got %d\\n\", file, ln, line, exp, rc); exit(1); } Then you can wrap calls that should never fail using CHECK(stat(\"/tmp\", &stat_buff), 0); If it should f ail, you' d get a m essage written to stderr: _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 101 Hunt, Thomas The Pragmatic Programme r 102 source.c line 19 'stat(\"/tmp\", &stat_buff)': expected 0, got -1 Clearly it is som etimes inappropriate sim ply to exit a running program . You m ay have claim ed resources that m ight not get released, or you may need to write log m essages, tidy up open transactions, or interact with other processes. The techniques we discuss in When to Use Exceptions , will help here. However, the bas ic princi ple stays the sam e—when your code discovers that som ething that was supposed to be im possibl e just happened, your program is no longer viable. Anything it does from this point forw ard becom es suspect, so term inate it as soon as possible. A dead program nor mally does a lot le ss dam age than a crippled one. Related sec tions include : • Design by Contract • When to Use Exception s Assertive Program ming There is a luxury in self-reproach. When we blam e ourselves we feel no o ne else has a right to blame us. Oscar W ilde, The Pictu re of Dorian Gray It seem s that there' s a m antra that ev ery program mer must mem orize early in his or her career. It is a funda mental tenet of computing, a co re belief that we learn to appl y to requirem ents, designs, code, comments, just about ev erything we do. It goes THIS CAN N EVER HAP PEN… \"This code won' t be used 30 years from now, so tw o-digit dates are fine.\" \"This application will never be used abroad, so why internationalize it? \" \"count can't be negative.\" \"This printf can't fail.\" Let's not practice this kind of self -deception, particularly when coding. Tip 33 If It Can' t Happen, Use Assertions to Ensure That It W on't Whenever you find yourself thinking \"but of course that could never happen,\" add code to check it. The easie st way to do th is is wi th assertions. In m ost C and C++ im plementations, you' ll find some form of assert or _assert macro that checks a Boolean condition. These m acros can be invaluable. If a pointer passed in to your procedure should never be NULL, then check for it: void writeString( char *string) { _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 102 Hunt, Thomas The Pragmatic Programme r 103 assert(string != NULL); ... Assertions are also useful checks on an algorith m's operation. Maybe you' ve written a clever sort algor ithm. Check tha t it works: for (int i = 0; i < num_entries-1; i++) { assert(sorted[i] <= sorted[i+i]); } Of course, the condition passed to an assertion s hould not have a side eff ect (see the box on page 124). Also rem ember that assertions m ay be tu rned off at compile tim e—never put code that must be executed into an assert. Don' t use assertions in p lace of real error h andling. Assertio ns check for things th at should never happen: you don' t want to be writing code such as printf(\" Enter 'Y' or 'N': \"); ch = getchar(); assert((ch == 'Y') || (ch == 'N')); /* bad idea! */ And just because the supplied assert macros call exit when an assertion fails, there' s no reason why versions you write should. If you need to free re sources, have an asserti on failure generate an exception, longjmp to an exit point, or call an error handler . Just m ake sure the code you execute in those dying m illiseconds doesn' t rely on the inform ation that triggered the a ssertion failure in the first place. Leave Assertions Turned On There is a comm on m isunderstand ing about assertions, promulga ted by the people who write compilers and language environm ents. It goes som ething like this: Assertion s odd some overhead to cod e. Because they check fo r things that should never happen, they'll get triggered o nly by a bug in the cod e. Once the co de has been tested and shipped, they are no longer needed, and should be turned off to make the code run faster. Assertions are a debugging facility. There are tw o patently wrong assum ptions here. F irst, they assum e that test ing finds all the bugs. In reality, for any com plex program you are unlikely to test even a m iniscule percentage of the perm utation s your code will be pu t through (see Ruthless Te sting ). Second, the optim ists are forgetting that your program runs in a dangerous world. During testing, ra ts probably won' t gnaw through a communications cable, som eone playing a gam e won' t exhaust m emory, and log files won' t fill the hard driv e. These thing s might happ en when your program runs in a prod uction environm ent. Your first line of defense is checki ng for any possible error, and your second is using assertions to try to detect those you' ve m issed. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 103 Hunt, Thomas The Pragmatic Programme r 104 Turning off assertions w hen you deliver a progra m to production is like crossing a high wire without a net because yo u once m ade it across in practice. Th ere's dram atic value, bu t it's hard to g et life insu rance. Even if you do have perf ormance issues, turn off only thos e assertions that rea lly hit you. The sort exam ple above m ay be a critical part of Assertion and Side Effects It is em barrassing when the code we add to de tect errors actually ends up creatings new errors. This can happen with a ssertions if evaluating the c ondition has side effects. for exam ple, in Java it would be a bad to code som ething such as while (iter.hasmoreElements () { Test.ASSERT(iter.nextElements() != null); object obj = iter.nextElement(); // .... } The .nextElement() call in the ASSERT has the side effects of moving the ite rator past the elem ent being fetched, and so the loop w ill process only h alf the elements in the collection. It would be better to write while (iter.hasmoreElements()) { object obj = iter.nextElement(); Test.ASSERT(obj != null); //.... } This problem is a kind of \"Heisenbug\"—debug ging that changes the behavior of the system system being debugged (see [ URL 52 ]). your application, and m ay need to be fast. Addi ng the check m eans another pass through the data, which m ight be unaccep table. Mak e that particu lar check op tional,[2] but leave the rest in. [2] In C -based languages, you can either use the preprocessor or u se if statements t o make assertions optional. Ma ny impleme ntations turn off code generation for the assert macr o if a compile-time flag is set (or not set). Otherwise, yo u can place the code within an if statement with a consta nt condition, whic h ma ny compilers (inc luding most common Ja va system s) will optim ize away. Related sec tions include : • Debugging • Design by Contract • How to Balance Resources • Programm ing by Coincidence Exercises _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 104 Hunt, Thomas The Pragmatic Programme r 105 19. A quick reality check. Which of thes e \"im possible\" th ings can happen? 1. A month with fewer than 28 days 2. stat(\".\" ,&sb) == -1 (that is, can' t access the curren t directory) 3. In C++: a = 2; b = 3; if (a + b != 5) exit(1); 4. A triangle with an interior angle sum \\u8800 180° 5. A minute that doesn' t have 60 seconds 6. In Java: a + 1) <= a 20. Develop a simple assertion checking class for Java . When to Use Exceptions In Dead Pro grams Tell No Lies , we suggested that it is good pr actice to check for every possible error—p articularly the u nexpected o nes. However, in practic e this can le ad to som e pretty ugly code; the norm al logic of your program can end up being totally obscured by error handling, particularly if you subscribe to the \"a routine m ust have a sing le return statem ent\" school of programm ing (we don' t). W e've seen code that looks som ething like the following: retcode = OK; if (socket.read(name) != OK) { retcode = BAD_READ; } else { processName(name); if (socket.read(address) != OK) { retcode = BAD_READ; } else { processAddress(address); if (socket.read(telNo) != OK) { retcode = BAD_READ; } else { // etc, etc... } } } return retcode; Fortunately, if the programming language supports exceptions, you can rewrite this code in a far neater way: retcode = OK; try { socket.read(name); process(name); _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 105 Hunt, Thomas The Pragmatic Programme r 106 socket.read(address); processAddress(address); socket.read(telNo); // etc, etc... } catch (IOException e) { retcode = BAD_READ; Logger.log( \"Error reading individual: \" + e.getMessage()); } return retcode; The norm al flow of cont rol is now clear, with a ll the error handling m oved off to a single place. What Is Exceptional? One of the problem s with exceptions is knowing wh en to use them . We believe that exceptions should rarely be used as part of a program' s normal flow; exceptions should be reserved for unexpected events. Assum e that an uncaught exception will term inate your program and ask yourself, \"W ill this co de still run if I rem ove a ll the excep tion handlers ?\" If the ans wer is \"no, \" then maybe exceptions are being used in nonexceptional circum stances. For exam ple, if your code tries to open a file fo r reading and that file does not exist, should an exception be raised ? Our answer is, \"It depends.\" If the file should have been there, then an exception is warranted. Something unexpected happened—a f ile you were expecting to exist seems to have disappeared. O n the other hand, if you have no idea w hether the fi le should exist or not, then it doesn' t seem exceptional if you can' t find it, and an error return is appropriate. Let's look at an exam ple of the first case. The following code opens the file /etc/passwd, which should exist on all Unix system s. If it fails, it passes on the FileNotFoundException to its caller. public void open_passwd() throws FileNotFoundException { // This may throw FileNotFoundException... ipstream = new FileInputStream(\" /etc/passwd \"); // ... } However, the second case m ay involve opening a file specified by the user on the com mand line. Here an exception isn' t warrante d, and the code looks different: public boolean open_user_file(String name) throws FileNotFoundException { File f = new File(name); if (!f.exists()) { return false; } _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 106 Hunt, Thomas The Pragmatic Programme r 107 ipstream = new FileInputStream(f); return true; } Note that th e FileInputStream call can still generate an ex ception, which the routine passes on. However, the exception will be gen erated und er onl y truly exception al circumstances; sim ply tryin g to open a file that does not exist will generate a conven tional error return. Tip 34 Use Exceptions for Exceptional Problem s Why do we suggest this approach to exceptions? Well, an excep tion represents an imm ediate, nonlocal transfer of contro l—it' s a kind of cascading goto. Program s that use exceptions as part of their norm al processing suffer from all the re adability and mainta inability problem s of classic spaghetti code. These program s break encapsulation: routines and their ca llers are more tigh tly coupled via exception handling. Error Han dlers Are a n Alternative An error han dler is a rou tine tha t is ca lled when an error is detected. You ca n register a routine to handle a specific category of erro rs. When one of these errors o ccurs, the handler will be called. There are tim es when you m ay want to use error handlers, either in stead of or alongside exceptions. Clearly, if you are using a language such as C, which does not support exceptions, this is one of your few other options (see the challenge on the next page). However, sometim es error handlers can be used even in languages (such as Java) that have a good exception handling scheme built in. Consider the im plementation of a client-server applica tion, using Java' s Rem ote Method Invocation (RMI) facility. Because of the way RMI is im plem ented, every call to a rem ote routine m ust be prepared to handle a RemoteException. Adding code to handle these exceptions can becom e tedious, and m eans that it is diffi cult to write cod e that works with both local and remote routines. A possible work-around is to wrap your rem ote objects in a class that is not re mote. This class then implem ents an erro r han dler interf ace, allowing the client cod e to register a routine to be called when a remote excep tion is detected . Related sec tions include : • Dead Program s Tell No Lies Challeng es • Languages that do not support exceptions often have som e other nonlocal transfer of control mechanism (C has longjmp/setjmp, for exam ple). Consider how you could im plement some kind of ersatz exception m echanism using these facilities. W hat are the benefits and _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 107 Hunt, Thomas The Pragmatic Programme r 108 dangers? What special steps do you need to take to ensure that resources are not orphaned? Does it m ake sense to use this kind of solution whenever you code in C ? Exercises 21. While designing a new container class, you identify the following possible error conditions : 1. No m emory available for a new element in the ad d routin e 2. Requested entry not found in the fetch routine 3. null pointer passed to the add routine How should each be han dled? Should an erro r be generated, should an exception be raised, or should the condition b e ignored ? How to Balance Resources \"I brought you into this world, \" my father w ould say,\" and I can take you out. It don't make no difference to me. I'll just make another one like you.\" Bill Cosby, Fatherhood We all m anage resources whenever we code: m emory, transactions, threads, flies, tim ers—all kinds of things with lim ited availability. Most of the time, resource usage follo ws a predictable pa ttern: you allocate the resource, use it, and then deallocate it. However, many developers have no consistent plan for dealin g with resou rce alloca tion and deallocation. So let us suggest a sim ple tip: Tip 35 Finish W hat You Start This tip is e asy to app ly in m ost circ umstances. It simply means tha t the routin e or o bject that allocates a resource should be responsible for de allocating it. Let' s see how it applies by looking at an exam ple of som e bad code—an a pplication that opens a file, reads custom er inform ation from it, updates a field, and writes the result back. W e've eliminated error handling to m ake the exam ple clearer. void readCustomer( const char *fName, Customer *cRec) { cFile = fopen(fName, \" r+\"); fread(cRec, sizeof(*cRec), 1, cFile); } void writeCustomer(Customer *cRec) { _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 108 Hunt, Thomas The Pragmatic Programme r 109 rewind(cFile); fwrite (cRec, sizeof(*cRec), 1, cFile); fclose(cFile); } void updateCustomer( const char *fName, double newBalance) { Customer cRec; readCustomer(fName, &cRec); cRec.balance = newBalance; writeCustomer(&cRec); } At first sigh t, the rou tine updateCustomer looks pretty good. It seem s to implem ent the logic we require—reading a record, updating th e balance, and writing the reco rd back out. However, this tidiness hid es a m ajor problem . The routines readCustomer and writeCustomer are tightly coupled[3] —they share the global variable cFile.readCustomer opens the file and stores the file pointer in cFile, and writeCustomer uses that stored pointer to close the file when it finishes. This global variable doesn 't even appear in the updateCustomer routine. [3] For a discussion of the dangers of couple d code, see Decoupling and the Law of D emeter. Why is this bad? Let's consider the unfortunate maintenance programm er who is told that the specification has changed—the balance should be update d only if the new value is not negative. She goes into the source and changes updateCustomer: void updateCustomer( const char *fName, double newBalance) { Customer cRec; readCustomer(fName, &cRec); if (newBalance >= 0.0) { cRec.balance = newBalance; writeCustomer(&cRec); } } All seem s fine during testing. However, when th e code goes into product ion, it collapses after several hours, com plaining of too many open files. Because writeBalance is not getting called in some circum stances, the file is not getting closed. A very bad solution to this problem would be to deal with th e special cas e in updateCustomer: void updateCustomer( const char *fName, double newBalance) { Customer cRec; _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 109 Hunt, Thomas The Pragmatic Programme r 110 readCustomer(fName, &cRec); if (newBalance >= 0.0) { cRec.balance = newBalance; writeCustomer(&cRec); } else fclose(cFile); } This will f ix the prob lem—the f ile will now get c losed rega rdless of the ne w balance— but the f ix now m eans that three routines are couple d through the global cFile. We're falling in to a trap, and things a re going to star t going downhill ra pidly if we continue on this cou rse. The finish what you start tip tells us that, ideally, the routin e that allocates a resource should also free it. W e can apply it here by refactoring th e code sligh tly: void readCustomer(FILE *cFile, Customer *cRec) { fread(cRec, sizeof(*cRec), 1, cFile); } void writeCustomer(FILE *cFile, Customer *cRec) { rewind(cFile); fwrite(cRec, sizeof(*cRec), 1, cFile); } void updateCustomer( const char *fName, double newBalance) { FILE *cFile; Customer cRec; cFile = fopen(fName, \"r+\"); // >--- readCustomer(cFile, &cRec); // / if (newBalance >= 0.0) { // / cRec.balance = newBalance; // / writeCustomer(cFile, &cRec); // / } // / fclose(cFile); // <--- } Now all the responsibility for the file is in the updateCustomer routine. It opens the file and (finishing w hat it starts) closes it bef ore exiting. The routine balanc es the use of the file: the open and close are in the same place, and it is apparen t that for every open there will be a correspond ing close. The refactoring also re moves an ugly global variable. Nest Alloca tions The basic pattern for resource allo cation can be extended for routines that need m ore than one resource at a tim e. There ar e just two more suggestions: 1. Deallocate resources in the opposite order to that in which you allocate them . That wa y you won' t orphan resources if one resource contains references to another. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 110 Hunt, Thomas The Pragmatic Programme r 111 2. When allocating the same set of resources in different places in your code, always allocate them in the sam e order. This will red uce the poss ibility of deadlock. (If process A cla ims resource1 and is about to claim resource2, while process B has claim ed resource2 and is try ing to g et resource 1, the two p rocesse s will wait f orever.) It doesn' t matter what kind of resources we' re using—transactions, m emory, files, threads, windows—the basic pattern applies: whoever a llocates a resource shoul d be responsible for deallocating it. However, in som e languages we can develop the concept f urther. Objects and Exceptions The equilibr ium between alloc ations and dealloc ations is reminiscent of a class' s constructor and destructor. T he class represents a resource, the constr uctor gives you a particular object of that resource type, and the destructor removes it from your scope. If you are programm ing in an object-oriented la nguage, you m ay find it useful to encapsulate resources in classes. Each tim e you need a particul ar resource type, you instan tiate an object of that class. W hen the object goes out of scope, or is reclaim ed by the garbage collector, the object' s destructor th en deallocates the wrapp ed resource. This approach has particular benefits when you' re working with languages such as C++, where exceptions can interfere w ith resou rce deallocatio n. Balanc ing and Excep tions Languages that support exceptions can m ake resource de allocation tricky . If an exception is throw n, how do you guarantee that everything allocated prio r to the exception is ti died up? The answer depends to som e extent on the language. Balancing Resources w ith C++ Exceptions C++ supports a try…catch exceptio n mechanis m. Unfortunately, th is means that there are alway s at least two po ssible p aths when exitin g a routine th at catches a nd then re throws an exce ption: void doSomething( void) { Node *n = new Node; try { // do something } catch (...) { delete n; throw; } delete n; } _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 111 Hunt, Thomas The Pragmatic Programme r 112 Notice that the node we create is freed in two places—once in the routine' s nor mal exit path, and once in the exception handler. This is an obvious violation of the DRY principle and a m aintenance problem waiting to happen. However, we can use the sem antics of C++ to our advantage. Local obj ects a re automatically destroyed on exiting from their enclosing bloc k. This gives us a couple of options. If the circum stances perm it, we can chang e \"n\" from a pointer to an actual Node object on the stack: void doSomething1( void) { Node n; try { // do something } catch (...) { throw; } } Here we rely on C++ to handle the destruction of the Node object autom atically, whether an exception is thrown or not. If the switch from a pointer is not possible, the sam e effect can be achieved by wrapping the resource (in this case, a Node pointer) within another class. // Wrapper class for Node resources class NodeResource { Node *n; public: NodeResource() { n = new Node; } ~NodeResource() { delete n; } Node * operator ->() { return n; } }; void doSomething2( void) { NodeResource n; try { // do something } catch (...) { throw; } } Now the wrapper class, NodeResource, ensures that when its objects are destroyed th e corresponding nodes are also destroyed. For conven ience, the wrapper provides a dereferencing operato r ->, so that its u sers can access the field s in the contained Node object directly. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 112 Hunt, Thomas The Pragmatic Programme r 113 Because th is techniqu e is so useful, th e standard C++ lib rary p rovides the tem plate clas s auto_ptr, which gives you autom atic wrappers for dyna mically allocated objects. void doSomething3( void) { auto_ptr<Node> p (new Node); // Access the Node as p->... // Node automatically deleted at end } Balancing Resources in Java Unlike C++, Java im plem ents a lazy for m of aut omatic object destruction. Unreferenced objects are considered to be candidates fo r garb age collectio n, and their finalize method will get called should garbage collection ever claim them . While a convenience for developers, who no longer get the blam e for m ost memory leaks, it m akes it di fficult to im plem ent resource clean-up using the C++ schem e. Fortunately, the designers of the Ja va language thoughtfully a dded a language feature to com pensate, the finally clause. When a try block contains a finally clause, code in that clause is guaranteed to be executed if any statem ent in the try block is executed. It doesn' t matter whether an exception is thrown (or even if the co de in the try block executes a return)—the cod e in the finally clause will get run. T his means we can bala nce our resource usage with code such as public void doSomething() throws IOException { File tmpFile = newile(tmpFileName); F FileWriter tmp = new FileWriter(tmpFile); try { // do some work } finally { tmpFile.delete(); } } The routine uses a tem porary file, which we want to delete, regardless of how the routine exits. Th e finally block allows us to express this concisely. When You Can't Balan ce Resources There are tim es when the basic re source a lloca tion patte rn just isn' t appropriate. Commonly this is found in program s that use dynam ic data structures . One routine will allo cate an area of memory and link it in to som e larger structu re, where it m ay stay f or some time. The trick here is to establish a semantic invariant for memory allocation. You need to decide who is responsible for data in an aggreg ate data structure. W hat happens when you deallocate the top-level structure? You have three m ain options: 1. The top-level structure is al so responsible for freeing any substructures that it contains. These structures then recursively de lete data they contain, and so on. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 113 Hunt, Thomas The Pragmatic Programme r 114 2. The top-level structure is sim ply deallocated. A ny structures that it poi nted to (that are not referenced elsewhere) are orphaned. 3. The top-level stru cture refuses to deallocat e itself if it contains any substructures. The choice here depend s on the circum stances o f each individual data structure. However, you need to make it explicit for each, and im plem ent your decision consistently. Implem enting any of these options in a procedural language such as C can be a problem : data structures them selves are not active. Our preference in these circum stances is to write a m odule for eac h major structure that provides standard allocation and d eallocation facilities for that st ructure. (This m odule can also provide facilities such as de bug printing, serialization, deserial ization, and traversal hooks.) Finally, if keeping track of res ources gets tricky, you can write your own form of lim ited autom atic garbage collection by implem enting a reference counting schem e on your dynam ically allocated objects. The book More Effec tive C++ [Mey96 ] dedicates a section to this topic. Check ing the Balanc e Because Pragm atic Prog ramm ers trust no one, in cluding ourselves, we feel that it is always a goo d idea to bu ild code tha t actually check s that re sources are indeed freed appropriately. For m ost applications, this norm ally m eans producing wrappe rs for each type of resource, and using these wrappers to keep track of all allocations and deallocations. At certain points in your code, the program logic will dictate that the resources will be in a certain state: u se the wrappe rs to check th is. For exam ple, a long-run ning progra m that serv ices re quests will prob ably have a sin gle poin t at the top of its m ain processing loop where it waits for th e next request to arrive. This is a good place to ensure that resource usage has not increased since the last execution of the loop. At a lower, but no less useful le vel, you can invest in tools that (among other things) check your running program s for mem ory leaks. Purify ( http://www.rational.com ) and Insure+ + (http://www.parasof t.com) are popular choices. Related sections include: • Design by Contract • Assertive Programm ing • Decoupling and the Law of De meter Challenges • Although there are no guaranteed ways of ensu ring that you always fr ee resources, certain design techniques, when applied consistently, will help. In the te xt we discussed how estab lishing a sem antic invarian t for major data structures could direct m emory deallocation decisions. Consider how Design by Contract , could help refine this idea. Exercises 22. SC dC d l k if i i fh dll h _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 114 Hunt, Thomas The Pragmatic Programme r 115 memory it references. Why is this a good idea? 23. Some Java developers make a point of setting an object variable to NULL after they h ave finished using the object. W hy is this a good idea? _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 115 Hunt, Thomas The Pragmatic Programme r 116 Chapter 5. Bend or Break Life doesn' t stand still. Neither can the code that we write. In order to keep up with today' s near-frantic pace of change, we need to m ake every effort to write co de that' s as loose—as flexible—as possible. Otherwise we m ay find our code quickly b ecoming outdated, or too brittle to fix, and m ay ultim ately be lef t behind in the m ad dash toward the future. In Reversib ility, we talked about the perils of irreversible decisions. In this chapter, we' ll tell you how to m ake revers ible decisions, so your code can stay flex ible and adap table in the f ace of an uncertain w orld. First we need to look at coupling— the dependencies am ong modules of code. In Decoupling and the Law of Demeter we'll show how to keep separate c oncepts separate, and decrease coupling. A good way to stay flexible is to write less code. Changing code leaves you open to the possibility of introducing new bugs. Metaprogramming will explain ho w to m ove details out of the code completely, where they can be changed m ore safe ly and easily. In Temporal Coupling, we'll look at two aspects of tim e as they relate to coupling. D o you depend on the \"tick\" com ing before the \"tock\" ? Not if you want to stay flexible. A key concept in creating flexible code is the separation of a data model from a view, or presentation, of that m odel. W e'll decouple m odels from views in It's Jus t a View. Finally, there' s a techniq ue for decou pling m odules even further by providing a m eeting place wh ere modules can exchange data anonym ously a nd asynchronously. This is the topic of Blackboards. Armed with these techniques, you can write code that will \"roll with the punches.\" Decouplin g and the Law of Demeter Good fences make good neighbors. Robert Frost, \"Mendin g Wall\" In Orthogonality , and Design by Contract , we suggested that writing \"s hy\" code is beneficial. But \"shy\" works two ways: don' t reveal yourself to ot hers, and don' t interact with too m any people. Spies, dissidents, revolutionaries, and such are often organized into sm all groups of people called cells. Althou gh individu als in each cell m ay know each other, they have no knowledge of those in other cells. If one cell is discovered, no am ount of truth seru m will reveal the nam es of others outside the cell. Elim inating interact ions between cells protects everyone. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 116 We feel that this is a good principle to apply to coding as well. Organi ze your code into cells (modules) and lim it the interaction be tween them . If one m odule then gets com promised and has to be replaced, the other m odules should be able to carry on. Hunt, Thomas The Pragmatic Programme r 117 Minimiz e Coupling What' s wrong with havin g modules that know a bout each o ther? Nothing in prin ciple—we don' t need to be as paranoid as spies or dissident s. However, you do need to be careful about how many other m odules you interact with and, more im portantly, how you cam e to intera ct with them . Suppose you are rem odeling your house, or buildi ng a house from scratch. A typical arrangem ent involves a \"general contract or.\" You hire the contract or to get the work done , but the contractor m ay or may not do the construction personally; the w ork may be offered to various subcontractors. But as the client, you are not involve d in dealing with the subcontr actors directly—the general contractor assum es that set of headaches on your behalf. We'd like to f ollow this s ame model in sof tware. W hen we ask an objec t for a par ticular serv ice, we'd like the service to be perform ed on our behalf. W e do not want the object to give us a third- party object that we have to deal with to get the required se rvice. For exam ple, suppose you are writing a class that ge nerates a graph of scien tific recorder data. You have data recorders spread around th e world; each recorder object contains a location object giving its position and tim e zone. You want to let your users select a recorder and plot its data, labeled with the correct tim e zone. You m ight write public void plotDate(Date aDate, Selection aSelection) { TimeZone tz = aSelection.getRecorder().getLocation().getTimeZone(); ... } But now the plotting routine is unnecessarily coupled to three classes— Selection, Recorder, and Location. This style of coding dram atically increa ses the num ber of cla sses on which our class depends. Why is this a bad thing? It increas es the risk th at an unr elated ch ange som ewhere else in the system will af fect your code. For instance, if Fred m akes a change to Location such that it n o longer directly contains a TimeZone, you have to change your code as well. Rather than digging though a hierarchy yourself, just ask for what you need directly: public void plotDate(Date aDate, TimeZone aTz) { ... } plotDate(someDate, someSelection.getTimeZone()); We added a m ethod to Selection to get the tim e zone on our beha lf: the plotting routine doesn' t care wheth er the tim e zone com es from the Recorder directly, from some contained object within Recorder, or whether Selection makes up a dif ferent tim e zone en tirely. The selec tion routin e, in turn, should probably just ask the re corder for its tim e zone, leaving it up to the recorder to get it from its contained Location object. Traversing relationships between objects d irectly can quick ly lead to a combinatorial explosion[1] of dependency relationships. You can see sym ptoms of this phenom enon in a num ber of ways: _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 117 Hunt, Thomas The Pragmatic Programme r 118 [1] If n objects all know about each other , then a ch ange to just one object can result i n the ot her n - 1 obje cts needing changes. 1. Large C or C++ projects where the command to link a unit test is longer than the test program itself 2. \"Sim ple\" changes to one m odule that propaga te through unrelated m odules in the system 3. Developers who are afraid to chang e code becau se they aren' t sure what might be affected System s with m any unnecessary dependencies are very hard (and expensive) to m aintain, and tend to be highly unstable. In order to keep th e dependencies to a m inimum, we' ll use the Law of Demeter to design our m ethods and functions. The Law of Demeter fo r Functions The Law of De meter for functions [ LH89 ] attem pts to m inimize coupling between m odules in any given program. It tries to prevent you from reaching into an o bject to gain access to a third object' s methods. The law is sum marized in Figure 5.1 on the next page. Figure 5. 1. Law of Deme ter for functions By writing \"shy\" code that honors the Law of De meter as m uch as possible, we can achieve our objective: Tip 36 Minim ize Coupling Between Modules Does It Really Make a Difference? _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 118 Hunt, Thomas The Pragmatic Programme r 119 While it sounds good in theory, does following the La w of Dem eter really help to create m ore maintainable code ? Studies have shown [ BBM96 ] that classes in C+ + with la rger response sets are m ore prone to error than classes with sm aller response sets (a respon se set is defined to be th e num ber of functions directly invoked by m ethods of the class). Because following the L aw of De meter reduces the si ze of th e response set in the calling class, it follows that classe s designed in th is way w ill als o tend to ha ve fewer err ors (se e [URL 56] for m ore papers and infor mation on the Dem eter project). Using The Law of De meter will m ake your code mo re adaptable and robust, but at a cost: as a \"general contractor,\" your m odule must delegate and m anage any and all subcontractors directly, without invo lving clien ts of your m odule. In prac tice, this m eans that you will be writing a larg e number of wrapper m ethods that simply forwar d the request on to a delegate. These wrapper methods will im pose both a runtim e cost and a s pace overh ead, which may be sign ificant—even prohibitive—in som e applications. As with any technique, you m ust balance the pros and cons for your particular application. In database schem a design it is comm on practice to \"denorm alize\" the schema for a perform ance improvem ent: to v iolate the rules of normalization in exchange for speed. A sim ilar tra deoff can be made here as well. In fact, by reversing the Law of De meter and tightly coupling several m odules, you m ay realize an im portant perf ormance gain. As long as it is well known and acceptable for those m odules to be coupled, your design is fine. Physical Decoupling In this section we' re concerned largely with designing to keep things logically decoupled within sys tems. However, ther e is an other kind of interdependence that becom es highly significant as system s grow larger.In his book Large-sca le C++ software Design [Lak96 ], John Lakos addresses the issues surrounding the relationships am ong the files, directories, and libraries that m ake up a system . Large projects that ignore these physical design problem s wind up with build cycles that are m easured in days and unit tests that m ay drag in the entire system as support code , among other problem s. Mr. Lakos argues convincingly that logical a nd physical design m ust procee d in tandem —that undoing the damage done to a large body of code by cyclic dependencies is extr emely difficult. We recomm end this book if you are involved in la rge-scale developm ents, even if C++ isn' t your im plem entation language. Otherwise, you m ay find yourself on the road to a br ittle, inflexible future. Or no future at all. Related sec tions include : • Orthogonality • Reversib ility • Design by Contract • How to Balance Resources _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 119 • It's Just a View Hunt, Thomas The Pragmatic Programme r 120 • Pragm atic Team s • Ruthless Te sting Challeng es • We've discussed how using de legation makes it e asier to obey the Law of De meter and hence reduce coupling. However, writing all of the m ethods needed to forward calls to delegated classes is boring and error prone. W hat are the adv antages and disadvan tages of writing a preprocessor that genera tes these calls autom atically? Should this preprocessor be run only once, or should it be used as part of the build? Exercises 24. We discussed the concept of physical decoupli ng in the box on on the facing page. W hich of the following C++ header flies is more ti ghtly coupled to the rest of the system ? person1.h person2.h: #include \"date.h\" class rson1 { Pe private: Date myBirthdate; public: Person1(Date &birthDate); // ... class Date; class rson2 { Pe private: Date *myBirthdate; public: Person2(Date &birthDate); // ... 25. For the example below and for those in Exerci ses 26 and 27, determ ine if the m ethod calls shown are allowed according to th e Law of Demeter. Th is first one is in J ava. public void showBalance(BankAccount acct) { Money amt = acct.getBalance(); printToScreen(amt.printFormat()); } 26. This exam ple is also in Java . public class Colada { private Blender myBlender; private Vector myStuff; public Colada() { myBlender = new Blender(); myStuff = new Vector(); } private void doSomething() { myBlender.addIngredients(myStuff.elements()); } } _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 120 Hunt, Thomas The Pragmatic Programme r 121 27. This exam ple is in C++ . void processTransaction(BankAccount acct, int) { Person *who; Money amt; amt.setValue(123.45); acct.setBalance(amt); who = acct.getOwner(); markWorkflow(who->name(), SET_BALANCE); } Metaprogramming No amount of genius can overco me a preoccupation with detail Levy's Eighth Law Details m ess up our pristine code—e specially if they change frequently. E very tim e we have to go in and chang e the code to accomm odate som e change in busin ess logic, or in the law, or in manage ment's personal tastes of the day, we run the risk of breaking the system —of i ntroducing a new bug. So we say \"out with the details!\" Get them out of the code. While we' re at it, we can m ake our code highly configurable and \"soft\"—that is, eas ily ad aptable to ch anges. Dynamic Configuration First, we want to m ake our system s highly configur able. Not just thing s such as scr een colors and prom pt text, but deeply ingrained item s such as the choice of algorithm s, database products, middleware technology, and user-interface sty le. These item s should be implem ented as configuration options, not thr ough integration or engineering. Tip 37 Configure, Don' t Integrate Use metadata to describe configuration options for an application: tuning param eters, user preferences, the installa tion directory, and so on. What exactly is m etadata? Strictly speaking, m etadata is data about data. The m ost common exam ple is probably a database schem a or data di ctionary. A schem a contai ns data that describes fields (columns) in terms of na mes, storage leng ths, and other attributes. You should be able to access and m anipulate this inform ation just as you would any other data in the databa se. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 121 Hunt, Thomas The Pragmatic Programme r 122 We use the term in its broadest sense. Metadata is any data that desc ribes the application—how it should run, what resources it shoul d use, and so on. Typically, m etadata is accessed and used at runtim e, not at com pile tim e. You us e metadata all the tim e—at leas t your program s do. Suppose you click on an option to hide the too lbar on your W eb browser. The bro wser will s tore that preference, as m etadata, in som e sort of internal database. This database m ight be in a proprietary form at, or it m ight use a standard m echanis m. Under Windows, either an initia lization f ile (using th e suffix .ini ) or entr ies in th e system Registry are typical. Under Unix, the X W indow System prov ides sim ilar functionality using Application Default files. Java uses P roperty files. In all of these environm ents, you specify a key to retrieve a value. Alternatively, m ore powerful and flexible implementations of metadata use an em bedded scripting language (see Dom ain Languages , for details). The Netscap e browser has actually implem ented preferences u sing both of these techniques. In Version 3, p references were sav ed as sim ple key/value pairs: SHOW_TOOLBAR: False Later, Version 4 preferences looked more like JavaScript: user_pref(\"custtoolbar.Browser.Navigation_Toolbar.open\", false); Metadata-Driven Applications But we want to go beyond using m etadata for sim ple preferen ces. W e want to configure and drive the application via m etadata as m uch as possible. Our goal is to think declaratively (specifying what is to be done, not how) and create highly dynam ic and adapta ble programs. W e do this by adopting a general rule: program for the general case, a nd put the sp ecifics som ewhere else—ou tside the compiled code base. Tip 38 Put Abstrac tions in Code Details in Metada ta There are several b enefits to this app roach: • It forces you to decouple your design, which results in a m ore flexible and adaptable program . • It forces you to create a more robust, abstra ct design by deferring de tails—deferring them all the way out of the program . • You can custom ize the application w ithout reco mpiling it. Yo u can also use this level of custom ization to provide easy work-arounds fo r critical bugs in live production system s. • Metadata can be expressed in a m anner that' s much closer to the problem dom ain than a general-purpose program ming language m ight be (see Dom ain Languages ). _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 122 Hunt, Thomas The Pragmatic Programme r 123 • You m ay even be able to im plement several di fferent projects using the sam e application engine, but with different m etadata. We want to defer definition of m ost details until the last m oment, and leave the details as soft—as easy to change—as we can. By crafting a solution th at allows us to m ake changes quickly, we stand a better chance of coping with the flood of directional shifts that swam p many projects (see Reversib ility). Business Logi c So you' ve made the choice of database engine a configuration option, an d provided m etadata to determ ine th e user-interface sty le. Can we do m ore? Defin itely. Because bus iness policy and rules are m ore likely to ch ange th an any other aspect of th e project, it makes sense to m aintain them in a very f lexible f ormat. For exam ple, your purchasing application m ay include various corporate policies. Maybe you pay small suppliers in 45 days and large ones in 90 days . Make the definitions of the supplier types, as well as the tim e periods them selves, configur able. Take the opportunity to generalize. Maybe you are writing a system with horrendous wo rkflow requirem ents. Actions start and stop accord ing to com plex (and changing ) busines s rules. Consider encoding them in som e kind of rule - based (or expert) system , embedded within your application. That way, you' ll configure it by writing rules, not cutting code. Less com plex logic can be expressed using a m ini-language, rem oving the need to recom pile and redeploy when the environm ent changes. Have a look at page 58 for an exam ple. When to Configure As m entioned in The power of plain Text , we recomm end representing configuration metadata in plain text— it makes lif e that m uch easier. But when should a program read this configur ation? Many program s will scan such th ings only at startup, which is unfort unate. If you need to change the configuration, this forces you to restart the application. A m ore flexible approach is to write program s that can reload their configuration while they' re running. This flexibility com es at a cost: it is more complex to implem ent. So consider how your application will be used : if it is a long-running server process, you will want to provide som e way to re read and apply m etadata while the p rogram is running. For a sm all client GUI application th at restarts quickly, you m ay not need to. This phenom enon is not lim ited to application code. W e've all been annoyed at operating system s that force us to reboot when we inst all som e simple application or change an innocuous param eter. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 123 An Example: Enterprise Java Beans Hunt, Thomas The Pragmatic Programme r 124 Enterprise Java Beans (EJB) is a fram ework for sim plifying programm ing in a distributed, transa ction- based enviro nment. W e mention it he re bec ause EJB illus trates how m etadata can b e used both to configure applications and to reduce the com plexity of writing code. Suppose you want to create som e Java software that will participate in transa ctions across different machines, between different database vendors, and with different thread a nd load-balancing m odels. The good news is, you don' t have to wo rry about all that. You write a bean— a self -contained ob ject that follows certain conv entions— and place it in a bean container that m anages m uch of the low- level detail on your behalf. You can write the code for a bean w ithout including any transaction operations or thread m anagem ent; EJB uses m etadata to specify how transactions should be handled. Thread alloc ation and lo ad balanc ing are spe cified as metadata to the und erlying tr ansaction serv ice that the container us es. T his sepa ration allows us great f lexibility to conf igure the env ironm ent dynam ically, at runtim e. The bean' s container can m anage tran sactions on the bean' s behalf in one of several different styles (including an option where you control your ow n comm its and rollbacks). All of the param eters that affect the bean' s behavior are sp ecified in the b ean's deployment descriptor— a serialized object th at contains the m etadata we need. Distributed system s such as EJ B are leading the way into a ne w world of configurable, dynam ic system s. Cooperativ e Configura tion We've talked about users and developers config uring dynam ic applications. But what happens if you let applications configure each other—softw are that adapts itself to its environm ent? Unplanned, spur-of-the-mom ent configuration of existing software is a powerful concept. Operating system s already configure them selves to hardware as they boot, and W eb browsers update themselves with new components automatically. Your larger applications probably already have issues with handling different versions of data and different releases of lib raries and op erating sy stems. Perhaps a m ore dynam ic approach will help. Don't Write Dodo-Cod e Without m etadata, your code is not as adaptable or flexible as it coul d be. Is this a bad thing? Well, out here in the real world, species that don' t adapt die. The dodo didn' t adapt to the presence of hum ans and their livestock on the is land of Mauritius, and quickly becam e extinct.[2] It was the first docum ented extinction of a species at the hand of m an. [2] It didn't help that the settlers be at the placid (read stupid) birds to death with clubs for sport. Don' t let your project (or your career) go the way of the dodo. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 124 Hunt, Thomas The Pragmatic Programme r 125 Related sec tions include : • Orthogonality • Reversib ility • Dom ain Languages • The Power of Plain Text Challeng es • For your current project, consider how m uch of the application m ight be moved out of the program itself to m etadata. W hat would the re sultant \"engine\" look lik e? Would you be able to reuse that engine in the cont ext of a different application? Exercises 28. Which of the following things would be better represented as code within a program , and which exte rnally a s metadata ? 1. Communication port assignm ents 2. An editor' s support for highlighting the syntax of various languages 3. An editor' s support for different graphic devices 4. A state m achine for a parser o r scann er 5. Sample values and result s for use in unit testing Temporal Coupling What is temporal coupling all about, you m ay ask. It' s about tim e. Time is an often ignored aspect of software arch itectures. The only tim e that preoccupies us is the time on the schedule, th e tim e left until we sh ip—but this is not what we' re talking about here. Instead, we are talking about the ro le of tim e as a design element of the software itself. There are two aspects of time that are im portan t to us: c oncurrency (things happening at the sam e time) and ordering (th e relativ e position s of things in tim e). We don' t usually approach program ming with either of these aspects in m ind. When people first sit down to design an architecture or wr ite a program, things tend to be linear. That' s the way m ost people think— do this and then alway s do that. But think ing th is way leads to temporal coupling: coupling in tim e. Method A m ust always be called before m ethod B; only one report can be run at a time; you must wait for the screen to redraw before the button click is received. Tick m ust happen before tock. This approach is not very flex ible, and not very realistic. We need to allow for concurrency[3] and to think about decoupling a ny tim e or order dependencies. In doing so, we can gain flexibility and redu ce any tim e-based dependencies in m any areas of developm ent: workflow analysis, architecture, design, and deploym ent. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 125 Hunt, Thomas The Pragmatic Programme r 126 [3] We won't go into the details of c oncurrent or parallel programming he re; a good c omputer science textboo k should cover the basics, including scheduling, deadlock, star-vation, mutual exclusion/semaphore s, and so on. On m any projects, we need to m odel and analyze the users' workflows as part of requirem ents analysis. W e'd like to find out what can happen at the sam e time, and what m ust happen in a strict order. One way to do this is to capture the ir description of workflow using a notation such as the UML activity diagram.[4] [4] For more information on a ll of the UML dia gram types, see [FS97 ]. You can use activity diagram s to m aximize parallelism by identifying activities that could be perform ed in parallel, but aren' t. Tip 39 Analyze W orkflow to Improve Concurrency For instance, in our blender proj ect (Exercise 17, page 119), user s may initially describe their current workflow as follows. 1. Open blender 2. Open piña colada m ix 3. Put m ix in blender Workflow An activity diagram consists of a set of actions drawn as roun ded boxes. The arrow leaving an action leads to either ano ther action (which can st art onc e the f irst ac tion c ompletes) o r to a th ick line called a synchronization bar. Once all the ac tions lead ing into a synchronization bar are complete, you can then proceed alo ng any arro ws leav ing the bar. An action with n o arrows leading into it can be started at any tim e. 4. Measure 1/2 cup white rum 5. Pour in rum 6. Add 2 cups of ice 7. Close blender 8. Liquefy for 2 m inutes 9. Open blender 10. Get glasses 11. Get pink umbrellas 12. Serve Even though they describe these actions serially, and may even perform them serially, we notice that m any of them could be perform ed in para llel, as we show in the a ctivity diagram in Figure 5.2 on the next page. Figure 5.2. UML activity diagram: making a piña colada _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 126 Hunt, Thomas The Pragmatic Programme r 127 It can b e eye-opening to see where the dependenc ies re ally exist. In th is ins tance, the to p-leve l tasks (1, 2, 4, 10, and 11) can all happen concurrently, up front. Tasks 3, 5, and 6 can happen in parallel later. If you were in a piña colada-m aking contest, th ese optim izations m ay make all the dif ference. Architecture We wrote an On-Line Transaction Processing (OLTP ) system a few yea rs ago. At its sim plest, all the system had to do was read a request and proc ess the trans action again st the d atabase. But we wrote a three-tier, m ultiprocessing distributed ap plication: each com pone nt was an independent entity that ran concurrently with all other com ponents. W hile this sounds like m ore wor k, it wasn' t: taking advantage of temporal decoupling m ade it easier to w rite. Let' s take a closer look at this project. The system takes in requests from a large num ber of data communication lines and processes transactions agains t a back-end database. The design addresses the following constraints: • Database operations take a re latively long tim e to com plete. • For each transaction, we m ust not block communication services while a database transaction is being processed. • Database perform ance suffers with too m any concurrent sessions. • Multip le tra nsactions are in progress concurrently on each da ta line. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 127 Hunt, Thomas The Pragmatic Programme r 128 The solution that gave us the best perfor mance and cleanest architecture lo oked som ething lik e Figure 5.3 . Figure 5.3. OLTP archite cture over view Each box represents a separate process; proc esses communicate via work queues. Each input process m onitors one incom ing communication line, and m akes requests to the application server. All requests are asynchronous: as so on as the input process m akes its current request, it goes back to monitoring the line f or more traf fic. Similarly, the a pplication server m akes requests of the database process,[5] and is notified when the indi vidua l transaction is co mplete. [5] Even though we show the database as a single , monolit hic entity, it is no t. The database softwa re is pa rtitioned into several processes and client threads, but th is is handled internally by the database softw are and isn 't part of our example. This exam ple also shows a way to get quick a nd dirty load balancing am ong m ultiple consum er processes: the hungry consumer model. In a hungry consum er model, you replace the central schedu ler wi th a nu mber of independent consum er tasks and a centralized wo rk queue. Each consum er task grab s a piece from the work queue and g oes on about the busin ess of processin g it. As each task finish es its work, it goes back to the queue for som e more. This way, if any partic ular task gets bogged down, the others can pick up the slack, an d each ind ividual com ponent can p roceed at its o wn pace. Each com pone nt is temporally decoupled from the others. Tip 40 Design Using Services Instead of com ponents, we have really created services —independent, concurrent objects behind well-defined , consistent interfaces. Design for Concurrency _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 128 The ris ing acceptan ce of Java as a p latform has exposed m ore developers to m ultithreaded programm ing. But programm ing with threads imposes som e design constraints—and that' s a good thing. Those constraints are actually so helpful that we want to abide by them whenever we program . It will help us decouple ou r code and fight program ming by coincidence . Hunt, Thomas The Pragmatic Programme r 129 With linear code, it' s easy to m ake assum ptions that lead to sloppy progr amming. But concurrency forces you to think through things a bit m ore car efully—you' re not alone at the party anym ore. Because th ings can now happen at the \"sam e time,\" you m ay suddenly see som e time-based dependencies. To begin with, any global or static variables m ust be protected from concurrent access. Now m ay be a good tim e to ask yourself why you need a global variable in the first place. In addition, you need to make sure that you present consistent state inform ation, regardless of the order of calls. For exam ple, when is it valid to que ry the state of your object? If your object is in an invalid state between certain calls, you may be relying on a coincidence that no one can call your object at that point in tim e. Suppose you have a windowing subsystem where the widgets are first crea ted and then shown on the display in two separate steps. You aren' t allowed to set s tate in the widget until it is shown. Depending on how the code is set u p, you m ay be relying on the fact that no other object can use the created widget until you' ve shown it on the screen. But this m ay not be true in a concurrent system . Objects m ust always be in a valid state when called, and they can be called at the most awkward tim es. You m ust ensure that an object is in a valid s tate any time it could possibly be called. Often this pr oblem shows up with classes that define separa te con structor and initializa tion routin es (w here th e con structor doe sn't leave th e objec t in a n initialized s tate). Using c lass inv ariants, discu ssed in Design by Contract , will he lp yo u avoid th is trap. Cleaner Interfaces Thinking about concurrency and tim e-ordered de pendencies can lead you to design cleaner interfaces as well. Consider the C lib rary rou tine strtok, which breaks a st ring into tokens. The design of strtok isn't thread sa fe,[6] but that isn' t the worst pa rt: look at the tim e dependency. You m ust make the f irst call to strtok with the variable you want to parse, and all successive calls with a NULL instead. If you pass in a non- NULL value, it restarts the parse on that buffer instead. Without even considering threads, suppose you wanted to use strtok to parse two separate strings at the sam e time: [6] It uses static data to maintain the current position in the buffer. The static data isn't protected against concurrent acce ss, so it i sn't thread safe. In addition, it clobbers the first argument you pass in, which can lead to som e nasty surpri ses. char buf1[BUFSIZ]; char buf2[BUFSIZ]; char *p, *q; strcpy(buf1, \" this is a test \"); strcpy(buf2, \" this ain't gonna work \"); p = strtok(buf1, \" \"); q = strtok(buf2, \" \"); while (p && q) { printf( \"%s %s\\n\", p, q); p = strtok(NULL, \" \"); _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 129 q = strtok(NULL, \" \"); Hunt, Thomas The Pragmatic Programme r 130 } The code as shown will not work: th ere is im plicit state retained in strtok between calls. You have to use strtok on just one buffer at a tim e. Now in Java, the design of a string parser has to be diffe rent. It m ust be thread safe and present a consistent state. StringTokenizer st1 = new StringTokenizer(\" this is a test \"); StringTokenizer st2 = new StringTokenizer(\" this test will work \"); while (st1.hasMoreTokens() && st2 hasMoreTokens()) { System.out.println(st1.nextToken()); System.out.println(st2.nextToken()); } StringTokenizer is a much cleaner, m ore maintainab le, interface. It co ntains no su rprises, and won' t cause mysterious bugs in the f uture, as strtok might. Tip 41 Always Design for Concurrency Deployment Once you' ve designed an architecture with an el ement of concurrency, it becom es easier to think about handling many concurren t services: the m odel becom es pervasiv e. Now you can be flexible as to how the applicatio n is deployed: standalone, client-server, or n-tier. By architecting your system as independent serv ices, you can m ake the co nfiguration dynam ic as well. By planning for concurrency, and decoupling operations in tim e, you ha ve all these options— including the stand-alone option, where you can choose not to be concurrent. Going the other way (trying to add concu rrency to a nonconcurrent application) is much harder. If we design to allow for concurrency, we can m ore easily m eet scalab ility o r perform ance requirem ents when the tim e com es—and if the tim e never com es, we still have the benefit of a cleaner design. Isn't it abou t time? Related sec tions include : • Design by Contract • Programm ing by Coincidence Challeng es _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 130 Hunt, Thomas The Pragmatic Programme r 131 • How m any tasks do you perform in parallel when you get ready for work in the m orning? Could you express this in a UML activity di agram ? Can you find som e way to get ready more quickly by increasing concurrency? It's Just a View Still, a man hears What he wants to hear And disrega rds the rest La la la… Simon and Garfunkel, \"The Boxer\" Early on we are taught not to writ e a program as a single big chunk, but that we should \"divide and conquer\" and separate a program into m odules. Each module has its own responsibilities; in fact, a good definition of a m odule (or class) is that it has a single, well-defined responsibility. But once you separate a program into different modules based on responsi bility, you have a new problem . At runtim e, how do the objects talk to each other? How do you m anage the logical dependencies between them ? That is, how do you sync hronize changes in state (or updates to data values) in these different objects? It needs to be done in a clean, flexib le manner—we don' t want them to know too m uch about each o ther. W e want each m odule to be lik e the m an in the song an d just hear what it wants to hear. We'll sta rt off with the c oncept of an event . An event is sim ply a special m essage that says \"som ething interesting just happene d\" (interesting, of course, lies in the eye of the beholder). W e can use events to signal change s in one object that som e othe r object m ay be interested in. Using events in this way m inimizes coupling betw een those objects—the sende r of the event doesn' t need to have any explicit knowledge of the receiv er. In fact, there cou ld be multiple receivers, each one focused on its own agenda (of which the sen der is b lissfully unawar e). We need to exercise som e care in using events, how ever. In an early version of Java, for exam ple, one routine received all the events destined for a particular ap plication. N ot exactly the road to easy maintenance or evolution. Publish/Subscribe Why is it bad to push all the events through a single routine? It violates object encapsulation—that one routine now has to have intim ate knowledge of the interactions am ong m any objects. It also increases the coupling—and we' re trying to decrease coupling. Because the objects them selves have to have knowledge of these events as well, you are probably going to violate the DRY principle, orthogonality, and perhaps even sections of the Ge neva Convention. You m ay have seen this kind of code—it is usually dom inated by a huge case statem ent or m ultiway if-then. We can do better. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 131 Hunt, Thomas The Pragmatic Programme r 132 Objects should be able to regist er to receive only the events they need, and should never be sent events they don' t need. We don' t want to spam our objects! Instead, we can use a publish/subscribe protocol, illustrated using the UML sequence diagram in Figure 5.4 on the next page.[7] [7] See also the Ob server pattern in [GHJV9 5] for m ore information. Figure 5.4. Publish/subscri be protocol A sequence diagram shows the flow of m essages among several objects, w ith objects arranged in colum ns. Ea ch m essage is shown as a labeled ar row from the sender' s colu mn to the re ceive r's colum n. An aster isk in th e labe l means that m ore than one m essage of this type can be sent. If we are interested in certain events generated by a Publisher, all we have to do is register ourselves. The Publisher keeps tr ack of all in terested Subscriber obje cts; when th e Publisher generates an event of interest, it will call each Subscriber in turn and no tify them that the even t has occurred . There are several v ariations on this them e—m irroring other comm unication styles. O bjects m ay use publish/subscribe on a peer-to-peer basis (as we saw above); they may use a \"software bus\" where a centr alized object m aintains th e data base of listeners and dispatches m essages appropriately. You might even have a schem e where critical ev ents ge t broad cast to a ll listen ers—registered or not. One possible im plementation of events in a dist ributed environm ent is illustrated by the CORBA Event Service, described in the box on the following page. We can use this publish/subscribe mechanism to implement a very im portant design concept: the separation of a m odel from views of the m odel. Let's start w ith a GUI-based exam ple, using the Smalltalk d esign in whic h this con cept was born. Model-Vie w-Controlle r Suppose you have a spreadsheet app lication. In addition to the num bers in the spreadsheet itself, you also have a graph that displa ys the num bers as a bar chart a nd a running total dialog box that shows the su m of a column in the sp readsheet. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 132 Hunt, Thomas The Pragmatic Programme r 133 The CORBA Event Service The CORBA Event Service a llows particip ating objects to send and receive event notifications via a common bus, the event channel. The event channel arbitrates even t handling, and also decouples event producers from event consum ers. It works in two basic ways: push and pull. In push m ode, event suppliers inform the even t channel that an ev ent has occurred. The channel then autom atically distri butes that event to all c lient objects tha t have reg istered interest. In pull m ode, clients periodically poll the even t channel, which in turn polls the supplier that offers event data corresponding to the request. Although the CORBA Event Service can be used to im plement all of the event m odels discussed in this section, you can also view it as a different anim al. CORBA facilities communication am ong objects written in di fferent programm ing languages running on geographically dispersed m achines with differe nt architectures . Sitting on top of CORBA, the event service give you a decoupled way of interacting with applications around the world, written by people you' ve never m et, using programm ing languages you' d rather not know about. Obviously, we don' t want to ha ve three separate copies of the data. So we create a model— the data itself, with comm on operations to m anipul ate it. Then we can create separate views that display the data in different ways: as a spr eadsheet, as a graph, or in a totals box. Each of these views m ay have its own controller. The graph view may have a controller th at allows you to zoom in or out, or pan around the data, for example. None of this affects the data itse lf, just that view. This is the key concept behind the Model-View -Controller (MVC0 idiom : separating the m odel from both the GUI that represents it a nd the controls that m anage the view.[8] [8] The view and controller are tight ly couple d, and in som e Implem entations of MVC the view and controller are a sing le compone nt. By doing so, you can tak e advantag e of som e interesting possibilities. You can support m ultiple views of the sam e data model. You can use co mmon viewers on m any different data models. You can even su pport m ultiple controllers to provid e nontrad itional inpu t mechanism s. Tip 42 Separate Views from Models By loosening the coupling between the m odel a nd the view/controller, you buy yourself a lot of flexibility a t low cost. In fact, this tec hnique is one of the m ost importa nt ways of maintaining revers ibility (see Reve rsibility ). Java Tree View _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 133 Hunt, Thomas The Pragmatic Programme r 134 A good example of an MVC design can be found in the Java tree widget. The tree widget (which displays a clickable, trav ersable tr ee) is ac tually a set of sever al different classes organized in an MVC pattern. To produce a fully functional tree wi dget, all you need to do is provi de a data source that conforms to the TreeModel interface. Your code now b ecom es the m odel for the tre e. The view is created by the TreeCellRenderer and TreeCellEditor classes, which can be inherited from and custom ized to provide diffe rent colors, fonts, and icons in the widget. JTree acts as the con troller for the tree widget an d provides som e general viewing functionality. Because we have decoup led the m odel from the view, we simplify the programm ing a great deal. You don' t have to think about programming a tree widget anymore. Instead, you just provide a data source. Suppose the vice president com es up to you and wants a quick application that lets her navigate the company's organiz ational char t, whic h is held in a legacy database on the m ainfra me. Just write a wrapper th at takes the mainfram e data, presen ts it as a TreeModel, and voilà: you have a fully navigable tree widget. Now you can get fancy and start using the viewer classes; you can change how nodes are rendered, and use special icons, fonts, or colors. W hen the VP com es back and says the new corporate standards dictate the use of a Skull and Crossbones icon for certain em ployees, you can m ake the changes to TreeCellRenderer without touching any other code. Beyond GUIs While MVC is typically taught in the context of GUI developm ent, it is really a general-purpose programm ing technique. The view is an inte rpretation of the model (perhaps a subset)—it doesn' t need to be graphical. The controller is m ore of a coordination m echanism , and doesn' t have to be related to any sort of input device. • Model. The abstract data m odel representing the ta rget object. The m odel has no direct knowledge of any views or controllers. • View . A way to interpre t the m odel. I t subs cribes to changes in the model a nd logical events from the controller. • Controller. A way to control the view and provide the m odel with new data. It publishes events to both the m odel and the view. Let's look at a nongraphical exam ple. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 134 Hunt, Thomas The Pragmatic Programme r 135 Baseball is a unique institution. W here else can you learn such gem s of trivia as \"this has becom e the highest-scoring gam e played on a Tuesday, in the ra in, und er artificial lights, between team s whose nam es start with a vowel?\" Suppose we were charged with developing software to support those intrepid announcers who m ust dutifully report on the scores, the statistics, and the trivia. Clearly we need inform ation on the gam e in progr ess—the team s playing, the conditions, the player at bat, the sc ore, and so o n. These f acts f orm our models; the y will be up dated as n ew inf ormation arrives (a pitcher is changed, a play er strikes out, it starts raining…). We'll then have a num ber of view objects that use these m odels. One view m ight look for runs so it can update the current score. Another m ay receive no tification s of new batters , and retrieve a b rief summary of their year-to-date st atistics. A third viewer m ay look at the data and check for new world records. W e might even have a trivia view er, responsible for com ing up with those weird and useless f acts that thrill th e viewing p ublic. But we don' t want to flood the poor announcer with al l of these views directly. Instead, we' ll have each view g enerate notifications of \"interesting\" events, and let som e higher-level ob ject schedu le what gets shown.[9] [9] The fact that a plane flies ove rhead probably isn't interesting unless it's the 100th plane to fly overhead that night. These viewer objects have suddenly becom e models for the higher-level obj ect, which itself m ight then be a m odel for different form atting view ers. One for matting viewer m ight create the teleprom pter script for the announcer, another m ight generate video captions di rectly on the satellite uplink, another m ight update the network' s or team' s Web pages (see Figure 5.5 ). Figure 5.5. Basebal l reporting, Viewers s ubscribe to m odels. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 135 This kind of m odel-view er network is a co mmon (and valuable) design technique. Each link decouples raw data from the even ts that created it—each new viewer is an abstraction. And because the relationships are a network (not just a linear chain), we have a lot of flexibility. Each m odel may have many viewers, and one viewer m ay work with m ultiple models. Hunt, Thomas The Pragmatic Programme r 136 In advanced system s such as this one, it can be handy to have debugging views— specialized views that show yo u in-dep th details of the model. A dding a facility to trace ind ividual ev ents can be a great tim e saver as well. Still Couple d (After All These Years) Despite the decrea se in coupling we have achieved, listeners and ev ent ge nerato rs (su bscribe rs an d publishers) still have some knowledge of each oth er. In Jav a, for instance, they m ust agree on common interface definitions and calling conven tions. In the next section, we' ll look at ways of reduci ng coupling even further by using a form of publish and subscrib e where none of the participants need know about each other, or call each other directly. Related sec tions include : • Orthogonality • Reversib ility • Decoupling and the Law of De meter • Blackboards • It's All W riting Exercises 29. Suppose you have an airline reservation syst em that includes the concept of a flight : public interface Flight { // Return false if flight full. public boolean addPassenger(Passenger p); public void addToWaitList(Passenger p); public int getFlightCapacity(); public int getNumPassengers(); } If you add a passenger to the wait list, they' ll be put on the flight autom atically when an opening becom es available. There' s a m assive reporting job that goes th rough looking for overbooked or full flights to suggest when additional flights m ight be sche duled. It works fine, but it takes hours to run. We'd like to have a little more flexibility in proc essing wait-list passeng ers, and we' ve got to do som ething about that big repor t—it takes too long to run. Use th e ideas from this section to redesign this interface. Black boards The writing is on the wall… _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 136 Hunt, Thomas The Pragmatic Programme r 137 You m ay not usually associate elega nce with police detectives, pict uring instead som e sort of doughnut and coffee cliché. But consid er how detectives m ight use a blackboard to coordinate and solve a m urder investigation. Suppose the chief inspector starts off by setting up a large blackboard in the conference room . On it, he writes a single question: H. D UMP TY (M ALE, EGG): A CCIDENT OR MURDE R? Did Hum pty really fall, or was he pushed? Each detective m ay make contri butions to this poten tial murder m ystery by adding facts, statem ents from witnesses, a ny forensic evidence tha t might arise , and so on. As the data accum ulates, a detective might notice a connection a nd post that observation or speculation as well. This process continues, across all shifts, with m any different people and agents, until the case is closed. A sample blackboard is show n in Figure 5.6 on the next page. Figure 5.6. Someone foun d a connec tion between Hum pty's gamblin g debts and the phone l ogs. Perhaps he was getting threatening phone calls. Some key fe atures of the blackboard approach are: • None of the detectives needs to know of the existence of an y other detective—they watch the board for new inform ation, and add their findings. • The detectives m ay be trained in different discip lines, m ay have different levels of education and expertise, and m ay not even work in the sa me precinct. T hey share a desire to so lve the case, but that' s all. • Different detectives m ay com e and go during the course of the pr ocess, and may work different shifts. • There are no restrictions on what m ay be pl aced on the black board. It m ay be pictu res, sentences, physical evidence, and so on. We've worked on a number of projects that involv ed a workflow or distributed data gathering process. W ith each, designing a solution around a simple blackboard m odel gave us a solid metaphor to work with: all of the features listed above using detec tives are just as applicable to objects and code m odules. A blackboard system lets us decouple our objects from each other com pletely, prov iding a forum where knowledge consum ers and producers can ex change data anonym ously and asynchronously. As you m ight guess, it also cuts dow n on the amount of code we have to write. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 137 Hunt, Thomas The Pragmatic Programme r 138 Blackboard Implementations Com puter-based blackboard system s were orig inally invented f or use in artif icial intelligence application s where the p roblem s to be solv ed were large and com plex—speech recognition, knowledge-based reasoning system s, and so on. Modern distributed blackboard-like system s such as JavaSpaces and T Spaces [ URL 50 , URL 25 ] are based on a m odel of key/value pairs first popularized in L inda [ CG90 ], where the concept was known as tuple space. With these system s, you can store active Java objects—not just da ta—on the blackboard, and retrieve the m by partia l matching of fields (via templates a nd wildcards) or by subtypes. For exam ple, suppose you had a type Author, which is a subtype of Person. You could search a blackboard containing Person objects by using an Author template with a lastName value of \"Shakespea re.\" You' d get Bill Shak espeare the au thor, but not Fred Shakes peare the ga rdener. The m ain operations in J avaSpaces are: Nam e Functi on read Searc h for a nd retrieve data from the space. write Put a n item into the space. take Similar to rea d, but removes the item from the s pace as well. notify Set up a notificatio n to occur whenever an ob ject is written th at matches the tem plate. T Spaces su pports a similar set of op erations, but with different nam es and slightly dif ferent semantics. Both system s are built like a database product; they provide atom ic operations and distributed transactions to ensure data integrity. Since we can store objects, we can use a blackboard to design algorithm s based on a flow of objects, not just data. It' s as if our de tectives could pin people to the blackboard—witnesses them selves, not just their statem ents. Anyone can ask a witness questions in the pursuit of the case, post the transcript, and m ove that witn ess to another area of the bl ackboard, where he m ight respond differently (if you allow the witne ss to read the blackboard too). A big advantage of system s such as these is th at you have a single, con sistent interface to the blackboard. When building a conventional distribu ted application, you can spend a great deal of time craftin g unique API calls for ev ery distributed transaction and in teraction in the system . With the com binatorial exp losion of interf aces and in teractions, th e project can quickly becom e a nightm are. Organizing Your Blackboard When the detectives work on large cases, the blackboard m ay be- com e cluttered, and it may becom e difficult to locate data on the board. The solution is to partition the blackboard and start to organize the data on the blackboard som ehow. Different software s ystem s handle this partitionin g in different wa ys; some use fairl y flat _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 138 Hunt, Thomas The Pragmatic Programme r 139 zones or interests group s, while others adopt a m ore hierarchical treelike structure. The blackboard style of programm ing rem oves the need for so m any interfaces, m aking for a m ore elegant and consistent system . Application Example Suppose we are writing a program to accept and p rocess m ortgage or lo an application s. The laws that govern this area are odiously complex, with federal, state, and local governm ents all having their say. The lender m ust prove they have disc losed cer tain th ings, and must ask for certain inform ation—but m ust not ask certain other questions, and so on, and so on. Beyond the m iasma of applicable law, we also have the following problem s to contend with. • There is no guarantee on the order in which data arriv es. For instan ce, qu eries for a credit check or title search m ay take a sub stantial am ount of tim e, while item s such as name and address m ay be available imm ediately. • Data gathering m ay be done by different peop le, distributed across different offices, in different tim e zones. • Some data gathering m ay be done autom atically by other system s. This data m ay arrive asynchronously as well. • Nonetheless , certain data m ay still b e depende nt on other data. For instan ce, you m ay not be able to start the title sear ch for a car until you g et proof of ownership o r insurance. • Arrival of new data m ay raise new questions and policies. Suppose the credit check com es back with a less than glowing report; now you need these five extra form s and perhaps a blood sam ple. You can try to handle every po ssible com bination and circum stance using a workflow system . Many such system s exist, but they can be com plex and programmer intensive. As regulations change, the work-flow must be reorganized: people may have to change their procedures and hard- wired code m ay have to be rewritten. A blackboard, in com bination with a rules engine that encapsulates the lega l requirem ents, is an elegan t solu tion to th e difficulties fo und here. Order of data arrival is irrele vant: when a fact is posted it can trigg er the appropria te rules. Feedba ck is eas ily handled as well: the output of any set of rules can post to the blackboa rd and cause the triggering of yet m ore applicable rules. Tip 43 Use Blackboards to Coordinate W orkflow We can use the blackboard to coordinate dispar ate facts and agents, while still m aintaining independence and even isolation among participants. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 139 Hunt, Thomas The Pragmatic Programme r 140 You can accom plish the sam e results with m ore brute-force methods, of course, but you' ll have a more brittle system . When it b reaks, all the king' s horses and all the king' s men might not get your program working again. Related sec tions include : • The Power of Plain Text • It's Just a View Challeng es • Do you use blackboard system s in the real worl d—the m essage board by the refrigerator, or the big whiteboard at work? What makes the m effective? Are m essages ever posted with a consistent form at? Does it m atter? Exercises 30. For each of the following application s, would a blackboard sy stem be appropriate or no t? Why? 1. Image processing. You' d like to have a number of parallel pr ocesses grab chunks of an im age, process them , and put the com pleted chunk back. 2. Group calendaring. You' ve got people scattered across the globe , in different tim e zones, and speaking different languages, trying to schedule a m eeting. 3. Netw ork monitoring to ol. The system gathers perf ormance statistics and collects trouble reports. You' d like to implement som e agents to use this infor mation to look for trouble in the system . _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 140 Hunt, Thomas The Pragmatic Programme r 141 _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 141 Hunt, Thomas The Pragmatic Programme r 142 Chapter 6. While You Are Coding Conventional wisdom says that once a project is in the coding phase, the work is m ostly mechanical, transcrib ing the des ign in to execu table st atements. W e think that th is attitude is th e single biggest reason that m any program s are ugly, in efficient, poorly structured, unm aintainable, and just plain wrong. Coding is not m echanical. If it were, all the CASE t ools that people pinned their hopes on in the early 1980s would have replaced programm ers long ago. There are decisions to be m ade every minute—decisions that require caref ul thought and judgm ent if the re sulting program is to enjoy a long, accu rate, and prod uctive life. Developers who don' t actively think about their code are programm ing by coincidence—the code might work, but there' s no particular reason why. In Programming by Coincidence, we advocate a more positive involvem ent with the coding process. While m ost of the code we write executes qu ickly, we occasionally dev elop algorith ms that have the potential to bog down even the fastest processors. In Algorithm Speed, we discuss ways to estim ate the speed of code, and we give som e tips on how to spot potential problem s before they happen. Pragm atic Programm ers think critically about all code, including our own. W e constantly see room for im prove ment in our program s and our designs. In Refac toring, we look at techniques that help us fix up existing code even while we' re in the midst of a project. Something that should be in the back of your mind whenever you' re producing code is that you' ll someday ha ve to test it. Make code easy to test, and you' ll increase th e likelihood that it will actually get tested, a th ought we develop in Code That's Easy to Test. Finally, in Evil Wizards, we suggest that you should be careful of tools that write ream s of code on your behalf unless you understand w hat they' re doing. Most of us can drive a car la rgely on autopilot— we don' t explic itly command our foot to press a pedal, or our arm to turn the wheel—we just th ink \"slow down and turn right.\" However, good, safe drivers are constantly review ing the situation, ch ecking for p otential p roblems, and putting them selves into good position s in case the unexp ected happ ens. The same is true of coding—it m ay be largely routine, but ke eping your wits about you c ould well prevent a disaster. Program ming by Coincid ence Do you ever watch old black-and-white war m ovies? The weary soldier advances cautiously out of the brush. T here's a clearing ahead: are th ere an y land m ines, or is it safe to cross? There aren' t any indications that it' s a minefield—no signs, barbed wire, or crat ers. The soldier pokes the ground ahead of him with his bayonet and winces, expecti ng an explosion. There isn' t one. So he proceeds painstakingly through the field fo r a while, prodding and poking as he goes. Eventually, convinced that the field is safe, he stra ightens up and m arches proudly f orward, only to be blown to pieces. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 142 Hunt, Thomas The Pragmatic Programme r 143 The soldier' s initial probes for m ines revealed nothing, but this wa s merely lucky. He was led to a false conclusion—with disastrous results. As developers, we also work in m inefields. There ar e hundreds of traps just waiting to catch us each day. Rem embering the soldier' s tale, we should be wary of drawing fals e conclusions. We should avoid programming by coincidence—relying on luck and accidental successes— in favor of programming deliberately. How to Program by Coincidence Suppose Fred is given a programm ing assignm ent. Fred types in som e code, tries it, and it seem s to work. Fred types in some m ore code, tries it, an d it still seem s to work. Af ter seve ral weeks of coding this way, the program sudde nly stops worki ng, and af ter hours of trying to fix it, he still doesn' t know why. Fred m ay well sp end a significant am ount of tim e chasing this piece of code around without ever being able to fix it. No m atter wh at he does, it just doesn' t ever seem to work right. Fred doesn' t know why the code is failing b ecaus e he didn't know why it wor ked in th e firs t place. It seem ed to work, given the lim ited \"testing\" that Fr ed did, but that was just a coincidence. Buoyed by false con fidence, Fred charged ah ead into oblivion. Now, most intellig ent people m ay know someone like Fred, but we know better. W e don't rely on coincidences—do we? Sometimes we m ight. Som etimes it can be pretty easy to confuse a happy coincidence with a purposeful plan. Let' s look at a few exam ples. Accidents of Implementati on Accidents of implem entation are th ings that h appen sim ply because th at's the way the code is currently written. You end up relying on undocum ented error or boundary conditions. Suppose you call a routine with bad data. The routine responds in a particular way, and you code based on that response. But the author didn' t inte nd for the routine to work that way—it was never even considered. W hen the routine gets \"fixed,\" your code may brea k. In the m ost extrem e case, the routine you called m ay not even be de signed to do what you want, but it seems to work okay. Calling things in the wrong order, or in the wrong context, is a related problem . paint(g); invalidate(); validate(); revalidate(); repaint(); paintImmediately(r); Here it looks like Fred is desper ately trying to get som ething out on the screen. But these routines were never designed to be called this way; although they seem to work, that' s really just a coincid ence. To add insult to injury, when the component fina lly does get drawn, Fred won' t try to go back and take out the spurious calls. \"It wo rks now, better leav e well enough alone….\" _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 143 Hunt, Thomas The Pragmatic Programme r 144 It's easy to be fooled by this line of thought . Why should you take the risk of m essing with something that' s working? W ell, we can think of several reasons: • It may not really be working— it might just look like it is. • The boundary condition you rely on m ay be just an accid ent. In different circum stances (a different screen resolution, perhaps), it m ight behave differently. • Undocum ented behavior m ay change with the next release of the library. • Additional and unnecessary calls m ake your cod e slower. • Additional calls also incr ease the risk of introduci ng new bugs of their own. For code you write that others will call, the basic principles of good m odularization and of hiding implem entation behind s mall, well-d ocumented inte rfaces can all help. A well-spe cified contract (see Design by Contract ) can help elim inate m isunderstandings. For routines you call, rely only on docum ented beha vior. If you can' t, for whatever reason, then docum ent your assum ption well. Acciden ts of Conte xt You can have \"accidents of context\" as well. Su ppose you are writing a utility m odule. Just becau se you are currently coding for a GUI environm ent, does the m odule have to rely on a G UI being present? Are you relying on English-speaking users? Literate users? What else are you relying on that isn' t guaranteed? Implicit As sumptions Coincidences can m islead at all levels—from gene rating requirem ents through to testing. Testing is particularly fraught with false causalities and coincide ntal outcom es. It' s easy to assum e that X causes Y, but as we said in Debugging : don' t assum e it, prove it. At all levels, people operate with m any assum ptions in m ind—but these assum ptions are rarely docum ented and are often in conflic t between different developers. Assumptions that aren' t based on well-es tablished f acts are the bane of all projects. Tip 44 Don' t Program by Coincidence How to Program Delib erate ly We want to spend less tim e churning out code, ca tch and fix errors as early in the developm ent cycle as pos sible, and create fewer errors to begi n with. It helps if we can program deliberately: • Always be aware of what you are doing. Fred let things get slowly out of hand, until he ended up boiled, like the frog in Stone Soup and Boiled Frogs . _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 144 • Don' t code blindfolded. Attem pting to build an application you don' t fully understand, or to use a techno logy you aren' t familiar with, is an invitation to be m isled by coincid ences. Hunt, Thomas The Pragmatic Programme r 145 • Proceed fro m a plan, whether that p lan is in your head, on th e back of a c ocktail napk in, or on a wall-sized printout from a CASE tool. • Rely only on reliable things. Don' t depend on accidents or assum ptions . If you can' t tell the difference in particular circum stances, assum e the worst. • Docum ent your assum ptions. Design by Contract , can help clarify your assum ptions in your own m ind, as well as help co mmunicate them to others. • Don' t just test your code, but test your assu mptions as well. Don' t guess; actually try it. Write an assertion to test your assumptions (see Assertive Programm ing). If your assertion is right, you have im proved the docum entation in your code. If you discover your assum ption is wrong, then count yourself lucky. • Prioritize your effort. Spend tim e on the im porta nt aspects; m ore than likely, thes e are the hard parts. If you don' t have fundamentals or infrastructure correct , brilliant bells and whistles will be irr elevant. • Don' t be a slave to history. Don' t let existing code dictate future code. All code can be replaced if it is no longer appropriate. Even within one program, don' t let what you' ve already done constrain what you do next—be ready to refactor (see Refactoring ). This decision m ay impact the project schedule. The assumption is that the im pact will be less than the cost of not making the chang e.[1] [1] You can also go too far here. We o nce knew a d eveloper who rewrote all source he was given because he had his own naming conve ntions. So next tim e som ething seem s to wor k, but you don' t know why, m ake sure it isn' t just a coincid ence. Related sec tions include : • Stone Soup and Boiled Frogs • Debugging • Design by Contract • Assertive Programm ing • Temporal Coupling • Refactoring • It's All W riting Exercises 31. Can you identify som e coincidences in the follow ing C code fragm ent? Assum e that this code is buried deep in a library routine . fprintf (stderr, \" Error, continue? \"); gets(buf); 32. This piece of C code m ight work som e of th e tim e, on som e machines. Then again, it m ight not. W hat's wrong? /* Truncate string to its last maxlen chars */ _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 145 Hunt, Thomas The Pragmatic Programme r 146 void string_tail( char *string, int maxlen) { int len = strlen(string); if (len > maxlen) { strcpy(string, string + (len - maxlen)); } } 33. This code com es from a general-purpose Java tr acing suite. The function writes a string to a log file. It passes its unit test, but fails when one of the W eb developers uses it. W hat coincid ence does it rely on? public static void debug(String s) throws IOException { FileWriter fw = new FileWriter( \"debug.log\", true); fw.write(s); fw.flush(); fw.close(); } Algor ithm Speed In Estimatin g, we talked about estim ating things such as how long it takes to walk across town, or how long a project will take to finish. However, there is another kind of estim ating that Pragm atic Programm ers use alm ost daily: estimating the re sources that algorithm s use—tim e, processor, memory, and so on. This kind of estim ating is often crucial. Give n a choice between two ways of doing som ething, which do you pick ? You know how long your program runs with 1,000 records, but how will it scale to 1,000,000? What parts of the code need optim izing? It turns out that these questions can often be answered using co mmon sense, som e analysis, and a way of writing approxim ations called the \"big O\" notation. What Do We Mean by Estimating Algorithms? Most nontrivial algorithm s handle som e kind of variable input—sorting n strings, inverting an m × n matrix, or decrypting a m essage with an n-bit key. Norm ally, the size of this inpu t will affect the algorithm : the larger the input , the longer the running tim e or the m ore mem ory used. If the relationship were always linear (so that the time increased in direct proportion to the value of n), this section wouldn' t be im portant. However, most significant algorithm s are not linear. The good news is that m any are sublinear. A binary sear ch, for exam ple, doesn' t need to look at every candidate when finding a m atch. The bad news is th at other algorithm s are c onsid erably worse th an linear; runtim es or m emory require ments increase far faster than n. An algorithm that takes a m inute to process ten item s may take a lifetim e to process 100. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 146 We find that whenever we write anything containing loops or recurs ive calls, we subconsciously check the runtim e and mem ory requirem ents. This is rarely a for mal proce ss, but rather a quick confirm ation that what we' re doing is sensible in the circumstances. However, we som etimes do find ourselves perform ing a m ore de tailed analys is. That' s when the O() notation comes in useful. Hunt, Thomas The Pragmatic Programme r 147 The O() Notation The O() notation is a m athem atical way of dealing with approxim ations. When we wr ite that a particula r sort rou tine so rts n records in O(n2) time, we are s imply saying that the wor st-case tim e taken will vary as the square of n. Double the nu mber of records, and the tim e will increase roughly fourfold. Think of the O as m eaning on the order of. The O() notation puts an upper bound on the value of the thing we' re measuring (tim e, memory, and so on). If we say a function takes O(n2) tim e, then we know that the u pper bound of the time it takes will not grow faster than n2. Som etimes we come up with f airly com plex O() functions, bu t because the h ighest-orde r term will dom inate the value as n increases, the convention is to remove all low-order term s, and not to bother showing any constan t multiplying f actors. O(n2/2+ 3n) is the sam e as O(n2/2), which is equivalent to O(n2). Th is is actually a weakness of the O() notation—one O(n2) algorithm m ay be 1,000 tim es faster than another O(n2) algorithm , but you won' t know it from the notation. Figure 6.1 shows several comm on O() notations you' ll com e across, along with a graph com paring running times of algorithm s in each catego ry. Clearly, things quickly start getting out of hand once we get over O(n2). Figure 6. 1. Runtimes of various al gorithms _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 147 Hunt, Thomas The Pragmatic Programme r 148 For exam ple, suppose yo u've got a routine that takes 1 s to process 100 records. How long will it take to process 1,000? If your code is O(1), then it will still ta ke 1 s. If it's O(lg(n)), then you' ll probably be waiting about 3 s. O(n) will show a linea r increase to 10 s, w hile an O(n lg(n)) will ta ke some 33 s. I f you' re unlucky enough to have an O(n2) routine, then sit b ack for 100 s while it does its stuff. And if you' re usi ng an exponential algorithm O(2n), you m ight want to m ake a cup of coffee—your routine should finish in about 10263 years. Let us know how the universe ends. The O() notation doesn' t apply just to tim e; you can use it to represent any other resources used by an algorithm . For exam ple, it is of ten useful to be able to m odel memory consum ption (see Exercise 35). Common Sense Estima tion _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 148 Hunt, Thomas The Pragmatic Programme r 149 You can estim ate the order of m any basic algorithm s using common sense. • Simple loops. If a sim ple loop runs from 1 to n, then the algo rithm is like ly to be O(n)—time increas es linea rly with n. Exam ples includ e exhaustiv e searches , finding the m aximum value in an array, and generating checksum s. • Nested loop s. If you nest a loop inside anothe r, then your algorithm becomes O(m × n ), where m and n are the two loops' limits. This commonly occurs in simple sorting algorithm s, such as bubble sort, where the outer loop scans each elem ent in the array in turn, and the inner loop works out where to place that elem ent in the sorted result. Such sorting algorith ms tend to be O(n2). • Binary chop. If your algorithm halves the set of things it considers each time around the loop, then it is likely to be logarithm ic, O(lg(n)) (see Exercise 3 7). A binary search of a s orted lis t, traversing a binary tree, and finding the f irst se t bit in a m achine word can all be O(lg(n)). • Divide and conquer. Algorithm s that partition their input, work on the two halves independently, and then combine the result can b e O(n lg(n)). The class ic exam ple is quicksort, which works b y partition ing the data into two halves and r ecursively sor ting e ach. Althou gh technically O(n2), becau se its b ehavior degrad es when it is fed sorted inp ut, the av erage runtim e of quicksort is O(n lg(n)). • Combinatoric. Whenever algorithm s start looking at the perm utations of things, their running tim es may get out of hand. This is because perm utations involv e factorials (there are 5! = 5 × 4 × 3 × 2 × 1 = 120 permutations of the digits from 1 to 5). Tim e a com binatoric algorithm for five elem ents: it will take six times longer to run it fo r six, and 42 times longer for seven. Exam ples include algorithm s for m any of the acknowledged hard problem s—the traveling salesm an problem , optim ally packing things into a container, partitioning a set of numbers so that each set has the sam e total, and so on. Often, heuristics are used to reduce the running times of these types of algorith ms in particular problem domains. Algorithm Speed in Practice It's unlikely that you' ll spend m uch time during your career w riting sort ro utines. The ones in the libraries availab le to you will prob ably outpe rform anything you m ay write withou t substantial effort. Howe ver, the basic kinds of algorithm s we've described earlier pop up tim e and tim e again. Whenever you find yourself writing a si mple loop, you know that you have an O(n) algorithm . If that loop contains an inne r loop, then you' re looking at O(m × n ). You should be asking yourself how large these values can get. If the num bers are bounded, then you' ll know how long the code _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 149 Hunt, Thomas The Pragmatic Programme r 150 will take to run. If the numbers depen d on extern al factors (su ch as the nu mber of records in an overnight batch run, or the num ber of na mes in a list of people), then you m ight want to stop and consider the effect that larg e values may have on your runni ng tim e or m emory consumption. Tip 45 Estim ate the Order of Your Algorithm s There are som e approaches you can take to addr ess potential problem s. If you have an algorithm that is O(n2), try to find a divide and conquer ap proach th at will take yo u down to O(n lg(n)). If you' re not sure how lo ng your cod e will take, or how m uch m emory it will use, try running it, varying the input record count or whatever is likely to im pact the runtim e. Then plot the results. You should soon get a good idea of the shape of the cu rve. Is it curving upwar d, a straight line, or flattening off as the input size increases? Three or four points should give you an idea. Also consider just what you' re doi ng in the code itself. A simple O(n2) loop m ay well perform better that a com plex, O(n lg(n)) one for sm aller values of n, partic ularly if the O(n lg(n)) algorithm has an expensive inner loop. In the m iddle of all this theory, don' t forget that there are practical consider ations as well. Runtim e may look like it increases linearly for sm all input se ts. But feed the code m illions of records and suddenly the tim e degrades as the system starts to thrash. If you test a so rt routine with random input keys, you m ay be surprised the first tim e it encounters ordered input. Pragm atic Programm ers try to cover both the theoretical and practical bases. After all th is estim ating, the only tim ing that counts is the speed of your code, running in the production environm ent, with real data.[2] This leads to our next tip. [2] In fact, while testing the sort algorithms used as an exercise for this section on a 64MB Pentium, the authors ran out of real memory while running the radix s ort with m ore than seven million numbers. The sort sta rted using swa p space, and tim es degrade d dramatically. Tip 46 Test Your Estim ates If it's tricky getting accu rate tim ings, use code profilers to count the num ber of tim es the different steps in your algorithm get executed, and plot these figures against the size of the input. Best Isn' t Always Best You also need to be pragm atic about choosing appropriate algorithm s—the fastest one is not always the best for the job. Given a sm all input set, a strai ghtforward insertion sort will perf orm just as well as a quicksort, and will take you less tim e to write and debug. You also need to be careful if the algorithm you choose has a high setup cost. For sm all input sets, this setu p may dwarf the running time and m ake the algorithm inappropriate. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 150 Hunt, Thomas The Pragmatic Programme r 151 Also be wary of premature optimization. It's always a good idea to m ake sure an algorithm really is a bottleneck before investing your precious tim e trying to im prove it. Related sec tions include : • Estim ating Challeng es • Every developer should have a feel for how algorithm s are designed and analyzed. Robert Sedgewick has written a series of accessible books on the subject ([ Sed83 , SF96 , Sed92 ] and others). W e recomm end adding one of his books to your coll ection, and m aking a point of reading it. • For those w ho like m ore detail than Sedgewick provides, re ad Donald Knuth' s def initive Art of Computer Programming books, which analyze a wide range of algorithm s [Knu97a , Knu97b , Knu98 ]. • In Exercise 34, we look at sorti ng arrays of long integers. W hat is the im pact if the keys are more com plex, and the overhead of key com parison is high? Does the key structure affect the efficiency of the sort algorithm s, or is the fastest sort always fastest? Exercises 34. We have coded a set of sim ple sort routines , which can be downloaded from our W eb site (http://www.pragm aticprogramm er.com ). Run them on various m achines available to you. Do your figures follow the expected curves? What can you deduce about th e relative speeds of your m achines? What are the effects of various com piler optim ization se ttings? Is the radix sort ind eed linear? 35. The routine below prints out th e con tents of a bin ary tree. Assum ing the tree is balanced, roughly how m uch stack space will th e routine use while printing a tree of 1,000,000 elem ents? (Assum e that subroutin e calls impose no significant stack overhead.) void printTree( const Node *node) { char buffer[1000]; if (node) { printTree(node->left) ; getNodeAsString(node, buffer); puts(buffer); printTree(node->right); } } 36. Can you see any way to reduce the stack requirem ents of the routine in E xercise 35 (apart from reducing the size of the buffer)? 37. we claim ed that a binary chop is O(lg(n)). Can you prove this? Refactor ing _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 151 Hunt, Thomas The Pragmatic Programme r 152 Change and decay in all around I see … H. F. Lyte, \"Abide With Me\" As a progra m evolves, it will b ecome necess ary to reth ink earlie r decision s and rework portions of the code. This process is perfectly natural. C ode needs to evolve; it' s not a static thing. Unfortunately, the m ost comm on m etaphor for so ftware developm ent is building construction (Bertrand Meyer [ Mey97b ] uses the term \"Sof tware Constru ction\"). But using construction as the guiding m etaphor im plies these steps: Step 1. An architect draws up blueprints. Step 2. Contractors dig the foundatio n, build the superstructure, wire and plum b, and apply finishing touches. Step 3. The tenants m ove in and live happily ever after, calling building m aintenance to fix any problem s. Well, software doesn' t quite work that way. Ra ther than construction, software is m ore like gardening— it is m ore organic than concrete. You plant many things in a garden according to an initial plan and conditions. Som e thrive, others are destined to end up as com post. You m ay move plantings relative to each other to tak e advantag e of the interp lay of li ght and shadow, wind and rain. Overgrown plants get split or pruned, a nd colors that clash m ay get moved to m ore aesthetically pleasing loca tions. You pull weeds, and you fertilize pl antings that are in need of some extra help. You constantly m onitor the health of the garden, and m ake adjustm ents (to the soil, the plants, the layout) as needed. Business people are comfortable with the m etaphor of building constr uction: it is more scientific than gardening, it' s repeatable, there' s a rigid re porting hierarchy for m anagem ent, and so on. But we're not building skyscrapers—we aren' t as co nstrained by the boundaries of physics and the real world. The gardening m etaphor is m uch closer to the real ities of software developm ent. Perhaps a certain routine has grown too large, or is trying to ac complish too much—it ne eds to be sp lit into two. Things that don' t work out as planned need to be weeded or pruned. Rewriting, reworking, and re-architec ting code is collectively known as refacto ring. When Should You Refactor? When you com e across a stum bling block becau se the cod e doesn' t quite fit anym ore, or you notice two things that should really be m erged, or a nything else at all strike s you as being \"wrong,\" don't hesitate to change it There' s no tim e like the pres ent. Any number of things m ay caus e code to qualify for refactoring: • Duplication . _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 152 Hunt, Thomas The Pragmatic Programme r 153 You' ve discovered a violation of the DRY princip le (The Evils of Duplication ). • Nonorthogonal design. You' ve discovered som e code or design that could be m ade more orthogonal (Orthogonality ). • Outdated know ledge. Things change, requirements drift, and your knowledge of the problem increases. Code needs to keep up. • Performance. You need to m ove functionality from one area of the system to another to im prove perform ance. Refactoring your code— moving func tionality aro und and updating earl ier decis ions—is really an exercise in pain management. Let's face it, chang ing source code around can be pretty painful: it was alm ost working, and now it' s really torn up. Many developers are reluctant to start ripping up code just because it isn' t quite right. Real-World Co mplicatio ns So you go to your boss or client and say, \"This code wo rks, but I need another week to refactor it.\" We can' t print their reply. Time pressure is often used as an excuse for not refactoring. But this excu se just doesn' t hold up: fail to refactor now, and there' ll be a far greater tim e invest ment to fix the problem down the road— when there are m ore dependencies to reckon with . Will there be m ore time available then? Not in our experience. You m ight want to explain this principle to the boss by using a m edical analogy: think of the code that needs refactoring as a \"gro wth.\" Re moving it requires invasive surgery. You can go in now, and take it out w hile it is still sm all. Or, you c ould wait while it grows and spreads—but removing it then will be both m ore expensive and m ore da ngerous. W ait even longer, and you m ay lose the patient entirely. Tip 47 Refactor Early, Refactor Often Keep track of the things that need to be ref actored. If you can' t refactor som ething i mmediately, make sure that it gets placed on the schedule. Make sure that users of the affected code know that it is scheduled to be refactored and how this m ight affect them . _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 153 Hunt, Thomas The Pragmatic Programme r 154 How Do Yo u Refactor? Refactoring started out in the Sm alltalk comm unity, and, alo ng with other trend s (such as design patte rns), h as star ted to g ain a wide r audience. B ut as a topic it is still f airly new; the re isn' t much published on it. The first m ajor book on refactoring ([ FBB+99], and also [ URL 47]) is being published around the sam e time as this book. At its heart, refactoring is redesign. Anything that you or others on your team designed can be redesigned in light of new facts, deeper unders tandings, changing requirem ents, and so on. But if you proceed to rip up v ast quantities of code w ith wild aband on, you m ay find yourself in a worse position than when you started. Clearly, refactoring is an activity that needs to be undertaken slowly, deli berately, and carefully. Martin Fowler offers the following simple tips on how to refactor without doing m ore harm than good (see the box on in [ FS97 ]): 1. Don' t try to refactor and add function ality at the s ame time. 2. Make sure you have good tests before you be gin refactoring. Run th e tests as often as possible. Th at way you will know quickly if your changes h ave broken anything. Automatic Refactoring Historically, Smalltalk u sers have always enjoye d a class bro wser as part of the IDE. Not to be confused with W eb browsers, class brow sers let users navigate through and examine class hierarchies and m ethods. Typically, class browsers allow you to edit code , create new m ethods and classes, and so on. The next variation on this idea is the refactoring browser. A refactoring browser can sem iautom atically perform common refact oring operations for you: splitting up a long routine into sm aller ones, autom atically propagating changes to method and variable nam es, drag and drop to assist you in m oving code, and so on. As we write this book, this tec hnology has yet to appear outs ide of the Smalltalk world, but this is likely to ch ange at th e same speed that Java chan ges—rapid ly. In the m eantim e, the pioneering Sm all-talk refactoring browser ca n be found online at [ URL 20]. 3. Take short, deliberate steps: m ove a field from one class to another, fuse two sim ilar methods into a superclass. Refactoring often involves m aking m any localized changes that result in a larger-scale change. If you keep your steps sm all, and tes t after each s tep, you will avoid prolonged debugging. We'll talk m ore about testing at this level in Code That' s Easy to Test , and larger-scale testing in Ruthless Te sting , but Mr. Fowler' s point of maintaining good regres sion tests is the key to refactoring with confidence. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 154 Hunt, Thomas The Pragmatic Programme r 155 It can also be helpful to m ake sure that drastic changes to a m odule—such as altering its interface or its functionality in an in compatible manner—break the build. That is, old clien ts of this code should fall to com pile. You can then quickly find the old clients and m ake the necessary changes to bring them up to date. So next tim e you see a piece of code that isn' t quite as it should be, fix both it and ev erything th at depends on it. Manage the pain: if it hurts now, but is going to hurt even m ore later, you m ight as well get it o ver with. Re member the lessons of Software Entropy , don' t live with broken windows. Related sec tions include : • The Cat Ate My Source Code • Software Entropy • Stone Soup and Boiled Frogs • The Evils of Duplication • Orthogonality • Programm ing by Coincidence • Code That' s Easy to Test • Ruthless Te sting Exercises 38. The following code has obviously been updated se veral tim es over the years, but the changes haven' t improved its structure. Refactor it . if (state == TEXAS) { rate = TX_RATE; amt = base * TX_RATE; calc = 2*basis(amt) + extra(amt)*1.05; } else if ((state == OHIO) || (state == MAINE; rate = (state == OHIO) ? OH_RATE : MN_RATE] amt = base * rate; calc = 2*basis(amt) + extra(amt)*1.05; if (state == OHIO) points = 2; } else { rate = 1; amt = base; calc = 2*basis(amt) + extra(amt)*1.05; } 39. The following Java class needs to support a few mo re shapes. Refactor th e class to prepare it for the additions . public class Shape { public static final int SQUARE = 1; public static final int CIRCLE = 2; _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 155 Hunt, Thomas The Pragmatic Programme r 156 public static final int RIGHT_TRIANGLE = 3; private int shapeType; private double size; public Shape(int shapeType, double size) { this.shapeType = shapeType; this.size = size; } // ... other methods ... public double area(){ switch (shapeType) { case SQUARE: return size*size; case CIRCLE: return Math.PI*size*size/4.0; case RIGHT_TRIANGLE: return size*size/2.0; } return 0; } } 40. This Java code is part of a fram ework that wi ll be used throughout your project. Refactor it to be m ore general and easier to extend in the future . public class Window { public Window( int width, int height) { ... } public void setSize( int width, int height) { ... } public boolean overlaps(Window w) { ... } public int getArea() { ... } } Code That's Easy to Test The Software IC is a m etaphor that people like to to ss around when discussing reusability and component-based developm ent.[3] The idea is that software compone nts should be combined just as integrated circuit chips are com bined. This wo rks only if the com ponents you are using are known to be re liable. [3] The term \"Softw are IC\" (Inte grated Circuit) seems to ha ve been inve nted in 1986 by Cox and N ovobilski in their Objective-C book Object-Oriented Programming [CN9 1]. Chips are designed to be tested—not ju st at the factory, not just when they are installed, but also in the field wh en they a re deployed. M ore com plex chips and s ystem s may have a f ull Built- in Self Test (BIST) feature that runs some base-lev el diagnostics internally, o r a Test Access Mechanism (TAM) that provides a test harne ss that allows the external environm ent to provide stimuli and collect respo nses from the chip. We can do the sam e thing in software. Like our ha rdware colleagues, we need to build testability into the software from the very beginning, and test each piece thoroughly before trying to wire them together. Unit Testin g _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 156 Hunt, Thomas The Pragmatic Programme r 157 Chip-level testing for hardwa re is roughly equivalent to unit testing in software—testing done on each m odule, in isolation , to verify its behavior. We can get a better fee ling for how a m odule will react in the big wide world once we have tested it throughly under controlled (even contrived) conditions. A sof tware unit test is c ode that exe rcises a m odule. Typica lly, the unit te st will establish som e kind of artificial environm ent, then i nvoke routines in the m odule being te sted. It then checks the results that are returned, either against know n values or ag ainst the results from previous runs of the sam e test (regression testing). Later, when we assem ble our \"sof tware IC's\" into a com plete system , we'll have conf idence tha t the individual parts work as expected, and then we can use the sam e unit te st facilities to test th e syste m as a whole. W e talk abo ut this la rge-scale checking of the system in Ruthless Testing . Before we get that far, however, we need to de cide what to test at the unit level. Typically, programm ers throw a few random bits of data at th e code and call it tested. We can do much better, using the ideas behind design by contract. Testing Against Contract We like to think of unit testing as testing against contract (see Design by Contract ). We want to write test cases that ensure that a given unit honors its contract. This will tell us two things: whether the code m eet the contract, and wh ether the contract m eans what we think it means. We want to tes t that the m odule delivers the functionality it prom ises, over a wide range of test cases and boundary conditions. What does this m ean in practice? Let's look at the square root routine we first encountered on page 114. Its contract is sim ple: require: argument >= 0; ensure: ((result * result) - argument).abs <= epsilon*argument; This te lls us what to te st: • Pass in a negative argum ent and ensure that it is rejected. • Pass in an argum ent of zero to ensure that it is accepted (this is the boundary value). • Pass in values between zero and the m aximum expressible argum ent and verify that the difference between the square of the result and the orig inal a rgument is le ss than som e small fraction of the argum ent. Armed with this contract, and assum ing that our routine does its own pre- and postcondition checking, w e can write a basic test script to exercise the square root function. public void testValue( double num, double expected) { double result = 0.0; _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 157 Hunt, Thomas The Pragmatic Programme r 158 try { // We may throw a result = mySqrt(num); // precondition exception } catch (Throwable e) { if (num < 0.0) // If input is < 0, then return; // we're expecting the else // exception, otherwise assert( false); // force a test failure } assert(Math.abs(expected-result) < epsilon*expected); } Then we can call this rou tine to test our square root function: testValue(-4.0, 0.0); testValue( 0.0, 0.0); testValue( 2.0, 1.4142135624); testValue(64.0, 8.0); testValue(1.0e7, 3162.2776602); This is a pretty sim ple test; in the real world, any nontrivial m odule is lik ely to be dependent on a number of other m odules, so how do we go about testing the com bination? Suppose we have a m odule A that uses a LinkedList and a Sort. In order, we would test: 1. LinkedList's contract, in full 2. Sort's contract, in full 3. A's contract, which relies on the other c ontracts but does not directly expose them This style of testing requires you to test subc omponents of a module first. Once the subcom ponent s have been verified, then th e module itself can be tested. If LinkedList and Sort 's tests passed, but A' s test failed, we can be pretty sure that the problem is in A, or in A' s use of one of those subcom ponents. This technique is a great way to reduce debugging effort: we can quickly concentrate on the likely source of the problem within m odule A, and not waste tim e reexam ining its subcom pone nts. Why do we go to all this trouble? Above all, we want to avoid creating a \"tim e bom b\"—som ething that sits around unnoticed and blows up at an awkw ard m oment later in the project. B y emphasizing testing against contract, we can try to avoid as m any of those dow nstream disasters as possib le. Tip 48 Design to T est When you design a m odule, or even a single routin e, you should design both its contract and the code to test that contract. By designin g code to pass a tes t and fulfill its co ntract, you m ay well _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 158 Hunt, Thomas The Pragmatic Programme r 159 consider bo undary cond itions and other issu es that wouldn' t occur to you otherwise. There' s no better way to fix errors than by avoiding them in the firs t place. In fact , by building the tests before you im plement the code, you get to try out the interface before you commit to it. Writ ing Unit Tests The unit tests for a m odule shouldn' t be shoved in some far-away corner of the source tree. They need to be conveniently located. For sm all projec ts, you can embed the unit test for a module in the module itself. For larger projects, we suggest moving each test into a subd irecto ry. Eith er way, remember that if it isn' t easy to find, it won' t be used. By m aking the test code readily accessible, you are providing developers who m ay use your code with two inv aluable reso urces: 1. Exam ples of how to use all the functionality of your m odule 2. A means to build regression tests to va lidate any future chang es to th e cod e It's convenient, but not always practical, for each class o r module to con tain its own un it test. In Java, for example, every class can have its own main. In all b ut the app lication' s main class f ile, th e main routine can be used to run unit tests; it will be ignored when th e application itself is run. T his has the benefit that the code you ship still contains the tests, which can be used to diagnose problem s in the field. In C++ you can achieve the sam e effect (at com pile tim e) by using #ifdef to com pile unit test code selectively. For exam ple, here' s a very sim ple unit test in C++, em bedded in our m odule, that checks our square root function using a testValue routine sim ilar to the Ja va one defined previously: #ifdef _TEST_ int main(int argc, char **argv) { argc--; argv++; // skip program name if (argc < 2) { // do standard tests if no args testValue(-4.0, 0.0); testValue( 0.0, 0.0); testValue( 2.0, 1.4142135624); testValue(64.0, 8.0); testValue(1.0e7, 3162.2776602); } else // else use args { double num, expected; while (argc >= 2) { num = atof(argv[0]); expected = atof(argv[1]); testValue(num,expected); argc -= 2; argv += 2; } } return 0; _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 159 } Hunt, Thomas The Pragmatic Programme r 160 #endif This unit tes t will eith er run a m inimal set of tests or, if given arguments, allow you to pass data in from the outside world. A shell script could use th is ability to run a m uch more com plete set of tests. What do you do if the correct response for a unit test is to exit, or abort th e program ? In that case, you need to be able to select the test to run, perhaps by specif ying an argum ent on the command line. You' ll also need to pass in param eters if you need to sp ecify different starting conditions fo r your tests. But providing unit tests isn' t enough. You m ust run th em, and run them often. It also helps if the class passes its tests o nce in a while. Using Test Harnesses Because we usually write a lot of test code, and do a lot of testing, we' ll make life easier on ourselves and develop a standard te sting harness for the project. The main shown in the previous section is a very sim ple test harness, but us ually we' ll need more f unction ality than th at. A test harness can handle common op erations such as logging status , analyzing output for expected results, and selecting and running the tests. Harn esses m ay be GUI driven, m ay be written in the same target language as the rest of the projec t, or m ay be i mplemented as a com bination of makefiles and Perl scripts. A sim ple test harness si s shown in the answer to Exercise 41 on page 305. In object-oriented languages and environm ents, you m ight create a base class that provides these common operations. Individual tests can subclass from that and a dd specific test code. You could use a standard nam ing convention and reflection in Java to build a list of tests dynam ically. This technique is a nice way of honoring the DRY principle—you don' t have to m aintain a list of available tests. But before you go off and star t writing your ow n harness, you m ay want to investigate Kent Beck and Erich Gamma 's xUnit at [ URL 22 ]. They' ve already done the hard work. Regardless of the technology you decide to use, test harnesses should include the following capabilities : • A standard way to specify setup and cleanup • A method for selecting individual tests or all av ailable tests • A means of analyzing output for expected (or u nexpected ) results • A standardized for m of failu re repo rting Tests should be com posable; that is, a test can be com posed of subtests of subcom pone nts to any depth. W e can use this feature to test selected parts of the system or the entir e system just as easily, using the sam e tools. Ad Hoc Testing _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 160 Hunt, Thomas The Pragmatic Programme r 161 During debugging, we may end up creating som e particular tests on-the-fly. These m ay be as sim ple as a print statem ent, or a piece of cod e entered in teractively in a debuggin g or IDE environ ment. At the end of the debugging session you need to formalize the adhoc test. If the code broke once, it is likely to break again. Dont' t just throw aw ay the test you created; add it to the ex isting unit test. For exam ple, using JUnit (the Java mem ber of th e xUnit fam ily), we m ight write our square root test as f ollows: public class JUnitExample extends TestCase { public JUnitExample( final String name) { super(name); } protected void setUp() { // Load up test data... testData.addElement( new dblPair(-4.0,0.0)); testData.addElement( new dblPair(0.0,0.0)); testData.addElement( new dblPair(64.0,8.0)); testData.addElement( new dblPair(Double.MAX_VALUE, 1.3407807929942597E154)); } public void testMySqrt() { double num, expected,.result = 0.0; Enumeration enum = testData.element(); while (enum.hasMoreElements()) { dblPair p = (dblPair)enum.nextElement(); num = p.getNum(); expected = p.getExpected(); testValue(num, expected); } } public static Test suite() { TestSuite suite= new Testsuit(); suite.addTest( new JUnitExample(\" testMySqrt \")); return suite; } } JUnit is designed to be com posable : we could add as m any tests as we wanted to this suite, and each of those tests could in turn be a suite. In addition, you have your choice of a graphical or batch interface to driv e the tes ts. Build a Test Window Even the best sets of tests are unlikely to find all the bugs; there' s som ething about the dam p, warm conditions of a production environm ent that seem s to bring them out of the woodwork. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 161 Hunt, Thomas The Pragmatic Programme r 162 This m eans you' ll often need to test a piece of so ftware once it has b een d eployed—with real-world data flowing though its veins. Unlike a circuit board or chip, w e don' t have test pins in software, but we can provide various views into th e internal state of a m odule, without using the debugger (which may be inconvenient or impossible in a production application). Log files containing trace m essages are one such m echanism . Log m essages should be in a regular, consistent form at; you may want to parse them autom atically to deduce processing tim e or logic paths that the program took. Poorly or inconsiste ntly form atted diagnostics are just so much \"spew\"—they are difficult to read and im practical to parse. Another m echanism for getting inside running code is the \"hot-key\" sequence. W hen this particular combination of keys is pressed, a diagnostic c ontrol window pops up with status m essages and so on. This isn' t som ething you norm ally would reveal to end users, but it can be very handy for the help desk. For larger, more com plex server code, a nifty tec hnique for providing a view into its operation is to include a built-in W eb server. A nyone can point a W eb browser to the application' s HTTP port (which is usually on a nonstandard num ber, such as 8080) and see internal st atus, log entries, and possibly even som e sort of a debug control panel. This m ay sound difficult to im plement, but it' s not. Freely available and em bed-dable HTTP W eb servers are available in a variety of modern languages. A good place to start loo king is [ URL 58 ]. A Culture of Testing All software you write will be tested—if not by you and your team , then by the eventual users—so you m ight as well plan o n testing it thoroughl y. A little forethought can go a long way toward minimizing m aintenance costs and help-desk calls. Despite its hacker reputation, the Perl comm unity has a very strong commitm ent to unit and regression testing. The P erl sta ndard module installation procedur e supports a regression test by invoking % make test There' s nothing m agic about Perl itself in this regar d. Perl m akes it easier to collate and analyze test results to en sure com pliance, but the big advantage is sim ply that it's a standard—tests go in a particular place, and hav e a certain expected ou tput. Testing is more cultural than technical; we can instill this testing culture in a project regardless of the language being used. Tip 49 Test Your Sof tware, or Your Users W ill Related sec tions include : • The Cat Ate My Source Code _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 162 Hunt, Thomas The Pragmatic Programme r 163 • Orthogonality • Design by Contract • Refactoring • Ruthless Te sting Exercises 41. Design a test jig for the blender interface descri bed in the answer to Exercise 17 on page 289. Write a shell scrip t that will pe rform a regr ession test f or the blender. Yo u need to tes t basic functionality , error and b oundary con ditions , and any contractual obligatio ns. What restrictions are placed o n changing the speed ? Are they b eing honored ? Evil W izards There' s no denying it—applications are getting harder and h arder to write. User inte rfaces in particular are becom ing increasingly sophisticat ed. Twenty years ago, th e average application would have a glass teletype inte rface (if it h ad an interface at all). Asynchronous term inals would typica lly provide a cha racter inte ractive display, wh ile pollable devices (such as the ubiquitous IB M 3270) would let you fill in an entire screen before hitting . Now, users expect graphical user interfaces, with con text-sensitive help , cut and pa ste, drag and drop, OLE integration, and MDI or SDI. Users are looking for W eb-browser integ ration and thin -client supp ort. All the tim e the applica tions them selves are g etting m ore complex. Most developm ents now use a multitier m odel, possib ly with som e middleware laye r or a tra nsaction m onitor. The se program s are expected to be dynam ic and flexible, and to interope rate with applications written by third parties. Oh, and did we m ention that we need ed it all nex t week? Developers are struggling to keep up. If we were using the sam e kind of t ools that produced the basic dum b-term inal applications 20 y ears ago, w e'd never get anything done. So the tool m akers and infrastructure ve ndors have com e up with a m agic bullet, the wizard. Wizards are great. Do you need an MDI application with OLE contai ner support? Just click a single button, answ er a coup le of si mple questions, and the wizard will au tomatically generate skeleton code for you. The Microsoft Visual C++ environm ent creates over 1,200 lines of code for this scenario, autom atically. W izards are hard at work in other contexts, too. You can use wizards to create server com ponents, im plement Java b eans, and handle n etwork in terfaces— all com plex areas where it' s nice to have expert help. But using a wizard designed by a guru does not auto matically m ake Joe developer equally expert. Joe can feel pretty good—he' s just produced a m ass of code and a pretty spiffy-looking program . He just adds in the specific applic ation functionality and it' s ready to ship. But unless Joe a ctually understands the code that has been produced on his behalf, he's foo ling him self. He 's programm ing by coincidence. W izards are a one-way street—the y cut the code for you, and then move on. If the code they produce isn' t quite right, or if circum stances change and you need to adapt the code, you're on your own. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 163 Hunt, Thomas The Pragmatic Programme r 164 We are not against wizards. On the contra ry, we dedicate an entire sec tion (Code Generators ) to writing your own. But if you do use a wizard, and you don' t understand all the code that it produces, you won' t be in control of your ow n application. You won' t be able to maintain it, and you' ll be struggling when it conies tim e to debug. Tip 50 Don' t Use W izard Code You Don' t Understand Some people feel that this is an extrem e position. They say that deve lopers routinely rely on things they don' t fully understand—the quantum mechanics of integrated circui ts, the interrupt structure of the processor, the algorithm s used to schedule pro cesses, the c ode in the supplied libraries, and so on. W e agree. And we' d feel the sam e about wizards if they w ere sim ply a set of library calls or standard operating system services that developers could rely on. But they' re not. W izards generate code that becom es an integral part of Joe's app lication. The w izard code is not factored out behind a tidy in terface—it is in terwoven line by line with f unctionality that Jo e writes.[4] Eventually, it stops being the wizard' s code and starts being Joe' s. And no one should be producing code they don' t fully understand. [4] However, there are othe r techniques that help manage complexity. We disc uss tw o, beans and A OP, in Orthogonality. Related sections include: • Orthogonality • Code Generators Challenges • If you have a GUI-building wizard available, us e it to generate a skeleton application. Go through every line of code it produces. Do you unde rstand it all? Could you have produced it yourself ? Would you have produced it yourself, or is it doing things you don' t need? _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 164 Hunt, Thomas The Pragmatic Programme r 165 _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 165 Hunt, Thomas The Pragmatic Programme r 166 Chapter 7. Before the Project Do you ever get the feeling that your project is doom ed, even before it starts? Som etimes it m ight be, unless you establish som e basic ground rules firs t. Otherwise, you might as well suggest that it be shut down now, and save the sponsor som e money. At the very beginning of a project, you' ll need to determ ine the requirements. Sim ply listening to users is not enough: read The Requirements Pit to find out more. Conventional wisdom and constraint manage ment are the topics of Solving Impossible Puzzles. Whether yo u are perform ing requirem ents, analysis, coding, or tes ting, d ifficult prob lems will cro p up. Most of the tim e, they won' t be a s difficult as they first appear to be. When you think you' ve got the problem s solved, you m ay still not feel comfortable with jum ping in and starting. Is it sim ple procras tination, or is it som ething more? Not Until You'r e Ready offers advice on w hen it m ay be prudent to listen to that cautionary voice inside your head. Starting too soon is one pr oblem , but waiting too long m ay be even worse. In The Specification Trap, we'll discuss the advantages of specification by exam ple. Finally, we' ll look at som e of the pitfalls of formal development processes and m ethodologies in Circles and Arrows. No m atter how well thought out it is, and regardless of which \"best practices\" it includes, no m ethod can replace thinking. With these critica l issues sorted ou t before the pro ject g ets und er way, you can be better position ed to avoid \"an alysis p aralysis\" and actu ally beg in your succes sful project. The Requirements Pit Perfection is achieved, not when there is nothing left to add, but when there is nothing left to take away…. Antoine de St. Exupery, Wind, Sand, and Stars, 1939 Many books and tutorials refer to requirements gathering as an early ph ase of the project. The w ord \"gathering\" seem s to imply a tribe of happy analysts , foraging for nuggets of wisdom that are lying on the ground all around them while the Pastor al Sym phony plays gently in the background. \"Gathering\" im plies that the re quirem ents are alrea dy there—you need m erely find them, place them in your basket, and be m errily on your way. It doesn' t quite work that way. Requirem ents rarely lie on the surface. Norm ally, they' re buried d eep beneath layers of assum ptions , misconceptions, and politics. Tip 51 Don' t Gathe r Requirem ents—Dig for Them _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 166 Hunt, Thomas The Pragmatic Programme r 167 Digging for Requirements How can you recognize a true requirem ent while you're digging through all the surrounding dirt? The answer is both sim ple and com plex. The sim ple answer is th at a requirem ent is a st atem ent of som ething that needs to be accom plished. Good requirem ents m ight include the following: • An e mployee record m ay be viewed only by a nom inated group of people. • The cylinder-head tem perature m ust not exceed the critical v alue, which varies by en gine. • The edito r will h ighlight keywords, which will be selec ted dep ending on th e type of file being edited. However, very few requirem ents are as clear-cut, and that' s what m akes requirem ents analysis complex. The first statem ent in the list above m ay have be en stated by the users as \"Only an employee' s supervisors and the personnel depart ment may view that em ployee' s records.\" Is this statem ent truly a requirem ent? Perhaps today, but it em beds busine ss policy in an absolute statem ent. Policies change regularly, so we probably don' t want to hardwire them into our requirem ents. Our recomm endation is to docum ent these policies se parately from the requirem ent, and hyperlink the two. Make the requirement the general statem ent, a nd give the developers the policy inform ation as an exam ple of the type of thing they' ll need to support in the implem entation. Eventually, policy may end up as m etadata in the application. This is a relatively subtle distinction, but it' s one that will have prof ound implications for the developers. If the requir ement is stated as \"Only personnel can view an employee record,\" the developer may end up coding an explicit test ev ery tim e the applica tion a ccesses thes e files. However, if the statem ent is \"Only au thorized users m ay access an em ployee reco rd,\" the develope r will prob ably design and implem ent som e kind of access control sys tem. When polic y changes (a nd it will), on ly the m etadata f or that sy stem will need to be upd ated. In f act, gather ing re quirem ents in this way naturally leads you to a system that is well factored to support metadata. The distinctions am ong r equirem ents, policy, and im plementation can get very blurred when user interfaces are discussed. \"The system must let you choose a loan term \" is a statem ent of requirem ent. \"W e need a list box to select the loan term\" may or m ay not be. If the users absolutely must have a list box, then it is a re quirem ent. If instead they are de scribing the ability to choose, but are using listbox as an exam ple, then it m ay not be. Th e box on page 205 discusses a project that went horrib ly wrong because the user s' interface needs were ignored. It's important to discover the underlying reason why users do a particular thing, rather than just the way they currently do it. At the end of th e day, your developm ent has to solve their business problem, not just m eet th eir stated re quirem ents. Docum enting the re asons behind req uirements will give your team invaluable inform ation wh en m aking daily implem entation decisions. There' s a simple technique for getting inside your users' requirem ents that isn' t used often enough: becom e a user. Are you writing a sys tem for the he lp desk ? Spend a couple of days monitoring th e phones with an experienced support person. Are y ou autom ating a m anual stock control system ? _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 167 Hunt, Thomas The Pragmatic Programme r 168 Work in the warehouse for a week.[1] As well as g iving you in sight in to ho w the system will really be used, you 'd be a mazed at how the request \"May I sit in fo r a week while you do y our job ?\" helps build trust and establishes a basis for comm unication with your users. Just remember not to get in the way! [1] Does a week sound like a long tim e? It re ally isn't, particularly when you're looking at proc esses in which management and w orkers occupy diffe rent worlds. Management will gi ve you one view of how thi ngs operate, but whe n you ge t down on the floor, you'll find a very diffe rent reality—one that will ta ke time to assimilate. Tip 52 Work with a User to Think Like a User The requirem ents m ining process is also the tim e to start to build a rapport with your user base, learning their expectations and hopes for the system you are building. See Great Exp ectations , for more. Documenting Requirements So you are sitting down with the users and pryi ng genuine requirem ents from them. You com e across a few likely scenarios that describe what th e application needs to do. Ever the professional, you want to write these down and publish a docu ment that everyone can use as a basis for discussions—the developers, the end users, and the project sponsors. That' s a pretty wide audience. Ivar Jacobson [ Jac94 ] proposed the concept of use cases to capture requirem ents. They let you describe a particular use of the system— not in term s of user interface, b ut in a m ore abstract fashion. Unfortunately, Jacobson' s book was a litt le vague on details, so there are now m any different opinions on what a use case should be. Is it form al or inform al, sim ple prose or a structured d ocument (lik e a form )? What level o f detail is ap propria te (re member we have a wide audience)? _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 168 Sometimes the Interface Is the System In an ar ticle in Wired magazine (January 1999, page 176) , producer and m usician Brian Eno describ ed an incred ible p iece of technology —the ultim ate m ixing board. It do es anything to sound that can be done. And yet, instead of le tting m usicians make better music, or produce a recording fa ster or less expe nsively, it g ets in the wa y; it d isrupts the creative p rocess. To see why, you have to look at how record ing engineers work. They balance sounds intuitively. Over the years, they devel op an innate feedback loop between their fingertip s—sliding faders, rotating k nobs, a nd so on However, the interface to th e new mixer didn' t leverage off those abilities. Instea d, it forced its users to type on a keyboard or click a mouse. The functions it provided we re com prehensive, but they were packaged in unf amiliar and exotic wa ys. The functions the en gineers needed were s ometimes Hunt, Thomas The Pragmatic Programme r 169 hidden behind obscure n ames, or we re ach ieved with nonintu itive com binations of bas ic facilities. That environm ent has a requirem ent to leve rage e xisting skill sets. W hile slavish ly duplicating what already exists doesn' t allow for progress, we must be able to provide a transition to the f uture. For exam ple, the recording engineers m ay have been better served by some sort of touchscreen interface—s till tactile, s till mounted as a tr aditio nal m ixing board m ight be, yet allowing the software to go beyond the realm of fixed knobs and switches. Providing a comfortable trans ition through fa miliar m etaphors is one way to help get buy-in. This exam ple also illu strates our b elief that succ essful tools a dapt to the h ands tha t use them . In this case, it is th e tools that you build for others that must be adaptable. One way of looking at use cases is to em phasize th eir goal-driven nature. Alistair Cockburn has a paper th at describ es this approach, a s well as te mplate s that can be used (stric tly or not) as a starting place ([ Coc97a ], also online at [ URL 46]). Figure 7.1 on the following page shows an abbreviated exam ple of his tem plate, while Figure 7.2 shows his sam ple use case. Figure 7. 1. Cockburn's use case templ ate Figure 7.2. A sample use case _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 169 Hunt, Thomas The Pragmatic Programme r 170 By using a form al tem plate as an aide-mémoire, you can be sure that you in clude all the inform ation you need in a use case: perform ance characteristics, other involved parties, priority, frequency, and various errors and exceptions that can crop up (\" nonfunctional requirem ents\"). This is also a great place to reco rd user com ments such as \"oh, except if we get a xxx condition, then we have to do yyy instead.\" The tem plate also serves as a read y-made agenda for m eetings with your users. This sort of organization supports the hierarchical structuring of use cases—nesting m ore detailed use cases inside higher-le vel ones. For exam ple, post debit and post cred it both elaborate on post transaction. Use Ca se Dia grams _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 170 Hunt, Thomas The Pragmatic Programme r 171 Workflow c an be captured with UML activity diag rams, and conceptual-level class d iagram s can sometimes be useful for modeling the business at hand. But true use cases are textual descriptions, with a hierarchy and cross-links. Use cases can co ntain hyperlinks to other use cases, and they can be nested within each other. It seem s incredible to us that anyone would seriously consider docum enting inform ation this dense using only simplistic stick people such as Figure 7.3 . Don' t be a slav e to any notation ; use whatev er method best communicates the requirem ents with your audience. Figure 7.3. UML use cases —so simple a child could do it! Overspec ifying A big danger in producing a requirem ents docum ent is being too specific. Good requirem ents docum ents rem ain abstract. W here requirem ents are concerned, the sim plest statem ent that accurately reflects the b usiness need is best. Th is doesn' t mean you can be vague—you m ust captu re the underlying sem antic invariants as requirem ents, and docum ent the specific or current work practices as policy. Requirem ents are not architecture. Requirem ents ar e not design, nor are they the user interface. Requirem ents are need. Seeing Further The Year 2000 problem is often blamed on short- sighted programm ers, desperate to save a few bytes in the days when m ainfra mes had less memory than a modern TV rem ote control. But it wasn' t the programm ers' doing, and it wasn' t really a m emory usage issue. If anything, it was the system analysts' and designers' fault. The Y2 K problem came about fr om two m ain causes: a failure to see beyond curre nt business practice, a nd a violation of the DRY principle. Businesses were using the two-dig it shortcut long before computers cam e on the scene. It was common practice. The earliest data processing ap plica tions m erely automated ex isting business processes, and sim ply repeated the mistak e. Even if the arch itecture requ ired two-dig it years f or data input, reporting, and storage, there should have been an abstraction of a DATE that \"knew\" the two digits were an abbreviated form of the real date. Tip 53 Abstractions Live Longer than Details _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 171 Hunt, Thomas The Pragmatic Programme r 172 Does \"seeing further\" require you to predict the f uture? No. It m eans generating statem ents such as The system makes active use of an abstract ion of DATEs. The system will implement DATE services, such as formattin g, storage, and math operations, consistently and universally. The requirem ents will specify only that dates are use d. It m ay hint th at some math may be done o n dates. It m ay tell you that dates will be stored on various form s of secondary storage. These are genuine requirem ents for a DATE module or class. Just One More Wafer-Thin Mint… Many projects failures are blam ed on an increase in scope—also known as feature bloat, creeping featurism , or requirem ents creep. This is an aspect of the boiled-frog syndrom e from Stone Soup and Boiled Frogs . What can we do to prevent requirem ents from creeping up on us? In the literature, you will find descri ptions of m any m etrics, such as bugs reported and fixed, defect density, cohesion, coupling, function points, lines of code, and so on. These m etrics m ay be tracked by hand or with software. Unfortunately, not m any projects seem to track requi rements actively. This m eans that they have no way to report on changes of scope—who requested a feature, who approved it, tota l number of requests approved, and so on. The key to m anaging growth of requirem ents is to point out each new feature' s impact on the schedule to the proje ct sponsors. W hen the pro ject is a yea r late from initia l estim ates and accusations start flying, it can b e helpful to have an accurate, com plete picture of how, and when, requirem ents growth occurred. It's easy to get sucked into the \"just one m ore feature\" m aelstrom , but by tracking requirem ents you can get a clearer p icture that \"ju st one m ore featur e\" is really the fifteenth new feature added this month. Maintain a Glossary As soon as you start dis cussing requ irements, users and dom ain experts will us e certain term s that have specific m eaning to them . The y may differe ntiate be tween a \"c lient\" and a \"cu stomer,\" for exam ple. It would then be inappropriate to use either word casually in the system . Create and m aintain a project glossary —one place that defines all the specific terms and vocab ulary used in a project. All participants in the project, f rom end use rs to support staff, should use the glossary to ensure consistency. This implies that the glossary needs to be widely accessible—a good argum ent for W eb-based docum entati on (m ore on that in a mom ent). Tip 54 Use a Project Glossary _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 172 Hunt, Thomas The Pragmatic Programme r 173 It's very hard to succeed on a project where the users and developers refer to the sam e thing by different nam es or, even worse, refer to different things by the sam e name. Get the Wo rd Out In It's All W riting, we discuss publishing of project docum ents to internal W eb sites for easy access by all participants. This m ethod of distribution is particularly us eful for requirem ents docum ents. By presenting requirem ents as a hypertext docum ent, we ca n better address the needs of a diverse audience— we can give each reader what they wa nt. Project sponsors can cruise alon g at a high level of abstraction to ensure th at business objectives are m et. Programm ers can use hyperlinks to \"drill down\" to inc reasing levels of detail (ev en referencing a ppropria te definition s or enginee ring specification s). Web-based distribution also avoids the typical two-inch-thick binder entitled Requirements Analysis that no one ever reads and that becom es outdated the instant ink hits paper. If it's on the Web, the programm ers may even read it. Related sec tions include : • Stone Soup and Boiled Frogs • Good-Enough Software • Circle s and Arrows • It's All W riting • Great Expectations Challeng es • Can you use the software you are writing ? Is it p ossible to have a good feel for requ irements without being able to use the software yourself ? • Pick a non-com puter-related prob lem you currently need to solve. Generate requirements for a noncom puter solution. Exercises 42. Which of the following are probably genuine requ irements? Restate thos e that are no t to m ake them more useful (if possible) . 1. The response tim e must be less than 500 m s. 2. Dialog boxes will hav e a gray backg round. 3. The applic ation will b e organiz ed as a num ber of front-end pr ocesses and a back-end server. 4. If a user en ters non-num eric characters in a num eric field, the system will beep and not accept them . _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 173 Hunt, Thomas The Pragmatic Programme r 174 5. The application code and data m ust fit within 256kB. Solving Impossib le Puzz les Gordius, the King of Phrygia, once tied a knot th at no one could untie. It was said that he who solved the riddle of the Gordian Knot would rule all of Asia. So along comes Alexander the Great, who chops the knot to bits with his sword. Just a little different interpreta tion of the requirements, that's all… and he did en d up ruling most of Asia. Every now and again, yo u will f ind yourself embroiled in the m iddle of a projec t whe n a rea lly tough puzzle com es up: som e piece of engineering that you just can' t get a handle on, or perhaps some bit of code that is turning out to be m uch harder to write than you thought. Maybe it looks impossible. But is it really as hard as it seem s? Consider real-world puzzles—those devious little bits of wood, wrought iron, or plastic that seem to turn up as C hristm as presents or at garage sales. All you have to do is remove the ring, or fit the T- shaped pieces in the box, or whatever. So you pull on the ring, or try to put the T' s in the box, and quickly discover that the obvious solutions just don' t work. The puzzle can' t be so lved that way. But even though it' s obvious, that doesn' t stop people from trying the sam e thing—over and over—thinking there m ust be a way. Of course, there isn' t. The solution lies elsewhere. The secret to solvin g the puzzle is to iden tify the real (not im agined) cons traints, and find a solution therein. Som e constraints are absolute; others are m erely preconceived notions. Absolute con straints must be honored, however distasteful or stupid they m ay appear to be. On the other hand , som e apparent constraints m ay not be real constraints at all. For example, there' s that old bar trick where you ta ke a brand new, unopened cham pagne bottle and bet that you can drink beer out of it. T he trick is to turn the bottle upside down, and pour a sm all quantity of beer in the hollo w in the bottom of the bottle. Many software problem s can be just as sneaky. Degrees of Freedom The popular buzz-phrase \"thinking ou tside the box\" encourages us to recognize constraints that might not be applicable and to ignore them . But this phrase isn' t entirely accurate. If the \"b ox\" is the boundary of c onstraints and conditions, then the tr ick is to find the box, which m ay be c onsiderably larger than you think. The key to solving puzzles is both to recognize the constrain ts placed on y ou and to recognize the degrees of freedom you do have, for in those you' ll find your solution. This is why som e puzzles are so effective; you m ay dism iss pot ential solutions too readily. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 174 For exam ple, can you connect all of the dots in the following puzzle a nd return to th e starting point with just three straight line s—without lifting your pen from the paper or retracing your steps [Hol78 ]? Hunt, Thomas The Pragmatic Programme r 175 You m ust challenge any preconceive d notions and evaluate whether or not they are real, hard-and- fast constraints. It's not whether you think inside the box or outside the box. The problem lies in finding the box— identifying the real constraints. Tip 55 Don' t Think Outside th e Box— Find the Box When faced with an in tractable problem , enum erate all the possible avenues you have before you. Don' t dismiss anything, no m atter how unusable or stupid it sounds. Now go through the list and explain why a certain path cannot be taken. Are you sure? Can you prove it? Consider the Trojan horse—a novel solution to an intractable problem . How do you get troops into a walled city without being disc overed? You can bet that \"thr ough the front door\" was initially dism issed as suicid e. Categorize and prioritize your constraints. W hen woodworkers begin a project , they cut the longest pieces first, then cut the sm aller pieces out of the rem aining wood. In the sam e manner, we want to identif y the most restric tive cons traints first, and fit the r emaining cons traints within them . By the way, a solution to the Four Posts puzzle is shown on page 307. There Must Be an Easier Way! Sometimes you will fin d yourself working on a probl em that seem s much harder than you thought it should be. Maybe it feels like you' re going down th e wrong path—that there m ust be an easier w ay than this! Perhaps you are running late on the sche dule now, or even despair of ever getting the system to work becaus e this part icular problem is \"im possible.\" That' s when you step back a pace and ask yourself these questions: • Is there an easier way ? • Are you trying to solve the right problem , or have you been distracted by a peripheral technicality ? • Why is this thing a problem ? • What is it th at's making it so hard to s olve? • Does it have to be done this way? • Does it have to be done at all? _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 175 Hunt, Thomas The Pragmatic Programme r 176 Many tim es a surprising revelation w ill com e to you as you try to answer one of these questions. Many tim es a reinterpretation of the requirem ents can m ake a whole set of problem s go away—just like the Gordian knot. All you need are the real constraints, the m isleading constraints, and the wisdom to know the difference. Challenges • Take a hard look at whatever difficult problem you are em broiled in today. Can you cut the Gordian kno t? Ask yours elf the key q uestions we outlin ed abo ve, especially \"Does it h ave to be done this way?\" • Were you handed a set of constraints when you si gned on to your current project? Are they all still app licable, and is the in terpretation of them still v alid? Not Until You're Ready He who hesitates is some times saved. James Thurber, The Glass in the F ield Great pe rformers share a trait: they k now when to start and when to wait. The dive r stands on th e high-board, waiting for the perfect m oment to jum p. The conductor stands before the orchestra, arms raised, until sh e sen ses tha t the mom ent is right to start the piece. You are a great perform er. You too need to listen to the voice that whispe rs \"wait.\" If you sit down to start typing and there' s som e nagging doubt in your m ind, heed it. Tip 56 Listen to Nagging Doubts—Start W hen You' re Ready There used to be a style of tennis coaching called \"inner tennis .\" You' d spe nd hours hitting balls over the n et, not particu larly trying f or accu racy, but instead verbalizing just where th e ball h it relative to s ome target ( often a chair). The idea was that the fee dback would train your subconscious and reflexes, so that you im proved w ithout consciously knowing how or why. As a developer, you' ve been doing the sam e kind of thing during your entire career. You' ve been trying things and seeing which worked and whic h didn' t. You' ve been accum ulating experience and wisdom . When you feel a nagging d oubt, or exp erience some relu ctance when faced with a task, heed it. You m ay not be able to put your finge r on exactly what' s wrong, but give it tim e and your doubts will probably crystallize in to som ething more solid, som ething you can address. Software developm ent is still not a science. L et your instincts contribute to your perform ance. Good Judgment or Procrastination? _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 176 Hunt, Thomas The Pragmatic Programme r 177 Everyone fears the blank sheet of paper. Starting a new project (or even a new m odule in an existing project) can be an unnerving expe rience. Many of us would prefer to put off making the initial comm itment of starting. So how can you tell when you' re simply procrastinating, rather than responsib ly waiting for all th e pieces to fall in to place? A technique that has worked for us in these ci rcum stances is to start prototyping. Choose an area that you feel will be d ifficult and b egin producing som e kind of proof of c oncep t. One of two things will typ ically happen. Shortly af ter starting, you m ay feel that you' re wasting your time. This boredom is probably a good indicati on that your initial re luctance was just a desire to put off the comm itment to start. Give up on the prototyp e, and hack into the real developm ent. On the other hand, as the prototype progresses yo u may have one of those m oments of revelation when you suddenly realize that som e basic prem ise was wrong. Not only that, but you' ll see clearly how you can put it right. You' ll feel com fortable abandoning the pr ototype and launching into the project proper. Your instincts were right, a nd you' ve just saved yourself and your team a considerable am ount of wasted effort. When you m ake the decision to pr ototype as a way of investiga ting your unease, be sure to remember why you' re doing it. The last thing you want is to find yourself several weeks into serious developm ent before rem embering that you started out writing a prototype. Somewhat cynically, sta rting work o n a proto type might also be m ore politically acc eptable than simply announcing that \"I don' t feel right about starti ng\" and firing up solitaire. Challeng es • Discuss the fear-of-starting syndrome with your colleagues. Do others experience the sam e thing? Do they heed it? What tricks do they use to overcom e it? Can a group help overcom e an individual' s reluctance, or is that just peer p ressure? The Specification Trap The Landing Pilot is the Non-Hand ling Pilot until the 'decision a ltitude' call, when the Handling Non-Landing Pilot hands the handling to the Non-H andling Landing Pilot, unl ess the latter calls 'go-around,' in which case the Handling Non- Landing Pilot continues handling and the Non- Handling Landing Pilo t continues no n-handling until the next call of 'land' or 'go-aro und' as appropriate. In view of recent con fusions over th ese rules, it was d eemed necessary to restate them clear ly. British Airw ays memorandum, quoted in Pilot Magaz ine, December 1996 Program specification is the proc ess of taking a requirem ent and reducing it down to the point where a pro gramm er's skill can tak e over. It is an act of communication, e xplain ing and clarifyin g the world in such a way as to rem ove m ajor am biguities. As well as talking to the developer who will be perform ing the initial im plementation, the speci ficatio n is a record for future generations o f programm ers who will b e maintainin g and enhan cing the cod e. The specif ication is also an agreem ent with the user—a codification of their need s and an im plicit contract that the final system will be in lin e with tha t requirem ent. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 177 Hunt, Thomas The Pragmatic Programme r 178 Writing a specification is quite a responsibility. The problem is that m any designers find it difficult to stop. T hey feel that unless every little detail is pinned down in excruciating detail they haven' t earned th eir daily do llar. This is a m istake f or seve ral reasons. First, it' s naiv e to assum e that a specif ication will ever captu re every detail and nuance of a system or its requ irement. In restri cted problem dom ains, there are formal methods that can describe a system , but they still require th e designer to explain the m eaning of the notation to the end users— there is still a hum an interpreta tion going on to m ess things up. Even without the problem s inherent in this interp retation, it is very unlikel y that the average user knows going in to a project exactly what they ne ed. They m ay say they have an understanding of the requirem ent, and they m ay sign off on the 200-page docum ent you produce, but you can guarantee that once they see th e running system you' ll be inun dated with change requests. Second, there is a problem with the expressive power of language itse lf. All the diagramming techniques and for mal methods st ill rely on natural language expres sions of the operations to be perform ed.[2] And natural language is really not up to th e job. Look at the wordi ng of any contract: in an attem pt to be precise, lawyers have to bend the language in the m ost unnatural ways. [2] There are some formal techniques that attempt to express operations algebraically, but these techniques are rarely used in practice. They still re quire that the analysts explain the meaning to the end use rs. Here' s a challenge for you. W rite a short descript ion that tells som eone how to tie bow s in their shoelaces. Go on, try it! If you are anything like us, you probably gave up som ewhere around \"now roll your thum b and forefinger so that the free end passes under and insi de the lef t lace….\" It is a phenom enally difficult thing to do. And yet m ost of us can ti e our shoes without conscious thought. Tip 57 Some Things Are Better Done than Described Finally, there is th e straightjack et effect. A desig n that leaves the code r no room for interpr etation robs the p rogramm ing ef fort of any skill and ar t. Some would say this is for the best, but they' re wrong. Often, it is only during coding that certai n options becom e apparent. W hile coding, you may think \"Look at that. Beca use of th e particu lar way I coded th is routine, I could add this addition al functionality with almost no effort\" or \"The specification says to do this, but I cou ld achieve an almost identical result by doing it a differ ent way, and I could do it in half the time.\" Clearly, you shouldn' t just hack in and m ake the changes, but you wouldn't even have spo tted the opportunity if you were constrained by an overly prescriptive design. As a Pragm atic Programm er, you should tend to view requirem ents gathering, design, and implem entation as different facets of the sam e process—the delivery of a qua lity system . Distrust environm ents where requ irements are gathered, sp ecifications are written, and then coding starts, all in isolation. Instead, try to adopt a seam less approach: specification and implem entation are sim ply different aspects of the sam e process—an attem pt to capture and codify a requirem ent. Each should _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 178 Hunt, Thomas The Pragmatic Programme r 179 flow directly into th e next, with no a rtificial boundaries. You' ll find that a healthy developm ent process en courages feed back from implem entation and tes ting into th e specifica tion p rocess. Just to be clear, we are not against generating sp ecifications. Indeed, we recognize that there are times where incred ibly d etailed specifications are dem anded—for contractual reasons, because of the environ ment where you work, or because of the natu re of the product you are developing.[3] Just be aware that you reach a point of diminishing, or even negative, re turns as the specif ications get more and more detailed. Also be careful a bout building specificati ons layered on top of specifications, without any supporting im plementati on or prototyping; it' s all too easy to specify something that can' t be built. [3] Detailed spe cifications a re clearly appropriate for li fe-critical system s. We feel they shoul d also be produced for interfaces and libraries used by others. Whe n your e ntire outp ut is seen as a set of rout ine calls, you'd be tter make sure those calls are well specified. The longer you allow specifications to be security blankets, protecting developers from the scary world of writing code, th e harde r it will be to m ove on to hack ing out code . Don' t fall into this specification spiral: at som e point, you need to st art coding! If you find your team all wrapped up in warm , comfy specifications, break them out. Look at prototyping, or consider a tracer bullet developm ent. Related sections include: • Tracer Bullets Challenges • The shoelace exam ple mentioned in the text is an inte resting illustr ation of the problems of written descriptions. Did you consider describi ng the process using di agram s rather than words? Photographs? Som e formal notation fr om topology? Models w ith wire laces? How would you teach a todd ler? Sometimes a pictu re is worth m ore than any nu mber of wor ds. Som etimes it is worthless. If you find yourself overspecifying, would pictures or special notations help? How detailed do they have to be? When is a draw ing tool better th an a whitebo ard? Circles and Arrows [photographs ] with circles and arrows and a paragr aph on the back of each one explaining what each one was, to be used as evidence against us… Arlo Guthr ie, \"Alic e's Restaurant \" From structured programming, through chief pr ogramm er team s, CASE tools, waterfall developm ent, the spiral model, Jackson, ER diagram s, Booc h clouds, OMT, Objectory, and Coad/Yourdon, to today' s UML, computing has neve r been short of m ethods intended to m ake programm ing m ore like engineering. Each m ethod ga thers its discip les, an d each enjoy s a period of popularity. Then each is replaced by the next. Of all of them , perhaps only the first— structured programm ing— has enjoyed a long life. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 179 Hunt, Thomas The Pragmatic Programme r 180 Yet som e developers, adrift in a sea of sinking projects, keep clin ging to the latest fad just as shipwreck v ictims latch onto passing driftwood. As each new piece floats by they pain fully swim over, hoping it will be better. At the end of the day, though, it doesn' t matter how good the flotsam is, the developers are still aim lessly adrift. Don' t get us wrong. W e like (som e) form al techni ques and m ethods. But we believe that blindly adopting any technique without putting it into the context of your developm ent practices and capabilities is a recipe for disappointm ent. Tip 58 Don' t Be a Slave to Formal Methods Form al methods have som e serious shortcom ings. • Most form al methods capture requirem ents us ing a com bination of diagram s and som e supporting words. These pictures represent the designers' understanding of the requirem ents. However in m any cases these diag rams are m eaningless to the end users, so the designers have to in terpret them . Theref ore, there is no real for mal ch ecking of the requirem ents by the actual user of the system —everything is based on the designers' explanations, just as in old- fashioned written requirem ents. W e see som e benefit in capturing requir ements this way, but we prefer, where possible, to show the user a prototype and let them play with it. • Form al methods seem to encourage specia lization. One group of people works on a data model, another looks at the ar chitecture, while requirem ents ga therers collect use cases (or their equivalent). W e've seen this lead to poor communication and wasted effort. There is also a tende ncy to f all back into the us versus th em mentality of designers against coders. We prefer to understand the whol e of the system we're working on. It m ay not be possible to have an in-depth grasp of every aspect of a system, but you should know how the components interact, where the data lives, and what the requirem ents are. • We like to write adaptable, dynam ic system s, using m etadata to allow us to change the character of applications at ru ntime. Most current form al methods com bine a static object or data m odel with som e kind of event- or activ ity-charting m echanism . We haven' t yet com e across one that allows us to illustrate the ki nd of dynam ism we feel system s should exhibit. In fact, m ost for mal methods will lead you astray , encourag ing you to set up static relationships between objects that really should be kn itted together dynam ically. Do Methods Pay Off? In a 1999 CACM article [ Gla99b ], Robert Glass reviews the res earch into the productivity and quality im provem ents gained using seven different software developm ent technologies (4GLs, structured techniques, C ASE tools, form al methods, clean room m ethodol ogy, process m odels, and object orientation). He reports th at the initial hyp e surrounding all of thes e methods was overblow n. Although there is an indication that som e methods have benef its, th ese benefits start to m anifest them selves only after a significant productivity and quality drop while the technique is adopted and its users train them selves. Never underestim ate the cost of adopting new tools and m ethods. Be prepared to treat the firs t projects us ing these tech niques as a learning exp erience. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 180 Hunt, Thomas The Pragmatic Programme r 181 Should We Use Formal Methods? Absolutely. But always rem ember that form al deve lopm ent m ethods are just one m ore tool in the toolbox. If, after careful analysis, you feel you need to use a formal method, then embrace it—but remember who is in charge. Never becom e a slav e to a m ethodology: circles and arrows m ake poor masters. Pragm atic Prog ramm ers look at m ethodologies critically, then extract the b est from each and m eld them into a set of working practices th at gets b etter each m onth. This is crucial. You should work constan tly to refine and im prove your processes. Never accep t the rigid co nfines of a methodology as the lim its of your world. Don' t give in to the false authority of a m ethod. Pe ople m ay walk into m eetings with an acre of class diagram s and 150 use cases, but all that paper is still ju st their fa llible interpretation o f requirem ents and design. Try not to think a bout how m uch a tool cost when you look at its output. Tip 59 Expensive T oo Do Not Produce Better Designs Form al methods certain ly have th eir place in dev elopm ent. However, if you com e across a project where the philosophy is \"the class diagram is the application, the rest is mechanical coding,\" you know you' re looking at a waterlogged pr oject team and a long paddle hom e. Related sec tions include : • The Requirem ents Pit Challeng es • Use case diagram s are part of the UM L process for gathering requirem ents (see The Requirem ents Pit ). Are they an effective way of comm unicating with your users? If not, why are you using them ? • How can you tell if a form al method is bringi ng your team benefits? What can you m easure? What constitutes an im provem ent? Can you dis tinguish betw een benefits of the tool and increased ex perien ce on the part of team members? • Where is the break-even point for introduc ing new m ethods to your team ? How do you evaluate the trade-off between future benefits a nd current losses of produc tivity as the tool is introdu ced? • Are tools that work for large projects good for sm all ones? How about the other way around? _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 181 Hunt, Thomas The Pragmatic Programme r 182 Chapter 8. Pragmatic Projects As your project gets under way, we need to m ove away from issues of individual philosophy and coding to talk about larger, proj ect-sized issues. We aren' t going to go into specifics of project manage ment, but we will talk about a handful of cr itical areas that c an make or break any project. As soon as you have m ore than one person worki ng on a project, you need to establish som e ground rules and d elegate parts o f the project accord ingly. In Pragmatic Teams, we'll show how to do this while honoring the pragm atic philosophy. The single most im portant factor in making project-level ac tivities work consiste ntly and reliably is to autom ate your procedures. W e'll explain why, and show som e real-life exam ples in Ubiquitous Automation. Earlier, we talked about testing as you code. In Ruthless Te sting, we go to the next step of project- wide testing philosophy and tools— especially if you don' t have a large QA staff at your beck and call. The only thing that developers dislike m ore than testing is docum entation. W hether you have technical writers helping you or are doing it on yo ur own, we' ll show you how to m ake the chore less painful and m ore productive in It's All Wr iting. Success is in the eye of the beholder—the sponsor of the pro ject. The p erception of success is what counts, and in Great Expectations we'll show you som e tricks to delight every project' s sponsor. The last tip in the book is a direct consequence of all the rest. In Pride and Prejudice, we encourage you to sign your work, and to take pride in what you do. Pragmatic Teams At Group L, Stoffel oversees six first-rate programmers, a managerial challenge roughly comparable to herding cats. The Washington Post Magazine, June 9, 1985 So far in this book we' ve looked at pragm atic te chniques that help an individual be a better programm er. Can these m ethods work for team s as well? The answer is a resounding \"yes!\" There are advant ages to being a pragm atic individual, but these advantage s are m ultiplie d manyfold if the individ ual is work ing on a prag matic team . In this section we' ll look briefly at how pragm atic techniques can be applied to team s as a whole. These notes are only a start. Once you' ve got a group of pragm atic developers working in an enabling environm ent, they' ll quickly develop and refine their own team dynam ics that work for them . Let's recast som e of the previous sections in terms of team s. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 182 Hunt, Thomas The Pragmatic Programme r 183 No Broken Window s Quality is a team issue. The m ost diligent dev eloper placed o n a team that just do esn't care will f ind it dif ficult to maintain th e enthus iasm needed to fix niggling problem s. The problem is further exacerb ated if the team actively dis courages th e developer from spending tim e on these fixes. Team s as a whole should not tolerate broken window s—those sm all im perfections that no one fixes. The team must take responsibility for the quality of the product, supporting developers who understand the no broken windows philosophy w e describe in Software Entropy , and encouraging those who haven' t yet discovered it. Some team methodologies have a quality officer —som eone to whom the team delegates the responsib ility for the quality of the d eliverable. Th is is clearly ridiculous : quality can co me only from the individual contributions of all team members. Boiled Frog s Remember the poor frog in the pan of water, back in Stone S oup and Boiled Frogs? It doesn' t notice the gradual change in its environm ent, and ends up cooked. The sam e can happen to individuals who aren' t vigilant. It can be difficult to keep an eye on your overall envi ronm ent in the heat of project developm ent. It's even eas ier for team s as a whole to get boiled. People assum e that some one else is handling an issue, or that the team leader m ust have OK' d a change that your user is requesting. Even the best- intentioned team s can be oblivious to significant ch anges in their projects. Fight this. Make sure everyone ac tively m onitors the environm ent for changes. Maybe appoint a chief water tester. Have this person check constantly for increased scop e, decreased tim e scales, additional features, new environm ents—anything that wasn' t in the original agreem ent. Keep metrics on new requirements (see page 209). The team needn't reject changes out of hand—you simply need to be aware that th ey're happening. Otherwise, it' ll be you in the hot water. Communic ate It's obvious that dev elopers in a team must talk to each other. We gave som e suggestions to facilitate this in Communicate! . However, it' s easy to forget th at the team itself has a presen ce within the organization. Th e team as an entity needs to comm unicate clearly with the rest of the world. To outsiders, the worst project te ams are those that appear sullen and reticent. They hold m eetings with no structure, where no one wants to talk. Th eir docum ents are a m ess: no two look the sam e, and each uses different term inology. Great pro ject team s have a distinct p ersonality. Pe ople look fo rward to m eetings with them , because they know that they' ll see a well-prepared pe rform ance that m akes everyone feel good. The docum entation they prod uce is crisp, accurate, an d consistent. The team speaks with o ne voice.[1] They m ay even have a sense of humor. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 183 Hunt, Thomas The Pragmatic Programme r 184 [1] The team speaks with one voic e-externally. Internally, we stron gly encourage lively, robus t debate. Good de velopers tend to be passionate about t heir work. There is a simple m arketing trick that helps t eams communicate as one: gene rate a brand. W hen you start a project, com e up with a nam e for it, ideally som ething off-the-wall. (In the past, we' ve named projects after things such as kill er parrots that prey on sheep, optical illusions, and m ythical cities.) Spend 30 m inutes com ing up with a zany logo, a nd use it on your m emos and reports. Use your team' s name liberally when talking with people. It sounds silly, but it gives your team an identity to build on, and the world som ething m emorable to associate with your work. Don't Repeat Yourself In The Evils of Duplication , we talked about the difficulties o f elim inating duplicated work between members of a team . This duplication leads to wa sted effort, and can result in a m aintenance nightm are. Clearly good communication can help he re, but som etimes som ething extra is needed. Some team s appoint a m ember as the project li brarian, responsible for coordinating docum entation and code rep ositories. Other team members can u se this person as the first port of call when they' re looking for s omething. A good librarian will also be able to sp ot im pending duplicatio n by reading the m aterial that they' re handling. When the project' s too big for one librarian (or when no one wants to play the role), appoint people as focal points for various functional aspects of th e work. If people want to talk over date handling, they should know to talk with Mary. If there' s a database schem a issue, see Fred. And don' t forget the value of groupware system s and local Usenet news-g roups for communicating and archiving questions and answers. Orthogonality Traditional team organization is based on the old-fashioned waterfall m ethod of softwa re construction. Individuals are assigned roles based on their job func tion. You' ll find business analysts, architects, designers, programme rs, testers, docum enters, and the like.[2] There is an implicit hierarchy here—the clos er to the user you' re allowed, the m ore senior you are. [2] In The Rati onal Unifie d Proc ess: An Introduction, the author identifies 27 separate roles within a project team! [Kru98] Taking things to the extrem e, som e developm ent cult ures dictate strict divi sions of responsibility; coders a ren't allowed to talk to testers , who in tu rn aren' t allow ed to ta lk to the chief architect, and so on. Som e organizations then com pound the problem by ha ving different sub-team s report through separate m anagem ent chains. It is a m istake to think that the activities of a project—analysi s, design, coding, and testing—can happen in isolation. They can' t. These are differe nt views of the sam e problem , and artificially separating them can cause a boatloa d of trouble. Programm ers who ar e two or three levels rem oved from the actual users of their code are unlikely to be aware of the context in which the ir work is used. They will not b e able to m ake inf ormed decisions. Tip 60 _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 184 Hunt, Thomas The Pragmatic Programme r 185 Organize Around Functionali ty, Not Job Functions We favor splitting team s functionall y. Divide your people into sm all team s, each respo nsible for a particular functional aspect of the final system . Let the team s organiz e themselves inte rnally, building on individual strengths as th ey can. Each team has responsibilities to others in the project, as defined by their agreed-upon comm itments. Th e exact set of comm itments changes with each project, as does the allocation of people into team s. Functionality here does not necessarily m ean end-us er use cases. The data base access layer counts, as does the help subsystem . We're looking for c ohesive, largely self-con tained team s of people— exactly the sam e criteria we should be using wh en we m odularize code. There are warning signs that the team organization is wrong—a classic exam ple is having two subteam s wor king on the same program m odule or class. How does this functional style of organization help? Organize our reso urces using the sam e techniques we use to organize code, using techniques such as contracts ( Design by Contract ), decoupling ( Decoupling and the Law of De meter), and orthogonality ( Orthogonality ), and we help isolate the team as a whole from the effects of change. If the user suddenly decides to change database vendors, only the database team should be affected. Should m arketing suddenly decide to use an off-the-shelf tool for the calendar function, the calendar group takes a hit. Properly executed, this kind of group approach can dr amatically reduce the number of interactions between individuals' work, reducing tim e scales, increas ing quality, and cutting down on the num ber of defects. This approach can also lead to a m ore committed set of developers. Each team knows that they alon e are responsible for a particular function, so they feel more ownership of their output. However, this approach works only with responsib le developers and strong project m anagem ent. Creating a p ool of auton omous teams and letting them loose without lead ership is a recipe for disaster. The project needs at least two \"head s\"—one technical, the other adm inistrative. The technical head sets the developm ent philosophy and style, assigns responsibi lities to team s, and arbitrates the inevitable \"discussions\" between peopl e. The technical head also looks constantly at the big p icture, try ing to f ind any unnecessa ry commonality between te ams that could reduce the orthogonality of the overall effort. The adm inistra tive head, or project m anager, schedules the resources that the team s need, m onitors and reports on progress, and helps decide priorities in term s of business needs. The adm inistrative head m ight also act as the te am's ambassador when communicating with the outside world. Team s on larger projects need additional resource s: a librarian who indexes and stores code and docum entation, a tool builder who provides com mon tools and environm ents, operational support, and so on. This type of team organization is similar in sp irit to the o ld chief program mer team concept, f irst docum ented in 1972 [ Bak72 ]. Automation _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 185 Hunt, Thomas The Pragmatic Programme r 186 A great way to ensure both consistency and accuracy is to autom ate everything the team does. Why lay code out m anually when your editor can do it autom atically as you type? Why complete test forms when the overn ight build can r un tests auto matically ? Autom ation is an essential com ponent of every project team—im portant enough for us to dedicate an entire section to it, starting on the following page. To ensure th at things get autom ated, appoint one or m ore team members as tool builders to construct and deploy th e tools tha t autom ate the project drudgery. Have them produc e makefiles, she ll scripts, editor tem plates, utility program s, and the like. Know Whe n to Stop Adding Paint Rem ember that team s are m ade up of individuals . Give each m ember the ability to shine in his o r her own way. Give them just enough structure to support them and to ensure that the project delive rs aga inst its requ irements. Then, like the p ainter in Good-Enough Software , resist the temptation to add m ore paint. Related sec tions include : • Software Entropy • Stone Soup and Boiled Frogs • Good-Enough Software • Communicate! • The Evils of Duplication • Orthogonality • Design by Contract • Decoupling and the Law of De meter • Ubiquitous Autom ation Challeng es • Look around for successful team s outside the ar ea of software development. W hat makes them successful? Do they use any of the processes discussed in this section? • Next tim e you start a project, tr y convincing people to brand it. Give your organization tim e to becom e used to the idea, and then do a qui ck audit to see w hat difference it m ade, both within th e team and externally. • Team Algebra: In school, we are given problem s such as \"If it takes 4 workers 6 hours to dig a ditch, how long would it take 8 workers? \" In real life, however, what factors affect the answer to: \"If it takes 4 programm ers 6 m onths to develop an applica tion, how long would it take 8 programmers?\" In how m any scenarios is the tim e actu ally reduced ? Ubiquitou s Automation Civilization advances by extendi ng the number of important opera tions we can perform without think ing. Alfred North Whitehea d _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 186 Hunt, Thomas The Pragmatic Programme r 187 At the dawn of the age o f autom obiles, the ins tructions for starting a Model-T Ford were m ore than two pages long. W ith m odern cars, you just turn the key—the star ting procedure is autom atic and foolproof. A person following a list of instructions m ight flood the e ngine, but the autom atic starter won' t. Although computing is still an indu stry at the Model-T stage, we can't afford to go through two pages of instructions again and again for som e common operation. W hether it is the build and release procedure, code review pa perwork, or any other recurring ta sk on the project, it has to be autom atic. We m ay have to build the starter and fuel injector fr om scratch, but once it' s done, we can just turn the key from then on. In addition, we want to ensure consistency and repeatability on the pr oject. Manual procedures leave con sistency up to chance; repeatability isn' t guaran teed, especially if aspects of the procedu re are open to interpretation by different people. All on Automatic We were once at a client site where all th e deve lopers were using the sam e IDE. Their system administrator gave each developer a set of instructions on ins talling add -on packages to the IDE. These instructions filled m any pages —pages full of click here, scroll there, drag this, double-click that, and do it again. Not surprisingly, every developer' s machine wa s load ed slightly dif ferently. Subtle differences in the application' s behavior occurred when differe nt developers ran the sam e code. Bugs would appear on one m achine but not on others. Tracking down version differences of any one com pone nt usually revealed a surprise. Tip 61 Don' t Use Manual Procedures People just aren' t as repeatable as computers are. Nor shoul d we expect them to be. A shell script or batch file will execute the sam e instructions, in the sam e order, ti me after tim e. It can be put under source control, so you can exam ine changes to the procedure over tim e as well (\"but it used to work…\"). Another favorite tool of autom ation is cron (or \"at\" on W indows NT). It allows us to schedule unattended tasks to run periodical ly—usually in the m iddle of the night. For exam ple, the following crontab file specifies th at a pro ject's nightly command be run at five m inutes past midnight every day, that the backup be run at 3:15 a.m. on weekdays, and that expense_ reports be run at midnight on the first of the m onth. # MIN HOUR DAY MONTH DAYOFWEEK COMMAND # --------------------------------------------------------------- 5 0 * * * /projects/Manhattan/bin/nightly 15 3 * * 1-5 /usr/local/bin/backup _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 187 Hunt, Thomas The Pragmatic Programme r 188 0 0 1 * * /home/accounting/expense_reports Using cron, we can schedule backups, the nightly build, Web site m aintenance, and anything else that needs to be done—una ttended, autom atically. Compiling t he Project Com piling the project is a chore that should be reliable and repeat-able. We generally com pile projects with m akefiles, even when using an ID E environment. There are several ad vantages in using m akefiles. It is a scripted, autom atic procedure. W e can add in hooks to generate code for us, and run regression tests autom atically. IDEs have their advantages, but with IDEs alone it can be hard to achieve the level of autom ation that we' re looking for. W e want to check out, build, test, and ship with a single command. Generating Code In The Evils of Duplication , we advocated generating code to derive know ledge from common sources. W e can exploit make 's dependency analysis m echanism to m ake this process easy. It' s a pretty sim ple matter to a dd rules to a makefile to generate a file from some other source autom atically. For example, suppose we wanted to ta ke an X ML file, generate a Java file from it, and com pile the resu lt. .SUFFIXES: .Java .class .xml .xml.java: perl convert.pl $< > $@ .Java.class: $(JAVAC) $(JAVAC_FLAGS) $< Type make test.class, and make will au tomatically look f or a file nam ed test.xml, build a .java file by running a Perl script, and then compile that file to produce test.class. We can use the sam e sort of rules to genera te source code, header files, or docum entation autom atically from som e other form as well (see Code Generators ). Regre ssion Tests You can also use the m akefile to run regression test s for you, either for an individual module or for an entire sub system . You can eas ily test th e entir e project with just one command at the top of the source tree, or you can test an individual m odule by using the sam e comm and in a single directory. See Ruthles s Testing , for m ore on regression testing. Recursive make Many projects set up recursive, hi erarchical for project builds and testing. But be aware of some potential problem s. make calcu lates depend encies be tween the va rious targe ts it has to build. But it can analyze on ly the de pende ncies that ex ist with in on e single make invocation. In particu lar, _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 188 Hunt, Thomas The Pragmatic Programme r 189 a recu rsive make has no knowledge of dependencie s that other invocations of make may have. If you are careful and precise, you can ge t the proper results, bu t it's easy to cause extra work u nnecessarily —or m iss a dependency and not reco mpile when it' s needed. In addition, build dependencies m ay not be the sam e as test dependencies, and you may need separate hierarch ies. Build Automation A build is a procedure that takes an empty direct ory (and a known com pilation environm ent) and builds the project from scratch, producing whatev er you hope to produce as a final deliverable—a CD-ROM master im age or a self-e xtracting arch ive, for instance. Typically a project build will encom pass the following steps. Step 1. Check out the source code from the repository. Step 2. Build the project from scratch, typically f rom a top-level m akefile. Each build is m arked with som e form of release or version num ber, or perhaps a date stam p. Step 3. Create a distributable im age. This pro cedure m ay entail fixing file ownership and perm issions, and producing all examples, docum entation, README files, and anything else that will ship w ith the product, in th e exact form at that will be requ ired when y ou ship.[3] Step 4. Run specified tes ts (make test). For m ost projects, this level of build is run au tomatically ev ery nigh t. In this nigh tly build, you will typica lly run more com plete test s than an individual m ight run while building som e specific portion of the project. The im portant poin t is to have th e full build run all available tests. You want to know if a regression test failed because of one of toda y's code changes. By identifying the problem close to the source, you stand a better chance of finding and fixing it. When you don' t run tests regularl y, you m ay discover that the app lication broke due to a code change m ade three m onths ago. Good luck finding that one. Fina l Builds Final builds, which you intend to ship as products, m ay have different requirem ents from the regular nightly build. A final build m ay require that the repository be locked, or tagged with the release number, that optim ization and debug flags be set differently, and so on. W e like to use a separate make target (such as make final ) that sets all of these param eters at once. Remember that if the product is compiled differen tly from earlier versions, then you must test agains t this version all over again. Automatic Administr ivia Wouldn' t it be nice if programm ers could actually devote all of their time to programm ing? Unfortunately, this is ra rely the case. There is e- mail to be answered, pa perwork to b e filled ou t, _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 189 Hunt, Thomas The Pragmatic Programme r 190 docum ents to be posted to the W eb, and so on. You m ay decide to create a shell script to do som e of the dirty work, but you still have to rem ember to run the script when needed. Because m emory is the second th ing you lose as you age,[4] we don' t want to rely on it too heavily. We can run scripts to perform procedur es for us autom atically, based on the content of source code and docum ents. Our goal is to m aintain an au tomatic, unattended, content-driven workflow. [4] Wha t's the first? I forget. Web Si te Ge nerati on Many developm ent team s use an internal W eb site for project comm unication, a nd we think this is a great idea. B ut we don' t want to spend too m uch time maintaining the W eb site, and we don' t want to let it get stale or out of date. Misleading info rmation is worse than no inform ation at all. Docum entation that is extracted from code, re quirem ents analyses, design docum ents, and any drawings, charts, or graphs all need to be pub lished to the W eb on a regular basis. W e like to publish these docum ents autom atically as part of th e nightly build or as a hook into the source code check-in pro cedure. However it is done, W eb content should be gene rated autom atically from inform ation in the repository and published without hum an intervention. This is real ly another application of the DRY princ iple: information e xists in one for m as checked-in code and docum ents. The view from the Web browser is sim ply that—just a view. You shouldn' t have to m aintain that view by hand. Any infor mation generated by the nightly build s hould be accessible on the developm ent W eb site: results of the build itse lf (for ex ample, the build results m ight be presented as a one-page summ ary that includes com piler warnings, errors, and current status), regression tests, performance sta tistics, coding m etrics and any other static analysis, and so on. Appr oval Procedures Some projects have various adm inistrative workflow s that m ust be follow ed. For instance, code or design reviews need to be scheduled and followe d through, approvals m ay need to be granted, and so on. W e can use autom ation—and especially the Web site—to help ease the paperwork burden. Suppose you wanted to autom ate code review sc heduling and approval. You m ight put a special marker in each source co de file: /* Status: needs_review */ A sim ple script could go through all of the source code and look for all files that had a status of needs_review, indicating that they were ready to be reviewed. You c ould then post a list of those files as a W eb page, autom atically send e-m ail to the appropriate people, or even schedule a meeting autom atically using som e calendar software. You can set up a for m on a W eb page for the review ers to register approval or disapproval. After the rev iew, the status can be autom atically changed to reviewed. Whether you have a code walk- _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 190 Hunt, Thomas The Pragmatic Programme r 191 through with all the participan ts is u p to you; yo u can still d o the paperwor k automatically. (In an article in the April 1999 CACM, Ro bert Glass summarizes research that seem s to indicate that, while code inspection is effective, co nducting reviews in m eetings is not [ Gla99a ].) The Cobbler's Childre n The cobbler' s children have no shoes. Often, peopl e who develop software use the poorest tools to do the job. But we have all the raw m aterials we need to craft better tools. W e have cron. We have make, on both W indows and Unix platform s. And we have Perl and other high-level scripting languages for quickly developing custom tools, Web page generato rs, code generators, test harnesses, and so on. Let the com puter do the repetitious, the m undane —it will do a better job of it than we would. W e've got m ore important and more difficult things to do. Related sec tions include : • The Cat Ate My Source Code • The Evils of Duplication • The Power of Plain Text • Shell Gam es • Debugging • Code Generators • Pragm atic Team s • Ruthless Te sting • It's All W riting Challeng es • Look at your habits throughout th e workday. Do you see any repe titive tasks? Do you type the sam e sequence of commands over and over again? Try writing a few shell scripts to autom ate the process. Do you always click on the sam e sequence of icons repeatedly ? Can y ou create a m acro to do all that for you? • How m uch of your project paperwork can be autom ated? Given the high expense of programm ing staff,[5] determ ine how much of the project' s budget is being wasted on administrative procedures. Can you justify the amount of tim e it would take to craft an autom ated solution based on the overa ll cost savings it would achieve? [5] For estimating p urposes, you can figure an indu stry average of about US$100,000 per head—tha t's salary plus be nefits, training, office space an d overhead, and so on. Ruthless Testing Most developers hate testing. They tend to test gently, subconsci ously knowing where the code will break and avoiding the weak spots. Prag matic Programm ers are different. We are driven to find our bugs now, so we don' t have to endure the sham e of others finding our bugs later. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 191 Hunt, Thomas The Pragmatic Programme r 192 Finding bugs is som ewhat like fishin g with a net. W e use fine, sm all nets ( unit tests ) to catch the minnows, and big, coarse nets (int egration tests) to catch the k iller sharks. Som etimes the fish manage to escape, so we patch any holes that we find, in hopes of catching m ore and more slippery defects that are swimm ing about in our project pool. Tip 62 Test Early. Test Often. Test Automatically. We want to start testing as soon as w e have code. Those tiny m innows have a nasty habit of becom ing giant, m an-eating sharks pretty fast, an d catching a shark is quite a bit harder. But we don't want to have to do all that testing by hand. Many team s develop e laborate tes t plans f or their projec ts. So metimes they will even use them . But we've found that team s that use au tomated tests have a m uch better ch ance of success. Tests that run with every b uild are m uch m ore effectiv e than test plans th at sit on a shelf. The earlier a bug is found, the cheaper it is to rem edy. \"Code a little, test a little\" is a popular saying in the Sm alltalk world,[6] and we can adopt that ma ntra as our own by writing test code at the sam e time (or even before) we write the production code. [6] eXtreme P rogramming [URL 4 5] calls thi s concept \"continuous I ntegration, relentless testing.\" In fact, a good project may well have more test code than production code. The tim e it takes to produce this test code is worth the ef fort. It ends up being m uch cheaper in the long run, and you actually stand a chance of producing a pr oduct with close to zero defects. Additionally, knowing that you' ve pa ssed the test gives you a high degr ee of confidence that a piece of code is \"done.\" Tip 63 Coding Ain't Done ' Til All the Tests Run Just becau se you have finished hack ing out a pi ece of code doesn' t mean you can go tell you r boss or your client that it' s done. It's not. First of all, code is never really done. More im portantly, you can't claim that it is us able by anyone un til it pass es all of th e available tes ts. We need to look at three m ain asp ects of project-wide testing: what to test, how to test, and when to test. What to Test There are several m ajor types of softwa re testing that you need to perform: _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 192 Hunt, Thomas The Pragmatic Programme r 193 • Unit tes ting • Integration testing • Validation and verification • Resource exhaustion, errors, and recovery • Perform ance testing • Usability te sting This lis t is b y no m eans com plete, and som e speciali zed projects will requir e various other types of testing as w ell. But it give s us a good starting point. Unit Testing A unit tes t is code that exercises a m odule. We covered this topic by itself in Code That' s Easy to Test. Unit testing is the f oundation of all the other for ms of testing that we' ll discuss in this section. If the parts don' t work by them selves, they proba bly won' t wor k well together. All of the m odules you are usin g must pass their own unit tests b efore you can proceed. Once all of the pertinent modules ha ve passed their individual tests, you're ready for the next stage. You need to test how all the m odules use and interact with each othe r throughout the system . Integration T esting Integra tion testing show s that the m ajor subsystem s that make up the project work and play well with each o ther. W ith good contracts in place and well tested, any inte gration issues can be detected easily. Otherwise, integration becom es a fertile br eeding ground for bugs. In fact, it is often the single largest source of bugs in the system . Integration testing is really ju st an extension of th e unit testing we' ve described—only now you' re testing how entire subsystem s honor their contracts. Validation and Veri fication As soon as you have an executab le user in terface or proto type, you need to answer an all-im portant question: the users told you what they wanted, but is it what they need? Does it m eet the functional requirem ents of the system ? This, too, needs to be tested. A bug-free system that answers the wrong question isn' t very us eful. Be conscious of end-user access patterns and how they differ from developer test data (for an exam ple, see the story about brush strokes on page 92). Resource E xhaus tion, Err ors, and Recovery Now that you have a pretty good id ea that the sy stem will behave correctly under ideal condition s, you need to discover ho w it will b ehave under real-world conditions. In the real world, your program s don' t have lim itless resou rces; th ey run out of things . A few li mits your code m ay encounter include: • Mem ory • Disk space _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 193 Hunt, Thomas The Pragmatic Programme r 194 • CPU bandwidth • Wall-clo ck tim e • Disk bandwidth • Network bandwidth • Color pale tte • Video resolution You m ight actually check for disk sp ace or m emory allocatio n failures, b ut how often do you test for the others? Will your applic ation fit on a 640 × 480 screen with 256 co lors? Will it run on a 1600 × 1280 screen with 24-bit color without look ing lik e a po stage s tamp? Will the b atch job finish before the archive starts ? You can detect env ironmental lim itations, su ch as the video specifications, and adapt as appropriate. Not all failures are recoverable, however. If your code detects that m emory has been exhausted, your options are lim ited: you m ay not have enoug h resources left to do anything except fail. When the system does fail,[7] will it fa il gracefully ? Will it try, as best it c an, to save its state and prevent loss of work? Or will it \"GPF\" or \"co re-dump\" in the user' s face? [7] Our copy editor wanted us to change this sentence to \"If the system does fail….\" We resisted. Perfor mance Testing Perform ance testing, stress testing, or testing under load m ay be an im portant aspect of the project as well. Ask yourself if the software m eets the perform ance requ irements under real-world conditions —with the expected num ber of users, or connections, or transacti ons per second. Is it scalable? For som e applications, you m ay need specia lized testing hard ware or sof tware to sim ulate the lo ad realistically. Usability Testing Usability testing is different from the types of test ing discussed so far. It is perform ed with real users, under real environ mental conditions. Look at usability in term s of hum an factors. We re there any m isunderstandi ngs during requirem ents analysis that need to be addressed? Does the soft ware fit the user like an extension of the hand? (Not only do we want our own tools to fit our hands, but we want the tools we create for users to fit their hands as well.) As with validation and v erification, y ou need to p erform usability tes ting as early as yo u can, while there is s till tim e to m ake corr ections. For larger projects, you m ay want to bring in hum an factors specialists. (If nothing else, it' s fun to play with th e one-way m irrors). Failur e to meet usab ility criter ia is just as big a b ug as dividing by zero. How to Test _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 194 Hunt, Thomas The Pragmatic Programme r 195 We've looked at what to test. Now we' ll turn our atten tion to how to test, including: • Regression testing • Test data • Exercis ing GUI systems • Testing the tests • Testing thoroughly Design/Methodology Testing Can you test the design of the code itself and the m ethodology you used to build the software? After a fashion, yes you can. You do this by analyzing metrics—measurements of various aspects of the code. The simplest metric (and of ten the le ast inte resting) is lines of code —how big is the code itself ? There are a wide variety of other m etrics you can use to exam ine code, including: • McCabe Cyclom atic Complexity Metric (m easures com plexity of decision struc tures) • Inheritance fan-in (num ber of base cl asses) and fan-out (num ber of derived modules using this one as a parent) • Response set (see Decoupling and the Law of De meter) • Class coupling ratios (see [ URL 48 ]) Some metrics are des igned to give you a \"passing grade,\" wh ile others are useful only by comparison. That is, you calcula te these m etrics for every m odule in the system and see how a particular m odule relates to its brethren. Standard stat istical techniques (such as mean and standard deviation) are usually used here. If you find a m odule whose m etrics are m arkedly different from all the rest, you need to ask yourself if that is appropriate. For som e modules, it m ay be okay to \"blow the curve.\" But f or those that don't have a good excuse, it can indicate problem s. Regre ssion Testing A regression test com pares the ou tput of the current test with pr evious (or known) values. W e can ensure that bugs we fixed today didn' t break th ings that wer e working yesterday. This is an important safety net, and it cu ts down on unpleasant surprises. All of the te sts we' ve mentioned so far can be run as regression test s, ensuring that w e haven' t lost any ground as we develop new code. W e can run re gressions to verify perfor mance, contracts, validity, and so on. Test Data Where do we get the data to run all these tests? There are only two kinds of data: real-world data and synthetic data. W e actually need to use both, becau se the different natures of these kinds of data will expos e different bu gs in our sof tware. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 195 Hunt, Thomas The Pragmatic Programme r 196 Real-world data com es from som e actual sou rce. Possibly it has been collected from an existing system , a competitor' s system , or a prototype of some sort. I t repres ents ty pical u ser da ta. The big surprises com e as you discover what typical means. This is m ost lik ely to reveal defects and misunderstandings in requirem ents analysis. Synthetic data is artificially ge nerated, perhaps under ce rtain statistical co nstraints. You m ay need to use synthetic data for any of the following reasons. • You need a lot of data, possibly m ore than a ny real-world sample c ould provide. You might be able to use the real-world da ta as a seed to g enerate a larg er sam ple set, and tweak certain fields that need to be unique. • You need data to stress the boundary conditions. This data m ay be com pletely synthetic: date fields containing February 29, 1999, huge reco rd sizes, or addresses with foreign postal codes. • You need data that exhibits ce rtain s tatistical pro perties. W ant to see what happens if every third tran saction f ails? Rem ember the sort algorithm that slows to a craw l when handed presorted data? You can presen t data in random or sorted order to expose this kind of weakness. Exercising GUI Systems Testing GUI-intensive sy stem s ofte n requires specialized testing tool s. These tools m ay be based on a sim ple event captu re/playback m odel, or they ma y require specially written scripts to drive the GUI. Som e system s combine elements of both. Less sophisticated tools enforce a high degree of coupling between the version of software being tested and the test script itself : if you move a dialog box or make a button sm aller, the test m ay not be able to find it, and m ay fall. Most m odern GUI testing tools use a number of different techniques to get around this problem, and try to adjust to m inor layout differences. However, you can' t autom ate everything. Andy worked on a graphics system that allowed the user to create and display nondeterm inistic visual e ffects which simulated various natural phenom ena. Unfortunately, during testing you couldn' t just gr ab a bitm ap and com pare the output with a previous run , because it was designe d to be different ev ery tim e. For situ ations su ch as this on e, you may have no choice but to rely on m anual in terpretation of test results. One of the m any advantages of writing decoupled code (see Decoupling and the Law of De meter ) is more m odular testing. F or instance, for data proce ssing applications that ha ve a GUI front end, your design should be decoupled enough so that you can test the application logic without having a GUI present. This idea is sim ilar to testing your subcom ponents first. On ce the application logic has been validated, it becom es easier to locate bugs that sh ow up with the user in terface in place (it' s likely that the bugs were created by the user-in terface code). Testing the Tests Because we can' t write p erfect softw are, it follo ws that we can' t write perfect test sof tware either. We need to test th e tests. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 196 Hunt, Thomas The Pragmatic Programme r 197 Think of our set of test suites as an elaborate security system , designed to sound the alarm when a bug shows up. How better to test a security system than to try to break in? After you have written a test to detect a particular bug, cause the bug deliberately and m ake sure the test com plains. This ensures that the te st will catch the bug if it happens for real. Tip 64 Use Saboteurs to Test Your Testing If you are really serious about testing, you might want to appoint a project saboteur. The saboteu r's role is to take a separate copy of the source tree, introduce bugs on purpose, and verify that the tests will ca tch th em. When writin g tests, m ake sure th at alarm s sound when they s hould. Testing Tho roughly Once you are confident that your tests are correct, and are find ing bugs you create, how do you know if you have tested the code base thoroughly enough? The short an swer is \"you don' t,\" and you never will. But there are produ cts on the m arket that can help. These coverage analysis tools watch your code dur ing testing and keep tr ack of which lines of code have been executed and which haven' t. Th ese tools help give you a general feel for how comprehensive your testing is, but do n't expect to see 100% coverage. Even if you do happen to hit every line of code, that 's not the whole picture. W hat is important is the num ber of states that your program m ay have. St ates are not equivalent to lines of code. For instan ce, su ppose you have a function that takes tw o integers, each of which can be a num ber fr om 0 to 999. int test(int a, int b) { return a / (a + b); } In theory, th is three-line f unction has 1,000,000 logical states , 999,999 of which will work correctly and one tha t will not (when a + b equals zero). Sim ply knowing that you executed this line of code doesn' t tell you that—you would need to iden tify all poss ible states of the program . Unfortunately, in gener al this is a really hard problem. Hard as in, \"The sun w ill be a cold hard lum p before you can solve it. \" Tip 65 Test State Coverage, Not Code Coverage _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 197 Hunt, Thomas The Pragmatic Programme r 198 Even with good code coverage, the data you use for testing stil l has a huge im pact, and, m ore importantly, the order in which you traverse code m ay have the largest impact of all. When to Test Many projects tend to leave testing to the last m inute—right w here it will b e cut against the sharp edge of a deadline.[8] We need to start m uch sooner than that . As soon as any production code exists, it need s to b e tested. [8] dead.line \\ded-lîn\\ n (1864) a line drawn within or around a priso n that a prisoner passes at the risk of be ing shot—Webster's Collegiate Dictionary. Most testing should be done autom atically. It' s important to note that by \"autom atically\" we m ean that the te st results are interpr eted a utomatically as well. See Ubiquitous Autom ation, for m ore on this sub ject. We like to test as frequently as we can, and alwa ys before we check code into th e sour ce repository. Some source code control system s, such as Aegis, can do this autom atically. Otherwise, we just type % make test Usually, it isn' t a problem to run regressions on a ll of the ind ividua l unit tests and inte gration tes ts as often as needed. But som e tests m ay not be easily run on a such a frequent basis. Stress tests, for instance, m ay require special setup or equipm ent, and som e hand holding. These tests m ay be run less often— weekly or monthly, perhaps. But it is im portant that they be run on a regular, scheduled basis. If it can't be done autom atically, then m ake sure it appears on the schedule, with all the necessary resources allocated to the task. Tightening the Net Finally, we' d like to reveal the si ngle m ost important concept in te sting. It is an obvious one, and virtually every textbook says to do it this way. But for som e reason, m ost projects still do not. If a bug slips through the net of ex isting tests, you need to add a new test to trap it next tim e. Tip 66 Find Bugs Once Once a human tester finds a bug, it should be the last time a hum an tester finds that bug. The autom ated tests should be m odified to check for that particular bug from then on, every tim e, with no exceptions, no m atter how trivial, and no m atter how m uch the developer com plains and says, \"Oh, that will never happen again.\" _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 198 Hunt, Thomas The Pragmatic Programme r 199 Because it will h appen again. And we just don' t have the tim e to go chas ing after bugs that the autom ated tests could have found for us. W e have to spend our tim e writing new code—and new bugs. Related sec tions include : • The Cat Ate My Source Code • Debugging • Decoupling and the Law of De meter • Refactoring • Code That' s Easy to Test • Ubiquitous Autom ation Challeng es • Can you autom atically test your project? Many team s are forced to answ er \"no.\" W hy? Is it too hard to define the acceptab le results? Won't this m ake it hard to prove to the sponsors that the project is \"done\"? Is it too hard to test the application logic independent of the GUI? What does this say about the GUI? About coupling? It's All Writin g The palest ink is better than the best memory. Chinese Proverb Typically, developers don' t give m uch thought to docum entation. At best it is an unfortunate necessity; at worst it is tr eated as a lo w-priority task in the ho pe that m anagem ent will forget about it at the end of the project. Pragm atic Programm ers em brace docum entation as an integral part of the overall developm ent process. W riting docum entation can be m ade easier by not duplicating effort or wasting tim e, and by keeping docum entation close at hand—i n the code itself, if possible. These aren' t exactly original or novel thought s; the idea of wedding code and docum entation appears in Donald Knuth 's work on literate programming and in Sun' s JavaDoc utility, am ong others. W e want to downplay the dichotom y between code and docum entation, and instead treat them as two views of the sam e model (see It's Just a View ). In fact, we want to go a little further and apply all of our pragm atic principles to docum entation as well as to code. Tip 67 Treat English as Just An other Programming Language _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 199 Hunt, Thomas The Pragmatic Programme r 200 There are basically two kinds of docum entation produced for a project: in ternal and external. Internal docum entation includes source code com ments, design and test docum ents, and so on. External docum entation is anything shipped or pu blished to the outside world, such as user manuals. But rega rdless of the inte nded audience, or the role of the writer (developer or technical writer), all docum entation is a m irror of the code . If there' s a discrep ancy, the code is what matters—for better or worse. Tip 68 Build Docum entation In, Don' t Bolt It On We'll start w ith internal docum entation. Comments in Code Producing form atted docum ents from the comments and declarations in s ource code is fairly straightforward, but first we have to ensure th at we actually have comm ents in the code. Code should have comments, but too m any comment s can be just as bad as too few. In general, comm ents should discuss why som ething is done, its purpo se and its goal. The code already sho ws how it is done, so commenting on this is redundant—and is a violation of the DRY principle. Comm enting source code gives you th e perfect opportunity to docum ent those elusive bits of a project that can' t be docum ented anywhere else: engineering trade-offs, why decisions were m ade, what other alternatives we re discarded, and so on. We like to s ee a simple module-level header comment, comm ents for significant data and type declarations, and a brief per-cla ss and per-m ethod header, describing how the function is used and anything that it does that is not obvious. Variable nam es, of course, should be well chosen and m eaningful. foo, for instanc e, is meaningless, as is doit or manager or stuff. Hungarian notation (where you encode the variable' s type information in the nam e itself) is utterly inappropriate in object-oriented systems. Re member that you (and others after you) will be reading the code m any hundreds of tim es, but only writing it a few tim es. Take the time to spe ll out connectionPool instead of cp. Even worse than m eaningless nam es are misleading nam es. Have you ever had som eone explain inconsis tencies in legacy code such as, \"The routine called getData really writes da ta to disk\" ? The human brain will repeatedly foul this up—it' s called the Stroop Effect [Str35 ]. You ca n try the following experim ent yourself to see the effects of such interf erence. Get som e colored pens, and use them to write down the nam es of colors. Howe ver, never write a color nam e using that color pen. You could write the word \"blue\" in green, th e word \"brown\" in red, and so on. (Alternatively, we have a sample set of colors already drawn on our W eb site at http://www.pragm aticprogramm er.com.) Once you have the color nam es drawn, try to say aloud the color with which each w ord is drawn, as fast as you can. At s ome point y ou'll trip up and start _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 200 Hunt, Thomas The Pragmatic Programme r 201 reading the nam es of the colors, and not the colors them selves. Na mes are deeply m eaningful to your brain, and m isleading nam es add chaos to your code. You can docum ent param eters, but as k yourself if it is rea lly necessary in all cases. T he level of comment suggested by the Java Doc tool seem s appropriate: /** * Find the peak (highest) value within a specified date * range of samples. * * @param aRange Range of dates to search for data. * @param aThreshold Minimum value to consider. * @return the value, or <code>null</code> if no value found greater than or equal to the threshold. */ public Sample findPeak(DateRange aRange, double aThreshold); Here' s a list of things that shoul d not appear in source comm ents. • A list of the functions e xported by code in the file. There are program s that analyze source for you. Us e them , and the list is guaranteed to be up to date. • Revision history. This is what source cod e contro l system s are for (see Source Code Control ). However, it can be useful to include inform ation on the date of last change and th e person who m ade it.[9] [9] This kind of information, a s well as the filename, is prov ided by the RCS $Id$ tag. • A list of o ther files this file uses. This can be determ ined more accurately us ing au tomatic tools. • The name of the file. If it m ust appear in the file, don' t maintain it by hand. RCS and sim ilar system s can keep this inform ation up to date autom atically. If you m ove or renam e the file, you don' t want to have to rem ember to edit the h eader. One of the most im portant pieces of inform ation that should appear in th e source file is the autho r's name—not necessarily who edited the file last, but the own er. Attachin g responsib ility and accountability to source code does wonde rs in keeping people honest (see Pride and Prejudice ). The project m ay also require certai n copyright notices or other legal boilerplate to appear in each source file. Get your editor to in sert these for you autom atically. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 201 Hunt, Thomas The Pragmatic Programme r 202 With m eaningful comments in place, tools such as JavaDoc [ URL 7 ] and DOC++ [ URL 21 ] can extract and f ormat them to autom atically produce API-level docum entation. This is one specific exam ple of a m ore general technique we use— executab le documents. Executable Documents Suppose we have a specification that lists the co lumns in a database table. We 'll then have a separate set of SQL comm ands to create th e actu al table in the da tabase, and probably som e kind of programm ing language record struct ure to hold the contents of a row in the table. The sam e inform ation is repeated three tim es. Change any one of these three sou rces, and the other two are immediately out of date. This is a clear violation of the DRY principle. To correct this problem , we need to choose the au thoritative source of inform ation. This m ay be the specification, it m ay be a database schem a tool, or it m ay be som e third source altogether. Let' s choose the specification docum ent as the source. It' s now our model for this process. We then need to find a way to export the inform ation it contains as different views —a database schem a and a high-level language record, for example.[10] [10] See It's Just a View, for m ore on models and vie ws. If your docum ent is stored as plain text with markup commands (using H TML, LaTeX, or troff, for exam ple), then you can use tools such as Perl to extract the schem a and refor mat it autom atically. If your document is in a w ord processor' s binary fo rmat, then see the box on the following page for some options. Your document is now an integral part of the pr oject developm ent. The only way to change the schem a is to change the docum ent. You are guara nteeing that the specifi cation, schem a, and code all ag ree. Y ou m inimize the am ount of work you have to do for each ch ange, and you can update the views of the change autom atically. What if My Document Isn't Plain Text? Unfortunately, m ore and more project docum ents are now being written using world processors that store the file on disk in so me proprietary form at. W e say \"unfortunately\" because this severely restricts your op tions to p rocess the docu ment automatically. However, you still have a couple of options: • Write macros. Most sophisticated word pr ocessors now have a m acro language. W ith som e effort you can program them to export tagged sections of your docum ents into the alternative form s you ne ed. If programming at this level is too painful, you could always export the appropriat e section into a standard fo rmat plain text file, and then use a tool such as P erl to convert this into the final form s. • Make the document su bordinate. Rather th an have the doc ument as the definitive source , use another _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 202 Hunt, Thomas The Pragmatic Programme r 203 representation. (In the database example, you might want to use the schem a as the authoritative inform ation.) Then write a tool that exports this inform ation into a form that the docum ent can im port. Be car eful, however. You need to ensure that this inf ormation is im ported eve ry tim e the docum ent is printed, rath er than just once when the docum ent is created. We can generate API-level docum entation from source code using tools such as JavaDoc and DOC++ in a sim ilar fashion. The m odel is the source code: one view of the m odel can be com piled; other views are m eant to be printed out or viewed on the W eb. Our goal is always to w ork on the model—whether the m odel is the code itself or som e other docu ment—and have all views updated autom atically (see Ubiqu itous Autom ation, for more on autom atic processes). Suddenly, docum entation isn' t so bad. Technical Writers Up until no w, we 've talked only ab out intern al docum entation—written by the programmers them selves. But what happens when you have professi onal technical writers invo lved in the project? All too often, programm ers just throw material \"ove r the wa ll\" to te chnic al writers and let them fend for them selves to produce user m anuals, prom otional pieces, and so on. This is a m istake. Jus t because prog rammers aren 't writing these docum ents doesn' t mean that we can forsake pragm atic princip les. W e want the write rs to em brace the sam e basic principles th at a Pragm atic Programm er does—especially honoring the DRY principle, orthogonality, the m odel- view concept, and the use of autom ation and scripting. Print It or Weave It One problem inherent with published, paper docum entation is that it can becom e out of date as soon as it's printed. Docum entation of any for m is just a snapshot. So we try to produce all docum entation in a fo rm that can be published online, on the W eb, complete with hyperlinks. It' s easie r to keep this view of the docum entation up to date than to track down every existing paper copy, burn it, and reprint a nd redistribute new copi es. It' s also a better way to address the needs of a wide audience. Rem ember, though, to put a date stam p or version number on each W eb page. This way the reader can get a go od idea of what' s up to date, what' s changed recently, and w hat hasn' t. Many tim es you need to present the sam e docum entation in different for mats: a printed docum ent, Web pages, online help, or perhaps a slide show. The typical solution relies heavily on cut-and- paste, creating a num ber of new independent docum ents from the or igina l. This is a b ad idea: a docum ent's presentation should be independent of its content. If you are us ing a m arkup system , you have the fl exibility to implem ent as m any different outpu t formats as you need. You can choose to have <H1> Chapter Title </H1> _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 203 Hunt, Thomas The Pragmatic Programme r 204 generate a n ew chapter in the repo rt version of the docum ent and title a new slide in the slid e sho w. Technologies such as XSL and CSS[11] can be used to gener ate multiple ou tput f ormats from this one markup. [11] eXtensible Style Langua ge and C ascading Style Sheets, two technologies designed to help separate presentation from content. If you are using a word processor, you' ll probably have sim ilar capabilities. If you remem bered to use styles to identify different document elem ents, then by applying different style sheets you can drastically alter the look of the final output. Most word proc essors now allow you to convert your docum ent to for mats such as HTML for W eb publishing. Markup Languages Finally, for large-scale docum entation projects, we recommend looking at som e of the more modern schem es for m arking up docum entation. Many technical authors now use DocBook to define their docum ents. DocBook is an SGML-based markup standard that carefully identifies ever y component in a docum ent. The document can be passed through a DSSSL processor to render it into any num ber of different form ats. The Linux docum entation project uses DocBook to publish inform ation in RTF, , info, PostScript, and HTML for mats. As long as your original m arkup is rich enough to express all the concepts you need (including hyperlinks), translation to any other pub-lishable for m can be both easy and autom atic. You can produce online help, published m anuals, product highlig hts for the W eb site, and even a tip-a-day calendar, all from the sam e source—which of course is und er source con trol and is bu ilt along with the nigh tly build (s ee Ubiquitous Autom ation). Docum entation and code are different views of the sam e underlying m odel, but the view is all that should be different. Don't let docum entation becom e a second-class citizen, banished from the m ain project workflow. Treat docum entation with th e sam e care you treat code, and the users (and maintainers who f ollow) will sing yo ur praises. Related sec tions include : • The Evils of Duplication • Orthogonality • The Power of Plain Text • Source Code Control • It's Just a View • Programm ing by Coincidence • The Requirem ents Pit • Ubiquitous Autom ation Challeng es • Did you write an explanatory comm ent for th e source code you just wrote? Why not? Pressed f or tim e? Not su re if the cod e will really work—are y ou just tryin g out an ide a as a _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 204 Hunt, Thomas The Pragmatic Programme r 205 prototype? You' ll throw the code aw ay afterwar ds, right? It won' t make it into the project uncommented and experim ental, will it? • Sometimes it is uncom fortable to docum ent the design of source code because the design isn't clear in your m ind; it' s still evolv ing. You don' t feel that you should waste effort describing what som ething does until it actual ly does it. Does this sound like programming by coincid ence (page 17 2)? Great Exp ectations Be astonished, O ye heavens, at this, and be horribly afraid… Jeremiah 2:12 A com pany announces record profits, and its share price drops 20%. The financial new s that night explain s that the com pany failed to m eet anal ysts' expectations. A child opens an expensive Christm as present and bursts into tears—it wasn' t the cheap doll the child was hoping for. A project team works m iracles to implem ent a phenom enally com plex application, only to have it shunned by its users because it doesn' t have a help system . In an abstract sense, an applic ation is successf ul if it corr ectly implem ents its spe cifications. Unfortunately, this pays only abstract bills. In reality, the success of a project is measured by how well it m eets the expectations of its users. A project that falls below their expectations is d eemed a failure, no m atter how good the deliverable is in absolute term s. However, like the parent of the child exp ecting the cheap doll, go too far and you'll be a failure, too. Tip 69 Gently Exceed Your Users' Expectations However, the execution of this tip requires som e work. Communicating Expectations Users initially com e to you with some vision of what they want. It m ay be incom plete, inconsistent, or technically im possible, but it is theirs, and, like the child at Christm as, they have som e emotion invested in it. You cannot just ignore it. As your understanding of their needs develops, you' ll find areas where their expectations cannot be met, or where their expectations are perhaps too conservative. Part of your role is to communicate this. W ork with your users so th at their understanding of what you' ll be delivering is accurate. A nd do this throughout the developm ent process. Ne ver lose sight of th e business problems your applic ation is intend ed to solve. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 205 Hunt, Thomas The Pragmatic Programme r 206 Some consultants call this process \"m anaging exp ectations\"—actively contro lling w hat users should hope to get f rom their system s. We think this is a som ewhat elitist position. Our role is not to control the hopes of our users. Instead, we need to work with them to come to a common understanding of the developm ent process and the fi nal deliverable, along w ith those expectations they have not yet verbalized. If the team is communicating fluen tly with th e outsid e world, th is process is almost automatic; everyo ne should un derstand wh at's expected and how it will be bu ilt. There are som e important techniques that can be used to facilitate th is pro cess. Of these, Tracer Bullets , and Prototypes and Post-it Notes , are the most im portant. Both le t the te am construc t something that the user can see. Both are ideal ways of communicating your understanding of their requirem ents. And both let you and your user s practice com municating with each o ther. The Extra Mile If you work closely with your us ers, sharing their expectations and communicating what you' re doing, then there will be few surprise s when the project gets delivered. This is a BAD THING. Try to surprise your users. Not scare them , mind you, but delight them . Give them that little bit more th an they were expecting. The extra bit of effort it requires to add some user-orien ted featu re to the sys tem will pay for itself time and tim e again in good will. Listen to your users as the proj ect progresses for clues about what features would really delight them . Som e things you can add relatively easily that look good to the average user include: • Balloon or T oolTip help • Keyboard shortcuts • A quick reference guide as a supplem ent to the user' s manual • Coloriza tion • Log file analyzers • Autom ated installation • Tools for checking the integrity of the system • The ability to run m ultiple vers ions o f the system for train ing • A splash screen custom ized for their organization All of these things a re relatively sup erficial, and don' t really overburden the system with feature bloat. However, each tells your users that the developm ent team cared about producin g a great system , one that was intended for real use. Just remember not to break the system adding these new features. Related sec tions include : • Good-Enough Software • Tracer Bullets • Prototypes and Post-it Notes • The Requirem ents Pit Challeng es _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 206 Hunt, Thomas The Pragmatic Programme r 207 • Sometimes the toughest critics of a project ar e the people who worked on it. Have you ever experienced disappointment that your own expectations weren' t met by som ething you produced? How could that be? Maybe ther e's more than logic at work here. • What do your users comm ent on when you deliver so ftware? Is their atte ntion to the various areas of the application proportional to the e ffort you invested in each ? What deligh ts them ? Pride and Prejudice You have delighted us long enough. Jane Austen, Pride and Prejudice Pragm atic Programm ers don' t shirk from responsibil ity. Instead, we rejoice in accepting challenges and in m aking our expertise well known. If we are re sponsible for a design, or a piece of code, we do a job we can be proud of. Tip 70 Sign Your Work Craftsm en of an earlier age were pro ud to sign their work. You should be, too. Project team s are still m ade up of people, howev er, and this rule can cause trouble. On som e projects, the idea of code ownership can cause cooperation problem s. People m ay becom e territorial, or unwilling to work on common f oundation e lements. The pr oject m ay end up like a bunch of insular little fiefdom s. You becom e prejudiced in favor of your code and against your coworkers. That' s not what we want. You shouldn' t jealously defend your code against interlopers; by the sam e token, you should treat other people' s code with re spect. The Golden Rule (\"Do unto others as you would have them do unto you\") and a foundation of m utual respect am ong the de velopers is critical to make this tip work. Anonym ity, especially on large projects, can provide a breeding ground for sloppiness, m istakes, sloth, and bad code. It becom es too easy to see your self as just a cog in the wheel, producing lam e excuses in endless status reports instead of good code. While code must be owned, it doesn' t have to be owned by an individual. In fact, Kent Beck' s successful eXtrem e Programm ing m ethod [ URL 45] recomm ends communal ownership of code (but th is als o requires addition al practices, such as pair p rogramm ing, to guard agains t the dang ers of anonym ity). We want to see pride of ownership. \"I wrote th is, and I stand behind m y work.\" Your signature should com e to be recog nized as an indicato r of quality. People should see your nam e on a piece o f code and expect it to be soli d, well written, tested, and docum ented. A r eally professional job. Written by a real p rofessional. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 207 Hunt, Thomas The Pragmatic Programme r 208 A Pragm atic Programm er. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 208 Hunt, Thomas The Pragmatic Programme r 209 Appendix A. Resources The only reason we were able to cover so m uch ground in this book is that we viewed m any of our subjects from a high altitude. If we' d given them the in-depth coverage they deserved, the book would have been ten times longer. We started the book with the sugge stion that Pragm atic Programm ers should always be learning. In this appendix we' ve listed resources that m ay help you with this process. In the sectio n Professional Societies , we give details of the I EEE and the ACM. W e recomm end that Pragm atic Program mers join one (o r both) of these societies. Then, in Building a Library, we highligh t periodicals, bo oks, and W eb sites tha t we f eel contain high -quality and per tinent inform ation (or that are just plain fun). Throughout the book we referenced m any software resources accessible via the Internet. In the Intern et Res ources section, we list the URLs of these res ources, along w ith a short description of each. However, the nature of the W eb means that many of these links m ay well be stale by the time you read this book. You could try one of the m any search engines for a more up-to-date link, or visit our W eb site at www.pragm aticprogrammer.com and check our links section. Finally, this appendix contai ns the book' s bibliography. Profession al Soc ieties There are tw o world-clas s profession al societie s for program mers: the Association for Com puting Machinery (ACM)[1] and the IEEE Computer Society.[2] We recomm end that all programmers belong to one (or both) of these societies. In addition, de velopers outside the United States m ay want to join their national societies, such as the BCS in the United Kingdom . [1] ACM Member Services, PO Box 11 414, New York, NY 10286, USA. www. acm.org [2] 1730 Massachusetts A venue NW, Washi ngton, DC 20036-1992, USA. www. computer.org Mem bership in a professional society has m any bene fits. The conferences and local m eetings give you great opportunities to m eet peop le with sim ilar interests, and the special interest groups and technical committees give you the o pportunity to participate in set ting standards and guidelines used around the world. You' ll also get a lot out of th eir publications, from high-level discussions of industry practice to low-level com puting theory. Buildin g a Library We're big on reading. A s we noted in Your Knowledge Portfolio , a good programm er is always learning. Keeping current with books and periodicals can help. Here are som e that we like. Periodica ls _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 209 Hunt, Thomas The Pragmatic Programme r 210 If you' re like us, you' ll save old m agazines and p eriodicals u ntil they' re piled h igh en ough to turn the bottom ones to flat sheets of diam ond. This m eans it's worth being f airly selec tive. H ere are a few periodicals we read. • IEEE Com puter. Sent to m embers of the IEEE Co mputer Society, Computer has a practical focus but is not afraid of theory. Som e issues are orient ed around a them e, while others are sim ply collections of interesting articles. This magazine has a good signal-to-noise ratio. • IEEE Soft ware. This is another great bimonthly publication of the IEEE Co mputer Society aim ed at software practitioners. • Communications of the ACM. The basic m agazine received by all m embers of the ACM, CACM has been a standard in the industry for decades, and has probably publishe d more sem inal articles th an any other source. • SIGPLAN. Produced by the ACM Special Intere st Group on Programm ing Languages, SIGPLAN is an optional addition to your ACM membership. It is often used for publishing language specifications, along with articles of interest to everyone who likes looking deeply into programm ing. • Dr. Dobbs Journal. A monthly m agazine, available by subscription and on newsstands, Dr. Dobbs is quirky, but has articles ranging from bit-le vel practice to heavy theory. • The Perl Journal. If you like P erl, you should probably subscribe to The Perl Journal (www.tpj.com ). • Softw are Development Magaz ine. A monthly m agazine focusing on general issues of project managem ent and software developm ent. Weekly Tra de Papers There are several weekly newspapers published f or developers and their m anagers. These papers are largely a collection of company pres s releases, re dressed a s articles. However, the content is s till valuable—it lets you track what is going on, keep abreast of new product announcements, and _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 210 Hunt, Thomas The Pragmatic Programme r 211 follow industry alliances as they are forged and broken. Don' t expect a lot of in-depth technical coverage, though. Books Com puting books can be expensive, but choose carefu lly and they' re a worthwhile investm ent. Here are a handful of the m any we like. Analysis and Design • Object-Oriented Softw are Construction, 2nd Edition. Bertrand Meyer' s epic book on the fundam entals of object-oriented de velopm ent, all in about 1,300 pages [ Mey97b ]. • Design Patterns. A design pattern describes a way to solve a pa rticular class of probl ems at a higher level than a programm ing language idiom . This now-classic book [ GHJV95 ] by the Gang of Four describes 23 basic design patterns, including Proxy, Visitor, and Singleton. • Analysis Patterns. A treasure trove of high-level, ar chitectural patterns ta ken from a wide variety of real-world projects and distilled in book for m. A relativel y quick way to gain the insight of m any years of modeling experience [ Fow96 ]. Teams and Projects • The Mythical Man Mo nth. Fred Brooks' classic on the perils of orga nizing p roject team s, recen tly up dated [ Bro95 ]. • Dynamics o f Softw are Developme nt. A series of short essays on building software in large team s, focusing on the dynam ics between team m embers, and between th e team and the rest of the world [ McC95 ]. • Surviving Object-Oriented Proj ects: A Man ager's Guid e. Alistair Cockburn' s \"reports from the trenches\" illust rate m any of the per ils and pitfalls of managing an OO project— especially your fi rst one. Mr. Cockburn provides tips and techniques to get you through the m ost comm on problem s [Coc97b ]. Specific Environments • Unix. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 211 Hunt, Thomas The Pragmatic Programme r 212 W. Richard Stevens has several excellent books including Advanced Programming in the Unix Enviro nment and the Unix Network Programming books [Ste92 , Ste98 , Ste99 ]. • Window s. Marshall Brain' s Win32 System Services [Bra95 ] is a conc ise ref erence to the low- level APIs. Charles Petzold' s Programming Windows [Pet98 ] is the bible of W indows GUI developm ent. • C++. As soon as you find yourself on a C++ project, run, don' t walk, to the bookstore and get Scott Mey er's Effec tive C++, and possibly More Effec tive C++ [Mey97a , Mey96 ]. For building system s of any appreciable si ze, you need John Lakos' Large-Scale C++ Software Design [Lak96 ]. For advanced techniques, turn to Jim Coplien' s Advanced C++ Programming Styles and Idioms [Cop92 ], In addition, the O' Reilly Nutshell series ( www.ora.com ) gives quick, com prehensive treatm ents of miscellaneous topics and languages such as perl, yacc, sendmail, Windows internals, and regular expressions. The Web Finding good content on the W eb is hard. Here are se veral links that we check at leas t once a week. • Slashdot. Billed as \"News for nerds. Stuff that m atters,\" Slashdot is on e of the net hom es of the Linux community. As well as regular updates on Li nux news, the site offers inform ation on technologies that are cool and i ssues that affect developers. www.slashdot.org • Cetus Links. Thousands of links on object-oriented topics. www.cetus-links.org • WikiWikiWeb. The Portland Pattern Repository and patterns discussion. Not just a great resource, the WikiWikiWeb site is an interesting expe riment in colle ctive editing of ideas. www.c2.co m Internet Resources _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 212 Hunt, Thomas The Pragmatic Programme r 213 The links below are to resources available on the Intern et. They were valid at the tim e of writing, but (the Net being what it is) they m ay well be ou t of date by the tim e you read this. If so, you could try a general search for the filenam es, or com e to the Pragmatic Programmer Web site (www.pragm aticprogrammer.com ) and follow our links. Editors Emacs and vi are not the only cross-platform editors , but th ey are free ly av ailable and widely used. A quick scan through a m agazine such as Dr. Dobbs will turn up severa l commercial a lternatives. Emacs Both Em acs and XEm acs are available on Unix and W indows platform s. [URL l] The Emacs Editor www.gnu.or g The ultim ate in big ed itors, conta ining every f eature tha t any edito r has ev er had, Emacs has a near-v ertical learning cu rve, but repays handsomely once you' ve mastered it. It also m akes a great m all and news reader, address book, calendar and diary, adventure gam e, …. [URL 2] The XEmacs Editor www.xe macs.org Spawned from the original Em acs som e years ago, XEm acs is reputed to have cleaner in ternals and a b etter-lookin g interface. vi There are at leas t 15 different v i clon es available. Of these, vim is probably ported to the m ost platform s, and so would be a good choice of edit or if you find yourself working in m any different environm ents. [URL 3] The Vim Editor ftp://ftp.fu-b erlin.de/m isc/editors /vim From the docum entation: \"There are a lo t of enhancem ents above vi: m ulti level undo, m ulti windows and buffers, syntax highlighting, command line editing, filenam e completion, on-line hel p, visual selection, etc….\" [URL 4] The elvis Editor www. fh-we del.de/elvis An enhanced vi clone w ith support for X. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 213 Hunt, Thomas The Pragmatic Programme r 214 [URL 5] Em acs Viper Mode http://www.cs.sunysb.edu/~kifer/em acs.htm l Viper is a set of m acros that m ake Em acs look like vi. Som e may doubt the wisdom of taking the world' s larg est ed itor an d extending it to em ulate an edito r whose strength is its com pactness. Others clai m it com bines the best of both worlds. Compilers, Languages, and Development Tools [URL 6] The GN U C/C++ Com piler www. fsf.org /software/gcc/gcc.htm l One of the most popular C and C++ com pilers on the planet. It also does Objective- C. (At the tim e of writing, the egcs project, which previously splintered from gcc, is in the p rocess of m erging back into the fold.) [URL 7] The Java Language f rom Sun java.sun.com Hom e of Java, including downloadable S DKs, docum entation, tutorials, news, and more. [URL 8] Perl Language Home Page www.perl.com O'Reilly hos ts this set of Peri- related resourc es. [URL 9] The Pyt hon Language www.python.org The Python object-oriented program ming langua ge is interpreted and interactive, with a slightly quirky syntax and a w ide and loyal following. [URL 10 ] SmallEiffel SmallEif fel.loria.f r The GNU Ei ffel co mpiler runs on any m achine that has an ANSI C co mpiler and a Posix runtim e environm ent. [URL 11 ] ISE Eiffel www.eiffel.com _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 214 Hunt, Thomas The Pragmatic Programme r 215 Interactive S oftware Engineering is the or iginator of Design by Contract, and sells a commercial Eif fel com piler and related tools. [URL 12 ] Sather www.icsi.berkeley.edu/~sather Sather is an experim ental la nguage that grew out of Eiffel . It aim s to support higher- order functions and iteration abstraction as well as Comm on Lis p, CLU, or Schem e, and to be as efficient as C, C++, or Fortran. [URL 13 ] Vis ualWorks www.objectshare.com Hom e of the VisualW orks Sm alltalk environm ent. Noncommercial ve rsions for Windows and Linux are available for free. [URL 14] The Sque ak Language En viron ment squeak.cs.uiuc.edu Squeak is a freely available, portable im plementation of Sm alltalk-80 written in itself; it can produce C code out put for higher perform ance. [URL 15] The TOM Programmi ng L anguage www.gerbil.org/tom A very dynam ic language with roots in Objective-C. [URL 16] The Beow ulf Project www.beowulf.org A project th at builds hig h-perform ance co mputers out of networked clusters of inexpensive Linux boxes. [URL 17] iCont ract—Design by Contract Too l for Java www.reliable-system s.com Design by Contract formalism of prec onditions, postconditions , and invariants, implemented as a preprocessor for Java. H onors inheritance, im plements existential quantifiers, and m ore. [URL 18] Nana—Logging and Asserti ons for C and C+ + www.cs.ntu.edu.au/homepages/pjm /nana-hom e/index.htm l _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 215 Hunt, Thomas The Pragmatic Programme r 216 Improved support for assertion checking and l ogging in C and C++. It also provides some suppor t for Design by Contract. [URL 19 ] DD D–Data Displ ay Debugger www.cs.tu-bs.de/softech/ddd A free graphical front end for Unix debuggers. [URL 20] John Brant's Ref actoring Browser st-www.cs.uiuc.edu/users/brant/Refactory A popular refactoring b rowser for Sm alltalk. [URL 21 ] DO C++ Doc umentation Generator www.zib.de/Visual/softw are/doc++/index.htm l DOC++ is a docum entation system for C/ C++ and Java that generates both and HTML output for sophisticated online browsing of your docum entation directly from the C++ header o r Java class flies. [URL 22] xUnit–Unit Testing Framew ork www. XProg ranming.com A sim ple but powerful concept, the xU nit unit testing fram ework provides a consistent platform for testing softwa re written in a variety of languages. [URL 23] The Tcl La nguage www.scriptics.com Tcl (\"Tool Comm and Language \") is a scripting language designed to be easy to embed into an application. [URL 24] Expect— Automate Inter action with Pro grams expect.nist.gov An extensio n built on T cl [URL 23 ], expect allows you to script interaction with program s. As well as helping you write comm and flies that (f or exam ple) fetch files from remote servers or extend the power of your shell, expect can be useful when perform ing regression testing. A graphical version, expectk, lets you w rap non-GUI applications with a windowing front end. [URL 25 ] T Spaces _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 216 Hunt, Thomas The Pragmatic Programme r 217 www.al maden.ibm .com/cs/TSpaces From their Web page: \"T Spaces is a ne twork comm unication buffer wi th datab ase capabilities. It enab les co mmunicatio n between a pplica tions and devices in a network of heterog eneou s com puters and operatin g system s. T Spaces prov ides group communication services, database servic es, URL-based file transfer services, and event notification services.\" [URL 26] javaC C—Jav a Compiler- Compiler www. metam ata.co m/javacc A parser generator that is tight ly coupled to the Java language. [URL 27] The bison P arser Generator www.gnu.or g/software/bison/bison.htm l bison takes an input grammar specification and generates from it the C source code of a suitable parser. [URL 28] SWIG—Simplified Wra pper and Interface Generator www.s wig.org SWIG is a sof tware dev elopm ent tool tha t conn ects prog rams written in C, C++, and Objective-C with a variety of high-le vel programm ing languages such as Perl, Python, and Tcl/Tk, as w ell as Java, Eiffel, and Guile. [URL 29] The Object Management Gr oup, Inc . www.o mg.org The OMG is the steward of various speci fications for producing distributed object- based system s. Their work include s the Common Object Request Broker Archite cture (CORBA) and the In ternet Inter-ORB Protocol (IIOP). Combined, these specification s make it possible for ob jects to com municate with each o ther, even if they are written in different languages a nd run on different types of com puters. Unix Tools Under DOS [URL 30] The UWI N Developmen t Tools www.gtlinc.com /Products/Uwin/uwin.htm l Global Technologies, Inc., Old Bridge, NJ _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 217 Hunt, Thomas The Pragmatic Programme r 218 The UW IN package provides W indows Dyna mic Link Libraries (DLLs) that em ulate a larg e portion of the Unix C level library interface. Using th is interface, GTL has ported a large num ber of Unix command- line tools to W indows. See also [ URL 31 ]. [URL 31 ] The Cygnus Cygwin Tools sourceware.cygnus.com /cygwin/ Cygnus Solutions, Sunnyvale, CA The Cygnus package also em ulates the the Unix C library interface, and provides a large array of Unix comm and-line to ols under the W indows operating system . [URL 32] Perl Power T ools www.perl.com /pub/language/ppt/ A project to reim plem ent the classic Unix command set in Perl, m aking the commands available on all platform s that suppo rt Perl (and that' s a lot of platform s). Source Code Control Tools [URL 33 ] RC S—Re visio n Control System prep.ai.m it.edu GNU source code control system for Unix and Windows NT. [URL 34] CVS—Conc urre nt Version System www.cvsho me.com Freely available source code control sy stem for Unix and Windows NT. Extends RCS by supporting a client-server mode l and con curren t access to f iles. [URL 35] Aegis Trans action-Ba sed Configurat ion Management http://www.canb.auug.org.au/~m illerp/aegis.htm l A process-oriented revision control tool that im poses project standards (such as verifying th at check ed-in code passes tests). [URL 36 ] Cle arCase www.rational.com Version con trol, worksp ace and build m anagem ent, proces s control. [URL 37] MKS Source Inte grity _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 218 Hunt, Thomas The Pragmatic Programme r 219 www. mks.co m Version control and configuration m anagem ent. Som e version s incorpo rate features allowing remote developers to work on th e sam e files sim ultaneously (m uch like CVS). [URL 38 ] PVCS C onfiguration Management www. merant.com A source code control system , very popular for W indows system s. [URL 39 ] Vis ual Source Safe www. microsoft.com A version co ntrol sy stem that integ rates w ith Microsoft' s visual developm ent tools. [URL 40] Perforce www.perfor ce.com A client-server software conf iguration m anagem ent system. Other Tools [URL 4 1] WinZ ip—Archiv e Utility for Windo ws www. winzip.com Nico Mak C omputing, Inc., Mansfield, CT A W indows -based file archive utility. Supports both zip and tar form ats. [URL 42] The Z Shell sunsite.auc.dk/zsh A shell designed for interactive use, alt hough it is also a pow erful scripting language. Many of the useful features of bash, ksh, a nd tcsh were incorporated into zsh; m any original features were added. [URL 43] A Free SMB Clie nt for Unix Systems samba.anu.edu.au/pub/samba/ Samba lets you share files and other res ources between Unix and W indows system s. Samba inclu des: _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 219 Hunt, Thomas The Pragmatic Programme r 220 • An SMB server, to provide W indows NT and LAN Manager-style file and print s ervices to SMB clients such a s Windows 95, Warp Server, sm bfs, and others. • A Netbios nam eserver, which am ong ot her things gives brow sing support. Samba can be the m aster br owser on your LAN if you wish. • An ftp-like SMB client that allows you to access PC resources (disks and printers) from Unix, Netware, and other operating system s. Papers and Publications [URL 44] The com p.object FAQ www.cyberdyne-object-sys.com /oofaq2 A substantial and well-organized FAQ for the comp.object newsgroup. [URL 45] e Xtreme Progr amming www. XProg ramm ing.co m From the Web site: \"In XP, we use a very lightweight combination of practices to create a team that can rapidly p roduce extr emely reliable, efficient, well-factored software. Many of the XP pract ices were created and tes ted as part of the Chrysler C3 project, which is a v ery succ essful payro ll system implem ented in Sm alltalk.\" [URL 4 6] Alista ir Co ckburn's Home Page members.aol.com /acockburn Look for \"Structuring Use Cases with Goals\" and use case templates. [URL 47] Martin F owler's Home Page ourworld.CompuServe.com /hom epages/m artin_fowler Author of Analysis Patterns and co-author of UML Distilled and Refactoring: Improving the Design of Existing Code. Martin F owler' s home page discusses his books and his work with the UML. [URL 48] Robert C. Martin' s Home Page www.objectm entor.com Good introductory papers on object-orie nted techniques, including dependency analys is and metrics. [URL 49 ] Asp ect-Orien ted Programming www.pare.xerox.com /csl/projects/aop/ _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 220 Hunt, Thomas The Pragmatic Programme r 221 An approach to adding f unctionality to code, both orthogonally and declaratively. [URL 50] JavaSpaces Speci ficati on java.sun.com /products/javaspaces A Linda-like system for Java that supports distributed persiste nce and distributed algorithm s. [URL 51] Netscape Source Code www. mozilla.org The developm ent source of the Netscape browser. [URL 52] The Jargon File www.jargon.org Eric S. Raymond Definitions f or many common (and not so common) com puter industry term s, along with a good dose of folklore. [URL 53] Eric S. Raymond's Papers www.tuxed o.org/~esr Eric's papers on The Cathedral and the Bazaar and Homesteading the N oo-sphere describing the psychosocietal basis for and im plications of the Open Source move ment. [URL 54] The K Desk top Environmen t www.kde.or g From their Web page: \"KDE is a powerful graphical desktop environm ent for Unix workstations. KDE is an Internet proj ect and truly open in every sense.\" [URL 55] The GNU Image Manipulation Program www.gi mp.org Gimp is a freely distribu ted program used for im age creation, com position, and retouching. [URL 56] The Deme ter Pr oject www.ccs.neu.edu/research/dem eter _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 221 Hunt, Thomas The Pragmatic Programme r 222 Research focused on m aking software easier to maintain and evolve using Adaptive Programm ing. Miscellaneo us [URL 57] The GNU Project www.gnu.or g Free Software Foundation, Boston, MA The Free Software Foundation is a tax-exem pt charity that raises funds for the GNU project. The GNU project's goal is to pr oduce a complete, free, Unix-like system . Many of the tools they' ve developed along th e way have becom e industry standards. [URL 58] W eb Ser ver Information www.netcraft.com /survey/servers.htm l Links to the hom e pages of over 50 differe nt web servers. Som e are comm ercial products, w hile others are freely available. Bibliography [Bak72] F. T. Baker. Chief programmer team manage ment of production programm ing. IBM Systems Journal, ll(l):56–73, 1972. [Bbm96] V. Basili, L. Briand, and W . L. Melo. A validation of object-orien ted des ign metrics as quality indicators. IEEE Transactions on Software Engineering, 22(10):751–761, October 1996. [Ber96] Albert J. Bernstein. Dinosaur Brains: Dealing with A ll Those Impossible P eople at Work. Ballantine B ooks, New York, NY, 1996. [Bra95] Marshall Brain. Win32 System Services. Prentice Hall, Englewood Cliffs, NJ, 1995. [Bro95] Fre derick P. Brooks Jr. The Mythical Man Month: E ssays on Software Engineering. Addison-W esley, Reading, MA, anniversary edition, 1995. [CG90 ] N. Carriero and D. Gelenter. How to Write Para llel Programs: A First Course. MIT Press, Cambridge, MA, 1990. [CN91] Bra d J. Cox and Andrex J. Novobilski. Object-Oriented Programming, An Evolutionary Approach. Addison-W esley, Reading, MA, 1991. [Coc97a] Alistair Cockburn. Goals and use cases. Journal of Object Oriented Programming, 9(7):35–40, Septem ber 1997. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 222 Hunt, Thomas The Pragmatic Programme r 223 [Coc97b] Alistair Cockburn. Surviving Object-O riented Pr ojects: A Manager's Guide. Addison Wesley Longm an, Reading, MA, 1997. [Cop92] Jam es O. Copl ien. Advanced C++ Programming Styles and Idioms. Addison-W esley, Reading, MA, 1992. [DL99] Tom De marco and Tim othy Lister. Peopleware: P roductive Projects and Teams. Dorset House, New York, NY, second edition, 1999.. [FBB+99] Martin Fowler, Kent Beck, John Br ant, W illiam Opdyke and Don Roberts. Refactoring: Improving the Design of Existing Code. Addison Wesley Longm an, Reading, MA, 1999. [Fow96] Martin Fowler. Analysis Patterns: Reus able Objec t Models. Addison W esley Longm an, Reading, MA, 1996. [FS97] Martin Fowler and Kendall S cott. UML Distilled: Applying th e Standard Object Modeling Language. Addison W esley Longman, Reading, MA, 1997. [GHJ V95] Erich Gamm a, Richard Helm , Ralph Johnson and John Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, Reading, MA, 1995. [Gla99a] Robert L. Glass. Insp ections—Som e surprising findings. Communications of the ACM, 42(4): 17–19, April 1999. [Gla99b] Robert L. Glass. The reali ties of software technology payoffs. Communications of the ACM, 42(2):74–79, February 1999. [Hol78] Michael Holt. Math Puzzles and Games. Dorset Press, New York, NY, 1978. [Jac94] Ivar Jacobson. Object-Oriented Software Engineerin g: A Use-Case Driven Approach. Addison-W esley, Reading, MA, 1994. [KLM+97] Gregor Kiczales, John L amping, Anurag Mendhekar, Chri s Maeda, Cristina Videira Lopes, Jean-Marc Loingtier and John Irwin. Aspect-oriented programm ing. In European Conference on Object-O riented Programming (ECOOP), volume LNCS 1241. Springer-Verlag, June 1997. [Knu97a] Donald Ervin Knuth. The Art of Computer Programming: Fundamental Algorithms, volum e 1. Addison W esley Longm an, Reading, MA, third edition, 1997. [Knu97b] Donald Ervin Knuth. The Art of Computer Programmi ng: Seminumerical Algorithms, volum e 2. Addison W esley Longm an, Reading, MA, third edition, 1997. [Knu98] Donald Ervin Knuth. The Art of Computer Programming: Sorting and Searching, volum e 3. Addison Wesley Longm an, Reading, MA, second edition, 1998. [KP99] Brian W . Kernighan and Rob Pike. The Practice of Programming. Addison W esley Longm an, Reading, MA, 1999. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 223 Hunt, Thomas The Pragmatic Programme r 224 [Kru98] Phil ippe Kruchten. The Rational Unified Pr ocess: An Introduction. Addison Wesley Longm an, Reading, MA, 1998. [Lak96] John Lakos. Large-Scale C++ Software Design. Addison W esley Longm an, Reading, MA, 1996. [LH89] Karl J. Lieberherr and Ian Holland. Assuring good style for object-oriented program s. IEEE Software , pages 38–48, Septem ber 1989. [Lis88] Bar bara Liskov. Data abstraction and hierarchy. SIGPLAN Notices, 23(5), May 1988. [LMB92] John R. Levine, Tony Mason and Doug Brown. Lex and Yacc. O'Reilly & Associate s, Inc., Sebastopol, CA, second edition, 1992. [McC95] Ji m McCarthy. Dynamics of Software Developmen t. Microsoft Press, Redmond, W A, 1995. [Mey96] Sc ott Meyers. More Effective C++: 35 New Ways to Improve Your Programs and Designs. Addison-W esley, Reading, MA, 1996. [Mey97a] Scott Meyers. Effective C++: 50 Specifi c Ways to Improve Your Programs and Designs. Addison W esley Longman, Read ing, MA, second edition, 1997. [Mey97b] Bertrand Meyer. Object-O riented Software Construction. Prentice Hall, Englewood Cliffs, NJ, s econd edition, 1997. [Pet98] Cha rles Petzold. Programming Windows, The Definitive Guide to the Win32 API. Microsoft Press, Redmond, W A, fifth edition, 1998. [Sch95] Bruce Schneier. Applied Cryptography: Protocols, A lgorithms, and Source Code in C. John Wiley & Sons, New York, NY, second edition, 1995. [Sed83] Robert Sedgewick. Algorithms. Addison-W esley, Reading, MA, 1983. [Sed92] Robert Sedgewick. Algorithms in C++. Addison-W esley, Reading, MA, 1992. [SF96] Robert Sedgewick and Phillipe Flajolet. An Introduction to the Analysis of Algorithms. Addison-W esley, Reading, MA, 1996. [Ste92] W. Richard Stevens. Advanced Programming in the Unix Environment. Addison-W esley, Reading, MA, 1992. [Ste98] W. Richard Stevens. Unix Network Programming, Volume 1: Networking A PIs: Sockets and Xti. Prentice Hall, Englewood Cliffs, NJ, second edition, 1998. [Ste99] W. Richard Stevens. Unix Network Programming, Volume 2: Interprocess Communications. Prentice Hall, Englewood Cliffs, NJ, second edition, 1999. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 224 Hunt, Thomas The Pragmatic Programme r 225 [Str35] Ja mes Ridley Stroop. Studies of in terference in serial verbal reactions. Journal of Experimental Psychology, 18:643–662, 1935. [WK82] Ja mes Q. W ilson and George Kelling. The police and neighborhood safety. The Atlantic Monthly, 249(3):29–38, March 1982. [YC86] Edward Yourdon and Larry L. Constantine. Structured Design: Fundamentals of a Discipline of Computer Program and Systems Design. Prentice Hall, Englewood Cliffs, NJ, second edition, 1986. [You95] Edward Yourdon. Managing proj ects to produce good-enough software. IEEE Software, March 1995. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 225 Hunt, Thomas The Pragmatic Programme r 226 _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 226 Hunt, Thomas The Pragmatic Programme r 227 Appendix B. Answers to Exercises Exercise 1: from Orthogonality You are writing a class called Split, which splits input lines into fields. Which of the following two Java class signature s is the m ore orthogonal design? class Splitl { public Splitl(InputStreamReader rdr) { ... public void readNextLine() throws IOException { ... public int numFields() { ... public String getField( int fieldNo) { ... } class Split2 { public Split2(String line) { ... public int numFields() { ... public String getField( int fieldNo) { ... } Answ er 1: To our way of thinking, class Split2 is m ore orthogonal. It concentrates on its own task, splitting lines, and ignores details su ch as w here the lines are com ing from . Not only does this m ake the code easier to de velop, but it also m akes it m ore flexible. Split2 can split lin es read from a file, genera ted by another r outine, o r passed in via the environm ent . Exercise 2: from Orthogonality Which will lead to a m ore orthogonal design: m odeless o r modal dialog b oxes? Answ er 2: If done correctly, probably m odeless. A system that uses m odeless dialog boxes will be less conc erned with what is going on at any particular m oment in tim e. It will likely have a better interm odule communications in frastructure than a m odal system , which may have built-in assumptions about the stat e of the system—assum ptions that lead to increased coupling and decreased orthogonality . Exercise 3: from Orthogonality How about procedural languages versus obj ect technology? Which results in a m ore orthogonal system ? Answ er 3: This is a little tric ky. Object technology can provide a m ore orthogonal system , but because it h as more features to abu se, it is actually easier to create a nonorthogonal system using objects than it is u sing a pro cedu ral language. F eatures such as m ultiple inheritance, exceptions, operator overloading, and pa rent-m ethod overriding (via subclassing) provide am ple opportunity to increase coupling in nonobvious ways . With object technology and a little extra effort, you can achieve a m uch more orthogonal system . But while you can always wr ite \"spaghetti code\" in a procedural language, object-oriented languages used poorly can add m eatballs to your spaghetti. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 227 Hunt, Thomas The Pragmatic Programme r 228 Exercise 4: from Prototypes and Post-it Notes Marketing would like to sit down and brainstorm a few We b-page designs with you. They are thinking of clickable im age m aps to take you to other pages, and so on. But they can' t decide on a m odel for the im age—m aybe it' s a car, or a phone, or a house. You have a list of target pages and content; they' d like to see a few prototypes. Oh, by the way, you have 15 minutes. W hat tools m ight you use? Answ er 4: Low-tech to the rescue! Draw a few cartoons with m arkers on a whiteboard—a car, a phone, and a house. It do esn't have to be gr eat art; stick -figure outlin es are fine. Put Post-it notes that describe the contents of target pages on the clickable areas. As the meeting progresses, you can refine the dr awings and placem ents of the Post-it notes . Exercise 5: from Dom ain Languages We want to im plement a m ini-language to c ontrol a sim ple drawing package (perhaps a turtle-graphics system ). The language c onsists of single-letter commands. Som e commands are followed by a single num ber. For exam ple, the following input would draw a rectangle. P 2 # select pen 2 D # pen down W 2 # draw west 2cm N 1 # then north 1 E 2 # then east 2 S 1 # then back south U # pen up Implement the code that parses this language. It should be designed so that it is sim ple to add new comm ands. Answ er 5: Because we want to m ake the language extenda ble, we' ll make the parser table d riven. Each entry in the tab le contains the comm and letter, a flag to say whether an argum ent is required, and the nam e of the routine to call to handle th at particular command . typedef struct { char cmd; /* the command letter */ int hasArg; /* does it take an argument */ void (*func)( int, int ); /* routine to call */ } Command; static Command cmds[] = { { 'P', ARG, doSelectPen }, { 'U', NO_ARG, doPenUp }, { 'D', NO_ARG, doPenDown }, { 'N', ARG, doPenDir }, { 'E', ARG, doPenDir }, { 'S', ARG, doPenDir }, { 'W', ARG, doPenDir } }; _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 228 Hunt, Thomas The Pragmatic Programme r 229 The m ain program is pretty sim ple: read a line, look up the command, get the argum ent if required, then call the handler function. while (fgets (buff, sizeof(buff), stdin)) { Command *cmd = findCommand(*buff); if (cmd) { int arg = 0 ; if (cmd->hasArg && !getArg(buff+l, &arg)) { fprintf(stderr, \" '%c' needs an argument\\n \", *buff); continue; } cmd->func(*buff, arg); } } The function that looks up a comm and perform s a linear search of the table, returning either the m atching entry or NULL. Command *findCommand( int cmd) { int i; for (i = 0; i < ARRAY_SIZE(cmds); i++) { if (cmds[i].cmd == cmd) return cmds + i; } fprintf (stderr, \"Unknown command '%c'\\n\", cmd); return 0; } Finally, reading the num eric argum ent is pretty sim ple using scanf. int rg(const char *buff, int *result) { getA return sscanf(buff, \"%d\", result) == 1; } Exercise 6: from Dom ain Languages Design a BNF gra mmar to parse a tim e speci fication. All of the following exam ples should be accepted. 4pm, 7:38pm, 23:42, 3:16, 3:16am Answ er 6: Using BNF, a tim e specification could be <time> ::= <hour> <ampm>| <hour> : <minute> <ompm> | <hour> : <minute> <ampm> ::= am | pm <hour> ::= <digit> | <digit> <digit> <minute> ::= <digit> <digit> _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 229 Hunt, Thomas The Pragmatic Programme r 230 <digit> ::= 0|1|2|3|4|5|6|7|8|9 Exercise 7: from Dom ain Languages Implement a parser for the BNF grammar in Exercise 6 using yacc, bison, or a similar pars er-gen erator. Answ er 7: We coded our exam ple using bison, the GNU version of yacc. For clarity, we' re just showing the body of the parser here. Look at the source on our W eb site for the full implem entation . time: spec EOF { if ($1 >= 24*60) yyerror(\" Time is too large \"); printf( \"%d minutes past midnight\\n\", $1); exit(0); } ; spec: hour ':' minute { $$ = $1 + $3; } | hour ':' minute ampm { if ($1 > 11*60) yyerror(\" Hour out of range \"); $$ = $1 + $3 + $4; } | hour ampm { if ($1 > 11*60) yyerror(\" Hour out of range \"); $$ = $1 + $2; } ; hour: hour_num { if ($1 > 23) yyerror(\" Hour out of range \"); $$ = $1 * 60; }; minute: DIGIT DIGIT { $$ = $1*10 + $2; if ($$ > 59) yyerror( \" minute out of range \"); }; ampm: AM { $$ = AM_MINS; } | PM { $$ = PM_MINS; } ; hour_num: DIGIT { $$ = $1; } | DIGIT DIGIT { $$ = $1*10 + $2; } ; Exercise 8: from Dom ain Languages Implement the tim e parser using Perl. [ Hint: Regular expressions m ake good parsers.] _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 230 Hunt, Thomas The Pragmatic Programme r 231 Answ er 8: $_ = shift; /^(\\d\\d?)(am|pm)$/ && doTime ($1, 0, $2, 12); /^(\\d\\d?):(\\d\\d)(am|pm)$/ && doTime($l, $2, $3, 12); /^(\\d\\d?):(\\d\\d)$/ && doTime($l, $2, 0, 24); die \"Invalid time $_\\n \"; # # doTime(hour, min, ampm, maxHour) # subdoTime($$$$) { my ($hour, $min, $offset, $maxHour) = @_; die \"Invalid hour: $hour \" if ($hour >= $maxHour); $hour += 12 if ($offset eq \"pm\"); print $hour*60 + $min, \" minutes past midnight\\n\"; exit(0); } Exercise 9: from Estim ating You are asked \"W hich has a higher bandw idth: a 1Mbps communications line or a person walking between two com puters with a full 4GB tape in the ir pock et?\" W hat constraints will you put on your ans wer to en sure that the scope of your response is correct? (For exam ple, you m ight say that the tim e taken to access the tape is igno red.) Answ er 9: Our answer must be couched in several assum ptions : • The tape co ntains the in formation we need to be transferred. • We know the speed at which the person walks. • We know the distance between the m achines. • We are not accounting for the tim e it takes to transfer inform ation to and from the tap e. • The overhead of storing data on a tape is roughly equal to the overhead of sending it over a communications line. Exercise 10: from Estim ating So, which has the higher bandwidth? Answ er 10: Subject to th e caveats in Answer 9: A 4GB tape contains 32 × 109 bits, so a 1Mbps line would have to pum p data for about 32,000 seco nds, or roughly 9 hours, to transfer the equivalent amount of inform ation. If the pers on is walking at a constant 3½ m ph, then our two m achines would need to be at l east 31 m iles apart for the communication s line to outperform our courier. Ot herwise, the person wins . Exercise 11: from Text Manipulation Your C program uses an enum erated type to represent one of 100 states. You' d like to bb l i h i( d b)fdb i _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 231 Hunt, Thomas The Pragmatic Programme r 232 purposes. Write a script that reads fr om standard input a file containing name state_a state_b : : Produce the file name.h, which contains extern const char* NAME_names[]; typedef enum { state_a, state_b, : : } NAME; and the f ile name.c, which contains const char* NAME_names[] = { \"state_a\", \"state_b\", : : }; Answ er 11: We i mplemented our answer using P erl. myconsts; @ my $name = <>; die \"Invalid format - missing name\" unless defined ($name); chomp Sname; # Read in the rest of the file while (<>) { chomp; s/^\\s*//; s/\\s*$//; die \"Invalid line: $_\" unless /^(\\w+)$/; push @consts, $_; } # Now generate the file open(HDR, \">$name.h\") or die \"Can't open $name.h: $ !\"; open(SRC, \">$name.c\") or die \"Can't open $name. c: $ ! \"; my $uc_name = uc($name); my $array_name = $uc_name . \"_names\"; print HDR \"/* file generated automatically - do not edit */\\n\"; print HDR \"extern const char *$ {uc_name}_name[];\"; print HDR \"typedef enum {\\n \"; print HDR join \",\\n \", @consts; print HDR \"\\n} $uc_name;\\n\\n\"; _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 232 Hunt, Thomas The Pragmatic Programme r 233 print SRC \"/* File generated automatically - do not edit */\\n\"; print SRC \"const char *$ {uc_name}_name[] = {\\n \\\"\"; print SRC join \"\\\",\\n \\\"\", @consts; print SRC \"\\\"\\n};\\n\" ; close(SRC); close(HDR); Using the DRY principle, we won' t cut and paste th is new file into our code. Instead, we'll #include it—th e flat file is the master sour ce of these constants. This m eans that we'll need a m akefile to r egenera te the header wh en the file changes. The following extract is from the test bed in our s ource tree (available on the Web site). etest.c etest.h: etest.inc enumerated.pl perl enumerated.pl etest.inc Exercise 12: from Text Manipulation Halfway through writin g this book, we realized that we hadn' t put th e use strict directive into m any of our Perl examples. W rite a scri pt that goes through the .pl files in a directory and adds a use strict at the end of the initial comment block to all files that don' t already have one. Rem ember to keep a backup of all files you change. Answ er 12: Here' s our answer, written in Perl . myr = shift or die \"Missing directory\"; $di for my $file ( glob(\"$dir/*.pl \")) { open(IP, \"$file\") or die \"Opening $file: $ ! \"; undef $/; # Turn off input record separator -- my $content = <IP>; # read whole file as one string. close(IP); if tent !~ /^use strictm ($con /) { rename $file, \"$file.bak\" or die \"Renaming $file: $ !\"; open(OP,\">$file\" ) or die \"Creating $file: $ ! \"; # Put 'use strict' on first line that # doesn't start '#' $content =~ s/^(?!#)/\\nuse strict;\\n\\n/m; print OP $content; close(OP); print \"Updated $file\\n\"; } else { print \"$file already strict\\n\"; } } Exercise 13: from Code Generators Write a code generator that takes the input file in Figure 3.4 , and generates output in two languages of your choice. Try to m ake it easy to add new languages. Answ er 13: We use Perl to im plement our solution. It dynam ically loads a m odule to generate the back the loads routine mainThe easysi languages new addingso language requested _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 233 Hunt, Thomas The Pragmatic Programme r 234 end (based on a comm and-line param eter), then reads its input and calls code generation routines based on the content of each line. We're not particularly fussy about error handling—we' ll get to know pretty quickly if things go wrong . my $lang = shift or die \"Missing language\"; $lang .= \"_cg.pm\"; require \"$lang\" or die \"Couldn't load $lang\"; # Read and parse the file my $name; while >) { (< chomp; if (/^\\s*S/) { CG::blankLine(); } elsif (/^\\#(.*)/) { CG:: comment($1); } elsif (/^M\\s*(.+)/) { CG::startMsg($l); $name = $1; } elsif c/^E/) { CG::endMsg($name); } elsif (/^F\\s*(\\w+)$/) { CG::simpleType($l,$2); } elsif (/^F\\s*(\\w+)\\s+(\\w+)\\[(\\d+)\\]$/) { CG::arrayType($l,$2,$3); } else { die \"Invalid line: $_\"; } } Writing a language back end is sim ple: provid e a module that im plements the required six entry points. Here' s the C generator: #!/usr/bin/perl -w package CG; use strict; # Code generator for 'C' (see cg_base.pl) sub blankLine() { print \"\\n\"; } sub comment() { print \"/*$_[0] */\\n\"; } sub startMsg() { print \"typedef struct {\\n\"; } sub endMsg() { print \"} $_[0];\\n\\n\"; } sub arrayType() { my ($name, $type, $size) = @_; print \" $type $name\\ [$size];\\n\"; } sub simpleType() { my ($name, $type) = @_; print \" $type $name;\\n\"; } 1; And here' s the one for Pascal: #!/usr/bin/perl -w package CG; use strict; # Code generator for 'Pascal' (see cg_base.pl) sub blankLine() { print \"\\n\"; } sub comment() { print \"{$_[0] }\\n\"; } sub startMsg() { print \"$_[0] = packed record\\n\"; } sub endMsg() { print \"end;\\n\\n\"; } sub arrayType() { _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 234 Hunt, Thomas The Pragmatic Programme r 235 my ($name, $type, $size) = @_; $size--; print \" $name: array [0..$size] of $type;\\n\"; } subsimpleType() { my ($name, $type) = @_; print \" $name: $type;\\n\"; } 1; Exercise 14: from Design by Contract What m akes a good contract? Anyone can a dd preconditions and postcon ditions, b ut will th ey do you any good? Worse yet, will they actually do more harm than good? For the exam ple below and for those in E xercises 15 and 16, decide whether the specified contract is good, bad, or ugly, and explain why. First, let' s look at an Eiffel exam ple. Here we have a routine for adding a STRING to a doubly link ed, circu lar list (rem ember that precon ditions are labeled with require, and postconditions with ensure). -- Add an item to a doubly linked list, -- and return the newly created NODE. add_item (item : STRING) : NODE is require item /= Void -- '/=' is 'not equal'. find_item(item) = Void -- Must be unique deferred -- Abstract base class. ensure result.next.previous = result -- Cheek the newly result.previous.next = result -- added node's links. find_item(item) = result -- Should find it. end Answ er 14: This Eiffel exam ple is good. We require non-null data to be passed in, and we guarantee that the sem antics of a circul ar, doubly linked list are honored. It also helps to be able to find the strin g we stored. Because th is is a deferred class, the actual clas s that implements it is free to use whatever unde rlying m echanis m it wants to. It m ay choose to use pointers, or an array, or whatever; as long as it honors the contract, we don' t care . Exercise 15: from Design by Contract Next, let' s try an exam ple in Java—som ewha t sim ilar to the exam ple in Exercis e 14. insertNumber inserts an integer into an orde red list. Pre- and postconditions are labeled as in iContract (see [ URL 17 ]). private int data[]; /** _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 235 Hunt, Thomas The Pragmatic Programme r 236 * @post data[index-l] < data[index] && * data[index] == aValue */ public Node insertNumber (final int aValue) { int index = findPlaceToInsert(aValue); ... Answ er 15: This is bad. The m ath in the index clause ( index-1) won' t wor k on boundary conditions such as the f irst entry . The postcondition assumes a particular im plem entation: we want contracts to be m ore abstract than that. Exercise 16: from Design by Contract Here' s a fragm ent from a stack cla ss in Java. Is this a good contract? /** * @pre anItem != null // Require real data * @post pop() == anItem // Verify that it's * // on the stack */ public void push(final String anItem) Answ er 16: It's a good contract, but a bad im plem entation. Here, the infam ous \"Heisenbug\" [URL 52] rears its ugly head. T he program mer probably just m ade a sim ple typo—pop instead of top. While this is a simple and contrived exam ple, side effects in assertions (or in any unexpected place in the code) ca n be very dif ficult to diagnose . Exercise 17: from Design by Contract The classic exam ples of DEC (as in Exerci ses 14–16) show an im plementation of an ADT (Abstract Data Ty pe)—typ ically a stack or queue. But not m any people really write these kinds of low-level classes. So, for this e xercis e, design an inte rface to a kitchen blende r. It will eventu ally be a Web-based, Internet-enabled, CORBA-fled blender, but for now we just need the interface to contro l it. It has ten speed settings (0 means o ff). You can' t operate it em pty, and you can change the speed only one unit at a time (that is, from 0 to 1, and from 1 to 2, not from 0 to 2). Here are the m ethods. Add a ppropriate pre- and postconditions and an invariant. int getSpeed() void setSpeed( int x) boolean isFull() void fill() void empty() _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 236 Hunt, Thomas The Pragmatic Programme r 237 Answ er 17: We'll show the function signatu res in Java, with the pre- and postconditions labeled as in iContr act. First, the inv ariant for the class : /** * @invariant getSpeed() > 0 * implies isFull() // Don't run empty * @invariant getSpeed() >= 0 && * getSpeed() < 10 // Range check */ Next, the pre- and postconditions: /** * @pre Math.abs(getSpeed() - x) <= 1 // Only change by one * @pre x >= 0 && x < 10 // Range check * @post getSpeed() == x // Honor requested speed */ public void setSpeed( final int x) /** * @pre !isFull () // Don't fill it twice * @post isFull () // Ensure it was done */ void fill() /** * @pre isFull () // Don't empty it twice * @post !isFull() // Ensure it was done */ void empty() Exercise 18: from Design by Contract How m any num bers are in the series 0,5,10,15,…, 100? Answ er 18: There are 21 term s in the series. If you said 20, you just experienced a fencepost error . Exercise 19: from Assertive Programm ing A quick reality check. Which of thes e \"im possible\" th ings can happen? 1. A month with fewer than 28 days 2. stat(\".\" ,&sb) == -1 (that is, can' t access the curren t directory) 3. In C++: a=2;b=3; if (a+b!=5) exit(l); 4. A triangle with an interior angle sum ? 180° 5. A minute that doesn' t have 60 seconds 6. In Java: (a + 1) <= a Answer 1Septem ber1752 hadonly 19daysThiswasdone tosynchronize calendars as _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 237 Hunt, Thomas The Pragmatic Programme r 238 19: part of the G regorian Reform ation. 2. The directory could have been rem oved by another process, you m ight not have perm ission to read it, &sb m ight be invalid—you get the picture. 3. We sneakily didn' t specify the types of a and b. Operator overloading m ight have defined +, =, or ! = to have unexpected behavior. Also, a and b may be aliases for th e sam e variable, so th e second assig nment will o verwrite the value stored in the first. 4. In non-Euclidean geom etry, the sum of th e angles of a triang le will not add up to 180°. Think of a triangle m apped on the surface of a sphere. 5. Leap m inutes m ay have 61 or 62 seconds. 6. Overflow may leave the result of a + 1 negative (this can al so happen in C and C++). Exercise 20: from Assertive Programm ing Develop a simple assertion checking class for Java. Answ er 20: We chose to im plement a very sim ple class with a single static m ethod, TEST, that prints a m essage and a s tack trace if the passed condition param eter is false . package com.pragprog.util; import java.lang.System; // for exit() import lang.Thread; // for dumpStack () java. public class Assert { /** Write a message, print a stack trace and exit if * our parameter is false. */ public static void TEST(boolean condition) { if (!condition) { System.out.println(\" ==== Assertion Failed ==== \"); Thread.dumpStack(); System.exit(l); } } // Testbed. If our argument is 'okay', try an assertion that // succeeds, if 'fail' try one that fails public static final void main(String args[]) { if (args[0].compareTo(\" okay\") == 0) { TEST(1 == 1); } else if (args[0].compareTo(\" fail\") == 0) { TEST(1 == 2); } else { throw new RuntimeExceptionC \"Bad argument\" ); } } } _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 238 Hunt, Thomas The Pragmatic Programme r 239 Exercise 21: from When to Use Exceptions While designing a new container class, you identify the following possible error conditions: 1. No m emory available for a new element in the add routine 2. Requested entry not found in the fetch routine 3. null pointer passed to the add routine How should each be han dled? Should an erro r be generated, should an exception be raised, or should the condition be ignored? Answ er 21: Running out of m emory is an exceptional condition, so we feel that case (1) should raise an exception . Failure to find an entry is probably quite a no rmal occurrence. The application that ca lls our collectio n class m ay well write code that ch ecks to see if an entry is p resent b efore adding a potential duplicate. W e feel that case (2) should just return an error. Case (3) is more problem atic—if the value null is significant to th e application, then it may be justifiably added to the container. If, however, it m akes no sense to store null values, an exception should probably be thrown. Exercise 22: from How to Balance Resources Some C and C++ developers m ake a point of setting a pointer to NULL after they deallocate the m emory it refere nces. Why is this a good idea? Answ er 22: In most C a nd C++ im plem entations, there is no way of checking that a pointer actually points to valid m emory. A co mmon m istake is to deallocate a block of m emory and reference th at memory later in the p rogram . By t hen, the m emory pointed to m ay we ll have been reallocated to som e othe r purpose. By setting the pointer to NULL, the programm ers hope to prevent these rogue re ferences—in m ost cases, dereferencing a NULL pointer will generate a runtim e error . Exercise 23: from How to Balance Resources Some Java developers make a point of setting an object variable to NULL after they h ave finished using the object. W hy is this a good idea? Answ er 23: By setting the reference to NULL, you reduce the num ber of po inters to th e referenced object by one. Once this count reaches zero, the object is eligible for garbage collection. Setting the r eferences to NULL can be significant for long- running program s, where the programm ers need to ensure that m emory utilization doesn' t increase over tim e . Exercise 24: from Decoupling and the Law of De meter _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 239 Hunt, Thomas The Pragmatic Programme r 240 We discussed the concept of physical dec oupling in the box . Which of the following C++ header f iles is m ore tightly c oupled to the rest of the system ? person1.h: person2.h: #include \"date.h\" class rsonl { Pe private: Date public: myBirthdate; Person1(Date &birthDate); //... class Date; class Person2 { private: Date *myBirthdate; public: Person2(Date &birthDate); //... Answ er 24: A header file is supposed to define the interface between the correspond ing implementation and the rest of the world. Th e header file itself has no need to know about the internals of the Date class —it merely needs to tell the com piler that the constructor takes a Date as a param eter. So, unles s the head er file uses Dates in inline functions, the second snippet will work fine . What' s wrong with the first snippet? On a small project, nothing, except that you are unnecessarily m aking everything that uses a Personl class also include the header file for Date. Once this kind of usage gets common in a project, you soon find that including one header file ends up including m ost of the rest of the system—a serious drag on compilation tim es. Exercise 25: from Decoupling and the Law of De meter For the example below and for those in Exercises 26 and 27, determ ine if the m ethod calls shown are allowed accord ing to the Law of Dem eter. This first on e is in Java. public void showBalance(BankAccount acct) { Money amt = acct. getBalance() ; printToScreen(amt .printFormat()) ; } Answ er 25: The variab le acct is passed in as a param eter, so the getBalance call is allowed. Calling amt.printFormat(), however, is not. We don' t \"own\" amt and it wasn' t passed to us. W e could elim inate showBalance's coupling to Money with som ething lik e this : void showBalance(BankAccount b) { b.printBalance(); } Exercise 26: from Decoupling and the Law of De meter This exam ple is also in Java. public class Colada { _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 240 Hunt, Thomas The Pragmatic Programme r 241 private Blender myBlender; private tor myStuff; Vec public Colada() { myBlender = new Blender(); myStuff = new Vector() ; } private void doSomething() { myBlender.addlngredients(myStuff.elements()); } } Answ er 26: Since Colada creates and owns both myBlender and myStuff, the ca lls to addIngredients and elements are allowed . Exercise 27: from Decoupling and the Law of De meter This exam ple is in C++. void processTransaction(BankAccount acct, int) { Person *who; Money amt; amt.setValue(123.45); acct.setBalance(amt); who = acct .getOwner() ; markWorkflow(who->name(), SET_BALANCE); } Answ er 27: In this case, processTransaction owns amt—it is created on the stack, acct is passed in, so both setValue and setBalance are a llowed. But processTransaction does not own who, so the ca ll who->name() is in violation. The Law of De meter suggests repla cing th is line with markWorkflow(acct.name(), SET_BALANCE); The code in processTransaction should not have to know which subobject within a BankAccount holds the nam e—this structural knowledge should not show through BankAccount's contract. Instead, we ask the BankAccount for the nam e on the account. It knows where it keeps the nam e (maybe in a Person, in a Business, or in a polym orphic Customer object). Exercise 28: from Metaprogramm ing Which of the following things would be bett er represented as code within a program , and which e xterna lly as metadata? 1. Communication port assignm ents 2. An editor' s support for highlighting the syntax of various languages 3. An editor' s support for different graphic devices 4. A state m achine for a parser o r scann er _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 241 Hunt, Thomas The Pragmatic Programme r 242 5. Sample values and result s for use in unit testing Answ er 28: There ar e no definitive answers here —the ques tions were intended prim arily to give you food for thought. However, this is what we think : 1. Communication port assignments. Clearly, this inform ation should be stored as m etadata. But to what level of detail? Some W indows communications pr ogram s let you select only baud rate and port (say COM1 to COM4 ). But perhaps you need to specify word size, parity, stop bits, and the duplex setting as w ell. Tr y to allow the finest level of detail where practical. 2. An editor's support for highlighting the syntax of various languages. This should be im plemented as m etadata. You wouldn' t want to have to hack code just because the latest versi on of Java introduced a new keyword. 3. An editor's support for di fferent graphic devices. This would probably be difficult to imple ment strictly as m etadata. You would not want to burden your application with multiple device d rivers only to select one at runtim e. You could, however, use metadata to specif y the nam e of the driver and dynam ically load the code . This is another good argum ent for keeping the m etadata in a hum an-readable form at; if you use the program to set up a dysfunctional video driver, you m ay not be able to use the program to set it back. 4. A state machine for a p arser or s canner. This depends on what you are parsing or scanning. If you are parsing som e data that is rigidly defined by a standards body and is unlikely to change without an act of Congress, then hard coding it is fine. But if you are faced with a more volatile situation, it m ay be beneficial to define the state tables externally. 5. Sample values and results for use in unit testing. Most applications define these values in line in the testing harness, but you can get better flexibility by moving the te st data—and the definition of the acceptable results—ou t of the code itself. Exercise 29: from It's Just a View Suppose you have an airline reservation system that includes the c oncept of a flight: _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 242 Hunt, Thomas The Pragmatic Programme r 243 public interface Flight { // .Return false if flight full. public boolean addPassenger(Passenger p); public void addToWaitList(Passenger p); public int getFlightCapacity(); public int getNumPassengers(); } If you add a passenger to the wait list, they' ll be put on the flight autom atically when an opening becom es available. There' s a m assive reporting job that goes through looking for overbooked or full flights to suggest w hen additional flights m ight be scheduled. It works fine, but it takes hours to run. We'd like to have a little mo re flexibility in proc essing wait-list passeng ers, and we' ve got to do som ething about that big report—it takes too long to run. Use the ideas from this section to redesign this interface. Answ er 29: We'll take Flight and add som e addition al methods for m aintain ing two lists of listener s: one for wait- list notif ication, and the other f or full-flight no tification . public interface Passenger { public void waitListAvailable(); } public interface Flight { ... public void addWaitListListener(Passenger p); public void removeWaitListListener(Passenger p); public void addFullListener(FullListener b); public void removeFullListener(FullListener b); ... } public interface BigReport extends FullListener { public void FlightFullAlert(Flight f); } If we try to add a Passenger and fail becaus e the flight is full, we can, o ptionally, pu t the Passenger on the wait list. W hen a spot opens up, waitList-Available will be called. This m ethod can then choose to add the Passenger autom atically, or have a servic e rep resenta tive c all the cu stomer to ask if they are st ill interes ted, or whateve r. We now have the flexibility to perform di fferent behaviors on a per-custom er basis. Next, we want to avoid having the BigReport troll through tons of records looking for full flights. By having BigReport registered as a listener on Flights, each indiv idual Flight can report when it is full—or nearly fu ll, if we want. Now users can get live, up-to-the-m inute reports from BigReport instan tly, without waiting hou rs for it to ru n as it did previously. Exercise 30: from Blackb oards _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 243 Hunt, Thomas The Pragmatic Programme r 244 For each of the following application s, woul d a blackboard sy stem be appropriate or not? Why? 1. Image processing. You' d like to have a number of paralle l processes grab chunks of an im age, process them, and put the com pleted chunk back. 2. Group calendaring. You' ve got people scattered across the globe, in different tim e zones, and speaking different languages, tr ying to schedule a m eeting. 3. Netw ork monitoring to ol. The system gathers perf ormance statis tics and collects trouble reports. You' d like to im plem ent som e agents to use th is inform ation to look for trouble in the system . Answ er 30: 1. Image processing. For sim ple scheduling of a workload am ong the parallel processes, a shared work queue m ay be more than adequa te. You m ight want to consider a blackboard system if there is feedback involved—that is, if the results of one processed chunk affect other chunks, as in m achine vision applications, or complex 3D im age-warp transform s. 2. Group calendaring. This m ight be a good fit. You can post sc heduled m eetings and availability to the blackboard. You have entities func tioning autonom ously, feedback from decisions is im portant, and pa rticipants m ay come and go. You m ight want to cons ider partitio ning this kin d of blackboard system depending on who is searching: junior staff m ay care abou t only the immediate office, hum an resources m ay want only English-speaking offices worldw ide, and the CEO m ay want the whole enchilada . There is also s ome flexibility on data form ats: we are free to ignore form ats or languages we don' t understand. We have to understand different form ats only for those offices that have meetings with each o ther, and we do not n eed to expose all p articipan ts to a full transitive closure of all possible form ats. This reduces coupling to where it is necessary, and does not cons train us artificially. 3. Netw ork monitoring to ol. This is ve ry sim ilar to th e mortgage/l oan application program described. You' ve gottrouble reports sentinbyusers andstatistics reported autom atically all _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 244 Hunt, Thomas The Pragmatic Programme r 245 posting to the blackboard. A hum an or software agent can analyze the blackboard to diagnose network failures: two errors on a line m ight just be cosm ic rays, but 20,000 errors and you' ve got a hardware problem . Just as the detectives s olve the m urder m ystery, you can hav e multiple entities an alyzing and contributing ideas to so lve the network problem s. Exercise 31: from Programming by Coincidence Can you identify som e coincidences in the follow ing C code fragm ent? Assum e that this code is buried deep in a library routine. fprintf (stderr, \"Error, continue?\" ); gets(buf); Answ er 31: There are several potential problem s with this co de. First, it a ssum es a tty environm ent. That m ay be fine if the assum ption is true, but what if this code is called from a GUI environm ent where neith er stderr nor stdin is open ? Second, there is the problem atic gets, which will write as m any chara cters as it receives in to the buf fer passe d in. Malicious users have us ed this f ailing to crea te buffer overrun security holes in m any diffe rent system s. Never use gets(). Third, the code assum es the user understands English. Finally, no one in their right m ind would ever bury user in teraction su ch as this in a library rou tine. Exercise 32: from Programming by Coincidence This piece of C code m ight work som e of the tim e, on som e machines. Then again, it might not. What' s wrong? Truncate string to its last maxlen chars */ /* void string_tail( char *string, int maxlen) { int len = strlen(string); if (len > maxlen) { strcpy(string, string + (len - maxlen)); } } Answ er 32: POSIX strcpy isn't guaranteed to w ork for overlapping strings. It m ight happen to work on som e architectures, but only by coincidence . Exercise 33: from Programming by Coincidence This code com es from a general-purpose Java tracing suite. The func tion writes a string toalogfileItpasses itsunittestbutfails when oneoftheWebdevelopers uses it _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 245 Hunt, Thomas The Pragmatic Programme r 246 What coincidence does it rely on? public static void debug(String s) throws IOException { FileWriter fw = new FileWriter( \"debug.log\", true); fw.write(s); fw.flush() ; fw.close() ; } Answ er 33: It won' t work in an applet context w ith secu rity r estrictions a gainst wr iting to the loca l disk. Again, when you have a c hoice of running in GUI cont exts or not, you m ay want to check dynam ically to see what the current environm ent is like. In this case, you m ay want to put a log file som ewhere other th an the local d isk if it isn' t accessible . Exercise 34: from Algorithm Speed We have coded a set of sim ple sort routin es, which can be downloaded from our W eb site ( http://www.pragm aticprogrammer.com ). Run them on various m achines available to you. Do your figures follow the expected curves? What can you deduce about the relative speeds of your machines? What are the effects of various com piler optim ization settings? Is the radix sort indeed linear? Answ er 34: Clearly, we can' t give any absolute answers to this exercise. However, we can give you a couple of pointers . If you find that your results don' t follow a sm ooth curve, you m ight wa nt to check to see if som e other activity is using som e of your processor' s power. You probably won' t get good figures on a m ultiuser sys tem, and even if you are th e only user yo u may find that background processes periodically take cycles away from your program s. You m ight also want to check m emory: if the ap plica tion s tarts using swap space, pe rform ance will nose dive. It is interesting to experim ent with di fferent compilers and different optim ization settings. W e found som e that p retty s tartling speed-ups were possible by enabling aggressive optim ization. We also found th at on the wider RIS C architectures the manufacturer' s com pilers often outperfor med the more portable GCC. Presum ably, the manufacturer is privy to th e secrets o f efficient co de generatio n on these m achines. Exercise 35: from Algorithm Speed The routin e below prin ts out the con tents of a binary tree. Assum ing the tree is balanced, ro ughly how much stack space will the routine use while printing a tree of 1,000,000 elem ents? (Assum e that subroutin e calls im pose no significant stack overhead.) void printTree( const Node *node) { char buffer[1000]; if (node) { _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 246 Hunt, Thomas The Pragmatic Programme r 247 printTree(node->left); getNodeAsString(node, buffer); puts(buffer); printTree(node->right); } } Answ er 35: The printTree routine uses about 1,000 bytes of stack space for the buffer variable. It calls itself recursively to descend th rough the tree, and each nested call add s another 1,000 bytes to the stack. It also calls itself when it gets to the leaf nodes, but exits immediately when it discovers that the pointer passed in is NULL. If the depth of the tree is D, the m aximum stack requirem ent is therefore roughly 1000 x (D + 1) . A balanced binary tree h olds twice as m any el ements at each level. A tree of depth D holds 1 + 2+4+8 + … + 2D–1), or 2D–1, elem ents. Our m illion -elem ent tree will th erefore need | lg(l,000,001) |, or 20 levels. We'd therefore expect our routin e to use roughly 21,000 bytes of stack. Exercise 36: from Algorithm Speed Can you see any way to reduce the stack requ irements of the routine in E xercise 35 (apart from reducing the size of the buffer)? Answ er 36: A couple of optim izations com e to mind. First, the printTree routin e calls itself on leaf nodes, only to exit becau se there are no child ren. That call in creases the m aximum stack depth by about 1,000 bytes. W e can also elim inate the tail recursion (the second recursive call), although this won' t affect the worst-case stack usage . while (node) { if (node->left) printTree(node->left); getNodeAsString(node, buffer); puts(buffer); node = node->right; } The biggest gain, however, com es from allocating just a single buffer, shared by all invocations of printTre e. Pass this buffer as a param eter to the recu rsive calls, and only 1,000 bytes will be allocated, regard less of the depth of recursion. void printTreePrivate( const Node *node, char *buffer) { if (node) { printTreePrivate(node->left, buffer); getNodeAsString(node, buffer); puts(buffer); printTreePrivate(node->right, buffer); } } void newPrintTree(const Node *node) { char buffer[1000]; printTreePrivate(node, buffer); } _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 247 Hunt, Thomas The Pragmatic Programme r 248 Exercise 37: from Algorithm Speed On page 180, we claim ed that a binary chop is O(lg(n)). Can you prove this? Answ er 37: There are a couple of ways of gettin g there. One is to tu rn the problem on its head. If the array has just one elem ent, we don' t iterate around the loop. Each additional iteration doubles the size of the array we can search. The general form ula for the array size is therefore n = 2m, where m is the number of iterations. If you take logs to the base 2 of each sid e, you get lg (n) = lg(2m), which by the definition of logs becom es lg(n) = m. Exercise 38: from Refactoring The following code has obviously been update d several tim es over the years, but the changes haven' t improve d its structure. Refactor it. if (state == TEXAS) { rate = TX_RATE; amt = base * TX_RATE; calc = 2*basis(amt) + extra(amt)*1.05; } else if ((state == OHIO) || (state == MAINE)) { rate = (state == OHIO) ? OH_RATE : MN_RATE; amt = base * rate; calc = 2*basis(amt) + extra(amt)*1.05; if (state == OHIO) points = 2; } else { rate = 1; amt = base; calc = 2*basis(amt) + extra(amt)*1.05; } Answ er 38: We m ight suggest a fairly m ild restructur ing here: m ake sure that every test is perform ed just once, and m ake all the calculations common. If the expression 2*basis(. . . ) * 1.05 appears in other places in the program , we should probably make it a function. W e haven' t bothered here . We've added a rate_lookup array, initialized so that en tries other than T exas, Ohio, and Maine have a value of 1. This approach makes it easy to add values f or other states in the future. Depending on the expected us age pattern, we might want to m ake the points field an array lookup as well. rate = rate_lookup[state]; amt = base * rate; calc = 2*basis(amt) + extra(amt)*1.05; if (state == OHIO) points = 2; _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 248 Hunt, Thomas The Pragmatic Programme r 249 Exercise 39: from Refactoring The following Java class needs to support a few more shapes. Refactor the class to prepare it fo r the add itions. public class Shape { public static final int SQUARE = 1; public static final int CIRCLE = 2; public static final int RIGHT_TRIANGLE = 3; private int shapeType; private double size; publicShape(int shapeType, double size) { this.shapeType = shapeType; this.size = size; } // ... other methods ... public double area() { switch (shapeType) { case SQUARE: return size*size; case CIRCLE: return Math.PI*size*size/4.0; case RIGHT_TRIANGLE: return size*size/2.0; } return 0; } } Answ er 39: When you see som eone using enum erated t ypes (or their equivalent in Java) to distinguish between variants of a type, you can often im prove the code by subclassing : public class Shape { private double size; publicShape(double size) { this.size = size; } public double getSize() { return size; } } public class Square extends Shape { public Square( double size) { super(size); } public double area() { double size = getSize() ; return size*size; } } public class Circle extends Shape { public Circle( double size) { super(size); } public double area() { _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 249 Hunt, Thomas The Pragmatic Programme r 250 double size = getSize(); return Math.PI*size*size/4.0; } } // etc... Exercise 40: from Refactoring This Java code is part of a fram ework that will be used throughout your project. Refactor it to be m ore general a nd easier to extend in the future. public class Window { public Window( int width, int height) { ... } public void setSize( int width, int height) { ... } public boolean overlaps(Window w) { ... } public int getArea() { . . . } } Answ er 40: This case is interesting. At first sight, it seem s reasonabl e that a window should have a width and a height. However, consider the futu re. Let' s imagine that we w ant to support arbitrarily s haped windows (whi ch will be d ifficult if the Window class k nows all abo ut rectangles and their pro perties) . We'd suggest abstracting the shape of the window out of the Window class itself. public abstract class Shape { // ... public abstract boolean overlaps(Shape s); public abstract int getArea(); } public class Window { private Shape shape; public Window(Shape shape) { this.shape = shape; ... } public void setShape(Shape shape) { this.shape = shape; ... } public boolean overlaps(Window w) { return shape.overlaps(w.shape); } public int getArea() { return shape.getArea(); } } Note that in this approach we' ve use d dele gation rather than subclassing: a window is not a \"kind-of'' shape—a window \"has-a\" shap e. It uses a shape to do its job. You' ll often find delegation useful when refactoring. _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 250 Hunt, Thomas The Pragmatic Programme r 251 We could also have extended this exam ple by introducing a Java interface that specified the m ethods a class m ust support to support th e shape functions. This is a good idea. It means that when you extend the con cept of a shape, the com piler will warn you about classes that you have affected. W e reco mmend using interfaces this way w hen you delegate all the functions of som e other class. Exercise 41: from Code That' s Easy to Test Design a test jig for the blender interface desc ribed in the answer to Exercise 17. W rite a shell script that will perfor m a regression te st for the blender. You need to test basic functionality , error and b oundary con ditions , and any contractual obligatio ns. What restrictions are placed o n changing the speed ? Are they b eing honored ? Answ er 41: First, we' ll add a main to act as a unit test d river. It will accep t a very sm all, sim ple language as an argum ent: \"E\" to em pty the blende r, \"F\" to fill it, di gits 0-9 to set the speed, and so on . public static void main(String args[]) { // Create the blender to test dbc_ex blender = new dbc_ex(); // And test it according to the string on standard input try { int a; char c; while ((a = System.in.read()) != -1) { c = ( char)a; if (Character.isWhitespace(c)) { continue; } if (Character.isDigit(c)) { blender.setSpeed(Character.digit(c, 10)); } else { switch (c) { case 'F': blender.fill(); break; case 'E': blender.empty(); break; case 's': System.out.println( \"SPEED: \" + blender.getSpeed()); break; case 'f': System out.println( \"FULL \" + blender. isFull()); break; default: throw new RuntimeException( \"Unknown Test directive\" ); } } } } catch (java.io.IOException e) { _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 251 Hunt, Thomas The Pragmatic Programme r 252 System.err.println( \"Test jig failed: \" + e.getMessage()); } System.err .println( \"Completed blending \\n\"); System.exit(0); } Next com es the she ll script to dr ive the tes ts. #!/bin/sh CMD=\"java dbc.dbc_ex\" failcount=0 expect_okay() { if echo \"$*\" | $CMD #>/dev/null 2>&1 then : else echo \"FAILED! $*\" failcount='expr $failcount + 1' fi } expect_fail() { if echo \"$*\" | $CMD >/dev/null 2>&1 then echo \"FAILED! (Should have failed): $*\" failcount='expr $failcount + 1' fi } report() { if $failcount -gt 0 ] [ then echo -e \"\\n\\n*** FAILED $failcount TESTS\\n\" exit 1 # In case we are part of something larger else exit 0 # In case we are part of something larger fi } # # Start the tests # expect_okay F123456789876543210E # Should run thru expect_fail F5 # Fails, speed too high expect_fail1 # Fails, empty expect_fail F10E1 # Fails, empty expect_fail F1238 # Fails, skips expect_okay FE # Never turn on expect_fail F1E # Emptying while running expect_okay F10E Should be ok report # Report results The tests check to see if ill egal speed changes are detect ed, if you try to empty the blender while running, and so on. We put this in the m akefile so we can com pile and run the regression test by sim ply typing % make % make test _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 252 Hunt, Thomas The Pragmatic Programme r 253 _________________________________________________________________________________________________________ Hunt, Thomas The Pragmatic Programme r 253 Note that we have the tes t exit with 0 or 1 so we can use this as part of a larger test as well. There was nothing in the requirem ents that s poke of driving this co mponent via a script, or even usin g a language. End users will never see it. But we have a powerful tool that we can use to test our code, quickly and exhaustively. Exercise 42: from The Requirem ents Pit Which of the following are probably genuine re quirements? Restate thos e that are no t to make the m more useful (if possible). 1. The response tim e must be less than 500 m s. 2. Dialog boxes will hav e a gray backg round. 3. The applic ation will b e organiz ed as a num ber of front-end pr ocesses and a back- end server. 4. If a user en ters non-num eric characters in a num eric field, the system will beep and not accept them . 5. The application code and data m ust fit within 256kB. Answ er 42: 1. This statem ent sounds lik e a real requ irement: there m ay be constraints p laced on the application by its environm ent. 2. Even though this m ay be a corporate sta ndard, it isn' t a requirem ent. It would be better stated as \"The dial og background m ust be confi gurable by the end user. As shipped, the color will be gr ay.\" Even better would be the bro ader statem ent \"All visual elem ents of the ap plication (colors, fonts, and languages) m ust be configurable by the end user.\" 3. This statem ent is not a requirem ent, it' s architec ture. W hen faced with something like this, you have to dig deep to find out what the user is thinking. 4. The underly ing requ irement is probably som ething clos er to \"The system will prevent the user from making invalid entr ies in f ields, and will warn the u ser when these entries are m ade.\" 5. This statem ent is probably a hard requirem ent."
}