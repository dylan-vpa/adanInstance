{
  "title": "Design Patterns Elements of Reusable Object Oriented Software Erich Gamma et al.",
  "source": "Libros/Design Patterns Elements of Reusable Object Oriented Software Erich Gamma et al..pdf",
  "content": "ptg ptgC r e a t i o n a l P a t t e r n s A b s t r a c t F a c t o r y ( 8 7) P r o v i d e an interfac e f or c r e a t i n g familie s of r e l a t e d or d e p e n d e n t o b j e c t s withou t s p e c i f y i n g t h e ir c o n c r e t e c l a s s e s . Builde r ( 9 7) S e p a r a t e t he c o n s t r u c t i o n of a c o m p l e x o b j e c t from i ts r e p r e s e n t a t i o n so that t he s a me c o n s t r u c t i o n p r o c e s s c an c r e a t e differen t r e p r e s e n t a t i o n s . F a c t o r y M e t h o d ( 1 0 7) D e f i n e an interfac e f or c r e a t i n g an o b j e c t , b ut l et s u b c l a s s e s d e - c i de w h i c h c l a ss to i n s t a n t i a t e . F a c t o r y M e t h o d l e ts a c l a ss defer instantiatio n to s u b c l a s s e s . P r o t o t y p e ( 1 1 7) S p e c i f y t he k i n ds of o b j e c t s to c r e a te u s i ng a prototypica l i n s t a n c e , a nd c r e a t e n ew o b j e c t s by c o p y i n g t h is p r o t o t y p e . S i n g l e t o n ( 1 2 7) Ensur e a c l a ss o n ly h as o ne i n s t a n c e , a nd p r o v i d e a g l o b a l p o i nt of a c c e s s to it. S t r u c t u r a l P a t t e r n s Adapte r ( 1 3 9) C o n v e r t t he interfac e of a c l a ss i n to anothe r i n t e r f a c e c l i e n t s e x p e c t . Adapte r l e ts c l a s s e s work t o g e t h e r that c o u l d n ' t o t h e r w i s e b e c a u s e of i n c o m p a t - i b le i n t e r f a c e s . B r i d g e ( 1 5 1) D e c o u p l e an a b s t r a c t i o n from i ts implementatio n so that t he t wo c an vary i n d e p e n d e n t l y . C o m p o s i t e ( 1 6 3) C o m p o s e o b j e c t s into t r ee structure s to r e p r e s e n t p a r t - w h o l e hierar- c h i e s . C o m p o s i t e l e ts c l i e n t s treat individua l o b j e c t s a nd c o m p o s i t i o n s of o b j e c t s uniformly. D e c o r a t o r ( 1 7 5) Attac h a d d i t i o n a l r e s p o n s i b i l i t i e s to an o b j e c t d y n a m i c a l l y . D e c o r a t o r s provid e a f l e x i b l e alternativ e to s u b c l a s s i n g for extendin g functionality. F a c a d e ( 1 8 5) P r o v i d e a unifie d interfac e to a s et of interface s in a s u b s y s t e m . F a c a d e define s a h i g h e r - l e v e l interfac e that make s t he s u b s y s t e m e a s i e r to u s e . F l y w e i g h t ( 1 9 5) U se s h a r i n g to s u p p o r t l a r ge number s of f i n e - g r a i n e d o b j e c t s e f f i - c i e n t l y . P r o xy ( 2 0 7) P r o v i d e a s u r r o g a t e or p l a c e h o l d e r f or a n o t h e r o b j e c t to c o n t r o l a c c e s s to i t . ptgB e h a v i o r a l P a t t e r n s Chai n of Responsibilit y ( 2 2 3) Avoi d couplin g the s e n d e r of a reques t to its r e c e i v e r by g i v i n g more than o ne o b j e c t a c h a n c e to handl e t he r e q u e s t . C h a in t he r e c e i v i n g o b j e c t s and p a ss the reques t along the chain until an o b j e c t handle s it. C o m m a n d ( 2 3 3) E n c a p s u l a t e a r e q u e s t as an o b j e c t , t h e r e b y l e t t i n g y ou parameter- ize c l i e n t s with d i f f e r e n t r e q u e s t s , queu e or log r e q u e s t s , and suppor t undoabl e operations. Interprete r ( 2 4 3) Give n a language , defin e a representio n for its gramma r along with an interprete r that u s es the representatio n to interpre t s e n t e n c e s in the language. Iterato r ( 2 5 7) Provid e a way to a c c e s s the element s of an aggregat e o b j e c t sequentiall y withou t e x p o s i n g i ts u n d e r l y i n g r e p r e s e n t a t i o n . Mediato r ( 2 7 3) Defi n e an o b j e c t that encapsulate s h ow a s et of o b j e c t s interact . M e - d i a t o r p r o m o t e s l o o se c o u p l i n g by k e e p i n g o b j e c t s from r e f e r r i n g to e a ch o t h er explicitly , and it l e ts you vary their interactio n independently. Mement o ( 2 8 3) Withou t violatin g encapsulation , captur e and externaliz e an o b j e c t ' s interna l state so that the o b j e c t can be restore d to this state later. Observe r ( 2 9 3) Defin e a one-to-man y dependenc y betwee n o b j e c t s so that when one o b j e c t c h a n g e s state, all its dependent s are notifie d and update d automatically. S t a te ( 3 0 5) Allow an objec t to alter its behavio r when its interna l state c h a n g e s . The o b j e c t w i ll appea r to c h a n g e i ts c l a s s . Strateg y ( 3 1 5) Defin e a f a m i l y of algorithms , encapsulat e e a ch o n e, and make them i n t e r c h a n g e a b l e . S t r a t e g y l e ts t he algorith m vary i n d e p e n d e n t l y from c l i e n t s that use it. Templat e Metho d ( 3 2 5) D e f i n e t he s k e l e t o n of an a l g o r i t h m in an o p e r a t i o n , deferrin g s o me steps to s u b c l a s s e s . Templat e Metho d l e ts s u b c l a s s e s redefin e certai n steps of an algorith m w i t h o u t changin g the algorithm' s structure. Visito r ( 3 3 1) Represen t an operatio n to be performe d on the element s of an objec t structure . V i s i t o r l e ts you defin e a new operatio n withou t c h a n g i n g the c l a s s e s of t h e elements on which it operates. ptg This page intentionally left blank ptgD e s i g n Patterns ptgA d d i s o n - W e s l e y P r o f e s s i o n a l C o m p u t i n g S e r i e s Brian W. Kernighan , C o n s u l t i n g Editor Matthe w H. Austern , Generic Programming and the STL: Using and Extending the C++ Standard Template Library D a v i d R. Butenhof , Programming with POSIX® Threads B r e n t C a l l a g h a n , N FS Illustrated Tom C a r g i l l , C++ Programming Style W i l l i a m R. C h es wick /Steve n M. Bellovin/Avie l D. Rubin , Firewalls and Internet Security, Second Edition: Repelling the Wily Hacker D a v i d A. Curry , UNIX® System Security: A Guide for Users and System Administrators S t e p h e n C. Dewhurst , C++ Gotchas: Avoiding Common Problems in Coding and Design Dan Farmer/Wiets e V e n e m a , Forensic Discovery E r i ch Gamma/Richard Helm/Ralp h Johnson/Joh n V l i s s i d e s , Design Patterns: Elements of Reusable Object- Oriented Software Erich Gamma/Richar d Helm/Ralp h Johnson/Joh n V l i s s i d e s , Design Patterns CD: Elements of Reusable Object- Oriented Software P e t er H a g g a r , Practical Java\"\" Programming Language Guide D a v i d R. H a n s o n , C Interfaces and Implementations: Techniques for Creating Reusable Software Mark Harrison/Michae l M c L e n n a n , Effective Tcl/Tk Programming: Writing Better Programs with Tcl and Tk M i c h i Henning/Stev e V i n o s k i , Advanced CORBA® Programming with C++ B r i an W. Kernighan/Ro b P i k e, The Practice of Programming S. K e s h a v , An Engineering Approach to Computer Networking: ATM Networks, the Internet, and the Telephone Network J o hn L a k o s , Large-Scale C++ Software Design S c o tt M e y e r s , Effective C++ CD: 85 Specific Ways to Improve Your Programs and Designs S c o tt M e y e r s , Effective C++, Third Edition: 55 Specific Ways to Improve Your Programs and Designs S c o tt M e y e r s , More Effective C++ : 35 New Ways to Improve Your Programs and Designs S c o tt M e y e r s , Effective STL: 50 Specific Ways to Improve Your Use of the Standard Template Library Rober t B. Murray , C++ Strategies and Tactics D a v i d R. M u s s e r / G i l l m e r J. D e r g e / A t u l S a i n i , S TL Tutorial a nd Reference Guide, Second Edition: C++ Programming with the Standard Template Library John K. Ousterhout , Tel and the Tk Toolkit C r a ig Partridge , Gigabit Networking R a d i a P e r l m a n , Interconnections, Second Edition: Bridges, Routers, Switches, and Internetworking Protocols S t e p h e n A. R a g o , UNIX® System V Network Programming Eric S. Raymond , The Art of UNIX Programming M a rc J. R o c h k i n d , Advanced UNIX Programming, Second Edition C u rt S c h i m m e l , UNIX® Systems for Modern Architectures: Symmetric Multiprocessing and Caching for Kernel Programmers W. Richar d S t e v e n s , TCP/IP Illustrated, Volume 1: The Protocols W. Richar d S t e v e n s , TCP/IP Illustrated, Volume 3: TCP for Transactions, HTTP, NNTP, and the UNIX® Domain Protocols W. Richar d S t e v e n s / B i l l Fenner/Andre w M. Rudoff , UNIX Network Programming Volume 1, Third Edition: The Sockets Networking API W. Richar d S t e v e n s / S t e p h e n A. Rago , Advanced Programming in the UNIX® Environment, Second Edition W. R i c h a r d S t e v e n s / G a r y R. W r i g h t , TCP/IP Illustrated Volumes 1-3 Boxed Set J o hn Viega/Gar y M c G r a w , Building Secure Software: How to Avoid Security Problems the Right Way Gary R. Wright/W . Richar d S t e v e n s , TCP/IP Illustrated, Volume 2: The Implementation Ruixi Yuan/W. Timothy Strayer, Virtual Private Networks: T e c h n o l o g i e s and S o l u t i o n s V i s i t www.awprofessional.com/series/professionalcomputing for more information about t h e s e titles. ptgD e s i g n Patterns E l e m e n t s of Reusable Object-Oriented Software E r i ch G a m m a R i c h a r d H e l m R a l p h J o h n s o n J o h n V l i s s i d e s B o s t o n • San F r a n c i s c o • New Y o rk • T o r o n t o • M o n t r e a l L o n d o n • Munic h • P a r is • M a d r i d Capetown • S i d n e y • T o k y o • S i n g a p o r e • M e x i c o C i t y ptgM a t e r i a l f r om A Pattern Language: Towns/Buildings/Construction by C h r i s t o p h e r A l e x a n d e r , c o p y r i g h t © 1 9 77 by C h r i s t o p h e r A l e x a n d e r is r e p r i n t e d by p e r m i s s i o n of O x f o r d U n i v e r s i t y P r e s s , I n c . Many of t he d e s i g n a t i o n s used by manufacturer s a nd s e l l e r s to d i s t i n g u i s h t h e ir product s a re c l a i m e d as trademarks . W h e r e t h o se d e s i g n a t i o n s a p p e a r in t h is b o o k , a nd we were awar e of a trademar k claim , t he d e s i g n a t i o n s have b e en p r i n t e d in i n i t i a l c a p i t a l l e t t e r s or in a ll capitals. T he a u t h o r a nd p u b l i s h e r h a ve t a k en c a re in t he p r e p a r a t i o n of t h is b o o k , b ut m a ke no e x p r e s s e d or i m p l i e d warrant y of a ny k i nd a nd a s s u m e no r e s p o n s i b i l i t y f or error s or o m i s s i o n s . No l i a b i l i t y is a s s u m e d f or i n c i d e n t a l or c o n s e q u e n t i a l d a m a g e s in c o n n e c t i o n with or a r i s i n g o ut of t he u se of t he informatio n or program s c o n t a i n e d herein. T he p u b l i s h e r offers d i s c o u n t s on t h is b o ok w h en o r d e r e d in quantit y f or s p e c i a l s a l e s. F or m o re i n f o r m a - t i o n, p l e a s e c o n t a c t : P e a r s o n Educatio n C o r p o r a t e S a l es Divisio n 2 01 W. 1 0 3 rd S t r e e t I n d i a n a p o l i s , IN 4 6 2 90 ( 8 0 0) 4 2 8 - 5 3 3 1 c o r p s a l e s @ p e a r s o n e d . c o m V i s it AW on t he W e b: w w w . a w p r o f e s s i o n a l . c o m Library of Congress Cataloging-in-Publication Data D e s i g n Pattern s : e l e m e n t s of r e u s a b l e o b j e c t - o r i e n t e d softwar e / E r i ch Gamm a ... [et a l . ]. p. cm.—(Addison-Wesle y professiona l computin g s e r i e s ) I n c l u d e s b i b l i o g r a p h i c a l r e f e r e n c e s a nd i n d e x . I S BN 0 - 2 0 1 - 6 3 3 6 1 - 2 1. O b j e c t - o r i e n t e d programmin g ( C o m p u t e r s c i e n c e ) 2. C o m p u t e r software—Reusability. I. Gamma , Erich . II. S e r i e s . Q A 7 6 . 6 4 . D 4 7 1 9 9 4 0 0 5 . 1 ' 2 - d c 2 0 9 4 - 3 4 2 6 4 C I P C o p y r i g h t © 1 9 95 by A d d i s o n - W e s l e y A ll r i g h ts r e s e r v e d . No part of this publicatio n m ay be r e p r o d u c e d , s t o r ed in a r e t r i e v a l s y s t e m , or t r a n s m i t t e d , in a ny form , or by a ny m e a n s , e l e c t r o n i c , m e c h a n i c a l , p h o t o c o p y i n g , r e c o r d i n g , or o t h e r - wise, w i t h o u t t he p r i or c o n s e n t of t he p u b l i s h e r . P r i n t e d in t he U n i t e d S t a t es of A m e r i c a . P u b l i s h e d s i m u l t a n e o u s l y in Canada. C o v e r art © M.C. Escher/Cordon Art - Baarn - Holland. All rights reserved. I S B N 0 - 2 0 1 - 6 3 3 6 1 - 2 T e x t printed in the United States on recycled paper at Courier Westford in Westford, Massachusetts. 3 7 t h P r i n t i n g M a r c h 2 0 0 9 ptgTo Karin —E.G. To S y l v i e —R.H. To Faith -R.J. To D r u A n n a n d M a t t h e w Joshua 2 4 : 1 5 b —J.v. ptgP r a i s e for Design Patterns: Elements of Reusable Object-Oriented Software \" T h is is o ne of t he b e st writte n a nd wonderfull y insightfu l b o o k s that I have r e ad in a g r e at l o ng w h i l e . . . t h i s b o ok e s t a b l i s h e s t he l e g i t i m a c y of pattern s in t he b e st way: n ot by argumen t b ut by e x a m p l e . \" — S t an L i p p m a n , C ++ Report \" . . . t h i s n ew b o ok by G a m m a , Helm , Johnson , a nd V l i s s i d e s p r o m i s e s to have an i m p o r t a n t a nd l a s t i n g i m p a c t on t he d i s c i p l i n e of softwar e d e s i g n . B e c a u s e Design Patterns b i l ls i t s e lf as b e i ng c o n c e r n e d with o b j e c t - o r i e n t e d softwar e a l o n e , I fear that softwar e d e v e l o p e r s o u t s i d e the o b j e c t communit y may i g n o r e it. T h is woul d be a s h a m e . T h is b o ok h as s o m e t h i n g f or e v e r y o n e w ho d e s i g n s software . A ll softwar e design- e rs u se p a t t e r n s ; understandin g b e t t e r t he r e u s a b l e a b s t r a c t i o n s of o ur work c an only m a ke us b e t t er at i t . \" — T om D e M a r c o , IEEE Software \" O v e r a l l , I think this b o ok r e p r e s e n t s an e x t r e m e l y v a l u a b l e a nd uniqu e contributio n to t he field b e c a u s e it c a p t u r e s a wealt h of o b j e c t - o r i e n t e d d e s i g n e x p e r i e n c e in a c o m p a c t a nd r e u s a b l e form . T h is b o ok is c e r t a i n l y o ne that I s h a ll turn to often in s e a r c h of powerfu l o b j e c t - o r i e n t e d d e s i g n i d e a s ; after a l l, that's what r e u se is a ll about , isn't i t ? \" — S a n j i v G o s s a i n , Journal of Object-Oriented Programming \" T h is m u c h - a n t i c i p a t e d b o ok l i v es up to i ts f u ll year of a d v a n c e buzz . T he m e t a p h o r is of an architect' s p a t t e r n b o ok f i l l ed with t i m e - t e s t e d , u s a b l e d e s i g n s . T he author s have c h o s e n 23 pattern s from d e c a d e s of o b j e c t - o r i e n t e d e x p e r i e n c e . T he b r i l l i a n c e of t he b o ok l i es in t he d i s c i p l i n e r e p r e s e n t e d by that number . G i ve a c o py of Design Patterns to e v e ry g o od p r o g r a m m e r y ou know w ho want s to be b e t t e r . \" — L a r r y O ' B r i e n , Software Development \" T he s i m p l e fact of t he m a t t e r is that p a t t e r n s have t he p o t e n t i a l to p e r m a n e n t l y a l t er t he softwar e e n g i n e e r i n g field, catapultin g it into t he r e a lm of true e l e g a n t d e s i g n . Of t he b o o k s to d a te on t h is s u b j e c t , Design Patterns is f ar a nd away t he b e s t. It is a b o ok to be r e a d, s t u d i e d , i n t e r n a l i z e d , a nd l o v e d . T he b o ok will foreve r c h a n g e the way you v i ew software.\" — S t e ve B i l o w , Journal of Object-Oriented Programming \"Design Patterns is a powerfu l b o o k . After a m o d e s t investmen t of t i me with it, m o st C++ p r o g r a m m e r s w i ll be a b le to s t a rt a p p l y i n g i ts \" p a t t e r n s \" to p r o d u c e b e t t e r software . T h is b o ok d e l i v e r s i n t e l l e c t u a l l e v e r a g e : c o n c r e t e t o o ls that h e lp us think a nd e x p r e s s o u r s e l v e s m o re effectively . It m ay fundamentall y c h a n g e the way you think about programming. — Tom Cargill, C + + Report ptgC o n t e n t s P r e f a c e xi F o r e w o r d xiii Guide to Readers xv 1 Introduction 1 1 . 1 What Is a Design Pattern? 2 1 . 2 Design Patterns in Smalltalk MVC 4 1 . 3 Describing Design Patterns 6 1 . 4 The Catalog of Design Patterns 8 1 . 5 Organizing the Catalog 9 1 . 6 How Design Patterns Solve Design Problems 11 1 . 7 H o w t o Select a Design Pattern 28 1 . 8 H o w t o U s e a Design Pattern 29 2 A Case Study: Designing a D o c u m e n t Editor 33 2 . 1 Design Problems 33 2 . 2 Document Structure 35 2 . 3 Formatting 40 2 . 4 Embellishing the User Interface . 4 3 2 . 5 Supporting Multiple Look-and-Feel Standards 47 2 . 6 Supporting Multiple Window Systems 51 2 . 7 User Operations i 58 2 . 8 Spelling Checking and Hyphenation 64 v i i ptgv i i i CONTENTS 2 . 9 Summary 76 D e s i g n P a t t e r n C a t a l o g 7 9 3 C r e a t i o n a l P a t t e r n s 81 A b s t r a c t F a c t o r y 87 B u i l d e r 97 F a c t o r y M e t h o d 1 07 P r o t o t y p e 1 17 S i n g l e t o n 1 2 7 D i s c u s s i o n of C r e a t i o n a l P a t t e r n s 1 3 5 4 S t r u c t u r a l P a t t e r n s 1 37 A d a p t e r 1 39 B r i d g e 1 51 C o m p o s i t e 1 63 D e c o r a t o r 1 75 F a c a d e 1 85 F l y w e i g h t 1 95 P r o xy 2 0 7 D i s c u s s i o n of S t r u c t u r a l P a t t e r n s 2 1 9 5 B e h a v i o r a l P a t t e r n s 2 21 C h a in of R e s p o n s i b i l i t y 2 23 C o m m a n d 2 33 I n t e r p r e t e r 2 43 I t e r a t o r 2 57 M e d i a t o r 2 73 M e m e n t o 2 83 O b s e r v e r 2 93 S t a te 3 05 S t r a t e g y 315 ptgCONTENTS ix T e m p l a t e Method 325 V i s i t o r 331 D i s c u s s i o n of Behavioral Patterns 345 6 Conclusion 351 6 . 1 What t o Expect from Design Patterns 351 6 . 2 A Brief H i s t o r y 355 6 . 3 The Pattern Community 356 6 . 4 An Invitation 358 6 . 5 A Parting Thought 358 A G l o s s a r y 359 B Guide to Notation 363 B . I Class Diagram 363 B . 2 Object Diagram 364 B . 3 Interaction Diagram 366 C F o u n d a t i o n Classes 369 C . 1 List 369 C . 2 Iterator 372 C . 3 L i s t l t e r a t o r 372 C . 4 Point 373 C . 5 Rect 374 B i b l i o g r a p h y 375 I n d e x 383 ptg This page intentionally left blank ptgP r e f a c e T h is b ook i s n 't an introductio n to o b j e c t - o r i e n t e d t e c h n o l o g y or d e s i g n . Many b o o k s alread y do a g o od j ob of that. T h is b o ok a s s u m e s y ou a re r e a s o n a b l y proficien t in at l e a st o ne o b j e c t - o r i e n t e d programmin g l a n g u a g e , a nd y ou s h o u l d h a ve s o me e x p e r i e n c e in o b j e c t - o r i e n t e d d e s i g n as w e l l. Y ou d e f i n i t e l y s h o u l d n ' t h a ve to rush to t he n e a r e s t d i c t i o n a r y t he momen t we m enti o n \" t y p e s \" a nd \" p o l y m o r p h i s m , \" or \" i n t e r f a c e \" as o p p o s e d to \" i m p l e m e n t a t i o n \" i n h e r i t a n c e . On t he o t h er hand , t h is i s n 't an a d v a n c e d t e c h n i c a l t r e a t i s e e i t h e r . I t 's a b o ok of d e s i g n pattern s that d e s c r i b e s s i m p l e a nd e l e g a n t s o l u t i o n s to s p e c i f i c p r o b l e m s in o b j e c t - o r i e n t e d softwar e d e s i g n . D e s i g n pattern s captur e s o l u t i o n s that have d e v e l o p e d a nd e v o l v e d o v er time. H e n c e t h ey aren' t t he d e s i g n s p e o p l e t e nd to g e n e r a t e i n i t i a l l y . T h ey reflec t untol d r e d e s i g n a nd r e c e d i n g as d e v e l o p e r s have s t r u g g l e d f or g r e a t e r r e u se a nd f l e x i b i l i t y in their software . D e s i g n pattern s captur e t h e se s o l u t i o n s in a s u c c i n c t a nd e a s i ly a p p l i e d f o r m . The d e s i g n pattern s requir e n e i t h e r unusua l l a n g u a g e feature s nor amazin g program- ming t r i c ks with w h i c h to astoun d your friend s and m a n a g e r s . All can be i m p l e m e n t e d in standar d o b j e c t - o r i e n t e d l a n g u a g e s , thoug h they migh t take a l i t t le m o re work than ad hoc s o l u t i o n s . But the extra e f f o r t invariabl y pays d i v i d e n d s in i n c r e a s e d flexibilit y and r e u s a b i l i t y . O n ce you understan d the d e s i g n pattern s and have had an \" A h a ! \" (and not just a \" H u h ? \" ) e x p e r i e n c e with t h e m , y ou won' t e v er t h i nk abou t o b j e c t - o r i e n t e d d e s i g n in t he s a me w a y. Y o u ' l l have i n s i g h t s that c an make your o wn d e s i g n s more f l e x i b l e , modular , r e u s a b l e , a nd understandable—whic h is w hy you'r e i n t e r e s t e d in o b j e c t - o r i e n t e d t e c h n o l o g y in t he first p l a c e , ri g ht? A word of warnin g and e n c o u r a g e m e n t : D o n ' t worr y if you don't understan d t h is bo ok c o m p l e t e l y on t he first r e a d i n g . We didn' t understan d it a ll on t he f i r st w r i t i n g ! Remembe r that t h is i s n 't a book to read o n ce and put on a s h e l f . We h o pe y o u ' l l find y o u r s e l f referrin g to it a g a in and a g a in for d e s i g n i n s i g h t s and for inspiration. T h is book h as h ad a l o ng g e s t a t i o n . It h as s e en f o ur c o u n t r i e s , t h r ee of i ts authors ' marriages , and the birth of two (unrelated ) offspring . Many p e o p l e have had a part in i ts development . S p e c i a l thank s a re d ue Bruce A n d e r s o n , K e nt B e c k , a nd Andr e W e i n a n d f o r their inspiration a n d a d v i c e . We also thank those w h o r e v i e w e d d r a f t s XI ptgx ii PREFACE of t he m a n u s c r i p t : R o g e r B i e l e f e l d , Grad y B o o c h , T om C a r g i l l , M a r s h a l l C l i n e , Ralp h H y r e , B r i an K e r n i g h a n , T h o m a s L a l i b e r t y , Mark L o r e n z , Arthu r R i e l, D o ug S c h m i d t , C l o v i s T o n d o , S t e ve V i n o s k i , a nd R e b e c c a W i r f s - B r o c k . We a re a l so gratefu l to t he team at A d d i s o n - W e s l e y f or t h e ir h e lp a nd p a t i e n c e : Kate H a b i b , Tiffan y M o o r e , L i sa Raffaele , P r a d e e p a S i v a, a nd John Wait . S p e c i a l t h a n k s to C a rl K e s s l e r , D a n n y S a b b a h , a nd Mark W e g m a n at I BM R e s e a r c h f or t h e ir unflaggin g suppor t of t h is work. L a st b ut c e r t a i n l y n ot l e a s t, we thank e v e r y o n e on t he I n t e r n e t a nd p o i n t s b e y o n d w ho c o m m e n t e d on v e r s i o n s of t he patterns , offere d e n c o u r a g i n g w o r d s , a nd t o ld us that what we w e re d o i ng w as w o r t h w h i l e . T h e se p e o p l e i n c l u d e b ut a re n ot l i m i t e d to J on A v o t i n s , S t e ve B e r c z u k , J u l i a n B e r d y c h , Matthia s B o h l e n , J o hn B r a n t , A l l an C l a r k e , Paul C h i s h o l m , J e ns C o l d e w e y , D a ve C o l l i n s , J im C o p l i e n , D on D w i g g i n s , G a b r i e l e E l i a, D o ug F e l t, B r i an F o o t e , D e n is F o r t i n , W a rd H a r o l d , H e r m a n n H u e n i , N a y e e m I s l a m , Bikramji t K a l r a , P a ul K e e f e r , T h o m a s Kofler , D o ug L e a, D an L a L i b e r t e , J a m e s L o n g , A nn L o u i s e L u u, P u n d i M a d h a v a n , B r i an M a r i c k , R o b e r t M a r t i n , D a ve M c C o m b , Carl M c C o n n e l l , C h r i s t i n e M i n g i n s , H a n s p e t e r M o s s e n b o c k , E r ic N e w t o n , M a r i a n n e O z k a n , R o x s a n P a y e t t e , Larry P o d m o l i k , G e o r g e R a d i n , S i ta R a m a k r i s h n a n , R u ss R a m i r e z , A l e x a n d e r R a n, D i rk R i e h l e , B r y a n R o s e n b u r g , Aamo d S a n e, D u ri S c h m i d t , R o b e r t S e i d l , X in S h u, a nd B i ll W a l k e r . We d o n 't c o n s i d e r t h is c o l l e c t i o n of d e s i g n pattern s c o m p l e t e a nd s t a t i c ; i t 's m o re a r e c o r d i n g of o ur c u r r e n t t h o u g h t s on d e s i g n . We w e l c o m e c o m m e n t s on i t, w h e t h e r c r i t i c i s m s of o ur e x a m p l e s , r e f e r e n c e s a nd know n u s es w e ' ve m i s s e d , or d e s i g n pat- t e r ns we s h o u l d have i n c l u d e d . Y ou c an write us c a re of A d d i s o n - W e s l e y , or s e nd e l e c t r o n i c m a il to d e s i g n - p a t t e r n s @ c s . u i u c . edu. Y ou c an a l so o b t a i n softcop y f or t he c o de in t he S a m p l e C o de s e c t i o n s by s e n d i n g t he m e s s a g e \" s e nd d e s i g n patter n s o u r c e \" to d e s i g n - p a t t e r n s - s o u r c e i c s . u i u c . e d u. And now t h e r e ' s a Web p a ge at h t t p : / / s t - w w w . c s . u i u c . e d u / u s e r s / p a t t e r n s / D P B o o k / D P B o o k . h t m l f or l a t e - b r e a k i n g i n f o r m a t i o n and u p d a t e s . Mountain V i e w , California E.G. Montreal, Q u e b e c R.H. Urbana, Illinois R.J. Hawthorne, New Y o r k J.V. August 1 9 9 4 ptgF o r e w o r d A ll w e l l - s t r u c t u r e d o b j e c t - o r i e n t e d a r c h i t e c t u r e s a re full of patterns . I n d e e d , o ne of t he ways that I measur e the qualit y of an o b j e c t - o r i e n t e d s y s t e m is to judge whethe r or not its d e v e l o p e r s have p a id carefu l attentio n to the c o m m o n c o l l a b o r a t i o n s amon g its o b j e c t s . F o c u s i n g on s u ch m e c h a n i s m s durin g a s y s t e m ' s d e v e l o p m e n t c an y i e ld an architectur e that is s m a l l e r , s i m p l e r , and far m o re understandabl e than if t h e se pattern s a re i g n o r e d . T he importanc e of pattern s in craftin g c o m p l e x s y s t e m s h as b e en l o ng r e c o g n i z e d in o t h er d i s c i p l i n e s . In p a r t i c u l a r , C h r i s t o p h e r A l e x a n d e r a nd h is c o l l e a g u e s w e re p e r h a p s the first to p r o p o s e the i d ea of u s i ng a patter n languag e to a r c h i t e c t b u i l d i n g s and c i t i e s . H is i d e as a nd t he c o n t r i b u t i o n s of o t h e r s have n ow taken r o ot in t he o b j e c t - o r i e n t e d softwar e c o m m u n i t y . In s h o r t , t he c o n c e p t of t he d e s i g n patter n in softwar e p r o v i d e s a k ey to helpin g d e v e l o p e r s l e v e r a g e t he e x p e r t i s e of o t h er s k i l l e d a r c h i t e c t s . In this b o o k , E r i ch Gamma , R i c h a r d H e l m , Ralp h J o h n s o n , a nd J o hn V l i s s i d e s introduc e t he p r i n c i p l e s of d e s i g n pattern s a nd then o f f er a c a t a l o g of s u ch patterns . T h u s , t h is b o ok m a k e s t wo i m p o r t a n t c o n t r i b u t i o n s . F i r s t, it s h o w s t he r o le that p a t t e r n s c an p l ay in architectin g c o m p l e x s y s t e m s . S e c o n d , it p r o v i d e s a very pragmati c referenc e to a s et of w e l l - e n g i n e e r e d pattern s that the p r a c t i c i n g d e v e l o p e r can apply to craftin g his or her own s p e c i f i c a p p l i c a t i o n s . I'm h o n o r e d to have had the opportunit y to work d i r e c t l y with s o me of the author s of t h is b ook in architectura l d e s i g n efforts . I have l e a r n e d much from them , and I s u s p e c t that in reading this book, you will also. Grady Booch C h i e f Scientist, Rational S o f t w a r e Corporation xm ptg This page intentionally left blank ptgG u i d e to Readers T h is b ook has two main parts . The first part (Chapter s 1 and 2) d e s c r i b e s what d e s i g n pattern s a re a nd h ow they h e lp y ou d e s i g n o b j e c t - o r i e n t e d software . It i n c l u d e s a d e s i g n c a se study that demonstrate s h ow d e s i g n pattern s apply in p r a c t i c e . T he s e c o n d part of t he bo ok (Chapter s 3,4, a nd 5) is a c a t a l o g of t he actua l d e s i g n patterns. The catalo g make s up the majorit y of the b o o k . Its chapter s d i v i d e the d e s i g n pattern s into three t y p e s : c r e a t i o n a l , structural , a nd b e h a v i o r a l . Y ou c an u se t he c a t a l o g hi s e v e r a l ways . You can r e ad the c a t a l o g from start to finish , or you can just b r o w s e from patter n to pattern . Anothe r approac h is to study o ne of t he chapters . T h at w i ll help y ou s ee h ow c l o s e l y r e l a t e d pattern s d i s t i n g u i s h t h e m s e l v e s . You can use the r e f e r e n c e s betwee n the pattern s as a l o g i c a l route throug h the c a t a l o g . T h is approac h w i ll g i ve y ou i n s i g h t into h ow pattern s relate to e a ch o t h e r , h ow they c an be c o m b i n e d with o t h er patterns , a nd w h i c h pattern s work w e ll t o g e t h e r . F i g u r e 1 .1 ( p a ge 1 2) d e p i c t s t h e se r e f e r e n c e s g r a p h i c a l l y . Y et anothe r w ay to r e ad t he c a t a l o g is to u se a more p r o b l e m - d i r e c t e d a p p r o a c h . S k ip to S e c t i o n 1 .6 ( p a ge 2 4) to r e ad abou t s o me c o m m o n p r o b l e m s hi d e s i g n i n g r e u s a b l e o b j e c t - o r i e n t e d software ; then r e ad the pattern s that a d d r e s s t h e se p r o b l e m s . S o me p e o p l e r e ad the c a t a l o g throug h first and then use a p r o b l e m - d i r e c t e d approac h to apply the pattern s to their p r o j e c t s . If you aren' t an e x p e r i e n c e d o b j e c t - o r i e n t e d d e s i g n e r , then start with the s i m p l e s t and m o st c o m m o n patterns: • Abstrac t Factor y ( p a ge 8 7) • Factor y M e t h o d ( 1 0 7 ) • Adapte r ( 1 3 9) • O b s e r v e r ( 2 9 3 ) • C o m p o s i t e ( 1 6 3) • S t r a t e g y ( 3 1 5 ) • Decorato r ( 1 7 5) • T e m p l a t e Metho d ( 3 2 5 ) I t 's hard to f i nd an o b j e c t - o r i e n t e d s y s t e m that d o e s n ' t u se at l e a st a c o u p l e of t h e se patterns , a nd l a r ge s y s t e m s u se nearl y a ll of them . T h is s u b s e t w i ll h e lp y ou understan d d e s i g n p a t t e r n s in particular and good object-oriented design in general. xv ptg This page intentionally left blank ptgC h a p t e r 1 I n t r o d u c t i o n D e s i g n i n g o b j e c t - o r i e n t e d softwar e is hard, a nd d e s i g n i n g reusable o b j e c t - o r i e n t e d soft- ware is e v en h a r d e r . Y ou must f i nd p e r t i n e n t o b j e c t s , facto r them into c l a s s e s at t he r i g ht granularity , defin e c l a ss interface s a nd i n h e r i t a n c e h i e r a r c h i e s , a nd e s t a b l i s h k ey r e l a t i o n s h i p s amon g t h e m . Your d e s i g n s h o u l d be s p e c i f i c to t he p r o b l e m at hand b ut a l so g e n e r a l e n o u g h to a d d r e s s futur e p r o b l e m s a nd r e q u i r e m e n t s . Y ou a l so want to a v o id r e d e s i g n , or at l e a st m i n i m i z e i t. E x p e r i e n c e d o b j e c t - o r i e n t e d d e s i g n e r s w i ll t e ll y ou that a r e u s a b l e a nd f l e x i b l e d e s i g n is difficul t if n ot i m p o s s i b l e to g et \" r i g h t \" t he f i r st t i m e. B e f o r e a d e s i g n is f i n i s h e d , they u s u a l l y t ry to r e u se it s e v e r a l t i m e s , modifyin g it e a ch t i m e . Y et e x p e r i e n c e d o b j e c t - o r i e n t e d d e s i g n e r s do make g o od d e s i g n s . M e a n w h i l e n ew d e s i g n e r s a re o v e r w h e l m e d by t he o p t i o n s a v a i l a b l e a nd tend to fall back on n o n - o b j e c t - o r i e n t e d t e c h n i q u e s they'v e u s ed before . It takes a l o ng t i me f or n o v i c e s to l e a rn what g o od o b j e c t - o r i e n t e d d e s i g n is a ll a b o u t . E x p e r i e n c e d d e s i g n e r s e v i d e n t l y know s o m e t h i n g i n e x p e r i e n c e d o n es don't . Wha t is i t ? O ne t h i ng e x p e r t d e s i g n e r s know n ot to do is s o l ve e v e ry p r o b l e m from f i r st p r i n c i p l e s . R a t h e r , they r e u se s o l u t i o n s that have worke d for them in the past. Whe n they find a g o od s o l u t i o n , they u se it a g a in a nd a g a i n . S u ch e x p e r i e n c e is part of what make s them e x p e r t s . C o n s e q u e n t l y , y o u ' l l f i nd r e c u r r i n g pattern s of c l a s s e s a nd communicatin g o b j e c t s in many o b j e c t - o r i e n t e d s y s t e m s . T h e se p a t t e r n s s o l ve s p e c i f i c d e s i g n p r o b l e m s a nd make o b j e c t - o r i e n t e d d e s i g n s m o re f l e x i b l e , e l e g a n t , a nd ultimatel y r e u s a b l e . T h ey h e lp d e s i g n e r s r e u se s u c c e s s f u l d e s i g n s by b a s i n g n ew d e s i g n s on p r i or e x p e r i e n c e . A d e s i g n e r w ho is familia r with s u ch pattern s c an apply them i m m e d i a t e l y to d e s i g n p r o b l e m s withou t h a v i n g to r e d i s c o v e r them. An a n a l o g y w i ll h e lp i l l u s t r a t e t he p o i n t . N o v e l i s t s a nd playwright s rarely d e s i g n t h e ir p l o ts from s c r a t c h . I n s t e a d , they follow pattern s l i ke \" T r a g i c a l l y F l a w e d H e r o \" ( M a c b e t h , H a m l e t , e t c .) or \" T he Romanti c N o v e l \" ( c o u n t l e s s romanc e n o v e l s ) . In t he s a m e w a y , o b j e c t - o r i e n t e d d e s i g n e r s follow patterns like \"represent states with objects\" 1 ptg2 INTRODUCTION CHAPTER 1 a nd \"de cor at e o b j e c t s so y ou c an e a s i ly add/remov e features. \" O n ce y ou k n ow t he pattern , a l ot of d e s i g n d e c i s i o n s follow automatically. We a ll know t he v a l ue of d e s i g n e x p e r i e n c e . How many t i m es have y ou h ad d e s i g n deja- vu—that f e e l i n g that y o u ' v e s o l v e d a p r o b l e m b ef or e b ut n ot k n o w i n g e x a c t l y w h e r e or how? If y ou c o u ld r e m e m b e r t he d e t a i l s of t he p r e v i o u s p r o b l e m a nd h ow y ou s o l v e d i t, then y ou c o u ld r e u se t he e x p e r i e n c e i n s t e a d of r e d i s c o v e r i n g i t. H o w e v e r , we don't do a g o od j ob of r e c o r d i n g e x p e r i e n c e in softwar e d e s i g n f or o t h e r s to u s e . T he purpos e of t h is b o ok is to r e c o r d e x p e r i e n c e in d e s i g n i n g o b j e c t - o r i e n t e d softwar e as d e s i g n p a t t e r n s . E a ch d e s i g n patter n s y s t e m a t i c a l l y n a m e s , e x p l a i n s , a nd e v a l u a t e s an importan t a nd recurrin g d e s i g n in o b j e c t - o r i e n t e d s y s t e m s . O ur g o al is to captur e d e s i g n e x p e r i e n c e in a form that p e o p l e c an u se e f f e c t i v e l y . To t h is e nd we have d o c u m e n t e d s o me of t he most importan t d e s i g n pattern s a nd p r e s e n t them as a c a t a l o g . D e s i g n pattern s make it e a s i e r to r e u se s u c c e s s f u l d e s i g n s a nd a r c h i t e c t u r e s . E x p r e s s i n g p r o v e n t e c h n i q u e s as d e s i g n p a t t e r n s m a k e s t h em m o re a c c e s s i b l e to d e v e l o p e r s of n ew s y s t e m s . D e s i g n pattern s h e lp y ou c h o o s e d e s i g n alternative s that make a s y s t e m reusabl e a nd a v o id alternative s that c o m p r o m i s e r e u s a b i l i t y . D e s i g n pattern s c an e v en i m p r o v e t he documentatio n a nd maintenanc e of e x i s t i n g s y s t e m s by furnishin g an e x p l i c i t s p e c i f i c a t i o n of c l a ss a nd o b j e c t interaction s a nd t h e ir underlyin g i n t e n t . P ut s i m p l y , d e s i g n pattern s help a d e s i g n e r g et a d e s i g n \" r i g h t \" faster. None of t he d e s i g n pattern s in t h is b o ok d e s c r i b e s n ew or unprove n d e s i g n s . We have i n c l u d e d o n ly d e s i g n s that have b e en a p p l i e d m o re than o n ce in differen t s y s t e m s . M o st of t h e se d e s i g n s hav e n e v er b e en d o c u m e n t e d before . T h ey a re e i t h er part of t he f o l k l o r e of t he o b j e c t - o r i e n t e d communit y or a re e l e m e n t s of s o me s u c c e s s f u l o b j e c t - o r i e n t e d systems—neithe r of whic h is e a sy f or n o v i c e d e s i g n e r s to learn from . So althoug h t h e se d e s i g n s aren' t n e w, we captur e them in a n ew a nd a c c e s s i b l e way: as a c a t a l o g of d e s i g n pattern s havin g a c o n s i s t e n t format. D e s p i t e t he b o o k ' s s i z e, t he d e s i g n p a t t e r n s in it c a p t u r e o n ly a f r a c t i o n of what an e x p e r t migh t k n o w . It d o e s n ' t have a ny pattern s d e a l i n g with c o n c u r r e n c y or d i s t r i b u t e d p r o - grammin g or r e a l - t i m e programming . It d o e s n ' t have any a p p l i c a t i o n d o m a i n - s p e c i f i c patterns . It d o e s n ' t t e ll you how to b u i ld user i n t e r f a c e s , how to write d e v i c e d r i v e r s , or how to use an o b j e c t - o r i e n t e d database . E a ch of t h e se a r e as has its own p a t t e r n s , and it would be worthwhile for someone to catalog those too. 1 . 1 What Is a D e s i g n P a t t e r n ? C h r i s t o p h e r A l e x a n d e r s a y s, \" E a ch patter n d e s c r i b e s a p r o b l e m w h i c h o c c u r s o v er a nd o v er again in o ur e n v i r o n m e n t , a nd then d e s c r i b e s t he c o re of t he s o l u t i o n to that p r o b l e m , in s u ch a w ay that y ou c an u se this s o l u t i o n a m i l l i o n t i m es o v e r, withou t e v er d o i ng it t he s a me w ay t w i c e \" [ A I S + 7 7 , p a ge x }. E v en t h o u g h A l e x a n d e r w as t a l k i n g abou t pattern s in b u i l d i n g s a nd t o w n s , what he s a ys is true abou t o b j e c t - o r i e n t e d d e s i g n patterns. Our solutions are expressed in terms of objects a n d interfaces instead of walls ptgSECTION 1.1 WHAT IS A DESIGN PATTERN? 3 and d o o r s , but at the c o re of both kinds of pattern s is a s o l u t i o n to a p r o b l e m in a context. In g e n e r a l , a patter n has f o ur e s s e n t i a l e l e m e n t s : 1. T he p a t t e r n n a me is a handl e we c an u se to d e s c r i b e a d e s i g n p r o b l e m , i ts s o - l u t i o n s , and c o n s e q u e n c e s in a w o rd or two. Namin g a patter n immediatel y i n c r e a s e s o ur d e s i g n v o c a b u l a r y . It l e ts us d e s i g n at a highe r l e v el of abstraction . Havin g a v o c a b u l a r y for pattern s l e ts us talk abou t them with our c o l l e a g u e s , in our documentation , and e v en to o u r s e l v e s . It make s it e a s i e r to think abou t d e s i g n s and to communicat e them and their trade-off s to others . Findin g g o od name s has b e en one of the hardes t parts of d e v e l o p i n g our catalog. 2. The p r o b l e m d e s c r i b e s when to apply the pattern . It explain s the p r o b l e m and its c o n t e x t . It migh t d e s c r i b e s p e c i f i c d e s i g n p r o b l e m s such as h ow to r e p r e s e n t a l g o - rithm s as o b j e c t s . It migh t d e s c r i b e c l a ss or o b j e c t structure s that are symptomati c of an inflexibl e d e s i g n . S o m e t i m e s t he p r o b l e m w i ll includ e a l i st of condition s that must be met befor e it make s s e n se to apply the pattern. 3. The s o l u t i o n d e s c r i b e s the e l e m e n t s that make up the d e s i g n , their r e l a t i o n s h i p s , r e s p o n s i b i l i t i e s , and c o l l a b o r a t i o n s . The solutio n doesn' t d e s c r i b e a particula r c o n c r e t e d e s i g n or implementation , becaus e a patter n is l i ke a templat e that can be applie d in many differen t situations . Instead , the patter n provide s an abstrac t d e s c r i p t i o n of a d e s i g n p r o b l e m and how a genera l arrangemen t of element s ( c l a s s e s a nd o b j e c t s in o ur c a s e) s o l v e s i t . 4. The c o n s e q u e n c e s are the result s and trade-off s of applyin g the pattern . Thoug h c o n s e q u e n c e s are often u n v o i c e d when we d e s c r i b e d e s i g n d e c i s i o n s , they are c r i t i c a l for evaluatin g d e s i g n alternative s and for understandin g the c o s ts and benefit s of applyin g the pattern. The c o n s e q u e n c e s for softwar e o f t en c o n c e r n s p a ce and time trade-offs . T h ey may a d d r e s s languag e and implementatio n i s s u e s as w e l l. S i n ce reuse is o f t en a facto r in o b j e c t - o r i e n t e d d e s i g n , the c o n s e q u e n c e s of a patter n includ e its impac t on a s y s t e m ' s flexibility , e x t e n s i b i l i t y , or portability . Listin g these c o n s e q u e n c e s e x p l i c i t l y h e l ps you understan d and evaluat e them. P o i nt of v i ew a f f e c t s one's interpretatio n of what is and isn't a pattern . One person' s patter n can be anothe r person' s primitiv e buildin g b l o c k . For this book we have c o n c e n - trated on pattern s at a certai n l e v el of abstraction . Design patterns are not abou t d e s i g n s s u ch as l i n k e d l i s ts a nd hash table s that c an be e n c o d e d in c l a s s e s a nd r e u s e d as i s. N or are they c o m p l e x , d o m a i n - s p e c i f i c d e s i g n s for an entire applicatio n or subsystem . The d e s i g n pattern s in this b o ok are descriptions of communicating objects and classes that are customized to solve a general design problem in a particular context. A d e s i g n patter n n a m e s , abstracts , and identifie s the key aspect s of a commo n d e s i g n structur e that make it usefu l for creatin g a reusabl e object-oriente d d e s i g n . The d e s i g n pattern identifies the participating classes and instances, their roles and collaborations, ptg4 INTRODUCTION CHAPTER 1 and the distributio n of r e s p o n s i b i l i t i e s . Each d e s i g n patter n focuse s on a particula r object-oriente d d e s i g n proble m or i s s u e . It d e s c r i b e s when it a p p l i e s , whethe r it can be applie d in v i ew of other d e s i g n constraints , and the c o n s e q u e n c e s and trade-off s of its u s e. S i n ce we must eventuall y implemen t our d e s i g n s , a d e s i g n patter n a l so p r o v i d e s sampl e C++ and (sometimes ) Smalltal k c o de to illustrat e an implementation. A l t h o u g h d e s i g n pattern s d e s c r i b e o b j e c t - o r i e n t e d d e s i g n s , t h ey a re b a s ed on p r a c t i c a l s o l u t i o n s t h at have been implemente d in mainstrea m object-oriente d programmin g language s l i ke Smalltal k and C++ rathe r than procedura l language s ( P a s c a l , C, Ada) or m o re dynami c object-oriente d language s ( C L O S , D y la n , S e l f ). We c h o se Smalltal k a nd C++ for pragmati c r e a s o n s : Our day-to-da y e x p e r i e n c e has been in t h e se l a n g u a g e s , and they are i n c r e a s i n g l y popular. T he c h o i c e of programmin g languag e is importan t becaus e it influence s o n e 's point of v i e w. Our pattern s assum e Smalltalk/C++-leve l languag e features , and that c h o i c e determine s w h at can and canno t be implemente d e a s i l y . If we assume d procedura l l a n g u a g e s , we migh t have include d d e s i g n pattern s c a l l ed \" I n h e r i t a n c e , \" \"Encapsu- l a t i o n , \" and \" P o l y m o r p h i s m . \" S i m i l a r l y , some of our pattern s are supporte d d i r e c t l y by the l e ss commo n object-oriente d languages . C L OS has multi-methods , for e x a m p l e , w h i c h l e s s en the n e ed for a patter n s u ch as Visito r (page 3 3 1 ). In fact, t h e re are enoug h difference s betwee n Smalltal k and C++ to mean that s o me pattern s can be e x p r e s s e d more easily in one language than the other. (See Iterator (257) f o r a n example.) 1 . 2 Design Patterns i n Smalltalk MVC T he Model/View/Controlle r (MVC ) triad of c l a s s e s [ K P 8 8 ] is u s ed to b u i ld u s er inter- faces in S m a l l t a l k - 8 0 . Lookin g at the d e s i g n pattern s i n s i d e MVC shoul d help you see what we mean by the term \"pattern.\" M VC c o n s i s t s of three kinds of objects . T he M o d e l is t he applicatio n o b j e c t , t he V i ew is its s c r e e n presentation , and the C o n t r o l l e r define s the way the user interfac e r e a c t s to u s er input . Befor e M V C , user interfac e d e s i g n s tende d to lump these o b j e c t s together . MVC d e c o u p l e s them to i n c r e a s e flexibilit y and r e u s e . MVC d e c o u p l e s v i e w s and model s by establishin g a subscribe/notif y protoco l betwee n them . A v i ew must ensur e that its appearanc e reflect s the state of the m o d e l . Wheneve r the model' s data c h a n g e s , the mode l notifie s v i e w s that depen d on it. In r e s p o n s e , e a ch v i ew g e ts an opportunit y to updat e itself . T h is approac h l e ts you attac h multipl e v i e w s to a mode l to provid e differen t presentations . You can a l so creat e new v i e w s for a m o d e l withou t rewritin g it. The followin g diagra m show s a mode l and three v i e w s . ( W e ' v e left out the c o n t r o l l e r s for s i m p l i c i t y . ) The mode l contain s some data v a l u e s , and the v i e w s definin g a s p r e a d - s h e e t , h i s t o g r a m , a nd p ie c h a rt d i s p l a y t h e se data in v a r i o u s w a y s . T he m o d e l c o m m u - nicate s with its v i e w s when its value s c h a n g e , and the v i e w s communicat e with the model to access these values. ptgSECTION 1 . 2 DESIGN P A T T E R N S I N S M A L L T A L K M V C 5 m o d e l T a k e n at face v a l u e , this exampl e reflect s a d e s i g n that d e c o u p l e s v i e w s from m o d e l s . But t he d e s i g n is a p p l i c a b l e to a more g e n e r a l p r o b l e m : d e c o u p l i n g o b j e c t s so that c h a n g e s to one can a f f e c t any numbe r of o t h e r s withou t r equi ri n g the change d o b j e c t to know d e t a i l s of t he o t h e r s . T h is m o re g e n e r a l d e s i g n is d e s c r i b e d by t he O b s e r v e r ( p a ge 2 9 3) d e s i g n pattern. Anothe r featur e of M VC is that v i e w s c an be n e s t e d . F or e x a m p l e , a c o n t r o l panel of button s migh t be implemente d as a c o m p l e x v i ew containin g n e s t e d butto n v i e w s . The u s er interfac e for an o b j e c t i n s p e c t o r can c o n s i s t of n e s t e d v i e w s that may be r e u s e d in a d e b u g g e r . M VC support s n e s t e d v i e w s with t he C o m p o s i t e V i e w c l a s s, a s u b c l a s s of V i e w . C o m p o s i t e V i e w o b j e c t s a ct just l i ke V i ew o b j e c t s ; a c o m p o s i t e v i ew c an be u s ed w h e r e v e r a v i ew can be u s e d, but it a l so contain s and manage s n e s t e d v i e w s . A g a i n , we c o u ld think of t h is as a d e s i g n that l e ts us treat a c o m p o s i t e v i ew just l i ke we treat o ne of i ts components . B ut t he d e s i g n is a p p l i c a b l e to a more g e n e r a l p r o b l e m , w h i c h o c c u r s wheneve r we want to group o b j e c t s and treat the group l i ke an individua l o b j e c t . T h is m o re genera l d e s i g n is d e s c r i b e d by t he C o m p o s i t e ( 1 6 3) d e s i g n pattern . It l e ts y ou c r e a t e a c l a ss hierarch y in w h i c h s o me s u b c l a s s e s defin e primitiv e o b j e c t s ( e . g ., Button ) and other c l a s s e s defin e c o m p o s i t e object s ( C o m p o s i t e V i e w ) that a s s e m b l e the p r i m i t i v e s into m o re c o m p l e x o b j e c t s . MVC a l so l e ts you chang e the way a v i ew r e s p o n d s to u s er input withou t changin g its visua l presentation . You migh t want to c h a n g e the way it r e s p o n d s to the k e y b o a r d , for e x a m p l e , or have it u se a pop-u p menu instea d of comman d k e y s. M VC encapsulate s t he r e s p o n s e m e c h a n i s m in a C o n t r o l l e r o b j e c t . T h e re is a c l a ss h i e r a r c h y of c o n t r o l l e r s , making it easy to create a new controller as a variation on an existing one. ptg6 INTRODUCTION CHAPTER 1 A v i ew u s es an instanc e of a C o n t r o l l e r s u b c l a s s to i m p l e m e n t a particula r r e s p o n s e strategy ; to implemen t a differen t strategy , s i m p l y r e p l a c e the instanc e with a differen t k i nd of c o n t r o l l e r . It's e v en p o s s i b l e to c h a n g e a v i e w ' s c o n t r o l l e r at run-tim e to l et t he v i ew chang e t he w ay it r e s p o n d s to u s er input . F or e x a m p l e , a v i ew c an be d i s a b l e d so that it d o e s n ' t a c c e p t input s i m p l y by g i v i n g it a c o n t r o l l e r that i g n o r e s input e v e n t s . T he V i e w - C o n t r o l l e r relationshi p is an exampl e of t he S t r a t e g y ( 3 1 5) d e s i g n pattern . A Strateg y is an o b j e c t that r e p r e s e n t s an algorithm . It's usefu l when you want to r e p l a c e the algorith m eithe r staticall y or d y n a m i c a l l y , whe n you have a lot of variant s of the algorithm , or when the algorith m has c o m p l e x data structure s that you want to encapsulate. M VC u s es other d e s i g n patterns , such as F a c t o r y Metho d ( 1 0 7) to s p e c i f y t he defaul t c o n t r o l l e r c l a ss for a v i ew and Decorato r ( 1 7 5) to add s c r o l l i n g to a v i e w. But the main r e l a t i o n s h i p s in M VC a re g i v en by t he O b s e r v e r , C o m p o s i t e , a nd Strateg y d e s i g n patterns. 1 . 3 Describing Design P a t t e r n s How do we d e s c r i b e d e s i g n patterns ? Graphica l notations , w h i le importan t and useful , aren' t sufficient . T h ey s i m p l y captur e t he e nd produc t of t he d e s i g n p r o c e s s as r e l a - t i o n s h i p s betwee n c l a s s e s a nd o b j e c t s . To r e u se t he d e s i g n , we must a l so r e c o r d t he d e c i s i o n s , alternatives , and trade-off s that led to it. C o n c r e t e e x a m p l e s are importan t t o o, b e c a u s e they help y ou s ee t he d e s i g n in a c t i o n . We d e s c r i b e d e s i g n pattern s using a c o n s i s t e n t format . E a ch pattern is d i v i d e d into s e c t i o n s a c c o r d i n g to the followin g template . The templat e l e n d s a unifor m structur e to the information , makin g d e s i g n pattern s e a s i e r to l e a r n , c o m p a r e , and u s e . P a t t e r n N a m e a nd Classification The pattern' s name c o n v e y s the e s s e n c e of the patter n s u c c i n c t l y . A g o od name is v i t a l, b e c a u s e it w i ll b e c o m e part of your d e s i g n v o c a b u l a r y . T he pattern' s classificatio n reflect s t he s c h e m e we introduc e in S e c t i o n 1 . 5 . I n t e n t A s h o rt statemen t that a n s w e r s the followin g q u e s t i o n s : Wha t d o es the d e s i g n patter n do? Wha t is its rational e and intent ? Wha t particula r d e s i g n i s s ue or p r o b l e m does it address? Also Known As O t h e r w e l l - k n o w n n a m e s for the pattern, if a n y . Motivation A scenario that illustrates a d e s i g n p r o b l e m and how the c l a s s and object structures ptgSECTION 1.3 DESCRIBING DESIGN PATTERNS 7 in t he patter n s o l ve t he p r o b l e m . T he s c e n a r i o w i ll h e lp y ou understan d t he more abstrac t d e s c r i p t i o n of the patter n that follows. Applicability Wha t are the s i t u a t i o n s in whic h the d e s i g n patter n can be applied ? Wha t are e x a m p l e s of p o or d e s i g n s that t he patter n c an a d d r e s s ? H ow c an y ou r e c o g n i z e t h e se situations? S t r u c t u r e A g r a p h i c a l r e p r e s e n t a t i o n of the c l a s s e s in the patter n using a notatio n b a s ed on t he O b j e c t M o d e l i n g T e c h n i q u e ( O M T ) [ R B P + 9 1 ] . We a l so u se interactio n d i - a g r a m s [ J C J O 9 2 , B o o 9 4 ] to i l l u s t r a t e s e q u e n c e s of r e q u e s t s a nd c o l l a b o r a t i o n s b e t w e e n o b j e c t s . Appendi x B d e s c r i b e s t h e se notation s in detail. P a r t i c i p a n t s T he c l a s s e s a n d / o r o b j e c t s participatin g in t he d e s i g n patter n a nd their r e s p o n s i - b i l i t i e s . C o l l a b o r a t i o n s H ow t he participant s c o l l a b o r a t e to c a r ry o ut t h e ir r e s p o n s i b i l i t i e s . C o n s e q u e n c e s How d o es the patter n suppor t its o b j e c t i v e s ? Wha t are the trade-off s and r e s u l t s of u s i ng t he pattern? Wha t a s p e c t of s y s t e m structur e d o es it l et y ou vary i n d e - p e n d e n t l y ? Implementation Wha t p i t f a l l s , h i n t s , or t e c h n i q u e s s h o u l d y ou be awar e of when i m p l e m e n t i n g the pattern ? Are there l a n g u a g e - s p e c i f i c i s s u e s ? S a m p l e C o d e C o de fragment s that illustrat e how you migh t implemen t the patter n in C++ or S m a l l t a l k . K n o w n U s e s E x a m p l e s of t he patter n foun d in r e al s y s t e m s . We i n c l u d e at l e a st t wo e x a m p l e s from differen t d o m a i n s . R e l a t e d P a t t e r n s Wha t d e s i g n pattern s are c l o s e l y r e l a t e d to t h is o n e? Wha t are the importan t d i f f e r e n c e s ? With which other patterns should this one be used? The a p p e n d i c e s p r o v i d e b a c k g r o u n d i n f o r m a t i o n that will help y o u u n d e r s t a n d the pat- t e r n s and the discussions surrounding them. Appendix A is a glossary of terminology ptg8 INTRODUCTION CHAPTER 1 we u s e. W e ' v e alread y m e n t i o n e d Appendi x B, w h i c h p r e s e n t s t he v a r i o u s n o t a t i o n s . W e ' ll a l so d e s c r i b e a s p e c t s of t he notation s as we i n t r o d u c e them in t he u p c o m i n g d i s c u s s i o n s . F i n a l l y , Appendi x C c o n t a i n s s o u r c e c o de f or t he foundatio n c l a s s e s we u s e i n code samples. 1 . 4 The Catalog o f Design Patterns T he c a t a l o g b e g i n n i n g on page 79 c o n t a i n s 23 d e s i g n patterns . T h e ir n a m e s a nd i n t e n t s a re l i s t ed next to g i ve y ou an o v e r v i e w . T he numbe r in p a r e n t h e s e s after e a ch patter n name g i v es the p a ge numbe r for the pattern (a c o n v e n t i o n we f o l l ow throughou t the book). Abstrac t Factor y ( 8 7) P r o v i d e an interfac e f or c r e a t i n g f a m i l i e s of r e l a t e d or d e p e n d e n t o b j e c t s withou t s p e c i f y i n g t h e ir c o n c r e t e c l a s s e s . Adapte r ( 1 3 9) C o n v e r t t he interfac e of a c l a ss into anothe r interfac e c l i e n t s e x p e c t . Adapte r l e ts c l a s s e s work t o g e t h e r that c o u l d n ' t o t h e r w i s e b e c a u s e of i n c o m p a t - i b le interfaces. Bridg e ( 1 5 1) D e c o u p l e an abstractio n from i ts i m p l e m e n t a t i o n so that t he t wo c an vary i n d e p e n d e n t l y . Builde r ( 9 7) Separat e t he c o n s t r u c t i o n of a c o m p l e x o b j e c t from i ts r e p r e s e n t a t i o n so that the s a me c o n s t r u c t i o n p r o c e s s can c r e a t e differen t r e p r e s e n t a t i o n s . Chai n of R e s p o n s i b i l i t y ( 2 2 3) A v o i d c o u p l i n g t he s e n d e r of a r e q u e s t to i ts r e c e i v e r by g i v i n g m o re than o ne o b j e c t a c h a n c e to h a n d l e t he r e q u e s t . C h a in t he r e c e i v i n g o b j e c t s a nd pass t he r e q u e s t a l o ng t he c h a in until an o b j e c t h a n d l e s i t . Comman d ( 2 3 3) Encapsulat e a r e q u e s t as an o b j e c t , t h e r e b y l e t t i n g y ou p a r a m e t e r - i ze c l i e n t s with differen t r e q u e s t s , q u e u e or l og r e q u e s t s , a nd s u p p o r t u n d o a b l e o p e r a t i o n s . C o m p o s i t e ( 1 6 3) C o m p o s e o b j e c t s i n to t r ee s t r u c t u r e s to r e p r e s e n t p a r t - w h o l e h i e r a r - c h i e s . C o m p o s i t e l e ts c l i e n t s treat i n d i v i d u a l o b j e c t s a nd c o m p o s i t i o n s of o b j e c t s uniformly. Decorato r ( 1 7 5) Attac h additiona l r e s p o n s i b i l i t i e s to an o b j e c t d y n a m i c a l l y . D e c o r a t o r s p r o v i d e a f l e x i b l e alternativ e to s u b c l a s s i n g for e x t e n d i n g f u n c t i o n a l i t y . Facad e ( 1 8 5) P r o v i d e a u n i f i e d interfac e to a s et of interface s in a s u b s y s t e m . F a c a d e define s a h i g h e r - l e v e l interfac e that m a k e s t he s u b s y s t e m e a s i er to u s e . Factor y Metho d ( 1 0 7) Defin e an interfac e f or c r e a t i n g an o b j e c t , b ut l et s u b c l a s s e s d e - c i de w h i c h c l a ss to i n s t a n t i a t e . F a c t o r y M e t h o d l e ts a c l a ss defer i n s t a n t i a t i o n to s u b c l a s s e s . ptgSECTION 1.5 ORGANIZING THE CATALOG 9 F l y w e i g h t ( 1 9 5) U se s h a r i n g to suppor t l a r ge number s of fine-graine d o b j e c t s effi- c i e n t l y . Interprete r ( 2 4 3) G i v e n a l a n g u a g e , defin e a r e p r e s e n t i o n for its gramma r a l o ng with an i n t e r p r e t e r that u s es t he r e p r e s e n t a t i o n to i n t e r p r e t s e n t e n c e s in t he l a n g u a g e . I t e r a t o r ( 2 5 7) P r o v i d e a w ay to a c c e s s t he e l e m e n t s of an a g g r e g a t e o b j e c t s e q u e n t i a l l y w i t h o u t e x p o s i n g i ts u n d e r l y i n g r e p r e s e n t a t i o n . Mediato r ( 2 7 3) Defin e an o b j e c t that e n c a p s u l a t e s h ow a s et of o b j e c t s interact . M e - diato r p r o m o t e s l o o se c o u p l i n g by k e e p i n g o b j e c t s from referrin g to e a ch other e x p l i c i t l y , a nd it l e ts y ou vary t h e ir i n t e r a c t i o n i n d e p e n d e n t l y . Mement o ( 2 8 3) Withou t v i o l a t i n g e n c a p s u l a t i o n , captur e a nd externaliz e an o b j e c t ' s i n t e r n a l s t a te so that t he o b j e c t c an be r e s t o r e d to t h is s t a te l a t e r . O b s e r v e r ( 2 9 3) D e f i n e a o n e - t o - m a n y d e p e n d e n c y bet w ee n o b j e c t s so that when o ne o b j e c t c h a n g e s s t a t e, a ll i ts d e p e n d e n t s a re notifie d a nd update d automatically. P r o t o t y p e ( 1 1 7) S p e c i f y t he k i n ds of o b j e c t s to c r e a t e u s i ng a prototypica l i n s t a n c e , a nd c r e a t e n ew o b j e c t s by c o p y i n g t h is prototype. P r o xy ( 2 0 7) P r o v i d e a s u r r o g a t e or p l a c e h o l d e r f or anothe r o b j e c t to c o n t r o l a c c e s s to i t . S i n g l e t o n ( 1 2 7) E n s u r e a c l a ss o n ly h as o ne i n s t a n c e , a nd p r o v i d e a g l o b a l point of a c c e s s to i t . S t a te ( 3 0 5) A l l ow an o b j e c t to a l t er i ts b e h a v i o r w h en i ts interna l s t a te c h a n g e s . T he o b j e c t w i ll appea r to c h a n g e i ts c l a s s . S t r a t e g y ( 3 1 5) D e f i n e a famil y of a l g o r i t h m s , e n c a p s u l a t e e a ch o n e, a nd make t h em i n t e r c h a n g e a b l e . S t r a t e g y l e ts the a l g o r i t h m vary independentl y from c l i e n t s that u se i t . T e m p l a t e Metho d ( 3 2 5) Defin e t he s k e l e t o n of an algorith m in an o p e r a t i o n , deferrin g s o me s t e ps to s u b c l a s s e s . T e m p l a t e M e t h o d l e ts s u b c l a s s e s redefin e certai n s t e ps of an a l g o r i t h m withou t changin g the algorithm' s structure. V i s i t o r ( 3 3 1) R e p r e s e n t an o p e r a t i o n to be performe d on t he e l e m e n t s of an o b j e c t structure . V i s i t o r l e ts y ou defin e a n ew o p e r a t i o n withou t c h a n g i n g t he c l a s s e s of t h e elements on which it operates. 1 . 5 Organizing the C a t a l o g D e s i g n pattern s vary in t h e ir granularit y a nd l e v el of abstraction . B e c a u s e th ere a re many d e s i g n p a t t e r n s , we n e ed a w ay to o r g a n i z e them . T h is s e c t i o n c l a s s i f i e s d e s i g n patterns so that we can refer to families o f r e l a t e d p a t t e r n s . The classification helps you ptg1 0 INTRODUCTION CHAPTER 1 S c o p e C l a s s ObjectPurpose Creational Factor y M e t h o d ( 1 0 7 ) Abstrac t Factor y ( 8 7) B u i l d e r ( 9 7) Prototyp e ( 1 1 7) S i n g l e t o n (127)Structura l Adapte r ( c l a s s ) ( 1 3 9 ) Adapte r ( o b j e c t ) ( 1 3 9) B r i d g e ( 1 5 1) C o m p o s i t e ( 1 6 3) D e c o r a t o r ( 1 7 5) F a c a d e ( 1 8 5) F l y w e i g h t ( 1 9 5) P r o x y ( 2 0 7 )Behaviora l Interprete r ( 2 4 3 ) Templat e M e t h o d ( 3 2 5) Chain of R e s p o n s i b i l i t y ( 2 2 3) Command (233) Iterator (257) Mediator (273) M e m e n t o ( 2 8 3 ) O b s e r v e r (293) S t a t e ( 3 0 5 ) Strategy (315) V i s i t o r ( 3 3 1 ) T a b le 1 . 1: D e s i g n pattern s p a c e learn the pattern s in the c a t a l o g faster , and it can d i r e c t effort s to find new pattern s as w e l l . We classif y d e s i g n pattern s by two c r i t e r i a ( T a b l e 1 . 1 ). T he f i r st c r i t e r i o n , c a l l ed p u r p o s e , reflect s what a patter n d o e s. Pattern s c an have e i t h e r c r e a t i o n a l , s t r u c t u r a l , or b e h a v - i o r al p u r p o s e . Creationa l pattern s c o n c e r n t he p r o c e s s of o b j e c t c r e a t i o n . Structura l pattern s deal with t he c o m p o s i t i o n of c l a s s e s or o b j e c t s . B e h a v i o r a l pattern s c h a r a c t e r - i ze t he ways in whic h c l a s s e s or o b j e c t s interac t a nd d i s t r i b u t e r e s p o n s i b i l i t y . T he s e c o n d c r i t e r i o n , c a l l ed s c o p e , s p e c i f i e s whethe r t he patter n a p p l i e s p r i m a r i l y to c l a s s e s or to o b j e c t s . C l a ss pattern s d e al with r e l a t i o n s h i p s betwee n c l a s s e s a nd t h e ir s u b c l a s s e s . T h e se r e l a t i o n s h i p s a re e s t a b l i s h e d throug h i n h e r i t a n c e , so they a re s t a t i c — f i x ed at c o m p i l e - t i m e . O b j e c t pattern s d e al with o b j e c t r e l a t i o n s h i p s , w h i c h c an be c h a n g e d at run-tim e and are m o re d y n a m i c . A l m o s t all pattern s use i n h e r i t a n c e to s o me extent . So t he o n ly pattern s l a b e l e d \" c l a ss p a t t e r n s \" a re t h o se that focus on c l a ss r e l a t i o n s h i p s . Note that m o st pattern s a re in t he O b j e c t s c o p e . C r e a t i o n a l c l a ss pattern s defer s o me part of o b j e c t c r e a t i o n to s u b c l a s s e s , w h i le C r e - ationa l o b j e c t pattern s defer it to anothe r o b j e c t . T he Structura l c l a ss pattern s u se i n h e r i t a n c e to c o m p o s e c l a s s e s , w h i le t he S t r u c t u r a l o b j e c t pattern s d e s c r i b e ways to a s s e m b l e o b j e c t s . T he B e h a v i o r a l c l a ss pattern s u se i n h e r i t a n c e to d e s c r i b e a l g o r i t h m s a nd f l ow of c o n t r o l , w h e r e a s t he B e h a v i o r a l o b j e c t pattern s d e s c r i b e h ow a group of o b j e c t s c o o p e r a t e to perfor m a task that no s i n g le o b j e c t can c a r ry out a l o n e . T h e re a re other ways to o r g a n i z e t he patterns . S o me p a t t e r n s a re often u s ed t o g e t h e r . F or e x a m p l e , C o m p o s i t e is often u s ed with Iterato r or V i s i t o r . S o me pattern s a re a l t e r n a t i v e s : Prototyp e is often an alternativ e to Abstrac t F a c t o r y . S o me pattern s r e s u lt in s i m i l a r d e s i g n s e v en thoug h the pattern s have differen t i n t e n t s . For e x a m p l e , the structur e d i a g r a m s of Composite and Decorator are similar. ptgSECTION 1 .6 H OW DESIGN PATTERNS SOLVE DESIGN PROBLEMS 1 1 Yet anothe r way to organiz e d e s i g n pattern s is a c c o r d i n g to how they referenc e e a ch other in their \" R e l a t e d Patterns \" s e c t i o n s . F i g u r e 1 .1 depict s these relationship s graph- i c a l l y . C l e a r l y there are many ways to o r g a n i z e d e s i g n patterns . Havin g multipl e ways of thinkin g abou t pattern s w i ll d e e p e n your i n s i g h t into w h at they d o, how they c o m p a r e , and when to apply them. 1 . 6 How Design Patterns Solve Design Problems D e s i g n pattern s s o l ve many of the day-to-da y p r o b l e m s object-oriente d d e s i g n e r s face, and in many differen t ways . H e re are s e v e r a l of t h e se p r o b l e m s and how d e s i g n pattern s s o l ve them. F i n d i n g A p p r o p r i a t e Objects O b j e c t - o r i e n t e d program s are made up of o b j e c t s . An objec t p a c k a g e s both data and the p r o c e d u r e s that operat e on that data. The p r o c e d u r e s are t y p i c a l l y c a l l ed method s or operations . An o b j e c t perform s an operatio n when it r e c e i v e s a reques t (or m e s s a g e ) from a client. Request s are the only way to get an o b j e c t to execut e an operation . O p e r a t i o n s are the only way to c h a n g e an o b j e c t ' s interna l data. B e c a u s e of these r e s t r i c t i o n s , the object' s interna l state is s a id to be encapsulated ; it canno t be a c c e s s e d d i r e c t l y , a nd i ts representatio n is i n v i s i b l e from outsid e t he object. T he hard part abou t o b j e c t - o r i e n t e d d e s i g n is d e c o m p o s i n g a s y s t e m into o b j e c t s . T he task is difficul t b e c a u s e many factor s c o me into play: encapsulation , granularity , depen- d e n c y , f l e x i b i l i t y , performance , e v o l u t i o n , r e u s a b i l i t y , a nd on a nd o n. T h ey a ll influenc e t he d e c o m p o s i t i o n , often in c o n f l i c t i n g ways. O b j e c t - o r i e n t e d d e s i g n m e t h o d o l o g i e s favor many differen t approaches . You can write a p r o b l e m statement , s i n g le out the noun s and v e r b s , and creat e correspondin g c l a s s e s and o p e r a t i o n s . Or you can focus on the c o l l a b o r a t i o n s and r e s p o n s i b i l i t i e s in your system . Or you can m o d e l the r e al world and translat e the o b j e c t s found durin g analysi s into d e s i g n . T h e re w i ll alway s be disagreemen t on whic h approac h is best. Many o b j e c t s in a d e s i g n c o me from the analysi s model . But object-oriente d d e s i g n s often end up with c l a s s e s that have no counterpart s in the r e al world . S o me of these are l o w - l e v e l c l a s s e s l i ke arrays . Other s a re much h i g h e r - l e v e l . F or e x a m p l e , t he C o m p o s - ite ( 1 6 3) patter n i n t r o d u c e s an abstractio n for treatin g o b j e c t s uniforml y that d o e s n ' t have a physica l counterpart . S t r i ct m o d e l i n g of the r e al world l e a ds to a s y s t e m that reflect s today' s r e a l i t i e s but not n e c e s s a r i l y tomorrow's . The abstraction s that e m e r g e during design are key to making a design f l e x i b l e . ptg1 2 INTRODUCTION CHAPTER 1 F i g u r e 1.1: Design pattern relationships ptgSECTION 1.6 HOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS 13 D e s i g n pattern s h e lp you identif y l e s s - o b v i o u s abstraction s and the o b j e c t s t h at can captur e them . For example , object s t h at represen t a p r o c e s s or algorith m don't occur in nature , yet they are a crucia l part of flexibl e d e s i g n s . The Strateg y ( 3 1 5) patter n d e s c r i b e s how to implemen t interchangeabl e familie s of algorithms . The State ( 3 0 5) patter n represent s each state of an entity as an object . T h e se object s are seldo m f o u n d durin g analysi s or e v en the early stage s of d e s i g n ; they'r e d i s c o v e r e d later in the cours e of makin g a d e s i g n more flexibl e and reusable. D e t e r m i n i n g Objec t G r a n u l a r i t y O b j e c t s can vary tremendousl y in s i ze and number . T h ey can represen t everythin g down to the hardwar e or all the way up to entire applications . How do we d e c i d e w h at shoul d be an object? D e s i g n pattern s addres s this i s s ue as w e l l. The F a c a d e ( 1 8 5) patter n d e s c r i b e s how to represen t complet e subsystem s as objects , and the F l y w e i g h t ( 1 9 5) p a t t e r n d e s c r i b e s how to suppor t huge number s of o b j e c t s at the fines t granularities . Othe r d e s i g n pat- terns d e s c r i b e specifi c ways of decomposin g an objec t into smalle r objects . Abstrac t Factor y ( 8 7) and Builde r ( 9 7) y i e ld object s whos e only r e s p o n s i b i l i t i e s are creatin g other ob j ects . Visito r ( 3 3 1) a nd Comman d ( 2 3 3) y i e ld object s whos e only r e s p o n s i b i l i t i e s a re to implemen t a r e q u e s t on anothe r objec t or group of objects. Specifyin g Objec t Interfaces Every operatio n d e c l a r e d by an objec t specifie s the operation' s name , the object s it takes as parameters , and the operation' s retur n value . T h is is know n as the operation' s s i g n a t u r e . T he s et of a ll signature s define d by an object' s operation s is c a l l ed t he interfac e to the object . An object' s interfac e characterize s the complet e set of request s t h at can be sent to the object . Any r e q u e s t t h at matche s a signatur e in the object' s interfac e may be s e nt to the object. A type is a name used to denot e a particula r interface . We speak of an o b j e c t as havin g the type \" W i n d o w \" if it accept s all request s for the operation s define d in the interfac e name d \" W i n d o w . \" An o b j e c t may have many types , and widel y differen t object s can share a type. Part of an object' s interfac e may be characterize d by one type, and other parts by other t y p e s . Two object s of the same type need o n ly share parts of their interfaces . Interface s can contai n other interface s as s u b s e t s . We say t h at a type is a s u b t y p e of anothe r if i ts interfac e contain s t he interfac e of i ts s u p e r t y p e . Often we speak of a subtyp e inheriting the interfac e of its supertype. Interface s are f u n d a m e n t a l in object-oriente d systems . O b j e c t s are know n only throug h their interfaces . T h e re is no way to know anythin g abou t an objec t or to ask it to do anythin g withou t g o i ng throug h its interface . An object' s interfac e says nothin g abou t its implementation—different o b j e c t s are f r e e t o implement requests d i f f e r e n t l y . T h a t ptg14 INTRODUCTION CHAPTER 1 mean s two o b j e c t s havin g c o m p l e t e l y differen t implementation s can h a ve i d e n t i c a l interfaces. Whe n a r e q u e s t is s e nt to an o b j e c t , the particula r operatio n that's performe d d e p e n d s on both the r e q u e s t and the r e c e i v i n g o b j e c t . Differen t o b j e c t s that s u p p o r t i d e n t i c a l r e q u e s t s may have differen t implementation s of the o p e r a t i o n s that fulfil l t h e se r e q u e s t s . The run-tim e a s s o c i a t i o n of a reques t to an o b j e c t a nd o ne of i ts o p e r a t i o n s is know n as d y n a m i c b i n d i n g . Dynami c bindin g mean s that i s s u i n g a r e q u e s t d o e s n ' t c o m m i t you to a particula r implementatio n until run-time . C o n s e q u e n t l y , you can write program s that e x p e c t an objec t with a particula r interface , knowin g that any o b j e c t that has the c o r r e c t interfac e w i ll a c c e p t the r e q u e s t . M o r e o v e r , dynami c bindin g l e ts you substitut e o b j e c t s that have identica l interface s for e a ch other at run-time . T h is substitutabilit y is know n as p o l y m o r p h i s m , a nd it's a k ey c o n c e p t in o b j e c t - o r i e n t e d s y s t e m s . It l e ts a c l i e nt o b j e c t make few assumption s abou t other object s b e y o n d supportin g a particula r interface . Polymorphis m s i m p l i f i e s t he definition s of c l i e n t s , d e c o u p l e s o b j e c t s from e a ch o t h e r , and l e ts them vary their relationship s to each other at run-time. D e s i g n pattern s help you defin e interface s by identifyin g t h e ir key e l e m e n t s and the kinds of data t h at get s e nt a c r o s s an interface . A d e s i g n patter n migh t a l so t e ll you what not to put in the interface . The Mement o ( 2 8 3) patter n is a g o od e x a m p l e . It d e s c r i b e s how to encapsulat e and s a ve the interna l state of an o b j e c t so that the o b j e c t can be restore d to that state later. The patter n stipulate s that Mement o o b j e c t s must defin e two interfaces : a r e s t r i c t e d o ne that l e ts c l i e n t s h o ld a nd c o py m e m e n t o s , a nd a p r i v i l e g e d one that only the origina l o b j e c t can use to store and retriev e state in the memento. D e s i g n pattern s a l so specif y relationship s betwee n interfaces . In particular , they often requir e some c l a s s e s to have s i m i l a r interfaces , or they p l a ce constraint s on the interface s of s o me c l a s s e s . F or e x a m p l e , both Decorato r ( 1 7 5) a nd P r o xy ( 2 0 7) r e q u i r e t he interface s of Decorato r and P r o xy object s to be identica l to the decorate d and p r o x i e d o b j e c t s . In Visito r ( 3 3 1 ) , t he V i s i t o r interfac e must reflec t a ll c l a s s e s of o b j e c t s that v i s i t o r s c an v i s i t . Specifyin g Objec t Implementations So far we've s a id little abou t how we actuall y defin e an object . An o b j e c t ' s i m p l e - mentatio n is define d by i ts c l a s s . T he c l a ss s p e c i f i e s t he o b j e c t ' s interna l data and representatio n and define s the operation s the o b j e c t can perform. O ur O M T - b a s e d notatio n (summarize d in A p p e n d i x B) d e p i c t s a c l a ss as a r e c t a n g l e with the c l a ss name in bold. Operation s appea r in norma l type b e l ow the c l a ss name . Any data that the c l a ss define s c o m e s a f t er the operations . L i n es s e p a r a t e the c l a ss name from the operations and the operations f r o m the data: ptgSECTION 1 . 6 HOW D E S I G N P A T T E R N S S O L V E D E S I G N P R O B L E M S 1 5 Retur n t y p es a nd i n s t a n c e v a r i a b l e t y p es a re o p t i o n a l , s i n ce we d o n 't a s s u m e a s t a t i c a l l y t y p ed implementatio n language. O b j e c t s a re c r e a t e d by i n s t a n t i a t i n g a c l a s s. T he o b j e c t is s a id to be an i n s t a n c e of t he c l a s s. T he p r o c e s s of instantiatin g a c l a ss a l l o c a t e s s t o r a g e f or t he o b j e c t ' s interna l data (mad e up of instanc e variables ) and a s s o c i a t e s the o p e r a t i o n s with t h e se data. Man y s i m i l a r i n s t a n c e s of an o b j e c t c an be c r e a t e d by instantiatin g a c l a s s . A d a s h e d arrowhea d l i ne i n d i c a t e s a c l a ss that instantiate s o b j e c t s of anothe r c l a s s. T he a r r o w points to the class of the instantiated objects. N ew c l a s s e s c an be define d in terms of e x i s t i n g c l a s s e s using c l a ss inheritance . Whe n a s u b c l a s s inherit s from a paren t c l a s s, it include s the definition s of all the data and o p e r a t i o n s that the paren t c l a ss defines . O b j e c t s that are i n s t a n c e s of the s u b c l a s s w i ll contai n all data define d by the s u b c l a s s and its paren t c l a s s e s , and they'l l be a b le to perfor m a ll o p e r a t i o n s d e f i n e d by t h is s u b c l a s s a nd i ts p a r e n t s . We i n d i c a t e t he s u b c l a s s r e l a t i o n s h i p w i t h a vertical line and a triangle: An a b s t r a c t c l a ss is o ne w h o s e m a in p u r p o s e is to d e f i n e a c o m m o n i n t e r f a c e f or i ts s u b c l a s s e s . An a b s t r a c t c l a ss w i ll defer s o me or a ll of i ts implementatio n to operation s define d in s u b c l a s s e s ; h e n ce an abstrac t c l a ss canno t be instantiated . T he operation s that an abstrac t c l a ss d e c l a r e s b ut d o e s n ' t implemen t a re c a l l ed abstrac t operations . C l a s s e s t h a t a r e n ' t a b s t r a c t are called concrete classes. ptg1 6 INTRODUCTION CHAFTER 1 S u b c l a s s e s c an refine a nd redefin e b e h a v i o r s of their paren t c l a s s e s . M o re s p e c i f i c a l l y , a c l a ss m ay overrid e an o p e r a t i o n d e f i n e d by i ts paren t c l a s s. O v e r r i d i n g g i v es s u b c l a s s e s a c h a n c e to handl e r e q u e s t s i n s t e a d of t h e ir paren t c l a s s e s . C l a ss i n h e r i t a n c e l e ts y ou defin e c l a s s e s s i m p l y by e x t e n d i n g o t h er c l a s s e s , makin g it e a sy to defin e f a m i l i e s of o b j e c t s h a v i n g r e l a t e d f u n c t i o n a l i t y . T he n a m e s of a b s t r a c t c l a s s e s appea r in s l a n t e d type to d i s t i n g u i s h them from c o n c r e t e c l a s s e s . S l a n t e d type is a l so u s ed to d e n o t e a b s t r a c t o p e r a t i o n s . A d i a g r a m m ay i n c l u d e p s e u d o c o d e f o r a n operation's implementation; if so, the c o d e w i l l a p p e a r in a dog- e a r e d box connected by a dashed line to the operation it implements. A mixin c l a ss is a c l a ss that's i n t e n d e d to p r o v i d e an o p t i o n a l i n t e r f a c e or functionalit y to other c l a s s e s . I t 's s i m i l a r to an a b s t r a c t c l a ss in that i t 's n ot i n t e n d e d to be i n s t a n t i a t e d . M i x i n classes require multiple inheritance: C l a ss v e r s u s I n t e r f a c e I n h e r i t a n c e It's importan t to understan d the differenc e b e t w e e n an o b j e c t ' s class and its type. An o b j e c t ' s c l a ss d e f i n e s h ow t he o b j e c t is i m p l e m e n t e d . T he c l a ss d e f i n e s t he o b j e c t ' s interna l state a nd t he implementatio n of i ts o p e r a t i o n s . In c o n t r a s t , an o b j e c t ' s t y pe o n ly refers to i ts interface—th e s et of r e q u e s t s to w h i c h it c an r e s p o n d . An o b j e c t c an have many types, and objects of different c l a s s e s can have the same type. ptgSECTION 1.6 HOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS 17 Of c o u r s e , t h e r e ' s a c l o se r e l a t i o n s h i p b e t w e e n c l a ss a nd t y p e. B e c a u s e a c l a ss d e f i n e s the operation s an o b j e c t can perform , it a l so define s the o b j e c t ' s type. Whe n we say that an objec t is an instanc e of a c l a s s , we imply that the o b j e c t support s the interfac e d e f i n e d by t he c l a s s . L a n g u a g e s l i ke C ++ a nd Eiffe l u se c l a s s e s to s p e c i f y both an o b j e c t ' s t y pe a nd i ts i m p l e - mentation . S m a l l t a l k program s do n ot d e c l a r e t he t y p es of v a r i a b l e s ; c o n s e q u e n t l y , t he c o m p i l e r d o es n ot c h e ck that t he t y p es of o b j e c t s a s s i g n e d to a v a r i a b l e a re subtype s of t he v a r i a b l e ' s t y p e. S e n d i n g a m e s s a g e r e q u i r e s c h e c k i n g that t he c l a ss of t he r e c e i v e r implement s the m e s s a g e , but it doesn' t r e q u i r e c h e c k i n g that the r e c e i v e r is an instanc e of a particula r c l a s s . It's a l so importan t to understan d the differenc e betwee n c l a ss i n h e r i t a n c e and interfac e inheritanc e ( or subtyping) . C l a ss i n h e r i t a n c e define s an o b j e c t ' s i m p l e m e n t a t i o n in terms of a n o t h e r o b j e c t ' s i m p l e m e n t a t i o n . In s h o r t , i t 's a m e c h a n i s m f or c o de a nd representatio n sharing . In contrast , interfac e inheritanc e (or s u b t y p i n g ) d e s c r i b e s when an o b j e c t c an be u s ed in p l a ce of another. I t 's e a sy to confus e t h e se two c o n c e p t s , b e c a u s e many l a n g u a g e s don't make the d i s - t i n c t i o n e x p l i c i t . In l a n g u a g e s l i ke C ++ a nd Eiffel , i n h e r i t a n c e m e a n s both i n t e r f a c e and implementatio n inheritance . The standar d way to i n h e r i t an interfac e in C++ is to i n h e r i t publicl y f r om a c l a ss that has (pure ) virtua l membe r functions . P u re inter- face i n h e r i t a n c e c an be a p p r o x i m a t e d in C ++ by i n h e r i t i n g p u b l i c l y from pure a b s t r a c t c l a s s e s . Pure implementatio n or c l a ss inheritanc e c an be a p p r o x i m a t e d with privat e inheritance . In S m a l l t a l k , inheritanc e mean s just implementatio n i n h e r i t a n c e . You can a s s i g n i n s t a n c e s of a ny c l a ss to a v a r i a b l e as l o ng as t h o se i n s t a n c e s suppor t t he o p e r a - t i on performe d on the value of the v a r i a b l e . Althoug h most programmin g l a n g u a g e s don't suppor t the d i s t i n c t i o n betwee n i n t e r - face and implementatio n i n h e r i t a n c e , p e o p l e make the distinctio n in p r a c t i c e . S m a l l t a l k programmer s usuall y a ct as if s u b c l a s s e s w e re subtype s (thoug h there a re s o me w e l l - know n e x c e p t i o n s [ C o o 9 2 ] ) ; C ++ p r o g r a m m e r s m a n i p u l a t e o b j e c t s t h r o u g h t y p es d e - fined by abstrac t c l a s s e s . Many of the d e s i g n pattern s d e p e n d on this distinction . For e x a m p l e , o b j e c t s in a Chai n of R e s p o n s i b i l i t y ( 2 2 3) must have a commo n t y p e, b ut usuall y they don't s h a re a c o m - m on i m p l e m e n t a t i o n . In t he C o m p o s i t e ( 1 6 3) p a t t e r n , C o m p o n e n t d e f i n e s a c o m m o n interface , but Composit e often define s a commo n implementation . Comman d ( 2 3 3 ) , O b s e r v e r ( 2 9 3 ) , State ( 3 0 5 ) , a nd Strateg y ( 3 1 5) a re often implemente d with abstrac t c l a s s e s that a re p u re i n t e r f a c e s . P r o g r a m m i n g to an I n t e r f a c e , n ot an I m p l e m e n t a t i o n C l a ss inheritanc e is b a s i c a l l y just a mechanis m for extendin g an application' s function- a l i ty by r e u s i n g f u n c t i o n a l i t y in paren t c l a s s e s . It l e ts y ou d e f i n e a n ew k i nd of o b j e c t rapidl y in term s of an old o n e. It l e ts you get new implementation s a l m o s t for f r e e, inheriting most of what you need from existing classes. ptg18 INTRODUCTION CHAPTER 1 H o w e v e r , i m p l e m e n t a t i o n r e u se is o n ly h a lf t he s t o r y . I n h e r i t a n c e ' s a b i l i t y to d e f i n e familie s of o b j e c t s with identical interface s ( u s u a l l y by i n h e r i t i n g from an abstrac t c l a s s) is a l so i m p o r t a n t . W h y ? B e c a u s e p o l y m o r p h i s m d e p e n d s on i t . W h en i n h e r i t a n c e is u s ed c a r e f u l l y ( s o m e w i ll s ay properly), a ll c l a s s e s d e r i v e d from an abstrac t c l a ss w i l l s h a re i ts interface . T h is i m p l i e s that a s u b c l a s s m e r e l y a d ds or o v e r r i d e s o p e r a t i o n s a nd d o es n ot h i de o p e r a t i o n s of t he paren t c l a s s. A ll s u b c l a s s e s c an t h en r e s p o n d to t he r e q u e s t s in t he interfac e of t h is abstrac t c l a s s, m a k i n g them a ll s u b t y p e s of t he abstrac t c l a s s . T h e re a re t wo benefit s to manipulatin g o b j e c t s s o l e ly in terms of t he interfac e d e f i n e d by abstrac t c l a s s e s : 1. C l i e n t s r e m a i n unawar e of t he s p e c i f i c t y p es of o b j e c t s t h ey u s e, as l o ng as t he o b j e c t s a d h e r e to the interfac e that c l i e n t s e x p e c t . 2. C l i e n t s r e m a i n unawar e of t he c l a s s e s that i m p l e m e n t t h e s e o b j e c t s . C l i e n t s o n ly k n ow abou t t he a b s t r a c t c l a s s ( e s ) definin g t he interface. T h is so greatl y r e d u c e s implementatio n d e p e n d e n c i e s betwee n su bsy s tem s that it l e a ds to t he f o l l o w i n g p r i n c i p l e of r e u s a b l e o b j e c t - o r i e n t e d d e s i g n : Program to an interface, not an implementation. D o n ' t d e c l a r e v a r i a b l e s to be i n s t a n c e s of particula r c o n c r e t e c l a s s e s . I n s t e a d , c o m m i t o n ly to an i n t e r f a c e d e f i n e d by an a b s t r a c t c l a s s. Y ou w i ll f i nd t h is to be a c o m m o n them e of t he d e s i g n pattern s in t h is book. Y ou h a ve to instantiat e c o n c r e t e c l a s s e s (that i s, specif y a particula r i m p l e m e n t a t i o n ) s o m e w h e r e in your s y s t e m , of c o u r s e , a nd t he c r e a t i o n a l p a t t e r n s ( A b s t r a c t F a c t o r y ( 8 7 ), B u i l d e r ( 9 7 ), Factor y M e t h o d ( 1 0 7 ) , Prototyp e ( 1 1 7 ) , a nd S i n g l e t o n ( 1 2 7 ) ) l et y ou do just th a t. By a b s t r a c t i n g t he p r o c e s s of o b j e c t c r e a t i o n , t h e se p a t t e r n s g i ve y ou differen t ways to a s s o c i a t e an interfac e with its implementatio n transparentl y at i n s t a n t i a t i o n . C r e a t i o n a l pattern s e n s u r e that your s y s t e m is writte n in terms of i n t e r f a c e s , n ot i m p l e - m e n t a t i o n s . P u t t i n g R e u s e M e c h a n i s m s to W o r k M o st p e o p l e c an understan d c o n c e p t s l i ke o b j e c t s , interfaces , c l a s s e s , a nd i n h e r i t a n c e . T he c h a l l e n g e l i es in applyin g them to b u i ld f l e x i b l e , r e u s a b l e software , a nd d e s i g n pattern s c an s h ow y ou h o w . I n h e r i t a n c e v e r s u s C o m p o s i t i o n T he t wo m o st c o m m o n t e c h n i q u e s f or r e u s i n g functionalit y in o b j e c t - o r i e n t e d s y s t e m s a r e class inheritance and object composition. A s w e ' v e e x p l a i n e d , c l a s s i n h e r i t a n c e l e t s ptgSECTION 1.6 HOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS 19 y ou defin e t he implementatio n of o ne c l a ss in terms of another's . Reus e by s u b c l a s s i n g is often referre d to as white-bo x reuse . The term \" w h i t e - b o x \" refers to v i s i b i l i t y : With i n h e r i t a n c e , t he i n t e r n a l s of paren t c l a s s e s a re often v i s i b l e to s u b c l a s s e s . O b j e c t c o m p o s i t i o n is an a l t e r n a t i v e to c l a ss i n h e r i t a n c e . H e r e, n ew f u n c t i o n a l i t y is obtaine d by a s s e m b l i n g or composing o b j e c t s to get more c o m p l e x functionality . O b j e c t c o m p o s i t i o n r e q u i r e s that t he o b j e c t s b e i ng c o m p o s e d h a ve w e l l - d e f i n e d i n t e r f a c e s . T h is s t y le of r e u se is c a l l ed black-bo x reuse , b e c a u s e no interna l d e t a i l s of o b j e c t s a re v i s i b l e . O b j e c t s appea r o n ly as \" b l a c k b o x e s . \" Inheritanc e a nd c o m p o s i t i o n e a ch have their advantage s a nd disadvantages . C l a ss inheritanc e is define d staticall y at c o m p i l e - t i m e a nd is straightforwar d to u s e, s i n ce i t 's supporte d d i r e c t l y by the programmin g language . C l a ss inheritanc e a l so make s it e a s i er to modif y t he i m p l e m e n t a t i o n b e i ng r e u s e d . W h en a s u b c l a s s o v e r r i d e s s o me but not all operations , it can a f f e c t the operation s it inherit s as w e l l, assumin g they c a ll the overridde n o p e r a t i o n s . B ut c l a ss i n h e r i t a n c e h as s o me d i s a d v a n t a g e s , t o o. F i r s t, y ou c a n 't c h a n g e t he i m p l e - mentation s i n h e r i t e d from paren t c l a s s e s at run-time , becaus e inheritanc e is define d at c o m p i l e - t i m e . S e c o n d , a nd g e n e r a l l y w o r s e , paren t c l a s s e s often defin e at l e a st part of t h e ir s u b c l a s s e s ' p h y s i c a l representation . B e c a u s e inheritanc e e x p o s e s a s u b c l a s s to d e t a i l s of its parent' s implementation , i t 's often s a id that \" i n h e r i t a n c e break s e n c a p - s u l a t i o n \" [ S n y 8 6 ] . T he i m p l e m e n t a t i o n of a s u b c l a s s b e c o m e s so b o u n d up w i th t he implementatio n of its paren t c l a ss that any c h a n g e in the parent' s implementatio n w i ll force the s u b c l a s s to c h a n g e . I m p l e m e n t a t i o n d e p e n d e n c i e s c an c a u se p r o b l e m s w h en y o u ' r e trying to r e u se a s u b - c l a s s. S h o u l d any a s p e c t of the inherite d implementatio n not be appropriat e for new p r o b l e m domains , the paren t c l a ss must be rewritte n or r e p l a c e d by somethin g m o re appropriate . T h is dependenc y limits f l e x i b i l i t y a nd ultimatel y r e u s a b i l i t y . O ne c u re for this is to inheri t o n ly from abstrac t c l a s s e s , s i n ce they usuall y provid e little or no i m p l e m e n t a t i o n . O b j e c t compositio n is define d dynamicall y at run-tim e throug h o b j e c t s a c q u i r i n g refer- e n c es to other ob j ect s . C o m p o s i t i o n r e q u i r e s object s to r e s p e c t e a ch others ' interfaces , w h i c h in turn r e q u i r e s c a r e f u l l y d e s i g n e d i n t e r f a c e s that don't s t op y ou from u s i ng one o b j e c t with many others . But there is a p a y o f f . B e c a u s e o b j e c t s are a c c e s s e d s o l e ly throug h their interfaces , we don't break encapsulation . Any o b j e c t can be r e p l a c e d at run-tim e by anothe r as l o ng as it has the same type. M o r e o v e r , becaus e an o b j e c t ' s im- plementatio n w i ll be writte n in terms of o b j e c t interfaces , there are substantiall y fewe r i m p l e m e n t a t i o n d e p e n d e n c i e s . O b j e c t c o m p o s i t i o n h as anothe r effec t on s y s t e m d e s i g n . F a v o r i n g o b j e c t c o m p o s i t i o n o v er c l a ss inheritanc e h e l ps you keep e a ch c l a ss encapsulate d and focuse d on one task. Y o ur c l a s s e s a nd c l a ss h i e r a r c h i e s w i ll r e m a i n s m a ll a nd w i ll be l e ss l i k e ly to g r ow i n to unmanageabl e monsters . On the other hand , a d e s i g n b a s ed on o b j e c t c o m p o s i t i o n w i ll have more o b j e c t s (if fewe r c l a s s e s ) , and the system' s behavio r w i ll depen d on their interrelationships instead of being defined i n o n e class. ptg2 0 INTRODUCTION CHAPTER 1 That l e a ds us to o ur s e c o n d p r i n c i p l e of object-oriente d d e s i g n : Favor object composition over class inheritance. I d e a l l y , you shouldn' t have to c r e a t e new component s to a c h i e v e r e u s e . You s h o u l d be a b le to get all the functionalit y you n e ed just by a s s e m b l i n g e x i s t i n g component s throug h o b j e c t c o m p o s i t i o n . B ut t h is is r a r e ly t he c a s e, b e c a u s e t he s et of a v a i l a b l e component s is n e v er q u i te rich enoug h in p r a c t i c e . R e u s e by inheritanc e make s it e a s i e r to m a ke n ew c o m p o n e n t s that c an be c o m p o s e d with o ld o n e s. I n h e r i t a n c e a nd o b j e c t c o m p o s i t i o n thus work together. N e v e r t h e l e s s , our e x p e r i e n c e is that d e s i g n e r s o v e r u s e inheritanc e as a r e u se t e c h n i q u e , and d e s i g n s are o f t en made m o re r e u s a b l e (and s i m p l e r ) by d e p e n d i n g m o re on ob- ject c o m p o s i t i o n . Y o u ' l l s ee o b j e c t c o m p o s i t i o n a p p l i e d again a nd again in t he d e s i g n patterns. Delegation Delegatio n is a way of makin g c o m p o s i t i o n as powerfu l for r e u se as i n h e r i - t a n ce [ L i e 8 6 , J Z 9 1 1 . In d e l e g a t i o n , t wo o b j e c t s a re i n v o l v e d in handlin g a r e q u e s t : a r e c e i v i n g o b j e c t delegate s o p e r a t i o n s to i ts delegate . T h is is analogou s to s u b c l a s s e s d e f e r r i n g r e q u e s t s to p a r e n t c l a s s e s . B ut with i n h e r i t a n c e , an i n h e r i t e d o p e r a t i o n c an alway s refer to the r e c e i v i n g objec t throug h the t h is m e m b e r variabl e in C++ and sel f in S m a l l t a l k . To a c h i e v e t he s a me effect with d e l e g a t i o n , t he r e c e i v e r p a s s e s i t s e lf to the d e l e g a t e to let the delegate d operatio n refer to the r e c e i v e r . F or e x a m p l e , instea d of makin g c l a ss Windo w a s u b c l a s s of Rectangl e ( b e c a u s e win- d o ws h a p p e n to be rectangular) , the Windo w c l a ss migh t r e u se the behavio r of Rectan- gle by k eep i n g a R e c t a n g l e i n s t a n c e v a r i a b l e and delegating R e c t a n g l e - s p e c i f i c behavio r to it. In other w o r d s , i n s t e a d of a W i n d o w being a R e c t a n g l e , it woul d have a Rectangle . W i n d o w must now forwar d r e q u e s t s to its Rectangl e instanc e e x p l i c i t l y , w h e r e a s befor e it w o u l d h a ve i n h e r i t e d t h o se o p e r a t i o n s . The followin g diagra m d e p i c t s the W i n d o w c l a ss delegatin g its A r ea operatio n to a R e c t a n g l e instance. ptgSECTION 1.6 HOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS 21 A p l a in a r r o w h e a d l i ne i n d i c a t e s that a c l a ss k e e ps a r e f e r e n c e to an i n s t a n c e of anothe r c l a s s. The referenc e has an optiona l name , \" r e c t a n g l e \" in this c a s e . The main advantag e of delegatio n is that it make s it e a sy to c o m p o s e b e h a v i o r s at run-tim e and to chang e the way they'r e c o m p o s e d . Our windo w can b e c o m e c i r c u l a r at run-tim e s i m p l y by r e p l a c i n g its Rectangl e instanc e with a C i r c le instance , assumin g Rectangl e and C i r c l e have the same type. Delegatio n has a disadvantag e it s h a r e s with other technique s that make softwar e m o re f l e x i b l e throug h o b j e c t c o m p o s i t i o n : D y n a m i c , h i g h l y p a r a m e t e r i z e d softwar e is harde r to understan d than m o re static software . T h e re are a l so run-time i n e f f i c i e n c i e s , but the h u m a n inefficiencie s are more importan t in the l o ng run. D e l e g a t i o n is a g o od d e s i g n c h o i c e o n ly when it s i m p l i f i e s more than it c o m p l i c a t e s . It i s n 't e a sy to g i ve r u l es that t e ll you exactl y when to use d e l e g a t i o n , b e c a u s e how effectiv e it w i ll be d e p e n d s on the contex t and on how much e x p e r i e n c e you have with it. D e l e g a t i o n work s b e st when it's u s ed in highl y s t y l i z e d ways—tha t is, in standar d patterns. S e v e r a l desig n pattern s u se delegation . T he State ( 3 0 5 ) , Strateg y ( 3 1 5 ) , a nd Visito r ( 3 3 1) pattern s depen d on it. In the State pattern , an objec t d e l e g a t e s r e q u e s t s to a State o b j e c t that r e p r e s e n t s i ts c u r r e n t s t a t e. In t he S t r a t e g y pattern , an o b j e c t d e l e g a t e s a s p e c i f i c r e q u e s t to an objec t that represent s a strategy for carryin g out the request . An o b j e c t w i ll o n ly have one s t a t e, but it can have many s t r a t e g i e s for differen t r e q u e s t s . The purpos e of both pattern s is to c h a n g e the behavio r of an o b j e c t by changin g the o b j e c t s to w h i c h it delegate s r e q u e s t s . In V i s i t o r , the operatio n that g e ts performe d on e a ch elemen t of an o b j e c t structur e is a l w a y s d e l e g a t e d to t he V i s i t o r o b j e c t . O t h e r pattern s u se d e l e g a t i o n l e ss h e a v i l y . M e d i a t o r ( 2 7 3) i n t r o d u c e s an o b j e c t to m e d i - ate communicatio n betwee n other objects . S o m e t i m e s the Mediato r o b j e c t implement s operation s s i m p l y by forwardin g them to the other o b j e c t s ; other times it p a s s e s along a referenc e to i t s e lf a nd thus u s es true d e l e g a t i o n . C h a in of R e s p o n s i b i l i t y ( 2 2 3) h a n d l e s request s by forwardin g them from one o b j e c t to anothe r a l o ng a chain of objects . S o m e - t i m es t h is r e q u e s t c a r r i e s with it a r e f e r e n c e to t he o r i g i n a l o b j e c t r e c e i v i n g t he r e q u e s t , in whic h c a se t he patter n is using delegation . B r i d g e ( 1 5 1) d e c o u p l e s an abstractio n from its implementation . If the abstractio n and a particula r implementatio n are c l o s e l y m a t c h e d , then t he a b s t r a c t i o n m ay s i m p l y d e l e g a t e o p e r a t i o n s to that i m p l e m e n t a t i o n . D e l e g a t i o n is an extrem e ex amp l e of o b j e c t c o m p o s i t i o n . It s h o w s that y ou c an a l w a y s r e p l a c e inheritanc e with objec t c o m p o s i t i o n as a mechanis m for c o de r e u s e . Inheritanc e versu s Parameterize d T y p e s Anothe r (not s t r i c t l y object-oriented ) techniqu e for r e u s i n g functionalit y is throug h p a r a m e t e r i z e d t y p e s , a l so know n as g e n e r i c s ( A d a , Eiffel ) a nd t e m p l a t e s (C++) . T h is techniqu e l e ts you defin e a type withou t s p e c i f y i n g all the other t y p es it u s e s. The unspecifie d types are s u p p l i e d as parameters at the point of u s e. For e x a m p l e , a L i st c l a ss c an be p a r a m e t e r i z e d by t he t y pe of e l e m e n t s it c o n t a i n s . To d e c l a r e a l i st of i n t e g e r s , you supply the type \"integer\" as a parameter to the List parameterized type. ptg22 INTRODUCTION CHAPTER I To d e c l a r e a l i st of S t r i n g o b j e c t s , y ou s u p p l y t he \" S t r i n g \" type as a parameter . T he l a n g u a g e i m p l e m e n t a t i o n w i ll c r e a t e a c u s t o m i z e d v e r s i o n of t he L i st c l a ss templat e f or e a ch type of e l e m e n t . Parameterize d t y p es g i ve us a th ird way (in additio n to c l a ss inheritanc e and o b j e c t c o m p o s i t i o n ) to c o m p o s e b e h a v i o r in o b j e c t - o r i e n t e d s y s t e m s . M a ny d e s i g n s c an be i m p l e m e n t e d u s i ng a ny of t h e se three t e c h n i q u e s . To parameteriz e a s o r t i n g routin e by t he o p e r a t i o n it u s es to c o m p a r e e l e m e n t s , we c o u ld m a ke t he c o m p a r i s o n 1. an o p e r a t i o n i m p l e m e n t e d by s u b c l a s s e s ( an a p p l i c a t i o n of T e m p l a t e M e t h o d ( 3 2 5 ) ) , 2. t he r e s p o n s i b i l i t y of an o b j e c t that's p a s s e d to t he s o r t i n g routin e ( S t r a t e g y ( 3 1 5 ) ) , o r 3. an a r g u m e n t of a C ++ t e m p l a t e or A da g e n e r i c that s p e c i f i e s t he n a me of t he functio n to c a ll to c o m p a r e the e l e m e n t s . T h e re a re importan t difference s bet w ee n t h e se t e c h n i q u e s . O b j e c t c o m p o s i t i o n l e ts y ou c h a n g e t he b e h a v i o r b e i ng c o m p o s e d at r u n - t i m e , b ut it a l so r e q u i r e s i n d i r e c t i o n a nd c an be l e ss efficient . I n h e r i t a n c e l e ts you p r o v i d e defaul t implementation s for operation s a nd l e ts s u b c l a s s e s o v e r r i d e them . Parameterize d t y p es l et y ou c h a n g e t he t y p es that a c l a ss c an u s e. B ut neithe r i n h e r i t a n c e n or parameterize d t y p es c an c h a n g e at run-time . W h i c h a p p r o a c h is b e st d e p e n d s on your d e s i g n a nd implementatio n constraints. N o ne of t he pattern s in t h is b o ok c o n c e r n s p a r a m e t e r i z e d t y p e s , t h o u g h we u se t h em on o c c a s i o n to c u s t o m i z e a pattern' s C++ implementation . Parameterize d t y p es aren' t n e e d e d at a ll in a l a n g u a g e l i ke S m a l l t a l k that d o e s n ' t h a ve c o m p i l e - t i m e t y pe c h e c k i n g . R e l a t i n g R u n - T i m e a nd C o m p i l e - T i m e S t r u c t u r e s An o b j e c t - o r i e n t e d program' s run-tim e structur e often bears little r e s e m b l a n c e to its c o de s t r u c t u r e . T he c o de structur e is froze n at c o m p i l e - t i m e ; it c o n s i s t s of c l a s s e s in f i x ed inheritanc e r e l a t i o n s h i p s . A program' s run-tim e structur e c o n s i s t s of rapidl y c h a n g i n g network s of communicatin g o b j e c t s . In fact, the two structure s are l a r g e l y independent . T r y i n g to understan d one from the other is l i ke tryin g to understan d the d y n a m i s m of l i v i ng e c o s y s t e m s from t he static taxonom y of plant s a nd a n i m a l s , a nd v i ce versa. C o n s i d e r t he d i s t i n c t i o n betwee n o b j e c t a g g r e g a t i o n a nd a c q u a i n t a n c e a nd h ow dif- ferentl y t h ey manifes t t h e m s e l v e s at c o m p i l e - a nd r u n - t i m e s . A g g r e g a t i o n i m p l i e s that o ne o b j e c t owns or is r e s p o n s i b l e f or anothe r o b j e c t . G e n e r a l l y we s p e ak of an o b j e c t having or b e i ng part of anothe r o b j e c t . A g g r e g a t i o n i m p l i e s that an a g g r e g a t e o b j e c t a nd i t s owner have identical lifetimes. A c q u a i n t a n c e i m p l i e s t h a t a n o b j e c t m e r e l y k n o w s o f another o b j e c t . S o m e t i m e s ac- q u a i n t a n c e is called \"association\" o r t h e \"using\" relationship. Acquainted objects m a y ptgSECTION 1.6 HOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS 23 r e q u e s t o p e r a t i o n s of e a ch o t h e r , b ut they aren' t r e s p o n s i b l e f or e a ch o t h e r . A c q u a i n - tance is a weaker relationshi p t h an aggregatio n and suggest s much l o o s e r couplin g betwee n objects. In our diagrams , a p l a in arrowhea d l i ne denote s acquaintance . An arrowhea d l i ne w i th a diamond at its base denotes aggregation: It's easy to confus e aggregatio n and acquaintance , becaus e they are o f t en implemente d in t he s a me w a y. In S m a l l t a l k , a ll v a r i a b l e s a re r e f e r e n c e s to o t h er o b j e c t s . T h e r e ' s no distinctio n in the programmin g languag e betwee n aggregatio n and acquaintance . In C++, a g g r e g a t i o n can be i m p l e m e n t e d by definin g membe r v a r i a b l e s that are r e al i n s t a n c e s , but i t 's more commo n to defin e them as pointer s or reference s to instances . Acquaintanc e is implemente d with pointer s and reference s as w e l l . U l t i m a t e l y , acquaintanc e and aggregatio n are determine d more by inten t than by ex- p l i c it languag e mechanisms . The distinctio n may be hard to see in the compile-tim e structure , but it's significant . Aggregatio n relationship s tend to be fewe r and more permanen t than a c q u a i n t a n c e . A c q u a i n t a n c e s , in c o n t r a s t , a re made a nd remad e m o re frequently , s o m e t i m e s existin g o n ly f or the duratio n of an operation . Acquaintance s are more dynami c as w e l l, makin g them m o re difficul t to d i s c e r n in the s o u r c e c o d e . With s u ch d i s p a r i t y b e t w e e n a p r o g r a m ' s run-tim e a nd c o m p i l e - t i m e s t r u c t u r e s , i t 's c l e ar that c o de won' t r e v e a l everythin g abou t how a syste m w i ll work . The s y s t e m ' s run-tim e structur e must be i m p o s e d more by the d e s i g n e r than the language . The r e l a t i o n s h i p s betwee n o b j e c t s and their types must be d e s i g n e d with great c a r e, becaus e they determin e how g o od or bad the run-tim e structur e is. Many d e s i g n pattern s (in particula r t h o se that have o b j e c t s c o p e ) captur e the distinctio n betwee n c o m p i l e - t i m e a nd run-tim e structure s e x p l i c i t l y . C o m p o s i t e ( 1 6 3) a nd D e c o r a - tor ( 1 7 5) are e s p e c i a l l y usefu l for buildin g comple x run-tim e structures . O b s e r v e r ( 2 9 3) i n v o l v e s r u n - t i m e s t r u c t u r e s that a re often hard to understan d u n l e s s y ou k n ow t he pattern . Chai n of Responsibilit y ( 2 2 3) a l so result s in communicatio n pattern s that in- heritanc e d o e s n ' t r e v e a l . In g e n e r a l , the run-tim e structure s aren' t c l e ar f r om the c o de until you understan d the patterns. Designin g f or C h a n g e The key to maximizin g r e u se l i es in anticipatin g new requirement s and change s to ex- i s t i ng r e q u i r e m e n t s , and in d e s i g n i n g your system s so t h at they can e v o l v e a c c o r d i n g l y . To d e s i g n t he s y s t e m so that i t 's robus t to s u ch c h a n g e s , y ou must c o n s i d e r h ow t he s y s t e m migh t n e ed to chang e o v er its lifetime . A d e s i g n that doesn' t take chang e into account risks m a j o r r e d e s i g n i n t h e f u t u r e . T h o s e c h a n g e s m i g h t i n v o l v e c l a s s ptg24 INTRODUCTION CHAPTER 1 redefinitio n a nd reimplementation , c l i e nt m o d i f i c a t i o n , a nd r e t e s t i n g . R e d e s i g n affect s many parts of the softwar e s y s t e m , and unanticipate d c h a n g e s are i n v a r i a b l y e x p e n s i v e . D e s i g n pattern s h e lp y ou a v o id t h is by e n s u r i n g that a s y s t e m c an c h a n g e in s p e c i f i c ways . E a ch d e s i g n patter n l e ts s o me a s p e c t of s y s t e m structur e vary i n d e p e n d e n t l y of o t h er a s p e c t s , thereb y makin g a s y s t e m m o re r o b u s t to a particula r k i nd of c h a n g e . H e re a re s o me c o m m o n c a u s e s of r e d e s i g n a l o ng with t he d e s i g n pattern(s ) that a d d r e s s them: 1. Creating an object by specifying a class explicitly. S p e c i f y i n g a c l a ss name when you c r e a t e an o b j e c t commit s you to a particula r i m p l e m e n t a t i o n i n s t e a d of a particula r interface . T h is commitmen t c an c o m p l i c a t e f u t u r e c h a n g e s . To a v o id i t, c r e a t e o b j e c t s i n d i r e c t l y . D e s i g n patterns : Abstrac t Factor y ( 8 7 ), F a c t o r y M e t h o d ( 1 0 7 ) , Prototyp e ( 1 1 7 ) . 2. Dependence on specific operations. W h e n you s p e c i f y a p a r t i c u l a r o p e r a t i o n , you c o m m i t to o ne w ay of satisfyin g a r e q u e s t . By a v o i d i n g h a r d - c o d e d r e q u e s t s , y ou m a ke it e a s i e r to c h a n g e t he w ay a r e q u e s t g e ts s a t i s f i e d b o th at c o m p i l e - t i m e a nd at run-time. D e s i g n p a t t e r n s : C h a in of R e s p o n s i b i l i t y ( 2 2 3 ) , C o m m a n d ( 2 3 3 ) . 3. Dependence on hardware a nd software platform. E x t e r n a l o p e r a t i n g s y s t e m i n t e r f a c e s and applicatio n programmin g interface s ( A P I s ) are differen t on differen t hard- ware and softwar e platforms . Softwar e that d e p e n d s on a particula r platfor m w i ll be harde r to port to other platforms . It may e v en be difficul t to k e ep it up to date on its nativ e platform . It's importan t therefor e to d e s i g n your s y s t e m to l i m it its platfor m d e p e n d e n c i e s . D e s i g n patterns : Abstrac t Factor y ( 8 7 ), B r i d g e ( 1 5 1 ) . 4. Dependence on object representations or implementations. C l i e n t s that know how an o b j e c t is r e p r e s e n t e d , s t o r e d , l o c a t e d , or i m p l e m e n t e d m i g h t n e ed to be c h a n g e d when t he o b j e c t c h a n g e s . H i d i n g t h is informatio n from c l i e n t s k e e ps c h a n g e s from c a s c a d i n g . D e s i g n patterns : Abstrac t Factor y ( 8 7 ), B r i d g e ( 1 5 1 ) , Mement o ( 2 8 3 ) , P r o xy ( 2 0 7 ) . 5. Algorithmic dependencies. Algorithm s a re often e x t e n d e d , o p t i m i z e d , a nd r e p l a c e d durin g d e v e l o p m e n t a nd r e u s e . O b j e c t s that d e p e n d on an a l g o r i t h m w i ll have to chang e when the algorith m c h a n g e s . Therefor e a l g o r i t h m s that are l i k e ly to chang e s h o u l d be i s o l a t e d . D e s i g n patterns : B u i l d e r ( 9 7 ), Iterato r ( 2 5 7 ) , S t r a t e g y ( 3 1 5 ) , T e m p l a t e Metho d ( 3 2 5 ) , V i s i t o r ( 3 3 1 ) . 6. Tight coupling. C l a s s e s that a re tightl y c o u p l e d a re hard to r e u se in i s o l a t i o n , s i n ce t h ey d e p e n d on e a ch o t h e r . T i g ht c o u p l i n g l e a ds to m o n o l i t h i c s y s t e m s , w h e r e y o u can't change or remove a class without understanding a n d changing many ptgSECTION 1.6 HOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS 25 other c l a s s e s . T he s y s t e m b e c o m e s a d e n se m a ss that's hard to l e a r n , port, a nd m a i n t a i n . L o o s e c o u p l i n g i n c r e a s e s t he p r o b a b i l i t y that a c l a ss c an be r e u s e d by i t s e lf a nd that a s y s t e m c an be l e a r n e d , p o r t e d , m o d i f i e d , a nd e x t e n d e d more e a s i l y . D e s i g n pattern s use t e c h n i q u e s s u ch as abstrac t c o u p l i n g and layerin g to promot e l o o s e l y c o u p l e d s y s t e m s . D e s i g n patterns : Abstrac t F a c t o r y ( 8 7 ), B r i d g e ( 1 5 1 ) , C h a in of R e s p o n s i b i l i t y ( 2 2 3 ) , Comman d ( 2 3 3 ) , F a c a d e ( 1 8 5 ) , Mediato r ( 2 7 3 ) , O b s e r v e r ( 2 9 3 ) . 7. Extending functionality by subclassing. C u s t o m i z i n g an o b j e c t by s u b c l a s s i n g often i s n 't e a s y. Every n ew c l a ss h as a f i x ed implementatio n overhea d (initialization , f i n a l i z a t i o n , e t c . ). D e f i n i n g a s u b c l a s s a l so r e q u i r e s an i n - d e p t h understandin g of t he paren t c l a s s. F or e x a m p l e , o v e r r i d i n g o ne operatio n migh t requir e o v e r r i d i n g a n o t h e r . An o v e r r i d d e n o p e r a t i o n m i g h t be r e q u i r e d to c a ll an i n h e r i t e d o p e r a t i o n . A nd s u b c l a s s i n g c an l e ad to an e x p l o s i o n of c l a s s e s , becaus e y ou migh t have to introduc e many new s u b c l a s s e s for e v en a s i m p l e e x t e n s i o n . O b j e c t c o m p o s i t i o n in g e n e r a l a nd d e l e g a t i o n in particula r p r o v i d e f l e x i b l e a l t e r - n a t i v e s to i n h e r i t a n c e for c o m b i n i n g b e h a v i o r . New functionalit y can be adde d to an a p p l i c a t i o n by c o m p o s i n g e x i s t i n g o b j e c t s in new ways rathe r than by definin g n ew s u b c l a s s e s of e x i s t i n g c l a s s e s . On t he other hand , heav y u se of o b j e c t c o m - p o s i t i o n can make d e s i g n s harde r to understand . Many d e s i g n pattern s p r o d u c e d e s i g n s in w h i c h you can introduc e c u s t o m i z e d functionalit y just by definin g one s u b c l a s s a nd c o m p o s i n g i ts i n s t a n c e s with e x i s t i n g o n e s . D e s i g n patterns : B r i d g e ( 1 5 1 ) , C h a in of R e s p o n s i b i l i t y ( 2 2 3 ) , Composit e ( 1 6 3 ) , D e c o r a t o r ( 1 7 5 ) , O b s e r v e r ( 2 9 3 ) , S t r a t e g y ( 3 1 5 ) . 8. Inability to alter classes conveniently. S o m e t i m e s you have to modif y a c l a ss that can't be modifie d c o n v e n i e n t l y . P e r h a p s you n e ed the s o u r c e c o de and don't have it (as may be t he c a se with a c o m m e r c i a l c l a ss library) . Or mayb e any c h a n g e woul d r e q u i r e modifyin g l o ts of e x i s t i n g s u b c l a s s e s . D e s i g n pattern s o f f er ways to modif y c l a s s e s in such c i r c u m s t a n c e s . D e s i g n patterns : Adapte r ( 1 3 9 ) , Decorato r ( 1 7 5 ) , V i s i t o r ( 3 3 1 ) . T h e se e x a m p l e s r e f l e c t the flexibilit y that d e s i g n pattern s can help you b u i ld into y o ur s o f t w a r e . H ow c r u c i a l s u ch f l e x i b i l i t y is d e p e n d s on t he k i nd of s o f t w a r e y o u ' r e b u i l d i n g . L e t 's l o ok at t he r o le d e s i g n pattern s play in t he d e v e l o p m e n t of t hr ee broad c l a s s e s of s o f t w a r e : a p p l i c a t i o n p r o g r a m s , t o o l k i t s , a nd f r a m e w o r k s . Applicatio n P r o g r a m s If you'r e b u i l d i n g an a p p l i c a t i o n progra m s u ch as a documen t e d i t o r or s p r e a d s h e e t , then internal r e u s e , maintainability , a nd e x t e n s i o n a re h i gh p r i o r i t i e s . Interna l r e u se e n s u r e s t h a t y o u d o n ' t d e s i g n a n d i m p l e m e n t a n y m o r e t h a n y o u h a v e t o . D e s i g n ptg26 INTRODUCTION CHAPTER 1 pattern s t h at r e d u c e d e p e n d e n c i e s can i n c r e a s e interna l r e u s e . L o o s e r c o u p l i n g b o o s t s the l i k e l i h o o d that one c l a ss of objec t can cooperat e with s e v e r a l o t h e r s . For e x a m p l e , when you eliminat e dependencie s on s p e c i f i c operation s by i s o l a t i n g and encapsulatin g e a ch operation , you make it e a s i e r to r e u se an operatio n in differen t contexts . The same thing can happe n when you remov e algorithmi c and representationa l d e p e n d e n c i e s too. D e s i g n pattern s a l so make an applicatio n m o re maintainabl e when they'r e u s ed to l i m it platfor m d e p e n d e n c i e s and to layer a system . T h ey enhanc e e x t e n s i b i l i t y by s h owin g you how to exten d c l a ss hierarchie s and how to e x p l o i t o b j e c t c o m p o s i t i o n . Reduce d couplin g a l so enhance s e x t e n s i b i l i t y . Extendin g a c l a ss in i s o l a t i o n is e a s i e r if t he c l a ss doesn' t depen d on l o ts of other c l a s s e s . T o o l k i t s Often an applicatio n w i ll incorporat e c l a s s e s f r om one or more l i b r a r i e s of predefine d c l a s s e s c a l l ed toolkits . A toolki t is a s et of relate d a nd r e u s a b l e c l a s s e s d e s i g n e d to p r o - vide useful , general-purpos e functionality . An exampl e of a t o o l k i t is a s et of c o l l e c t i o n c l a s s e s for l i s t s, a s s o c i a t i v e t a b l e s , s t a c k s , and the l i k e. The C++ I/O strea m librar y is anothe r e x a m p l e . T o o l k i t s don't i m p o s e a particula r d e s i g n on your application ; they just provid e functionalit y that can help your applicatio n do its job. T h ey let you as an implemente r a v o id r e c e d i n g commo n functionality . T o o l k i t s emphasiz e code reuse. T h ey are the object-oriente d equivalen t of subroutin e l i b r a r i e s . T o o l k i t d e s i g n is arguabl y harde r than applicatio n d e s i g n , b e c a u s e toolkit s have to work in many application s to be useful . M o r e o v e r , the toolki t write r i s n 't in a p o s i t i o n to know what t h o se application s will be or their s p e c i a l n e e d s . T h at make s it all the more importan t to a v o id assumption s and dependencie s that can l i m it the toolkit' s flexibilit y and consequentl y its applicabilit y and effectiveness. Frameworks A framewor k is a set of cooperatin g c l a s s e s that make up a r e u s a b l e d e s i g n f or a s p e c i f i c c l a ss of softwar e [ D e u 8 9 , J F 8 8 ] . F or e x a m p l e , a f r a m e w o r k c an be g e a r e d towar d b u i l d - ing graphica l e d i t o r s for differen t domain s l i ke artisti c drawing , musi c c o m p o s i t i o n , and m e c h a n i c a l CAD [ V L 9 0 , J o h 9 2 ] . Anothe r framewor k can help you b u i ld c o m p i l e r s for differen t programmin g language s and targe t machine s [ J M L 9 2 ] . Yet anothe r migh t help you build financia l modelin g application s [ B E 9 3 ] . You customiz e a f r a m e w o r k to a particula r a p p l i c a t i o n by creatin g a p p l i c a t i o n - s p e c i f i c s u b c l a s s e s of abstrac t c l a s s e s from the framework. The framewor k dictate s the architectur e of your application . It w i ll defin e the o v e r - all structure , its partitionin g into c l a s s e s and o b j e c t s , the key r e s p o n s i b i l i t i e s thereof , how the classes and objects collaborate, a n d t h e thread of control. A framework prede- fines these design parameters so that you, the application designer/implementer, can ptgSECTION 1.6 HOW DESIGN PATTERNS SOLVE DESIGN PROBLEMS 27 concentrat e on t he s p e c i f i c s of your a p p l i c a t i o n . T he framewor k capture s t he d e s i g n d e c i s i o n s that are c o m m o n to its applicatio n domain . Framework s thus e m p h a s i z e de- sign reuse o v er c o de r e u s e , t h o u g h a framewor k w i ll u s u a l l y i n c l u d e c o n c r e t e s u b c l a s s e s you can put to work i m m e d i a t e l y . Reus e on this l e v el l e a ds to an i n v e r s i o n of c o n t r o l betwee n t he a p p l i c a t i o n a nd t he softwar e on w h i c h i t 's based . Whe n you use a t o o l k i t (or a c o n v e n t i o n a l subroutin e librar y for that matter) , you write the main body of the a p p l i c a t i o n and c a ll the c o de you want to r e u s e . Whe n you use a framework , you r e u se the main b o dy and write the c o de it c a l l s. Y o u ' l l have to write operation s with particula r name s and c a l l i n g c o n v e n t i o n s , but that r e d u c e s the d e s i g n d e c i s i o n s you have to make. Not o n ly can you b u i ld a p p l i c a t i o n s faste r as a r e s u l t , but the a p p l i c a t i o n s have s i m i l a r structures . T h ey a re e a s i e r to maintain , a nd they s e em m o re c o n s i s t e n t to t h e ir u s e r s . On t he other hand , y ou l o se s o me c r e a t i v e freedom , s i n ce many d e s i g n d e c i s i o n s have b e en made for you. If a p p l i c a t i o n s are hard to d e s i g n , and t o o l k i t s are harder , then framework s are ha r de s t of a l l. A framewor k d e s i g n e r g a m b l e s that one architectur e w i ll work f or all a p p l i c a t i o n s in t he d o m a i n . A ny s u b s t a n t i v e c h a n g e to t he framework' s d e s i g n w o u l d r e d u c e i ts benefit s c o n s i d e r a b l y , s i n ce the framework' s main contributio n to an a p p l i c a t i o n is the architectur e it defines . T h e r e f o r e it's i m p e r a t i v e to d e s i g n the framewor k to be as f l e x i b l e a nd e x t e n s i b l e as p o s s i b l e . Furthermore , b e c a u s e application s are so dependen t on the framewor k for their de- s i g n, they are particularl y s e n s i t i v e to c h a n g e s in framewor k interfaces . As a frame- work e v o l v e s , application s have to e v o l v e with i t. That make s l o o se c o u p l i n g a ll t he m o re i m p o r t a n t ; o t h e r w i s e e v en a m i n o r c h a n g e to t he framewor k w i ll h a ve m a j o r r e p e r c u s s i o n s . T he d e s i g n i s s u e s just d i s c u s s e d a re m o st c r i t i c a l to framewor k d e s i g n . A framewor k that a d d r e s s e s them using d e s i g n pattern s is f ar m o re l i k e ly to a c h i e v e h i gh l e v e ls of d e s i g n and c o de r e u se than one that doesn't . Matur e framework s usuall y incorporat e s e v e r a l d e s i g n patterns . T he pattern s h e lp make t he framework' s architectur e s u i t a b l e to many differen t application s withou t r e d e s i g n . An added benefi t c o m e s when the framewor k is d o c u m e n t e d w i th the d e s i g n pattern s it u s es [ B J 9 4 ] . P e o p l e who know the pattern s g a in i n s i g h t into the framewor k faster . E v en p e o p l e who don't know the pattern s can benefi t from the structur e they l e nd to the framework' s documentation . E n h a n c i n g documentatio n is importan t for all t y p es of software , but it's particularl y importan t for frameworks. Framework s often p o se a s t e ep l e a r n i n g c u r ve that must be o v e r c o m e befor e they'r e useful . W h i l e d e s i g n pattern s migh t not f l a t t e n the l e a r n i n g c u r ve e n t i r e l y , they can make it l e ss s t e ep by makin g key element s of t he framework' s d e s i g n more e x p l i c i t . B e c a u s e pattern s and framework s have s o me s i m i l a r i t i e s , p e o p l e often wonde r how or e v e n if they differ. They are different i n three major ways: ptg28 INTRODUCTION CHAPTER 1 1. Design patterns are more abstract than frameworks. Framework s can be e m b o d i e d in c o d e, b ut o n ly examples of pattern s c an be e m b o d i e d in c o d e. A strengt h of framework s is that they can be writte n down in programmin g l a n g u a g e s and not o n ly studie d but e x e c u t e d and r e u s e d d i r e c t l y . In contrast , the d e s i g n pattern s in this book have to be implemente d e a ch time they'r e u s e d. D e s i g n pattern s a l so explai n the intent , trade-offs , and c o n s e q u e n c e s of a d e s i g n . 2. Design patterns are smaller architectural elements than frameworks. A typica l frame- work contain s s e v e r a l d e s i g n patterns, but the r e v e r s e is n e v er true. 3. Design patterns are less specialized than frameworks. Framework s alway s have a particula r applicatio n domain . A graphica l edito r framewor k m i g h t be u s ed in a factor y simulation , but it won' t be mistake n for a simulatio n framework . In contrast , the d e s i g n pattern s in this catalo g can be u s ed in nearl y any kind of ap- p l i c a t i o n . W h i l e m o re s p e c i a l i z e d d e s i g n pattern s than ours are certainl y p o s s i b l e ( s a y, d e s i g n pattern s for distribute d system s or concurren t programming) , e v en these wouldn' t dictat e an applicatio n architectur e l i ke a framewor k would. Framework s are becomin g i n c r e a s i n g l y commo n and important . T h ey are the way that o b j e c t - o r i e n t e d s y s t e m s a c h i e v e t he most r e u s e . L a r g e r object-oriente d a p p l i c a t i o n s w i ll end up c o n s i s t i n g of layer s of framework s that c o o p e r a t e with e a ch o t h e r . M o st of the d e s i g n and c o de in the applicatio n w i ll c o me f r om or be influence d by the framework s i t uses. 1 . 7 How to Select a D e s i g n P a t t e r n With m o re than 20 d e s i g n pattern s in the catalo g to c h o o s e from , it m i g h t be hard to find t he o ne that a d d r e s s e s a particula r d e s i g n p r o b l e m , e s p e c i a l l y if t he catalo g is n ew a nd unfamilia r to you. H e re are s e v e r a l differen t approache s to findin g the d e s i g n patter n that's right for your p r o b l e m : • Consider how design patterns solve design problems. S e c t i o n 1 .6 d i s c u s s e s how d e s i g n pattern s help you find appropriat e o b j e c t s , determin e o b j e c t granularity , specif y o b j e c t interfaces , a nd s e v e r a l other ways in whic h d e s i g n pattern s s o l ve d e s i g n p r o b l e m s . Referrin g to these d i s c u s s i o n s can help g u i de your s e a r c h for the r i g ht pattern. • Scan Intent sections. S e c t i o n 1 .4 (page 8) l i s ts t he Inten t s e c t i o n s from a ll t he pattern s in the c a t a l o g . Read throug h e a ch pattern' s inten t to find one or m o re that s o u nd relevan t to your p r o b l e m . You can use the c l a s s i f i c a t i o n s c h e m e p r e s e n t e d in T a b le 1 .1 (page 1 0) to narro w your s e a r c h . • Study h ow patterns interrelate. F i g u r e 1 .1 (page 1 2) s h o w s relationship s b et we e n d e s i g n pattern s g r a p h i c a l l y . Studyin g t h e se r e l a t i o n s h i p s c an help d i r e c t y ou to the right pattern or group of patterns. ptgSECTION 1.8 HOW TO USE A DESIGN PATTERN 29 • Study patterns of like purpose. The c a t a l o g (page 79) has three chapters , one for creationa l patterns , anothe r for structura l patterns , and a third for behaviora l patterns . Each chapte r starts off with introductor y comment s on the pattern s and c o n c l u d e s with a s e c t i o n that compare s and contrast s them . T h e s e s e c t i o n s g i ve you i n s i g h t into t he s i m i l a r i t i e s and difference s betwee n pattern s of l i ke purpose. • Examine a cause of redesign. L o ok at the c a u s e s of r e d e s i g n startin g on page 24 to see if your proble m i n v o l v e s one or more of them . T h en l o ok at the pattern s that help you a v o id the cause s of redesign. • Consider what should be variable in your design. T h is approac h is the o p p o s i t e of focusin g on the c a u s e s of r e d e s i g n . Instea d of c o n s i d e r i n g what migh t force a chang e to a d e s i g n , c o n s i d e r what you want to be able to chang e withou t r e d e s i g n . The focus h e re is on encapsulating the concept that varies, a them e of many d e s i g n patterns . T a b le 1 .2 l i s ts t he d e s i g n aspect(s ) that d e s i g n pattern s l et y ou vary independently, thereby letting you change them without redesign. 1 . 8 How to Use a D e s i g n P a t t e r n O n ce you'v e p i c k e d a d e s i g n pattern , how do you use it? H e r e ' s a s t e p - b y - s t e p approac h to applyin g a d e s i g n patter n effectively: 1. Read the pattern once through for an overview. Pay particula r attentio n to the A p p l i c - abilit y and C o n s e q u e n c e s s e c t i o n s to ensur e the patter n is right for your p r o b l e m . 2. Go back and study the Structure, Participants, and Collaborations sections. Make s u re you understan d the c l a s s e s and o b j e c t s in the patter n and how they relate to one another. 3. Look at the Sample Code section to see a concrete example of the pattern in code. Studyin g the c o de h e l ps you learn how to implemen t the pattern. 4. Choose names for pattern participants that are meaningful in the application context. The name s for participant s in d e s i g n pattern s are usuall y too abstrac t to appea r d i r e c t l y in an a p p l i c a t i o n . N e v e r t h e l e s s , i t 's usefu l to incorporat e the participan t name into the name that appear s in the application . That h e l ps make the patter n m o re e x p l i c i t in the implementation . For e x a m p l e , if you use the Strateg y patter n f or a text c o m p o s i t i n g algorithm , then you migh t have c l a s s e s SimpleLayoutStrat- e gy or TeXLayoutStrategy. 5. Define the classes. D e c l a r e their interfaces , e s t a b l i s h their inheritanc e r e l a t i o n s h i p s , and defin e the instanc e v a r i a b l e s that r e p r e s e n t data and o b j e c t r e f e r e n c e s . Identif y e x i s t i n g c l a s s e s in your a p p l i c a t i o n that the patter n w i ll a f f e c t , and modif y them a c c o r d i n g l y . ptg3 0 INTRODUCTION CHAPTER 1 Purpos e Creational Structural B e h a v i o r a lDesig n Patter n Abstrac t Factor y ( 8 7) Builde r ( 9 7 ) F a c t o r y M e t h o d ( 1 0 7) P r o t o t y p e ( 1 1 7) S i n g l e t o n ( 1 2 7) Adapte r ( 1 3 9 ) Bridg e ( 1 5 1) C o m p o s i t e ( 1 6 3) Decorato r ( 1 7 5 ) Facad e ( 1 8 5 ) Flyweigh t ( 1 9 5 ) Proxy ( 2 0 7 ) C h a in of R e s p o n s i b i l i t y ( 2 2 3) Comman d ( 2 3 3) Interprete r ( 2 4 3 ) Iterato r ( 2 5 7 ) Mediato r ( 2 7 3 ) M e m e n t o ( 2 8 3 ) O b s e r v e r ( 2 9 3 ) S t a te ( 3 0 5 ) Strateg y ( 3 1 5) T e m p l a t e Metho d ( 3 2 5) V i s i t o r (331)Aspect(s ) That Can Vary familie s of produc t o b j e c t s h ow a c o m p o s i t e o b j e c t g e ts c r e a t e d s u b c l a s s of o b j e c t that is instantiate d c l a ss of objec t that is instantiate d t he s o le instanc e of a c l a ss interfac e to an objec t implementatio n of an o b j e c t structur e a nd c o m p o s i t i o n of an o b j e c t r e s p o n s i b i l i t i e s of an objec t withou t s u b c l a s s i n g interfac e to a subsyste m storag e c o s ts of o b j e c t s h ow an o b j e c t is a c c e s s e d ; i ts locatio n o b j e c t that c an fulfil l a r e q u e s t when and how a reques t is fulfille d gramma r and interpretatio n of a languag e h ow an a g g r e g a t e ' s e l e m e n t s a re a c c e s s e d , traverse d how and whic h o b j e c t s interac t with each other what p r i v a t e informatio n is s t o r ed o u t s i d e an o b j e c t , and when numbe r of object s that depen d on anothe r o b j e c t ; how the dependen t o b j e c t s stay up to date states of an o b j e c t an algorith m s t e ps of an algorith m operations that can be applied t o object(s) without changing their class(es) T a b l e 1.2: Design aspects that design patterns let you vary ptgSECTION 1.8 HOW TO USE A DESIGN PATTERN 31 6. Define application-specific names for operations in the pattern. H e re a g a i n , the name s g e n e r a l l y depen d on t he application . U se t he r e s p o n s i b i l i t i e s a nd c o l l a b o r a t i o n s a s s o c i a t e d with e a ch operatio n as a g u i d e . A l s o, be c o n s i s t e n t in your namin g c o n v e n t i o n s . For e x a m p l e , you migh t use the \" C r e a t e - \" prefix c o n s i s t e n t l y to d e n o t e a factor y m e t h o d . 7. Implement the operations to carry out the responsibilities and collaborations in the pattern. The Implementatio n s e c t i o n offer s hints to g u i de you in the implementation . The e x a m p l e s in t he S a m p l e C o de s e c t i o n c an help as w e l l . T h e se are just g u i d e l i n e s to get you started . O v er time y o u ' l l d e v e l o p your own way of workin g with d e s i g n patterns. No d i s c u s s i o n of how to use d e s i g n pattern s woul d be c o m p l e t e withou t a few word s on how not to use them . D e s i g n pattern s s h o u l d not be a p p l i e d i n d i s c r i m i n a t e l y . Often they a c h i e v e f l e x i b i l i t y a nd variabilit y by introducin g additiona l l e v e ls of i n d i r e c t i o n , and that can complicat e a d e s i g n a n d / o r c o st you s o me performance . A d e s i g n patter n s h o u l d o n l y be applied when the f l e x i b i l i t y i t affords i s actually needed. The Conse - q u e n c e s sections are most helpful when evaluating a pattern's benefits and liabilities. ptg This page intentionally left blank ptgC h a p t e r 2 A C a se S t u d y : D e s i g n i n g a D o c u m e n t E d i t o r T h is chapte r p r e s e n t s a c a se study in t he d e s i g n of a \" W h a t - Y o u - S e e - I s - W h a t - Y o u - G e t \" ( or \" W Y S I W Y G \" ) documen t e d i t o r c a l l ed Lexi. 1 W e ' ll s ee h ow d e s i g n pattern s captur e s o l u t i o n s to d e s i g n p r o b l e m s in L e xi a nd a p p l i c a t i o n s l i ke i t. By t he e nd of t h is chapte r you w i ll have g a i n e d e x p e r i e n c e with e i g ht patterns , l e a r n i n g them by e x a m p l e . F i g u r e 2 .1 d e p i c t s L e x i ' s u s er i n t e r f a c e . A W Y S I W Y G r e p r e s e n t a t i o n of t he d o c u m e n t o c c u p i e s t he l a r ge rectangula r a r ea in t he c e n t e r . T he documen t c an m ix text a nd g r a p h i c s freely in a variet y of formattin g s t y l e s . Surroundin g the documen t are the usual pull-dow n menu s and s c r o ll bars, p l us a c o l l e c t i o n of page i c o ns for jumpin g to a particular page in the document. 2 . 1 Design Problems We w i ll examin e s e v en p r o b l e m s in L e x i ' s d e s i g n : 1. Document structure. T he c h o i c e of interna l representatio n f or t he documen t affect s nearl y e v e ry a s p e c t of L e x i ' s d e s i g n . A ll e d i t i n g , formatting , d i s p l a y i n g , a nd textua l analysi s w i ll requir e traversin g the representation . The way we o r g a n i z e this informatio n w i ll i m p a c t t he d e s i g n of t he r e st of t he application. 2. Formatting. How d o es L e xi actuall y arrang e text and g r a p h i c s into l i n es and columns ? Wha t o b j e c t s are r e s p o n s i b l e for c a r r y i n g out differen t formattin g p o l i - c i e s? How do t h e se p o l i c i e s interac t with the document' s interna l representation? 1 L e x i ' s d e s i g n is b a s ed on D o c, a text editin g applicatio n d e v e l o p e d by Calde r [ C L 9 2 ] . 3 3 ptg3 4 A C A S E S T U D Y : D E S I G N I N G A D O C U M E N T E D I T O R CHAPTER 2 F i g u r e 2 . 1 : L e x i ' s u s e r i n t e r f a c e ptgSECTION 2 .2 DOCUMENT STRUCTURE 3 5 3. Embellishing t he user interface. L e x i ' s u s er interfac e i n c l u d e s s c r o ll b a r s , b o r d e r s , and drop shadow s that e m b e l l i s h the W Y S I W Y G documen t interface . S u ch em- b e l l i s h m e n t s a re l i k e ly to c h a n g e as L e x i ' s u s er interfac e e v o l v e s . H e n c e i t 's i m - portan t to be a b le to add and remov e e m b e l l i s h m e n t s e a s i ly withou t affectin g the r e st of t he a p p l i c a t i o n . 4. Supporting multiple look-and-feel standards. L e xi s h o u l d adap t e a s i ly to differen t l o o k - a n d - f e e l standard s s u ch as M o t if and Presentatio n Manage r ( P M) withou t majo r modification. 5. Supporting multiple window systems. Differen t l o o k - a n d - f e e l standard s are usuall y i m p l e m e n t e d on differen t windo w s y s t e m s . L e x i ' s d e s i g n s h o u l d be as indepen- d e nt of t he w i n d o w s y s t e m as p o s s i b l e . 6. User operations. U s e rs c o n t r o l L e xi throug h variou s u s er interfaces , i n c l u d i n g but- tons a nd p u l l - d o w n menus . T he functionalit y b e h i n d these interface s is s c a t t e r e d throughou t the o b j e c t s in the a p p l i c a t i o n . The c h a l l e n g e h e re is to p r o v i d e a u n i - form m e c h a n i s m both for a c c e s s i n g this scattere d functionalit y and for undoin g its effects. 7. Spelling checking a nd hyphenation. H ow d o es L e xi suppor t analytica l o p e r a t i o n s s u ch as c h e c k i n g for m i s s p e l l e d word s and determinin g hyphenatio n points ? How can we minimiz e the numbe r of c l a s s e s we have to modif y to add a new analytica l operation? We d i s c u s s t h e se d e s i g n p r o b l e m s in t he s e c t i o n s that f o l l o w . E a ch p r o b l e m h as an a s s o c i a t e d s et of g o a ls p l us constraint s on h ow we a c h i e v e t h o se g o a l s . We e x p l a i n t he g o a ls a nd constraint s in d e t a i l befor e p r o p o s i n g a s p e c i f i c s o l u t i o n . T he p r o b l e m a nd i ts s o l u t i o n w i ll illustrat e o ne or m o re d e s i g n patterns . T he d i s c u s s i o n f or e a ch p r o b l e m w i l l c u l m i n a t e in a brief introduction to the relevant patterns. 2 . 2 Document S t r u c t u r e A documen t is ultimatel y just an arrangemen t of b a s ic g r a p h i c a l e l e m e n t s s u ch as c h a r - a c t e r s , l i n e s, p o l y g o n s , a nd other s h a p e s . T h e s e e l e m e n t s captur e t he total informatio n conten t of the document . Yet an autho r often v i e w s t h e se e l e m e n t s not in g r a p h i c a l terms but in terms of the document' s p h y s i c a l s t r u c t u r e — l i n e s , c o l u m n s , figures , ta- b l e s, and o t h er substructures. 2 In turn, these substructure s have substructure s of their o w n, a nd so o n . L e x i ' s user interfac e s h o u l d l et u s e rs manipulat e these substructure s d i r e c t l y . F or e x - a m p l e , a u s er s h o u l d be able to treat a diagra m as a unit rathe r than as a c o l l e c t i o n of 2 Author s often v i ew the documen t in terms of its logical structur e as w e l l, that is, in terms of s e n t e n c e s , paragraphs , s e c t i o n s , s u b s e c t i o n s , a nd chapters . To k e ep this exampl e s i m p l e , o ur interna l r e p r e s e n t a t i o n won' t s t o re informatio n abou t the l o g i c a l structur e exp licitly . But the d e s i g n s o l u t i o n we d e s c r i b e work s equally well for representing such information. ptg36 A C A SE S T U D Y - DESIGNING A DOCUMENT EDITOR CHAPTER 2 individua l graphica l primitives . The user shoul d be able to refer to a table as a w h o l e , not as an unstructure d mass of text and graphics . That helps make the interfac e s i m p l e and intuitive . To g i ve L e x i ' s implementatio n simila r q u a l i t i e s , we'll c h o o s e an interna l representatio n t h at matche s the document' s physica l structure. In particular , the interna l representatio n shoul d suppor t the following: • Maintainin g the document' s physica l structure , t h at is, the arrangemen t of text and graphic s into l i n e s, columns , tables , etc. • Generatin g and presentin g the documen t v i s u a l l y . • Mappin g position s on the displa y to element s in the interna l representation . T h is l e ts L e xi determin e w h at the user is referrin g to when he point s to somethin g in the visua l representation. In additio n to these g o a ls are s o me constraints . F i r s t, we s h o u l d treat text and graphic s uniformly . The application' s interfac e l e ts the user e m b e d text withi n graphic s freely and v i ce versa . We shoul d a v o id treatin g graphic s as a s p e c i a l c a se of text or text as a s p e c i a l c a se of g r a p h i c s ; otherwis e we'll end up with redundan t f o r m a t t i n g and m a n i p u l a t i o n m e c h a n i s m s . O ne s et of m e c h a n i s m s s h o u l d suffic e f or both t e xt a nd g r a p h i c s . S e c o n d , our implementatio n shouldn' t have to distinguis h betwee n s i n g le element s and g r o u p s of element s in the interna l representation . L e xi shoul d be a b le to treat s i m p l e and c o m p l e x element s uniformly , thereb y a l l o w i n g arbitraril y c o m p l e x documents . The tenth e l e m e n t in l i ne five of colum n t w o, for i n s t a n c e , c o u ld be a s i n g le characte r or an intricat e diagra m with many subelements . As long as we know this elemen t can draw i t s e lf and specif y its d i m e n s i o n s , its complexit y has no bearin g on how and w h e r e it shoul d appea r on the page. O p p o s i n g the s e c o n d constraint , however , is the n e ed to analyz e the text for such t h i n g s as s p e l l i n g error s and potentia l hyphenatio n points . Often we don't c a re whethe r the e l e m e n t of a l i ne is a s i m p l e or c o m p l e x object . B ut sometime s an analysi s depend s on the object s b e i ng analyzed . It make s little s e n s e , for e x a m p l e , to c h e ck the s p e l l i n g of a polygo n or to hyphenat e it. The interna l representation' s d e s i g n s h o u l d take this and other potentiall y conflictin g constraint s into account. Recursiv e Composition A commo n way to represen t hierarchicall y structure d informatio n is throug h a t e c h - nique c a l l ed recursiv e composition , whic h entail s buildin g i n c r e a s i n g l y c o m p l e x e l e - ment s out of s i m p l e r o n e s. R e c u r s i v e compositio n g i v es us a way to c o m p o s e a d o c u - ment out of s i m p l e graphica l elements . As a first s t e p, we can tile a set of character s and graphic s f r om left to right to f o rm a l i ne in the document . T h en multipl e l i n es can be arrange d to f o rm a c o l u m n , multipl e column s can f o rm a p a g e, and so on ( s ee F i g u r e 2 . 2 ) . ptgSECTION 2 . 2 DOCUMENT S T R U C T U R E 37 F i g u r e 2 . 3 : O b j e c t structure for recursive composition of text and g r a p h i c s Fgure 2.2: Recusive coposition of text and graphics ptg3 8 A CASE STUDY- DESIGNING A D O C U M E N T EDITOR CHAPTER 2 F i g u r e 2 . 4: Partia l Glyp h c l a ss h i e r a r c h y We c an r e p r e s e n t this p h y s i c a l structur e by dev ot in g an o b j e c t to e a ch importan t e l e - ment . T h at i n c l u d e s not just the v i s i b l e e l e m e n t s l i ke the character s and g r a p h i c s but t he i n v i s i b l e , structura l e l e m e n t s as well—th e l i n es a nd t he c o l u m n . T he r e s u lt is t he o b j e c t structur e s h o w n in F i g u r e 2 . 3 . By using an o b j e c t for e a ch characte r and graphica l e l e m e n t in the document , we promot e f l e x i b i l i t y at t he fines t l e v e ls of L e x i ' s d e s i g n . We c an treat text a nd g r a p h i c s uniforml y with r e s p e c t to how they are drawn , formatted , and e m b e d d e d withi n e a ch o t h e r . We c an e x t e n d L e xi to suppor t n ew characte r s e ts withou t disturbin g other functionality . L e x i ' s o b j e c t structur e m i m i c s the document' s p h y s i c a l structure. T h is approac h h as t wo importan t i m p l i c a t i o n s . T he f i r st is o b v i o u s : T he o b j e c t s n e ed c o r r e s p o n d i n g c l a s s e s . T he s e c o n d i m p l i c a t i o n , w h i c h m a y b e l e ss o b v i o u s , is that t h e se c l a s s e s must have c o m p a t i b l e interfaces , b e c a u s e we want to treat the o b j e c t s uniformly . The way to make interface s c o m p a t i b l e in a l a n g u a g e l i ke C++ is to relate the c l a s s e s through inheritance. G l y p h s W e ' ll defin e a G l y p h abstrac t c l a ss for all o b j e c t s that can appea r in a documen t s t r u c t u r e . 3 I ts s u b c l a s s e s defin e both p r i m i t i v e g r a p h i c a l e l e m e n t s ( l i ke character s a n d 3 Calde r w as t he f i r st to u se t he term \" g l y p h \" in t h is c o n t e x t [ C L 9 0 ] . M o st contemporar y d o c u m e n t e d i t o r s d o n ' t u s e a n o b j e c t f o r every character, presumably for efficiency r e a s o n s . C a l d e r d e m o n s t r a t e d t h a t t h i s ptgSECTION 2 . 2 DOCUMENT STRUCTURE 3 9 R e s p o n s i b i l i t y appearance h it d e t e c t i o n structureO p e r a t i o n s v i r t u a l v i r t u a l v i r t u a l v i r t u a l v i r t u a l v i r t u a l v i r t u a lv o id D r aw ( W i n d o w * ) v o id B o u n d s ( R e c t & ) bool I n t e r s e c t s ( c o n s t P o i n t & ) vo id I n s e r t ( G l y p h * , v o i d R e m o v e (Glyph*) Glyph* C h i l d ( i n t ) G l y p h * P a r e n t ( )i n t ) T a b le 2 . 1: B a s ic g l y ph interface i m a g e s ) and structura l element s ( l i ke r o ws a nd columns) . F i g u r e 2 .4 depict s a r e p r e s e n - tative part of the Glyp h c l a ss h i e r a r c h y , and T a b le 2.1 present s the basic glyph interfac e in m o re d e t a i l u s i ng C ++ n o t a t i o n . 4 Glyph s have three b a s ic r e s p o n s i b i l i t i e s . T h ey know (1) how to draw themselves , (2) what s p a c e they o c c u p y , a nd ( 3) their c h i l d r e n a nd parent. Glyp h s u b c l a s s e s redefin e the D r aw operatio n to rende r t h e m s e l v e s onto a w i n d o w . T h ey are p a s s e d a referenc e to a W i n d o w o b j e c t in the c a ll to D r a w . The Windo w c l a ss define s g r a p h i c s operation s for renderin g text and b a s ic shape s in a windo w on the s c r e e n . A Rectangl e s u b c l a s s of Glyp h migh t redefin e D r aw as follows: v o id R e c t a n g l e : : D r a w ( W i n d o w * w) { w - > D r a w R e c t ( _ x O , _ y O, _ x l, _ _ y l ) ; } wher e _ x O, _y 0, _ x l, and _y 1 are data member s of R e c t a n g l e that defin e two o p p o s i n g corner s of the r e c t a n g l e . D r a w R e c t is the Windo w operatio n tha t make s the r e c t a n g l e appea r on t he s c r e e n . A paren t g l y ph often n e e ds to know how much s p a ce a c h i ld glyph o c c u p i e s , for e x a m p l e , to arrang e it a nd o t h er g l y p h s in a l i ne so that none o v e r l a p s ( as show n in F i g u r e 2 . 2 ). The B o u n d s operatio n return s the rectangula r area that the glyph o c c u p i e s . It return s the o p p o s i t e c o r n e r s of the s m a l l e s t r e c t a n g l e that contain s the g l y p h . Glyp h s u b c l a s s e s redefin e this operatio n to retur n the rectangula r area in whic h they draw. The I n t e r s e c t s operatio n return s whethe r a s p e c i f i e d point i n t e r s e c t s the glyph . Wheneve r t he u s er c l i c ks s o m e w h e r e in t he document , L e xi c a l ls this operatio n to determin e whic h g l y ph or g l y ph structur e is unde r t he mouse . T he Rectangl e c l a ss redefine s this operatio n to comput e t he i n t e r s e c t i o n of t he r e c t a n g l e a nd t he g i v en point. a p p r o a c h is f e a s i b l e in h is t h e s is [ C a l 9 3 ] . O ur g l y p h s a re l e ss s o p h i s t i c a t e d than h is in that we h a ve r e s t r i c t e d ours to strict hierarchie s for s i m p l i c i t y . Calder' s glyph s can be s h a r e d to reduc e storag e c o s t s , thereb y formin g d i r e c t e d - a c y c l i c graph structures . We can apply the F l y w e i g h t ( 1 9 5) patter n to get the s a me effect , but we'll leave that as an e x e r c i s e for the r e a d e r . 4 The interfac e we d e s c r i b e here is purposel y minima l to k e ep the d i s c u s s i o n s i m p l e . A c o m p l e t e interfac e would include operations for managing graphical attributes such as color, font, and coordinate transforma - t i o n s , plus operations for more sophisticated child management. ptg40 A C A SE S T U D Y - DESIGNING A DOCUMENT EDITOR CHAPTER 2 B e c a u s e g l y p h s can have c h i l d r e n , we n e ed a c o m m o n interfac e to add, r e m o v e , and a c c e s s those c h i l d r e n . F or e x a m p l e , a Row' s c h i l d r e n a re t he g l y p h s it arrange s into a r o w. The I n s e r t operatio n insert s a g l y ph at a p o s i t i o n s p e c i f i e d by an i n t e g e r i n d e x . 5 T he R e m o v e operatio n r e m o v e s a s p e c i f i e d glyph if it is i n d e e d a c h i l d . The C h i l d operatio n return s the c h i ld (if any) at the g i v en i n d e x . G l y p h s l i ke Row that can have c h i l d r e n s h o u l d use C h i l d internall y i n s t e a d of a c c e s s i n g the c h i ld data structur e d i r e c t l y . That way you won' t have to modif y operation s l i ke D r aw that iterat e throug h the c h i l d r e n when you chang e the data structur e from , s a y, an array to a l i n k e d l i s t. S i m i l a r l y , P a r e n t p r o v i d e s a standar d interfac e to the g l y p h ' s parent , if a n y. G l y p h s in L e xi store a referenc e to their parent , and their P a r e n t operatio n s i m p l y return s t h is reference. C o m p o s i t e P a t t e r n Recursiv e c o m p o s i t i o n is g o od for more than just documents . We can use it to r e p r e s e n t a ny potentiall y c o m p l e x , h i e r a r c h i c a l structure . T he C o m p o s i t e ( 1 6 3) patter n c a p t u r e s t he e s s e n c e of r e c u r s i v e c o m p o s i t i o n in object-oriente d terms . N ow woul d be a g o od time to turn to that pattern and study it, referring back to this scenario as needed. 2 . 3 Formatting W e ' v e s e t t l e d on a way to represent the document' s p h y s i c a l structure . Next , we n e ed to figur e out how to construc t a particular p h y s i c a l structure , one that c o r r e s p o n d s to a properl y formatte d document . Representatio n and formattin g are d i s t i n c t : The a b i l i t y to captur e the document' s p h y s i c a l structur e doesn' t t e ll us how to a r r i ve at a particula r structure . T h is r e s p o n s i b i l i t y r e s ts mostl y on L e x i. It must break text into l i n e s, l i n es into c o l u m n s , a nd so o n, takin g into a c c o u n t t he user' s h i g h e r - l e v e l d e s i r e s . F or e x a m p l e , t he u s er migh t want to vary margi n widths , indentation , and tabulation ; s i n g le or d o u b l e s p a c e ; and p r o b a b l y many other formattin g constraints. 6 L e x i ' s formattin g algorith m must take all of these into a c c o u n t . By the way, w e ' ll r estr ic t \"formatting \" to mean breakin g a c o l l e c t i o n of g l y p h s into l i n e s. In fact, w e ' ll use the terms \"formatting \" and \" l i n e b r e a k i n g \" i n t e r c h a n g e a b l y . T he t e c h n i q u e s we'll d i s c u s s apply e q u a l l y w e ll to breakin g l i n es into c o l u m n s a nd to breakin g c o l u m n s into p a g e s . BAn intege r index is probabl y not the b e st way to specif y a g l y p h ' s c h i l d r e n , dependin g on the data structur e the glyph u s e s. If it s t o r es its c h i l d r e n in a l i n k e d l i s t, then a pointe r into the l i st woul d be m o re efficient . W e ' ll s ee a bette r s o l u t i o n to t he indexin g p r o b l e m in S e c t i o n 2 . 8, when we d i s c u s s d o c u m e n t analysis. 6 The u s er will have e v en m o re to say abou t the document' s logical structure—th e s e n t e n c e s , paragraphs , s e c t i o n s , chapters , a nd so forth . T he physical structur e is l e ss interestin g by c o m p a r i s o n . M o st p e o p l e don't care wher e the linebreak s in a paragrap h o c c ur as l o ng as the paragrap h is formatte d p r o p e r l y . The s a me is true for formattin g column s and p a g e s . T h us u s e rs end up s p e c i f y i n g o n ly h i g h - l e v e l c o n s t r a i n t s on the p h y s i c a l structure, leaving Lexi to do the hard work of satisfying them. ptgSECTION 2.3 FORMATTING 41 R e s p o n s i b i l i t y what to format when to formatO p e r a t i o n s v o id S e t C o m p o s i t i o n ( C o m p o s i t i o n * ) v i r t u a l v o i d C o m p o s e ( ) T a b l e 2.2: B a s i c compositor interface E n c a p s u l a t i n g t he F o r m a t t i n g A l g o r i t h m T he formattin g p r o c e s s , with a ll i ts c o n s t r a i n t s a nd d e t a i l s , i s n 't e a sy to automate . T h e re are many approache s to the p r o b l e m , and peopl e have c o me up with a variet y of formattin g algorithm s with differen t strength s and w e a k n e s s e s . B e c a u s e L e xi is a W Y S I W Y G e d i t o r , an importan t t r a d e - o f f to c o n s i d e r is t he b a l a n c e b e t w e e n formattin g qualit y and formattin g s p e e d . We want g e n e r a l l y g o od r e s p o n s e from the edito r with- out s a c r i f i c i n g how g o od the documen t l o o k s . T h is trade-of f is subjec t to many factors , n ot a ll of w h i c h c an be a s c e r t a i n e d at c o m p i l e - t i m e . F or e x a m p l e , t he u s er m i g h t t o l - erate s l i g h t l y s l o w e r r e s p o n s e in e x c h a n g e for bette r formatting . That trade-of f migh t make an e n t i r e l y differen t formattin g algorith m more appropriat e than the curren t o n e. A n o t h e r , m o re i m p l e m e n t a t i o n - d r i v e n trade-of f b a l a n c e s formattin g s p e ed a nd storag e requirements : It may be p o s s i b l e to d e c r e a s e formattin g time by c a c h i n g more information. B e c a u s e formattin g algorithm s tend to be c o m p l e x , i t 's a l so d e s i r a b l e to keep them w e l l - containe d or—bette r yet—completel y independen t of the documen t structure . Ideall y we c o u ld add a new kind of Glyp h s u b c l a s s withou t r e g a r d to the formattin g algorithm . C o n v e r s e l y , addin g a new formattin g algorith m shouldn' t r e q u i r e modifyin g e x i s t i n g g l y p h s . T h e s e c h a r a c t e r i s t i c s s u g g e s t we s h o u l d d e s i g n L e xi so that i t 's e a sy to c h a n g e t he formattin g algorith m at least at c o m p i l e - t i m e , if not at run-tim e as w e l l. We can isolat e the algorith m and make it e a s i ly r e p l a c e a b l e at the same time by encapsulatin g it in an o b j e c t . M o re s p e c i f i c a l l y , w e ' ll defin e a s e p a r a t e c l a ss h i e r a r c h y f or o b j e c t s that encapsulat e formattin g algorithms . The root of the hierarch y w i ll defin e an interfac e that support s a w i de range of formattin g algorithms , and each s u b c l a s s w i ll implemen t t he i n t e r f a c e to c a r ry o ut a p a r t i c u l a r a l g o r i t h m . T h en we c an i n t r o d u c e a G l y p h s u b c l a s s that will structure its children automatically using a given algorithm object. C o m p o s i t o r a nd C o m p o s i t i o n W e ' ll d e f i n e a C o m p o s i t o r c l a ss f or o b j e c t s that c an e n c a p s u l a t e a formattin g a l g o r i t h m . The interfac e ( T a b l e 2 . 2) l e ts the composito r know what g l y p h s to f o r m a t and when to do the formatting . The g l y p h s it format s are the c h i l d r e n of a s p e c i a l Glyp h s u b c l a s s c a l l e d C o m p o s i t i o n . A c o m p o s i t i o n g e ts an i n s t a n c e of a C o m p o s i t o r s u b c l a s s ( s p e c i a l i z e d for a particula r l i n e b r e a k i n g algorithm ) when it is c r e a t e d , and it t e l ls the composito r to C o m p o s e its g l y p h s when n e c e s s a r y , for e x a m p l e , when the user change s a document . F i g u r e 2.5 d e p i c t s the relationships between the Composition a n d Compositor c l a s s e s . ptg4 2 A CASE S T U D Y - DESIGNING A D O C U M E N T EDITOR CHAPTER 2 F i g u r e 2 . 5: Compositio n a nd C o m p o s i t o r c l a ss r e l a t i o n s h i p s An unformatte d C o m p o s i t i o n o b j e c t c o n t a i n s o n ly the v i s i b l e g l y p h s that make up the document' s b a s ic content . It d o e s n ' t contai n g l y p h s that determin e the document' s physica l structure , s u ch as R ow a nd Column . T he c o m p o s i t i o n is in this state just a f t er it's create d and i n i t i a l i z e d with the g l y p h s it s h o u l d f o r m a t . Whe n the c o m p o s i t i o n n e e ds formatting , it c a l ls its compositor' s C o m p o s e operation . The c o m p o s i t o r in turn iterate s throug h the c o m p o s i t i o n ' s c h i l d r e n and i n s e r t s new Row and C o l u m n g l y p h s a c c o r d i n g to i ts linebreakin g algorithm. 7 F i g u r e 2 .6 show s t he r e s u l t i n g o b j e c t structure . G l y p h s that the composito r create d and i n s e r t e d into the o b j e c t structur e appea r with gray background s in the figure. Each Composito r s u b c l a s s c an i m p l e m e n t a differen t l i n e b r e a k i n g algorithm . F or e x - ample , a S i m p l e C o m p o s i t o r migh t do a q u i ck p a ss withou t r e g a r d for s u ch e s o t e r i c a as t he document' s \" c o l o r . \" G o od c o l or mean s havin g an e v en distributio n of text a nd whitespace . A T e X C o m p o s i t o r woul d implemen t the full T j ?X algorith m [ K n u 8 4 ] , w h i c h takes thing s l i ke c o l or into a c c o u n t in e x c h a n g e for l o n g e r formattin g t i m e s . T he C o m p o s i t o r - C o m p o s i t i o n c l a ss s p l it e n s u r e s a stron g separatio n betwee n c o de that support s the document' s p h y s i c a l structur e and the c o de for differen t formattin g algorithms . We c an a dd n ew C o m p o s i t o r s u b c l a s s e s withou t touchin g t he g l y ph c l a s s e s , and v i ce versa . In fact, we can c h a n g e the l i n e b r e a k i n g algorith m at run-tim e by a d d i n g a s i n g le S e t C o m p o s i t o r operatio n to C o m p o s i t i o n ' s b a s ic g l y ph interface. S t r a t e g y P a t t e r n Encapsulatin g an algorith m in an o b j e c t is t he inten t of t he Strateg y ( 3 1 5) pattern . The key participant s in the pattern are Strateg y o b j e c t s ( w h i c h encapsulat e differen t algorithms ) and the c o n t e x t in whic h they operate . C o m p o s i t o r s are s t r a t e g i e s ; they en- 7 The c o m p o s i t o r must get the characte r c o d es of Characte r g l y p h s in order to comput e the l i n e b r e a k s . In S e c t i o n 2.8 w e ' ll see how to get t h is informatio n polymorphicall y withou t addin g a character-specifi c o p e r a t i o n to the Glyph interface. ptgSECTION 2 . 4 EMBELLISHING THE U S E R I N T E R F A C E 43 F i g u r e 2 . 6: O b j e c t structur e reflectin g c o m p o s i t o r - d i r e c t e d l i n e b r e a k i n g capsulat e differen t f o r m a t t i n g algorithms . A c o m p o s i t i o n is the contex t for a c o m p o s i t o r s t r a t e g y . The key to a p p l y i n g the S t r a t e g y patter n is d e s i g n i n g interface s for the strateg y and its c o n t e x t that are g e n e r a l e n o u g h to s u p p o r t a range of a l g o r i t h m s . You shouldn' t have to c h a n g e the strateg y or c o n t e x t interfac e to suppor t a new algorithm . In our e x a m p l e , t he b a s ic Glyp h interface' s suppor t f or c h i ld a c c e s s , i n s e r t i o n , a nd remova l is g e n e r a l e n o u g h to l et C o m p o s i t o r s u b c l a s s e s c h a n g e t he d o c u m e n t ' s p h y s i c a l s t r u c t u r e , r e g a r d l e s s of the algorith m they use to do it. L i k e w i s e , the C o m p o s i t o r interfac e g i v es c o m p o s i t i o n s w h a t e v e r t h e y n e e d to initiate formatting. 2 . 4 Embellishing t h e User Interface We c o n s i d e r two e m b e l l i s h m e n t s in L e x i ' s user interface . The first adds a b o r d e r aroun d t he t e xt e d i t i n g a r ea to d e m a r c a t e t he p a ge of t e x t. T he s e c o n d a d ds s c r o ll b a rs that l et the u s er v i ew differen t parts of the p a g e. To make it e a sy to add and r e m o v e t h e se e m b e l l i s h m e n t s ( e s p e c i a l l y at run-time) , we shouldn' t use inheritanc e to add them to t he user interface . We a c h i e v e t he m o st f l e x i b i l i t y if other u s er interfac e o b j e c t s don't e v en know the e m b e l l i s h m e n t s are there . That w i ll let us add and remov e the e m b e l l i s h m e n t s withou t changin g other c l a s s e s . T r a n s p a r e n t E n c l o s u r e F r om a programmin g p o i nt of v i e w, e m b e l l i s h i n g t he u s er interfac e i n v o l v e s e x t e n d i n g e x i s t i n g c o d e . U s i n g i n h e r i t a n c e t o d o such extension precludes rearranging e m b e l l i s h - ptg44 A CASE STUDY: DESIGNING A DOCUMENT EDITOR CHAPTER 2 ment s at run-time , but an e q u a l l y s e r i o u s p r o b l e m is the e x p l o s i o n of c l a s s e s that can resul t from an i n h e r i t a n c e - b a s e d approach. We c o u ld add a borde r to C o m p o s i t i o n by s u b c l a s s i n g it to y i e ld a B o r d e r e d C o m p o s i - tion c l a s s . Or we c o u ld add a s c r o l l i n g interfac e in the same way to y i e ld a S c r o l l a b l e - Composition . If we want both s c r o ll bars and a b o r d e r , we migh t produc e a B o r d e r e d - S c r o l l a b l e C o m p o s i t i o n , and so f o r t h . In the extreme , we end up with a c l a ss for e v e ry p o s s i b l e c o m b i n a t i o n of e m b e l l i s h m e n t s , a s o l u t i o n that q u i c k l y b e c o m e s unworkabl e as the variet y of e m b e l l i s h m e n t s g r o w s . O b j e c t compositio n o f f e r s a potentiall y more workabl e and fl exi bl e e x t e n s i o n m e c h a - n i s m . But what object s do we c o m p o s e ? S i n ce we know we're e m b e l l i s h i n g an e x i s t i n g g l y p h , we c o u ld make the e m b e l l i s h m e n t i t s e lf an objec t ( s a y, an instanc e of c l a ss B o r - der). That g i v es us two candidate s for c o m p o s i t i o n , the glyph and the b o r d e r . The next step is to d e c i d e who c o m p o s e s whom . We c o u ld have the borde r contai n the g l y p h , whic h make s s e n se g i v en that the borde r w i ll surroun d the g l y ph on the s c r e e n . Or we c o u ld do the opposite—pu t the b o r d e r into the glyph—bu t then we must make modification s to the c o r r e s p o n d i n g Glyp h s u b c l a s s to make it awar e of the b o r d e r . Our first c h o i c e , c o m p o s i n g the glyph in the b o r d e r , k e e ps the border-drawin g c o de entirel y in t he B o r d e r c l a s s, l e a v i n g other c l a s s e s alone. Wha t d o es the Borde r c l a ss l o ok l i k e? The f a ct that border s have an appearanc e s u g g e s t s they s h o u l d a c t u a l l y be g l y p h s ; that i s, B o r d e r s h o u l d be a s u b c l a s s of Glyph . B ut there' s a more c o m p e l l i n g reaso n for d o i ng t h i s: C l i e n t s shouldn' t c a re whethe r g l y p h s have border s or not. T h ey s h o u l d treat g l y p h s uniformly . Whe n c l i e n t s t e ll a plain , unbordere d glyph to draw itself , it s h o u l d do so withou t e m b e l l i s h m e n t . If that g l y ph is c o m p o s e d in a b o r d e r , c l i e n t s shouldn' t have to treat the borde r containin g the g l y ph any differently ; they just t e ll it to draw i t s e lf as they t old the p l a in g l y ph before . T h is i m p l i e s that the B o r d e r interfac e matche s the Glyp h interface . We s u b c l a s s B o r d e r from Glyp h to guarante e this relationship. All this leads us to the c o n c e p t of transparen t e n c l o s u r e , w h i c h c o m b i n e s the notion s of ( 1) s i n g l e - c h i l d ( or single-component ) c o m p o s i t i o n a nd ( 2) c o m p a t i b l e interfaces . C l i e n t s g e n e r a l l y can't t e ll whethe r they'r e d e a l i n g with the componen t or its e n c l o s u r e ( i . e ., t he c h i l d ' s parent) , e s p e c i a l l y if t he e n c l o s u r e s i m p l y d e l e g a t e s a ll i ts o p e r a t i o n s to its component . But the e n c l o s u r e can a l so augment the component' s b e h a v i o r by d o i ng work of its own befor e a n d / o r a f t er delegatin g an operation . The e n c l o s u r e can a l so effectively a d d state to the component. We'll see how next. M o n o g l y p h We c an apply t he c o n c e p t of transparen t e n c l o s u r e to a ll g l y p h s that e m b e l l i s h other g l y p h s . To m a k e t h i s c o n c e p t c o n c r e t e , we'll define a subclass of Glyph called Mono- G l y p h to serve as an abstract class for \"embellishment glyphs,\" like Border (see Fig - ure 2.7). MonoGlyph stores a reference to a component and forwards all requests to it. ptgSECTION 2 . 4 EMBELLISHING THE U S E R INTERFACE 4 5 Figur e 2 . 7: MonoGlyp h c l a ss relationships T h at m a k e s M o n o G l y p h totall y transparen t to c l i e n t s by default . F or e x a m p l e , M o n o - Glyp h implement s the D r aw operatio n like this: void M o n o G l y p h : : D r a w ( W i n d o w* w) { _component->Draw(w) ; } MonoGlyp h s u b c l a s s e s reimplemen t at least one of these forwardin g opera- tions . B o r d e r : : D r a w , for instance , first invoke s the paren t c l a ss operatio n M o n o G l y p h : : D r aw on the componen t to let the componen t do its p a r t — t h a t is, draw everythin g but the b o r d e r . Then B o r d e r : : D r aw draw s the borde r by c a l l i n g a privat e operatio n c a l l ed D r a w B o r d e r , the detail s of whic h we'll omit: void Border::Dra w ( W i n d o w* w) { MonoGlyph::Draw(w) ; D r a w B o r d e r ( w ) ; } Notic e how B o r d e r : : D r aw effectivel y extends the paren t c l a ss operatio n to draw the b o r d e r . T h is is in contras t to m e r e l y replacing t he paren t c l a ss operation , whic h woul d omit the c a ll to M o n o G l y p h : : D r a w . Anothe r M o n o G l y p h s u b c l a s s a p p e a r s in F i g u r e 2 . 7. S c r o l l e r is a M o n o G l y p h that draw s its componen t in d i f f e r e n t location s based on the position s of two s c r o ll bars, w h i c h it a d ds as e m b e l l i s h m e n t s . When S c r o l l e r draw s i ts c o m p o n e n t , it t e l ls t he g r a p h - ics syste m to c l ip to its bounds . Clippin g parts of the componen t t h at are s c r o l l e d out of v i ew k e e ps them from a p p e a r i n g on t he s c r e e n . Now we have all the p i e c e s we need to add a borde r and a s c r o l l i n g interfac e to Lexi' s text e d i t i n g a r e a. We c o m p o s e t he e x i s t i n g C o m p o s i t i o n i n s t a n c e in a S c r o l l e r i n s t a n c e to add the s c r o l l i n g interface , and we compos e t h at in a Borde r instance . The resultin g o b j e c t structure appears in Figure 2.8. ptg4 6 A CASE STUDY- DESIGNING A D O C U M E N T E D I T O R CHAPTER 2 F i g u r e 2 . 8 : E m b e l l i s h e d o b j e c t structure ptgSECTION 2.5 SUPPORTING MULTIPLE LOOK-AND-FEEL STANDARDS 47 Note that we can r e v e r s e the order of c o m p o s i t i o n , puttin g the bordere d compositio n into the S c r o l l e r instance . In that c a se the borde r woul d be s c r o l l e d along with the text, whic h may or may not be d e s i r a b l e . The point is, transparen t e n c l o s u r e make s it e a sy to experimen t with differen t alternatives , and it k e e ps c l i e n t s free of e m b e l l i s h m e n t c o d e . Note a l so h ow t he borde r c o m p o s e s o ne g l y p h , n ot t wo or m o r e . T h is is unlik e c o m p o - s i t i o n s we'v e define d so far, in w h i c h paren t o b j e c t s w e re a l l o w e d to have arbitraril y many c h i l d r e n . H e r e, puttin g a borde r aroun d somethin g i m p l i e s that \" s o m e t h i n g \" is s i n g u l a r . We c o u ld a s s i g n a meanin g to e m b e l l i s h i n g m o re than one o b j e c t at a t i m e, but then we'd have to mix many kinds of c o m p o s i t i o n in with the notio n of e m b e l l i s h m e n t : row e m b e l l i s h m e n t , c o l u m n e m b e l l i s h m e n t , and so f o r t h . That won' t help us, s i n ce we alread y have c l a s s e s to do those kinds of c o m p o s i t i o n s . So i t 's bette r to u se e x i s t i n g c l a s s e s for c o m p o s i t i o n and add new c l a s s e s to e m b e l l i s h the result . K eep in g e m b e l l - i s h m e n t independen t of other k i n ds of compositio n both s i m p l i f i e s the e m b e l l i s h m e n t c l a s s e s and r e d u c e s their n u m b e r . It a l so keeps us from r e p l i c a t i n g e x i s t i n g compositio n functionality. The Decorato r ( 1 7 5) patter n capture s c l a ss and o b j e c t relationship s t h at suppor t em- b e l l i s h m e n t by transparen t e n c l o s u r e . The term \" e m b e l l i s h m e n t \" actuall y has broade r meanin g than what w e ' ve c o n s i d e r e d h e r e. In the Decorato r pattern , e m b e l l i s h m e n t refers to anythin g that adds r e s p o n s i b i l i t i e s to an object . We can think for ex amp l e of e m b e l l i s h i n g an abstrac t synta x t r ee with semanti c a c t i o n s , a finite state automato n with new transitions , or a networ k of persisten t o b j e c t s with attribut e tags. Decorato r g e n e r a l i z e s the approach we've used in Lexi to make i t more widely applicable. 2 . 5 Supporting Multiple L o o k - a n d - F e e l S t a n d a r d s A c h i e v i n g portabilit y a c r o s s hardwar e and softwar e platform s is a majo r p r o b l e m in s y s t e m d e s i g n . Retargetin g L e xi to a new p l a t f o r m shouldn' t r e q u i r e a majo r overhaul , or it wouldn' t be worth retargeting . We s h o u l d make portin g as easy as p o s s i b l e . O ne o b s t a c l e to portabilit y is t he diversit y of look-and-fee l standards , whic h a re i n - t e n d e d to enforc e uniformit y betwee n applications . T h e s e standard s defin e g u i d e l i n e s for how a p p l i c a t i o n s appea r and r e a ct to the u s e r. W h i l e e x i s t i n g standard s aren' t that differen t from e a ch o t h e r , p e o p l e c e r t a i n l y won' t confus e one for the other—Moti f ap- p l i c a t i o n s don't l o ok and feel exactl y l i ke their counterpart s on other platforms , and v i ce v e r s a . An applicatio n that runs on m o re than one platfor m must confor m to the u s er interfac e s t y le g u i de on e a ch platform. Our d e s i g n g o a ls are to make L e xi confor m to multipl e e x i s t i n g look-and-fee l standard s and to make it easy to add s u p p o r t for new standards as they (invariably) emerge. W e Decorator Pattern ptg48 A CASE STUDY: DESIGNING A DOCUMENT EDITOR CHAPTER 2 a l so want our d e s i g n to suppor t the ultimat e in flexibility : c h a n g i n g L e x i ' s l o ok and feel at run-time. A b s t r a c t i n g Objec t C r e a t i o n Everythin g we s ee a nd interac t with in L e x i ' s u s er interfac e is a g l y ph c o m p o s e d in o t h e r , i n v i s i b l e g l y p h s l i ke R ow a nd Column . T he i n v i s i b l e g l y p h s c o m p o s e v i s i b l e o n es l i ke Butto n a nd Characte r a nd l ay them o ut p r o p e r l y . S t y le g u i d e s have much to say abou t the l o ok and feel of s o - c a l l e d \" w i d g e t s , \" anothe r term for v i s i b l e g l y p h s l i ke buttons , s c r o ll bars, and menu s that act as c o n t r o l l i n g e l e m e n t s in a u s er interface . W i d g e t s m i g h t u se s i m p l e r g l y p h s s u ch as c h a r a c t e r s , c i r c l e s , r e c t a n g l e s , a nd p o l y g o n s to presen t data. W e ' ll assum e we have t wo s e ts of widge t g l y ph c l a s s e s with whic h to i m p l e m e n t multipl e look-and-fee l standards: 1. A s et of abstrac t Glyp h s u b c l a s s e s f or e a ch categor y of w i d g e t g l y p h . F or e x - a m p l e , an abstrac t c l a ss S c r o l l B a r w i ll augmen t the b a s ic g l y ph interfac e to add genera l s c r o l l i n g o p e r a t i o n s ; Butto n is an abstrac t c l a ss that adds button-oriente d o p e r a t i o n s ; a nd so o n . 2. A set of c o n c r e t e s u b c l a s s e s for e a ch abstrac t s u b c l a s s that i m p l e m e n t differen t look-and-fee l standards . F or e x a m p l e , S c r o l l B a r migh t have M o t if S c r o l l B a r a nd P M S c r o l l B a r s u b c l a s s e s that i m p l e m e n t M o t if a nd Presentatio n M a n a g e r - s t y l e s c r o ll b a r s, r e s p e c t i v e l y . L e xi must d i s t i n g u i s h betwee n widge t glyph s for differen t l o o k - a n d - f e e l s t y l e s . For e x a m p l e , when L e xi n e e ds to put a butto n in its interface , it must instantiat e a Glyp h s u b c l a s s for the right s t y le of butto n (MotifButton , P M B u t t o n , MacButton , e t c . ) . I t 's c l e ar that L e x i ' s implementatio n can't do t h is d i r e c t l y , s a y, using a constructo r c a ll in C++. T h at woul d har d- cod e the butto n of a particula r s t y l e, makin g it i m p o s s i b l e to s e l e ct the s t y le at run-time . W e 'd a l so have to track down and c h a n g e e v e ry s u ch constructo r c a ll to port L e xi to anothe r platform . And button s are o n ly one of a v a r i e t y of widget s in L e x i ' s us er interface . Litterin g o ur c o de with constructo r c a l ls to s p e c i f i c look-and-fee l c l a s s e s y i e l d s a maintenanc e nightmare—mis s just o n e, and you c o u ld end up with a M o t if menu in the middl e of your Mac a p p l i c a t i o n . L e xi n e e ds a way to determin e the l o o k - a n d - f e e l standar d that's b e i ng targete d in o rder to creat e the appropriat e widgets . Not o n ly must we a v o id makin g e x p l i c i t c o n s t r u c t o r c a l l s; we must a l so be a b le to r e p l a c e an e n t i re widge t s et e a s i l y . We c an a c h i e v e both by abstracting the process of o b j e c t c r e a t i o n . An example will illustrate what we mean. ptgSECTION 2.5 SUPPORTING MULTIPLE LOOK-AND-FEEL STANDARDS 49 Factorie s a nd P r o d u c t C l a s s e s Normall y we migh t creat e an i n s t a n c e of a Motif s c r o ll bar glyph with the followin g C ++ c o d e : S c r o l l B a r * sb = n ew M o t i f S c r o l l B a r ; T h is is t he k i nd of c o de to a v o id if y ou want to m i n i m i z e L e x i ' s look-and-fee l d e p e n - d e n c i e s . B ut suppos e we i n i t i a l i z e sb as follows: S c r o l l B a r * sb = g u i F a c t o r y - > C r e a t e S c r o l l B a r ( ) ; wher e g u i F a c t o r y is an i n s t a n c e of a MotifFactor y c l a s s. C r e a t e S c r o l l B a r return s a new i n s t a n c e of t he prope r S c r o l l B a r s u b c l a s s for t he l o ok and feel d e s i r e d , M o t if in t h is c a s e. As far as c l i e n t s a re c o n c e r n e d , t he effec t is t he s a me as c a l l i n g t he M o t i f S c r o l l B a r constructo r d i r e c t l y . But t h e r e ' s a c r u c i a l difference : T h e r e ' s no l o n g e r anythin g in the c o de that mention s Motif by name . The g u i F a c t o r y o b j e c t abstract s the p r o c e s s of c r e a t i n g not just M o t if s c r o ll bars but s c r o ll bars for any look-and-fee l standard . And g u i F a c t o r y i s n 't l i m i t e d to producin g s c r o ll bars. It can manufactur e a full r a n ge of widge t g l y p h s , i n c l u d i n g s c r o ll bars, buttons , entry fields , menus , and so forth. A ll t h is is p o s s i b l e b e c a u s e MotifFactor y is a s u b c l a s s of G U I F a c t o r y , an a b s t r a c t c l a ss that define s a g e n e r a l interfac e for c r e a t i n g widge t g l y p h s . It i n c l u d e s operation s l i ke C r e a t e S c r o l l B a r and C r e a t e B u t t o n for i n s t a n t i a t i n g differen t k i n ds of w i d g e t g l y p h s . S u b c l a s s e s of GUIFactor y i m p l e m e n t t h e se operation s to retur n g l y p h s s u ch as M o t i f S c r o l l B a r a nd P M B u t t o n that i m p l e m e n t a p a r t i c u l a r l o ok a nd f e e l. F i g u r e 2 .9 s h o w s the r e s u l t i n g c l a ss hierarch y for g u i F a c t o r y o b j e c t s . We say that factorie s creat e produc t o b j e c t s . M o r e o v e r , the product s that a factor y produce s are r e l a t e d to one another ; in t h is c a s e, the product s are all widget s for the s a me l o ok a nd feel. F i g u r e 2 . 10 s h o w s s o me of t he produc t c l a s s e s n e e d e d to make factorie s work for widge t g l y p h s . The l a st q u e s t i o n we have to answe r is, Wher e d o es the G U I F a c t o r y i n s t a n c e c o me from ? T he a n s w e r i s, A n y w h e r e that's c o n v e n i e n t . T he v a r i a b l e g u i F a c t o r y c o u ld be a g l o b a l , a static membe r of a w e l l - k n o w n c l a s s, or e v en a l o c al variabl e if the e n t i re u s er i n t e r f a c e is c r e a t e d w i t h i n o ne c l a ss or f u n c t i o n . T h e r e ' s e v en a d e s i g n pattern , S i n g l e t o n ( 1 2 7 ) , f or managin g w e l l - k n o w n , o n e - o f - a - k i n d o b j e c t s l i ke t h i s. T he importan t t h i n g , t h o u g h , is to i n i t i a l i z e g u i F a c t o r y at a p o i nt in t he p r o g r a m before it's e v er used to creat e w i d g e t s but after i t 's c l e ar whic h l o ok and feel is d e s i r e d . If t he l o ok a nd feel is know n at c o m p i l e - t i m e , then g u i F a c t o r y c an be i n i t i a l i z e d w i th a s i m p l e assignmen t of a new factor y i n s t a n c e at the b e g i n n i n g of the program: G U I F a c t o r y * g u i F a c t o r y = n ew M o t i f F a c t o r y ; If the user can specif y the l o ok and feel with a string name at startu p t i m e, then the c o d e to create the factory might be ptg5 0 A CASE STUDY- DESIGNING A D O C U M E N T E D I T O R CHAPTER 2 F i g u r e 2 . 1 0 : A b s t r a c t p r o d u c t c l a s s e s and concrete subclasses Fgure 2.9: GUFactory class hierarchy ptgSECTION 2.6 SUPPORTING MULTIPLE WINDOW SYSTEMS 51 GUIFactory * guiFactory ; c o n st c h a r* s t y l e N a me = getenv(\"LOOK_AND_FEEL\"); // u s er or e n v i r o n m e n t supplies this at startup if (strcmp(styleName , \"Motif\") = =0) { guiFactor y = new MotifFactory; } else if (strcmp(styleName , \"Presentation_Manager\" ) == 0) { guiFactor y - new PMFactory; } else { g u i F a c t o r y = n ew D e f a u l t G U I F a c t o r y ; } T h e re are more sophisticate d ways to s e l e c t the factor y at run-time . For e x a m p l e , you could maintai n a registr y that maps string s to factor y o b j e c t s . That l e ts you r e g i s t e r i n s t a n c e s of new factor y s u b c l a s s e s withou t modifyin g e x i s t i n g c o d e, as the p r e c e d i n g approac h requires . And you don't have to link all platform-specifi c factorie s into the application . That' s important , b e c a u s e it migh t not be p o s s i b l e to l i nk a MotifFactor y on a p l a t f o r m t h at doesn' t suppor t Motif. But the point is that o n ce we've configure d the applicatio n with the right factor y o b j e c t , its l o ok and feel is set f r om then on. If we chang e our m i n d s , we can r e i n i t i a l i z e g u i F a c t o r y with a f a c t o r y for a differen t l o ok and feel and then reconstruc t the interface . Regardles s of how and when we d e c i d e to initializ e g u i F a c t o r y , we know t h at o n ce we do, the applicatio n can creat e the appropriat e l o ok and feel withou t modification. A b s t r a c t F a c t o r y P a t t e r n F a c t o r i e s a nd p r o d u c t s a re t he k ey p a r t i c i p a n t s in t he Abs tr ac t F a c t o r y ( 8 7) pattern . T h is patter n capture s how to creat e familie s of relate d produc t object s withou t instantiatin g c l a s s e s d i r e c t l y . It's most appropriat e when the numbe r and g e n e r a l kinds of produc t object s stay constant , and there are difference s in s p e c i f i c produc t families . We c h o o s e betwee n familie s by instantiatin g a particula r c o n c r e t e factor y and using it consistentl y to creat e product s thereafter . We can a l so swap entire familie s of product s by r e p l a c i n g the concret e f a c t o r y with an instanc e of a differen t o n e. The Abstrac t Factor y pattern's emphasi s on families of product s d i s t i n g u i s h e s it from o t h er c r e a t i o n a l patterns , w h i c h involve only one kind of product o b j e c t . 2 . 6 Supporting Multiple Window S y s t e m s L o ok and feel is j u st one of many portabilit y i s s u e s . Another is the windowin g en- vironmen t in whic h L e xi runs. A platform' s windo w syste m create s the i l l u s i o n of multiple overlapping windows o n a bitmapped display. It manages screen space for ptg52 A C A SE S T U D Y - DESIGNING A DOCUMENT EDITOR CHAPTER 2 window s and route s input to them f r om the keyboar d and mouse . S e v e r a l importan t and l a r g e l y i n c o m p a t i b l e windo w s y s t e m s e x i st today ( e . g ., Macintosh , Presentatio n Manager , Windows , X ). W e 'd l i ke L e xi to run on as many of them as p o s s i b l e for exactl y the same reason s we suppor t multipl e look-and-fee l standards. C an We U se an A b s t r a c t F a c t o r y ? At first g l a n c e this may l o ok l i ke anothe r opportunit y to apply the Abstrac t Factor y pattern . But the constraint s for windo w syste m portabilit y d i f f er significantl y f r om those for look-and-fee l independence. In applyin g the Abstrac t Factor y pattern , we a s s u m e d we woul d defin e the c o n c r e t e widge t glyph c l a s s e s for e a ch look-and-fee l standard . That mean t we c o u ld deriv e e a ch c o n c r e t e produc t for a particula r standar d ( e . g ., M o t i f S c r o l l B a r and M a c S c r o l l B a r ) f r om an abstrac t produc t c l a ss ( e . g ., S c r o l l B a r ) . B ut suppos e we alread y have s e v e r a l c l a ss h i e r a r c h i e s from differen t v e n d o r s , o ne f or e a ch l o o k - a n d - f e e l s t a n d a r d . Of c o u r s e , i t 's h i g h l y unlikel y these h i e r a r c h i e s are compatibl e in any w a y. H e n c e we won' t have a commo n abstrac t produc t c l a ss for each kind of w i d g e t ( S c r o l l B a r , Button , Menu , etc.)— and the Abstrac t Factor y patter n won' t work withou t those c r u c i a l c l a s s e s . We have to make the differen t widge t h i e r a r c h i e s adher e to a commo n set of abstrac t produc t interfaces . Only then c o u ld we d e c l a r e the C r e a t e . . . operation s properl y in our abstrac t factory' s interface. We s o l v e d this p r o b l e m f or widget s by developin g our own abstrac t and c o n c r e t e prod- uct c l a s s e s . Now we're faced with a s i m i l a r p r o b l e m when we try to make L e xi work on e x i s t i n g windo w s y s t e m s ; n a m e l y , differen t w i n d o w s y s t e m s have incompatibl e programmin g interfaces . T h i n g s are a bit toughe r this t i m e, though , b e c a u s e we can't affor d to i m p l e m e n t o ur o wn nonstandar d w i n d o w s y s t e m . But there' s a s a v i n g grace . L i ke look-and-fee l standards , windo w syste m interface s aren' t r a d i c a l l y differen t from o ne a n o t h e r , b e c a u s e a ll w i n d o w s y s t e m s do g e n e r a l l y the same thing . We n e ed a unifor m set of windowin g abstraction s that lets us take differen t windo w s y s t e m implementation s and s l i de any one of them unde r a commo n interface. E n c a p s u l a t i n g I m p l e m e n t a t i o n Dependencies In S e c t i o n 2.2 we introduce d a W i n d o w c l a ss for d i s p l a y i n g a glyph or g l y ph structur e on the d i s p l a y . We didn' t s p e c i f y the windo w s y s t e m that this o b j e c t worke d with, b e c a u s e the t r u th is that it doesn' t c o me from any particula r windo w s y s t e m . The W i n d o w class encapsulates the things windows tend to do across window systems: • T h e y p r o v i d e o p e r a t i o n s for drawing basic geometric shapes. • T h e y can i c o n i f y and de-iconify t h e m s e l v e s . ptgSECTION 2 . 6 SUPPORTING MULTIPLE WINDOW SYSTEMS 53 R e s p o n s i b i l i t y w i n d o w m a n a g e m e n t g r a p h i c sO p e r a t i o ns virtual virtual virtual virtual virtual virtual virtual virtual virtualvoid Redraw () void Raise () void L o w er ( ) void I c o n i fy ( ) void DeiconifyO void D r a w L i ne ( . . .) void D r a w R e ct (...) v o id D r a w P o l y g o n ( . . .) void DrawText ( . . . ) T a b le 2 . 3: Windo w c l a ss interface • They can r e s i ze themselves. • T h ey can (re)dra w their content s on demand , for example , when they are de- iconifie d or when an overlappe d and obscure d portio n of their s c r e e n s p a ce is exposed. The Windo w c l a ss must span the functionalit y of window s from d i f f e r e n t windo w systems . Let's conside r two extrem e philosophies: 1. Intersection of functionality. T he Windo w c l a ss interfac e provide s only functionalit y that's c o m m o n to a ll w i n d o w s y s t e m s . T he p r o b l e m with t h is a p p r o a c h is that o ur Windo w interfac e wind s up being only as powerfu l as the least capabl e windo w system . We can't take advantag e of more advance d feature s e v en if most (but not all) windo w system s suppor t them. 2. Union of functionality. C r e a t e an interfac e that i n c o r p o r a t e s the c a p a b i l i t i e s of all existin g systems . The troubl e here is that the resultin g interfac e may w e ll be huge and incoherent . B e s i d e s , we'll have to chang e it (and L e x i, whic h depend s on it) anytim e a vendo r r e v i s e s its windo w syste m interface. N e i t h e r e x t r e m e is a v i a b l e s o l u t i o n , so o ur d e s i g n w i ll fall s o m e w h e r e betwee n t he two. The Windo w c l a ss w i ll provid e a convenien t interfac e that support s the most popula r w i n d o w i n g features . B e c a u s e L e xi w i ll d e al with t h is c l a ss d i r e c t l y , t he W i n d o w c l a ss must also suppor t the thing s L e xi know s about , n a m e l y , g l y p h s . That mean s Window' s interfac e must includ e a basic set of graphic s operation s that lets g l y p h s draw themselve s in the window . T a b le 2.3 g i v es a samplin g of the operation s in the Windo w c l a ss interface. Windo w is an abstrac t c l a s s. C o n c r e t e s u b c l a s s e s of Windo w suppor t the d i f f e r e n t kinds of window s t h at users deal with. For example , applicatio n windows , i c o n s , and warnin g d i a l o g s are all windows , but they have somewha t differen t behaviors . So we can defin e s u b c l a s s e s l i k e A p p l i c a t i o n W i n d o w , Icon W i n d o w , and DialogWindow to capture these ptg54 A C A SE S T U D Y - DESIGNING A DOCUMENT EDITOR CHAPTER 2 d i f f e r e n c e s . T he r e s u l t i n g c l a ss h i e r a r c h y g i v es a p p l i c a t i o n s l i ke L e xi a unifor m a nd intuitiv e windowin g abstraction , one that doesn' t depen d on any particula r vendor' s window system: Now that we've define d a windo w interfac e for L e xi to work with, wher e d o es the r e al platform-specifi c windo w c o me in? If we're not implementin g our own windo w s y s t e m , then at s o me point our windo w abstractio n must be implemente d in terms of what the targe t windo w syste m provides . So wher e d o es that implementatio n l i v e ? O ne approac h is to implemen t multipl e v e r s i o n s of t he Windo w c l a ss a nd i ts s u b c l a s s e s , o ne v e r s i o n f or e a ch w i n d o w i n g platform . W e 'd h a ve to c h o o s e t he v e r s i o n to u se w h en we b u i ld L e xi for a g i v en platform . But imagin e the maintenanc e headache s we'd have keep i n g track of multipl e c l a s s e s , all name d \" W i n d o w \" but each implemente d on a differen t windo w s y s t e m . A l t e r n a t i v e l y , we c o u ld creat e implementation-specifi c s u b c l a s s e s of e a ch c l a ss in the Windo w hierarchy—an d end up with anothe r s u b c l a s s e x p l o s i o n p r o b l e m l i ke the one we had tryin g to add e m b e l l i s h m e n t s . Both of these a l t e r n a t i v e s h a ve anothe r drawback : Neithe r g i v es us the flexibilit y to chang e the windo w syste m we use a f t er we've c o m p i l e d the program . So we'll have to keep s e v e r a l differen t e x e c u t a b l e s aroun d as w e l l . Neithe r alternativ e is v e ry appealing , but w h at e l se can we do? The same thing we did for formattin g and e m b e l l i s h m e n t , n a m e l y , encapsulate the concept that varies. Wha t v a r i e s in t h is c a se is t he w i n d o w s y s t e m i m p l e m e n t a t i o n . If we e n c a p s u l a t e a w i n d o w s y s t e m ' s functionalit y in an object , then we can implemen t our Windo w c l a ss and s u b c l a s s e s in terms of that object' s interface . M o r e o v e r , if t h at interfac e can s e r ve all t he windo w system s we're i n t e r e s t e d i n, then we won' t have to c h a n g e W i n d o w or any of its s u b c l a s s e s to suppor t differen t windo w systems . We can configur e windo w o b j e c t s to the windo w syste m we want s i m p l y by p a s s i n g them the right windo w s y s t e m - e n c a p s u l a t i n g o b j e c t . We can even configure t h e window at run-time. ptgSECTION 2 . 6 SUPPORTING M U L T I P L E WINDOW SYSTEMS 5 5 Windo w a nd Windowlmp W e ' ll defin e a separat e Windowlm p c l a ss hierarch y in whic h to hide d i f f e r e n t windo w syste m implementations . Windowlm p is an abstrac t c l a ss for o b j e c t s that encapsulat e windo w system-dependen t c o d e. To make L e xi work on a particula r windo w s y s - tem, we configur e each windo w objec t with an instanc e of a Windowlm p s u b c l a s s for that system . The followin g diagra m show s the relationshi p betwee n the Windo w and Windowlmp hierarchies: By hidin g the implementation s in Windowlm p c l a s s e s , we a v o id pollutin g the Windo w c l a s s e s with windo w syste m d e p e n d e n c i e s , whic h k e e ps the W i n d o w c l a ss hierarch y comparativel y s m a ll and s t a b l e . Meanwhil e we can e a s i ly exten d the implementatio n hierarch y to suppor t new windo w systems. Windowlm p S u b c l a s s e s S u b c l a s s e s of W i n d o w l m p c o n v e r t r e q u e s t s i n to w i n d o w s y s t e m - s p e c i f i c o p e r a t i o n s . Conside r the exampl e we used in S e c t i o n 2 . 2. We define d the R e c t a n g l e : : D r aw in terms of the D r a w R e c t operatio n on the Windo w instance: void Rectangle::Dra w ( W i n d o w* w) { w->DrawRect(_xO , _yO, _xl, _yl); } The defaul t implementatio n of D r a w R e c t uses the abstrac t operatio n for drawin g rectangle s declare d by Windowlmp: void Window::DrawRec t ( C o o rd xO, C o o rd yO, C o o rd xl, C o o rd yl ) { _imp->DeviceRect(xO , yO, xl, yl); } ptg56 A CASE STUDY: DESIGNING A DOCUMENT EDITOR CHAPTER 2 w h e r e _ i mp is a m e m b e r v a r i a b l e of W i n d o w t h at s t o r e s t he W i n d o w l m p with w h i c h t he W i n d o w is c o n f i g u r e d . T he w i n d o w i m p l e m e n t a t i o n is d e f i n e d by t he i n s t a n c e of t he W i n d o w l m p s u b c l a s s t h at _ i mp p o i n t s t o. F or an X W i n d o w I m p ( t h at i s, a W i n d o w l m p s u b c l a s s f or t he X W i n d o w S y s t e m ) , t he D e v i c e R e c t ' s i m p l e m e n t a t i o n m i g h t l o ok l i k e void X W i n d o w I m p : : D e v i c e R e c t ( C o o r d x O, Coor d y O, C o o r d x l, C o o r d y l ) { i nt x = r o u n d ( m i n ( x O , x l )) ; i nt y = r o u n d ( m i n ( y O , y l ) ) ; i nt w = r o u n d ( a b s ( x O - x l )) ; i nt h = r o u n d ( a b s ( y O - y l) ) ; X D r a w R e c t a n g l e ( _ d p y , _ w i n i d , _ g c, x, y, w, h) ; } D e v i c e R e c t is d e f i n e d l i ke t h is b e c a u s e X D r a w R e c t a n g l e ( t he X i n t e r f a c e for d r a w - i ng a r e c t a n g l e ) d e f i n e s a r e c t a n g l e in t e r m s of i ts l o w e r left c o r n e r , i ts w i d t h , a nd i ts h e i g h t . D e v i c e R e c t m u st c o m p u t e t h e se v a l u e s f r om t h o se s u p p l i e d . F i r st it a s c e r t a i n s t he l o w e r left c o r n e r ( s i n c e ( x O, y O) m i g h t be a ny o ne of t he r e c t a n g l e ' s f o ur c o r n e r s ) a nd t h en c a l c u l a t e s t he widt h a nd h e i g h t . P M W i n d o w I m p (a s u b c l a s s of W i n d o w l m p f or P r e s e n t a t i o n M a n a g e r ) w o u l d d e f i n e D e v i c e R e c t differently: void PMWindowImp::DeviceRec t ( Coord xO, Coord yO, Coord xl, Coord yl ) { Coord left = m i n f x O, xl); Coord right = max(xO, xl); Coord bottom = min(yO, yl); Coord top = max(yO, yl); P P O I N TL point[4]; point[0]. x = left; point[0]. y = top; point[l]. x = right; point[1]. y = top; point[2]. x = right; point[2]. y = bottom; point[3]. x = left; point[3]. y = bottom; if ( (GpiBeginPath(_hps , 1L) == false) I I (GpiSetCurrentPosition(_hps , &point[3] ) == false) II (GpiPolyLine(_hps , 4 L, point) == GPI_ERROR ) I I ( G p i E n d P a t h ( _ h p s ) == false) ) { // r e p o rt e r r o r } else { G p i S t r o k e P a t h ( _ h p s , 1L, OL); } } ptgSECTION 2.6 SUPPORTING MULTIPLE WINDOW SYSTEMS 57 Why is this so differen t from the X v e r s i o n ? W e l l, PM doesn' t have an o p e r a t i o n for drawin g r e c t a n g l e s e x p l i c i t l y as X d o e s. Instead , PM has a m o re genera l interfac e for s p e c i f y i n g v e r t i c e s of m u l t i s e g m e n t s h a p e s ( c a l l e d a path) a nd f or o u t l i n i n g or f i l l i ng t he a r ea they e n c l o s e . P M 's implementatio n of D e v i c e R e c t is o b v i o u s l y quite differen t from X ' s, but that doesn' t matter . Windowlm p h i d es variation s in windo w s y s t e m interface s behin d a potentiall y l a r ge but s t a b le interface . That l e ts W i n d o w s u b c l a s s writer s focus on the windo w abstractio n and not on windo w s y s t e m details . It a l so l e ts us add suppor t for new windo w system s withou t disturbin g the Windo w c l a s s e s . C o n f i g u r i n g W i n d o w s w i th W i n d o w l m p s A k ey i s s ue we h a v e n ' t a d d r e s s e d is h ow a w i n d o w g e ts c o n f i g u r e d w i th t he p r o p e r W i n d o w l m p s u b c l a s s in t he first p l a c e . S t a t e d a n o t h e r w a y, w h en d o es _ i mp g et i n i - t i a l i z e d , a nd w ho k n o w s what w i n d o w s y s t e m ( a nd c o n s e q u e n t l y w h i c h W i n d o w l m p s u b c l a s s ) is in u s e? T he w i n d o w w i ll n e ed s o me k i nd of W i n d o w l m p bef or e it c an do a n y t h i n g i n t e r e s t i n g . T h e re a re s e v e r a l p o s s i b i l i t i e s , b ut w e ' ll focus on o ne that u s es t he Abstrac t F a c t o r y ( 8 7) pattern . We can defin e an abstrac t factor y c l a ss W i n d o w S y s t e m F a c t o r y that p r o v i d e s an interfac e f or c r e a t i n g differen t k i n ds of windo w system-dependen t i m p l e m e n t a t i o n o b j e c t s : c l a s s W i n d o w S y s t e m F a c t o r y { p u b l i c : v i r t u a l W i n d o w l m p * C r e a t e W i n d o w I m p ( ) = 0; v i r t u a l C o l o r l m p * C r e a t e C o l o r l m p ( ) = 0; v i r t u a l F o n t l m p * C r e a t e F o n t l m p ( ) = 0 ; // a \" C r e a t e . . . \" o p e r a t i o n f or a ll windo w syste m r e s o u r c e s } ; Now we can defin e a c o n c r e t e factor y for e a ch windo w system: c l a s s P M W i n d o w S y s t e m F a c t o r y : p u b l i c W i n d o w S y s t e m F a c t o r y { v i r t u a l W i n d o w l m p * C r e a t e W i n d o w I m p ( ) { r e t u r n n ew P M W i n d o w I m p ; } // . . . } ; c l a ss X W i n d o w S y s t e m F a c t o r y : public WindowSystemFactor y { virtual Wi nd owlmp * C r e a t e W i n d o w I m p ( ) { r e t u rn new X W i n d o w I m p ; } // . . . } ; The W i n d o w b a se c l a ss constructo r can use the W i n d o w S y s t e m F a c t o r y interfac e to i n i t i a l i z e the _imp member with the Windowlmp that's right for the window system: ptg58 A CASE STUDY: DESIGNING A DOCUMENT EDITOR CHAPTER 2 W i n d o w : : W i n d o w ( ) { _ i mp = w i n d o w S y s t e m F a c t o r y - > C r e a t e W i n d o w I m p ( ) ; } The w i n d o w S y s t e m F a c t o r y v a r i a b l e is a well-know n instanc e of a W i n d o w S y s t e m - Factor y s u b c l a s s , akin to the well-know n g u i F a c t o r y variabl e definin g the l o ok and feel. The w i n d o w S y s t e m F a c t o r y variabl e can be initialize d in the same w a y . B r i d g e P a t t e r n The Windowlm p c l a ss define s an interfac e to commo n windo w syste m f a c i l i t i e s , but i ts d e s i g n is d r i v e n by differen t c o n s t r a i n t s than W i n d o w ' s i n t e r f a c e . A p p l i c a t i o n p r o - grammer s won' t deal with Windowimp' s interfac e d i r e c t l y ; they o n ly deal with W i n - d ow o b j e c t s . So Windowlmp' s interfac e needn' t matc h t he a p p l i c a t i o n programmer' s v i ew of the w o r l d , as was our concer n in the d e s i g n of the W i n d o w c l a ss hierarch y and interface . Windowlmp' s interfac e can more c l o s e l y reflec t what windo w system s a c t u a l l y p r o v i d e , warts a nd a l l. It c an be b i a s e d towar d e i t h er an i n t e r s e c t i o n or a u n i on of functionalit y approach , whicheve r suits the targe t windo w system s best. The importan t thing to realiz e is that Window' s interfac e cater s to the application s p r o g r a m m e r , w h i le Windowlm p c a t e rs to w i n d o w s y s t e m s . S e p a r a t i n g w i n d o w i n g functionalit y into Windo w and Windowlm p h i e r a r c h i e s l e ts us implemen t and s p e c i a l - i ze these interface s i n d e p e n d e n t l y . O b j e c t s from t h e se h i e r a r c h i e s cooperat e to l et L e xi work withou t modificatio n on multipl e windo w systems. T he relationshi p betwee n Windo w a nd Windowlm p is an exampl e of t he B r i d g e ( 1 5 1) pattern . T he inten t b e h i n d B r i d g e is to a l l ow separat e c l a ss h i e r a r c h i e s to work togethe r e v en as they e v o l v e independently . Our d e s i g n c r i t e r i a led us to creat e two separat e c l a ss h i e r a r c h i e s , one that support s the l o g i c a l notio n of w i n d o w s , and anothe r for c a p t u r i n g differen t i m p l e m e n t a t i o n s of w i n d o w s . T he B r i d g e patter n l e ts us m a i n t a i n and e n h a n c e our logical windowing abstractions without touching window system- dependent code, and vice versa. 2 . 7 User Operations S o me of L e x i ' s functionalit y is availabl e throug h t he document' s W Y S I W Y G r e p r e s e n - t a t i o n . Y ou enter a nd d e l e te t e x t, move t he i n s e r t i o n point , a nd s e l e ct range s of text by p o i n t i n g , c l i c k i n g , a nd typin g d i r e c t l y in t he document . Othe r functionalit y is a c c e s s e d i n d i r e c t l y throug h user operation s in L e x i ' s pull-dow n menus , buttons , and keyboar d a c c e l e r a t o r s . The functionality includes operations for • c r e a t i n g a new document, • o p e n i n g , s a v i n g , and printing an existing document, ptgSECTION 2.7 USER OPERATIONS 59 • cuttin g s e l e c t e d text out of the documen t and pastin g it back i n , • changin g the font and style of s e l e c t e d text, • c h a n g i n g the f o r m a t t i n g of text, such as its alignmen t and justification, • quittin g the application, • and on and on. L e xi provide s differen t u s er interface s for these operations . But we don't want to a s s o c i a t e a particula r u s er o p e r a t i o n w i th a particula r u s er i n t e r f a c e , b e c a u s e we m ay want multipl e u s er interface s to the same operatio n (you can turn the page using e i t h e r a page butto n or a menu operation , for example) . We may a l so want to c h a n g e the interfac e in the f u t u r e . Furthermore , t h e se operation s are implemente d in many differen t c l a s s e s . We as i m p l e - mentor s want to a c c e s s their functionalit y withou t creatin g a lot of d e p e n d e n c i e s be- twee n implementatio n and u ser interfac e c l a s s e s . Otherwis e we'll end up with a tightl y c o u p l e d i m p l e m e n t a t i o n , w h i ch w i ll be h a r d e r to u n d e r s t a n d , e x t e n d , a nd m a i n t a i n . To f u r t h e r complicat e matters , we want L e xi to suppor t undo and r e d o 8 of m o st but n ot a ll i ts f u n c t i o n a l i t y . S p e c i f i c a l l y , we want to be a b le to undo d o c u m e n t - m o d i f y i n g operation s l i ke d e l e t e , with whic h a user can destro y lots of data inadvertently . But we shouldn' t try to undo an operatio n l i ke s a v i n g a drawin g or quittin g the application . T h e se operation s s h o u l d have no e f f e c t on the undo p r o c e s s . We a l so don't want an arbitrar y l i m it on the numbe r of l e v e ls of undo and redo. It's c l e ar that suppor t for user operation s permeate s the application . The c h a l l e n g e is to c o me up with a s i m p l e and e x t e n s i b l e m e c h a n i s m that satisfie s all of t h e se n e e d s . Encapsulatin g a Request F r om our perspectiv e as d e s i g n e r s , a pull-dow n menu is j u st anothe r k i nd of g l y ph that contain s other g l y p h s . Wha t d i s t i n g u i s h e s pull-dow n menu s from other g l y p h s that have c h i l d r e n is that most g l y p h s in menu s do s o me work in r e s p o n s e to an u p - c l i c k . Let's assum e that t h e se work-performin g g l y p h s are instance s of a G l y p h s u b c l a s s c a l l ed Menulte m and that they do their work in r e s p o n s e to a reques t f r om a c l i e n t . 9 Carryin g out the reques t migh t i n v o l v e an operatio n on one object , or many operation s on many o b j e c t s , or s o m e t h i n g in b e t w e e n . We could defin e a s u b c l a s s of Menulte m for every us er operatio n and then hard-cod e e a ch s u b c l a s s to c a r ry o ut t he r e q u e s t . B ut that's n ot r e a l ly r i g h t; we d o n 't n e ed a s u b c l a s s of Menulte m for e a ch reques t any more than we n e ed a s u b c l a s s for each text 8 That is, redoin g an operatio n that was j u st undone. 9 Conceptually , the clien t is L e x i ' s u s e r, but in realit y it's anothe r objec t (such as an event dispatcher ) that manages inputs from t h e user. ptg60 A C A SE STUDY: DESIGNING A DOCUMENT EDITOR CHAPTER 2 s t r i ng in a p u l l - d o w n menu . M o r e o v e r , t h is approac h c o u p l e s the r e q u e s t to a particula r user interface , makin g it hard to f u l f i l l the reques t throug h a differen t u s er interface. To illustrate , suppos e you c o u ld advanc e to the last page in the documen t both throug h a Menulte m in a pull-dow n menu and by p r e s s i n g a page i c on at the botto m of L e x i ' s interfac e ( w h i c h m i g h t be m o re c o n v e n i e n t f or s h o rt d o c u m e n t s ) . If we a s s o c i a t e t he reques t with a Menulte m throug h inheritance , then we must do the same for the page i c on and any other kind of widge t t h at migh t i s s ue s u ch a request . That can g i ve rise to a numbe r of c l a s s e s approachin g the produc t of the numbe r of widge t types and the numbe r of requests. What' s m i s s i n g is a mechanis m that lets us parameteriz e menu i t e ms by the reques t they shoul d fulfill . That way we avoid a proliferatio n of s u b c l a s s e s and a l l ow for greate r flexibilit y at run-time . We could parameteriz e Menulte m with a functio n to c a l l, but that's not a complet e solutio n for at least three reasons: 1. It doesn' t addres s t he u n d o / r e d o problem. 2. It's hard to associat e state with a function . For example , a functio n t h at change s the f o nt n e e ds to know which f o n t . 3. Function s are hard to extend , and it's hard to reuse parts of them. T h e s e r e a s o n s s u g g e s t t h at we shoul d parameteriz e Menultem s with an object, not a function . T h en we c an use inheritanc e to exten d and r e u se the request' s implementation . We also have a place to store state and implemen t u n d o / r e d o functionality . H e re we have anothe r exampl e of encapsulatin g the c o n c e p t that v a r i e s , in this c a se a request . W e ' ll encapsulat e e a ch r e q u e s t in a c o m m a n d o b j e c t . C o m m a n d C l a ss a nd S u b c l a s s e s F i r st we defin e a C o m m a n d abstrac t c l a ss to provid e an interfac e for i s s u i n g a request . T he b a s ic interfac e c o n s i s t s of a s i n g le abstrac t operatio n c a l l ed \" E x e c u t e . \" S u b c l a s s e s of C o m m a n d i m p l e m e n t E x e c u t e in differen t ways to fulfil l differen t r e q u e s t s . S o me s u b c l a s s e s may delegat e part or all of the work to other objects . Othe r s u b c l a s s e s may be in a positio n to fulfil l t he reques t entirel y on their o wn ( s ee F i g u r e 2 . 1 1 ). To t he r e q u e s t e r , however , a Comman d objec t is a Comman d object—the y are treate d uniformly. N ow M e n u l t e m c an s t o re a C o m m a n d o b j e c t that e n c a p s u l a t e s a r e q u e s t ( F i g u r e 2 . 1 2 ). We g i ve each menu item o b j e c t an instanc e of the Comman d s u b c l a s s that's suitabl e for that menu item, just as we specif y the text to appea r in the menu i t e m. Whe n a u s er c h o o s e s a particula r menu i t e m, the Menulte m simpl y c a l ls Execut e on its Comman d o b j e c t to carry out the request . Note that b u t t o n s and other widget s can use command s in the same way menu items do. ptgSECTION 2 . 7 USER O P E R A T I O N S 61 F i g u r e 2.11: Partial Command class hierarchy F i g u r e 2.12: Menultem-Command r e l a t i o n s h i p ptg62 A CASE STUDY: DESIGNING A DOCUMENT EDITOR CHAPTER 2 Undoability U n d o / r e d o is an importan t capabilit y in interactiv e applications . To undo and r e do commands , we add an Unexecut e operatio n to Command' s interface . Unexecut e re- v e r s e s the effect s of a p r e c e d i n g Execut e operatio n using whateve r undo informatio n Execut e s t o r e d . In the c a se of a FontCommand , for example , the Execut e operatio n woul d store the range of text a f f e c t e d by the f o nt chang e along with the o r i g i n a l font(s) . FontCommand' s Unexecut e operatio n woul d restor e the range of text to its o r i g i n a l font(s). S o m e t i m e s undoabilit y must be determine d at run-time . A r e q u e s t to chang e the f o nt of a s e l e c t i o n d o es nothin g if the text alread y appear s in that f o n t. S u p p o s e the u s er s e l e c t s s o me t e xt a nd t h en r e q u e s t s a s p u r i o u s font c h a n g e . Wha t s h o u l d be t he r e s u l t of a s u b s e q u e n t undo request ? S h o u l d a m e a n i n g l e s s chang e c a u se the undo r e q u e s t to do somethin g e q u a l l y m e a n i n g l e s s ? P r o b a b l y not. If the u s er repeat s the spuriou s f o nt chang e s e v e r a l t i m e s , he shouldn' t have to perfor m e x a c t l y the same numbe r of undo operation s to get back to the last meaningfu l operation . If the net effec t of executin g a comman d was nothing , then there' s no n e ed for a c o r r e s p o n d i n g undo request. So to determin e if a comman d is undoable , we a dd an abstrac t R e v e r s i b l e operatio n to the Comman d interface . R e v e r s i b l e return s a B o o l e a n value . S u b c l a s s e s can redefin e this operatio n to retur n true or false b a s ed on run-tim e criteria. C o m m a n d H i s t o r y The final s t ep in supportin g arbitrary-leve l undo and redo is to defin e a c o m m a n d h i s t o r y , or l i st of command s that have b e en execute d ( or unexecuted , if s o me command s have been undone). Conceptually, the command history looks like this: Each c i r c le represent s a Comman d object . In this c a se the u s er has i s s u e d f o ur c o m - mands . The leftmos t comman d was i s s u e d first, followe d by the second-leftmost , and so on until the m o st recentl y i s s u e d command , whic h is rightmost . The l i ne marke d \" p r e s e n t \" keeps track of the most recently executed (and unexecuted) command. T o undo the last command, we simply call Unexecute on the most recent command: ptgSECTION 2 . 7 USER OPERATIONS 6 3 A f t er unexecutin g the command , we move the \" p r e s e n t \" l i ne one comman d to the left. If the user c h o o s e s undo again , the next-mos t recentl y i s s u e d comman d w i ll be undon e in the same way, a n d we're left in the state depicted here: Y ou c an s ee that by s i m p l y repeatin g this procedur e we g et multipl e l e v e ls of undo . T he numbe r of l e v e ls is l i m i t e d o n ly by t he lengt h of t he comman d h i s t o r y . To redo a comman d that's just been undone , we do the same thing in r e v e r s e . C o m - mand s to the right of the presen t l i ne are command s that may be redon e in the f u t u r e . To redo the last undon e command , we c a ll Execut e on the comman d to the right of the present line: T h en we advanc e the presen t l i ne so that a s u b s e q u e n t r e do w i ll c a ll r e do on the following command in the f u t u r e . ptg64 A CASE STUDY: D E S I G N I N G A D O C U M E N T E D I T O R CHAPTER 2 Of c o u r s e , if t he s u b s e q u e n t operatio n is n ot anothe r r e do b ut an undo , then t he comman d to t he left of t he p r e s e n t l i ne w i ll be undone . T h us t he user c an effectivel y go back and f o r th in time as neede d to r e c o v e r from e r r o r s . C o m m a n d P a t t e r n L e x i ' s command s are an applicatio n of the Comman d ( 2 3 3) pattern , whic h d e s c r i b e s how to encapsulat e a r e q u e s t . The Comman d patter n p r e s c r i b e s a unifor m interfac e for i s s u i n g r e q u e s t s that l e ts you configur e c l i e n t s to handl e differen t r e q u e s t s . The interfac e s h i e l d s c l i e n t s from the r e q u e s t ' s implementation . A comman d may delegat e a l l, part, or none of the r e q u e s t ' s implementatio n to other o b j e c t s . T h is is perfec t for application s l i ke L e xi that must provid e centralize d a c c e s s to functionalit y scattere d throughou t the a p p l i c a t i o n . The patter n a l so d i s c u s s e s undo and redo m e c h a n i s m s built on the basic Command interface. 2 . 8 Spelling Checking and Hyphenation T he l a st d e s i g n proble m i n v o l v e s textua l a n a l y s i s , s p e c i f i c a l l y c h e c k i n g for m i s s p e l l i n g s a nd i n t r o d u c i n g h y p h e n a t i o n p o i n t s w h e r e n e e d e d f or g o od formatting. The constraint s here are s i m i l a r to those we had for the formattin g d e s i g n p r o b l e m in S e c t i o n 2 . 3. As w as t he c a se f or l i n e b r e a k i n g s t r a t e g i e s , t h e r e ' s m o re than o ne w ay to c h e ck s p e l l i n g and comput e hyphenatio n p o i n t s . So h e re too we want to suppor t multi- p le a l g o r i t h m s . A d i v e r s e s et of algorithm s c an p r o v i d e a c h o i c e of space/time/qualit y trade-offs . We s h o u l d make it e a sy to add new algorithm s as w e l l . We a l so want to a v o id wirin g this functionalit y into t he documen t structure . T h is g o al is e v en more importan t h e re than it was in the formattin g c a s e, becaus e s p e l l i n g c h e c k i n g and hyphenation are just two of potentiall y many kinds of analyse s we may w a nt L e xi to support . Inevitabl y w e ' ll want to expan d L e x i ' s analytica l a b i l i t i e s o v er time. We migh t add s e a r c h i n g , w o rd counting , a calculatio n facilit y for addin g up tabula r v a l u e s , gramma r c h e c k i n g , and so f o r t h . But we don't want to c h a n g e the G l y p h c l a ss a n d a l l i t s subclasses every time we introduce new functionality of this sort. ptgSECTION 2.8 SPELLING CHECKING AND HYPHENATION 65 T h e re are actuall y two p i e c e s to this puzzle : ( 1) a c c e s s i n g the informatio n to be analyzed , whic h we have scattere d o v er the g l y p h s in the documen t structure , and (2) doing the analysis . W e ' ll l o ok at these two p i e c e s separately. Accessin g S c a t t e r e d Information Many kinds of a n a l y s i s r e q u i r e examinin g the text characte r by character . The text we n e ed to analyz e is scattere d throughou t a hierarchica l structur e of glyph objects . To examin e text in such a structure , we n e ed an a c c e s s mechanis m that has knowledg e abou t the data structure s in whic h object s are stored . S o me glyph s migh t store their c h i l d r e n in l i n k e d l i s t s, other s m i g h t u se arrays , a nd s t i ll other s m i g h t u se more e s o t e r i c data structures . Our a c c e s s mechanis m must be a b le to handl e all of t h e se p o s s i b i l i t i e s . An added c o m p l i c a t i o n is that differen t a n a l y s e s a c c e s s informatio n in differen t ways . Most analyse s w i ll travers e the text from b e g i n n i n g to e n d. But s o me do the opposite— a r e v e r s e s e a r c h , for e x a m p l e , needs to p r o g r e s s throug h the text backwar d rathe r than forward . Evaluatin g algebrai c e x p r e s s i o n s c o u ld requir e an inorde r traversal. So our a c c e s s mechanis m must accommodat e differin g data structures , and we must suppor t differen t kinds of traversals , such as preorder , postorder , and i n o r d e r . E n c a p s u l a t i n g Acces s a nd T r a v e r s a l R i g h t now our g l y ph interfac e u s es an intege r index to let c l i e n t s refer to c h i l d r e n . Althoug h that migh t be reasonabl e for glyph c l a s s e s that s t o re their c h i l d r e n in an array , it may be inefficien t for g l y p h s that use a l i n k e d l i s t. An importan t r o le of the g l y ph abstractio n is to hide the data structur e in whic h c h i l d r e n are stored . That way we can c h a n g e the data structur e a g l y ph c l a ss u s es withou t affectin g o t h er c l a s s e s . Therefor e o n ly the g l y ph can know the data structur e it uses. A corollar y is that the g l y ph interfac e shouldn' t be b i a s e d towar d one data structur e or another . It shouldn' t be bette r s u i t ed to array s than to l i n k e d l i s t s, for e x a m p l e , as it is n o w . We can s o l ve this p r o b l e m and suppor t severa l differen t kinds of traversal s at the s a me time. We can put multipl e a c c e s s and traversa l c a p a b i l i t i e s d i r e c t l y in the glyph c l a s s e s and p r o v i d e a way to c h o o s e amon g them , perhap s by supplyin g an enumerate d constan t as a parameter . The c l a s s e s pass this paramete r aroun d durin g a traversa l to e n s u r e they'r e all doing the same kind of traversal . T h ey have to pass aroun d any i n f o r m a t i o n t h e y ' v e a c c u m u l a t e d durin g t r a v e r s a l . We migh t add the followin g abstrac t operation s to Glyph' s interfac e to suppor t this approach: ptg66 A CASE STUDY: DESIGNING A DOCUMENT EDITOR CHAPTER 2 v o id F i r s t ( T r a v e r s a l k i n d ) v o id N e x t ( ) b o ol I s D o n e ( ) G l y p h * G e t C u r r e n t ( ) v o id I n s e r t ( G l y p h * ) Operation s F i r s t , N e x t , and I s D o n e contro l the traversal . F i r s t i n i t i a l i z e s the traversal . It takes the k i nd of traversa l as a paramete r of type T r a v e r s a l , an e n u - merate d constan t with v a l u e s s u ch as C H I L D R E N (to travers e the glyph' s immediat e c h i l d r e n o n l y ) , P R E O R D E R (to travers e the entire structur e in preorder) , P O S T O R D E R , and I N O R D E R . N e xt advance s to the next g l y ph in the traversal , and I s D o n e report s whethe r the traversa l is over or not. G e t C u r r e n t r e p l a c e s the C h i l d operation ; it a c c e s s e s the curren t g l y ph in the traversal . I n s e r t r e p l a c e s the old o p e r a t i o n ; it i n s e r t s the g i v en glyph at the curren t position. An analysi s woul d use the followin g C++ c o de to do a preorde r traversa l of a glyph structur e roote d at g: G l y p h * g ; f or ( g - > F i r s t ( P R E O R D E R ) ; ! g - > I s D o n e ( ) ; g - > N e x t ( ) ) { G l y p h * c u r r e n t = g - > G e t C u r r e n t ( ) ; // do some a n a l y s i s } Notic e that we've banishe d the intege r i n d ex from the glyph interface . T h e r e ' s no l o n g e r anythin g that b i a s e s the interfac e towar d one kind of c o l l e c t i o n or another . W e ' v e a l so s a v ed c l i e n t s from havin g to implemen t commo n kinds of traversal s themselves. But this approac h s t i ll has problems . For one thing , it can't suppor t new traversal s withou t e i t h e r extendin g the set of enumerate d v a l u e s or addin g new operations . Say we wante d to have a variatio n on preorde r traversa l that automaticall y s k i ps n o n - textua l g l y p h s . W e 'd have to chang e the T r a v e r s a l enumeratio n to includ e somethin g l i ke T E X T U A L - P R E O R D E R . W e 'd l i ke to a v o id changin g e x i s t i n g declarations . Puttin g the traversa l mechanis m en- tirely in the Glyp h c l a ss hierarch y make s it hard to modif y or e x t e n d withou t changin g l o ts of c l a s s e s . It's a l so difficul t to reuse t h e. mechanis m to travers e other k i n ds of o b j e c t structures . And we can't have mor e t h an one traversa l in p r o g r e s s on a structure. O n ce again , a bette r solutio n is to encapsulat e the c o n c e p t that v a r i e s , in this c a se the a c c e s s a nd traversa l m e c h a n i s m s . We c an introduc e a c l a ss of o b j e c t s c a l l ed i t e r a t o r s whos e s o le purpos e is to defin e differen t s e ts of t h e se mechanisms . We c an u se i n h e r - itanc e to let us a c c e s s differen t data structure s uniforml y and suppor t new kinds of t r a v e r s a l s as w e l l. A nd we won' t h a ve to c h a n g e g l y ph i n t e r f a c e s or distur b e x i s t i n g glyph implementations to do it. ptgSECTION 2 . 8 SPELLING C H E C K I N G A N D H Y P H E N A T I O N 67 F i g u r e 2 . 1 3 : I t e r a t o r c l a s s and s u b c l a s s e s Iterato r C l a ss a nd S u b c l a s s e s W e ' ll u se an a b s t r a c t c l a ss c a l l ed I t e r a t o r to defin e a g e n e r a l interfac e f or a c c e s s a nd t r a - versal . C o n c r e t e s u b c l a s s e s l i ke Arraylterato r and Listlterato r implemen t the interfac e to provid e a c c e s s to array s and l i s t s, while P r e o r d e r l t e r a t o r , P o s t o r d e r l t e r a t o r , and the l i ke implemen t differen t traversal s on s p e c i f i c structures . Each Iterato r s u b c l a s s has a referenc e to the structur e it traverses . S u b c l a s s instance s are initialize d with this refer- e n ce when they are created . F i g u r e 2 . 13 illustrate s the Iterato r c l a ss along with severa l s u b c l a s s e s . Notic e t h at we've adde d a Createlterato r abstrac t operatio n to the Glyp h c l a ss interfac e to suppor t iterators. The Iterato r interfac e provide s operation s F i r s t, Next , and I s D o n e for controllin g the t r a v e r s a l . T he L i s t l t e r a t o r c l a ss i m p l e m e n t s F i r st to p o i nt to t he first e l e m e n t in t he l i s t, and Next advance s the iterato r to the next item in the list. I s D o n e return s whethe r or not the l i st pointe r point s beyon d the last elemen t in the l i s t. Currentlte m dereference s the iterato r to retur n the g l y ph it point s to. An A r r a y l t e r a t o r c l a ss woul d do s i m i l a r things but on an array of glyphs. Now we can access the children of a glyph structure without knowing its r e p r e s e n t a - t i o n : ptg68 A C A SE S T U D Y - DESIGNING A DOCUMENT EDITOR CHAPTER 2 G l y p h * g ; I t e r a t o r < G l y p h * > * i = g - > C r e a t e ! t e r a t o r ( ) ; f or ( i - > F i r s t ( ) ; ! i - > I s D o n e () ; i - > N e x t ( ) ) { G l y p h * c h i l d = i - > C u r r e n t ! t e m ( ) ; // do s o m e t h i n g w i th c u r r e n t c h i l d } Createlterato r return s a Nulllterato r instanc e by default . A Nulllterato r is a degenerat e iterato r for g l y p h s t h at have no children , that i s, l e af glyphs . Nulllterator' s I s D o n e operatio n alway s return s true. A g l y ph s u b c l a s s t h at has c h i l d r e n w i ll overrid e Createlterato r to retur n an instanc e of a differen t Iterato r s u b c l a s s . Which s u b c l a s s depend s on the structur e t h at store s the c h i l d r e n . If the Row s u b c l a s s of Glyp h s t o r es its c h i l d r e n in a l i st . c h i l d r e n , then its Createlterato r operatio n woul d l o ok like this: I t e r a t o r < G l y p h * > * R o w : : C r e a t e I t e r a t o r () { r e t u r n n ew L i s t I t e r a t o r < G l y p h * > ( _ c h i l d r e n ) ; } Iterator s for preorde r and inorde r traversal s implemen t their traversal s in terms of g l y p h - s p e c i f i c iterators . The iterator s for these traversal s are s u p p l i e d the r o ot glyph in the structur e they traverse . T h ey c a ll Createlterato r on the g l y p h s in the structur e and use a stack to k e ep track of the resultin g iterators. For e x a m p l e , c l a ss P r e o r d e r It e r at or g e ts the iterato r from the root g l y p h , i n i t i a l i z e s it to point to its first e l e m e n t , and then p u s h e s it onto the s t a c k : void Preorderlterator::Firs t () { Iterator<Glyph*> * i = _root->Create!terator(); if ( i) { i->First(); ..iterator s . R e m o v e A l l ( ) ; _ i t e r a t o r s . P u s h ( i ) ; } } C u r r e n t 1 1 em w o u l d s i m p l y c a l l Cur r e n t 1 1 e m o n t h e iterator at the top of the stack: ptgSECTION 2.8 SPELLING CHECKING AND HYPHENATION 69 G l y p h* Preorderlterator::Currentlte m () c o n st { r e t u r n _iterators.Size( ) > 0 ? _iterators.Top()->CurrentItem( ) : 0; } The N e xt operatio n g e ts the top iterato r on the stack and asks its curren t item to creat e an iterator , in an e f f o r t to d e s c e n d the glyph structur e as far as p o s s i b l e (this is a preorde r traversal , a f t er a l l ). N e xt s e ts the new iterato r to the first item in the traversa l and p u s h e s it on the stack . T h en N e xt tests the latest iterator ; if its I s D o n e operatio n return s true, then we've finishe d traversin g the curren t subtre e (or leaf) in the traversal . In that c a s e, N e xt p o ps t he t op iterato r o ff t he s t a ck a nd r e p e a t s t h is p r o c e s s until it finds the next incomplet e traversal , if there is o n e; if not, then we have finishe d traversin g the structure. void P r e o r d e r l t e r a t o r : .-Nex t () { I t e r a t o r < G l y p h * > * i = _ i t e r a t o r s . T o p ( ) - > C u r r e n t I t e m ( ) - > C r e a t e I t e r a t o r ( ) ; i - > F i r s t ( ) ; _ i t e r a t o r s . P u s h ( i ) ; w h i l e ( _ i t e r a t o r s . S i z e ( ) > 0 && _ i t e r a t o r s . T o p ( ) - > I s D o n e ( ) ) { d e l e t e _ i t e r a t o r s . P o p ( ) ; _ i t e r a t o r s . T o p ( ) - > N e x t ( ) ; } Notic e how the Iterato r c l a ss hierarch y lets us add new k i n ds of traversal s withou t modifyin g glyph classes—w e s i m p l y subclas s I t e r a t o r and add a new traversa l as we have with P r e o r d e r l t e r a t o r . Glyp h subclasse s use the s a me interfac e to g i ve c l i e n t s a c c e s s to t h e ir c h i l d r e n withou t r e v e a l i n g the underlyin g data structur e they use to store them . Becaus e iterator s store their own copy of the state of a traversal , we can carry on multipl e traversal s simultaneously , e v en on the same structure . And thoug h o ur t r a v e r s a l s h a ve b e en o v er g l y ph s t r u c t u r e s in t h is e x a m p l e , t h e r e ' s no reaso n we can't parameteriz e a c l a ss like P r e o r d e r l t e r a t o r by the type of objec t in the structure . We'd use template s to do that in C + +. T h en we can reuse the machiner y in P r e o r d e r l t e r a t o r to travers e other structures. Iterato r Pattern The Iterato r ( 2 5 7) patter n capture s t h e se t e c h n i q u e s for supportin g a c c e s s and traversa l over objec t structures . It's applicabl e not o n ly to composit e structure s but to c o l l e c t i o n s a s w e l l . It a b s t r a c t s the traversal algorithm and shields c l i e n t s f r o m the internal structure ptg70 A CASE STUDY: DESIGNING A DOCUMENT EDITOR CHAPTER 2 of t he o b j e c t s they traverse . T he Iterato r patter n illustrate s o n ce m o re h ow e n c a p s u l a t i n g t he c o n c e p t that varie s h e l ps us g a in flexibilit y a nd r e u s a b i l i t y . E v en s o, t he proble m of iteratio n has surprisin g d e p t h , and the Iterato r patter n c o v e r s many more nuance s and trade-off s than we've c o n s i d e r e d h e r e . T r a v e r s a l v e r s u s T r a v e r s a l Actions Now that we have a way of traversin g the glyph structure , we n e ed to c h e ck the s p e l l i n g and do the hyphenation . B o th analyse s i n v o l v e accumulatin g informatio n durin g the traversal. F i r st we have to d e c i d e wher e to put the r e s p o n s i b i l i t y for a n a l y s i s . We c o u ld put it in the Iterato r c l a s s e s , thereb y makin g analysi s an integra l part of traversal . But we get m o re flexibilit y and potentia l f or r e u se if we d i s t i n g u i s h betwee n the traversa l and the a c t i o n s performe d durin g traversal . That' s becaus e differen t a n a l y s e s often r e q u i r e the s a me k i nd of traversal . H e n c e we can r e u se the same set of iterator s for differen t analyses . For e x a m p l e , preorde r traversa l is commo n to many a n a l y s e s , i n c l u d i n g s p e l l i n g c h e c k i n g , hyphenation , f o r w a r d s e a r c h , and word count. So a n a l y s i s a nd traversa l s h o u l d be separate . W h e r e e l se c an we p ut t he r e s p o n s i b i l i t y for analysis ? We know there are many kinds of analyse s we m i g h t want to do. Each analysi s w i ll do d i f f e r e n t t h i n g s at differen t point s in the traversal . S o me g l y p h s are more s i g n i f i c a n t than other s d e p e n d i n g on t he k i nd of a n a l y s i s . If we're c h e c k i n g s p e l l i n g or hyphenating , we want to c o n s i d e r characte r g l y p h s and not graphica l o n es l i ke l i n es and bitmappe d i m a g e s . If we're makin g c o l or separations , we'd want to c o n s i d e r v i s i b l e g l y p h s and not i n v i s i b l e o n e s. Inevitably , differen t a n a l y s e s will analyz e differen t g l y p h s . Therefor e a g i v en analysi s must be a b le to d i s t i n g u i s h differen t kinds of g l y p h s . An o b v i o u s approac h is to p ut t he analytica l capabilit y i n to t he g l y ph c l a s s e s t h e m s e l v e s . For e a ch analysi s we can add one or more abstrac t o p e r a t i o n s to the Glyp h c l a ss and have s u b c l a s s e s i m p l e m e n t them in accordanc e with the r o le they play in the a n a l y s i s . But the troubl e with that approac h is that we'll have to c h a n g e every g l y ph c l a ss wheneve r we a dd a n ew k i nd of analysis . We c an e a se t h is proble m in s o me c a s e s : If o n ly a f ew c l a s s e s p a r t i c i p a t e in t he a n a l y s i s , or if m o st c l a s s e s do t he a n a l y s i s t he same way, then we can suppl y a defaul t implementatio n for the abstrac t operatio n in the Glyp h c l a s s. The defaul t operatio n woul d c o v er the c o m m o n c a s e. T h us we'd l i m it c h a n g e s to j u st the Glyp h c l a ss and t h o se s u b c l a s s e s that deviat e from the norm. Yet e v en if a defaul t implementatio n reduce s the numbe r of c h a n g e s , an i n s i d i o u s proble m r e m a i n s : Glyph' s interfac e expand s with every new analytica l c a p a b i l i t y . O v er t i me the analytica l operation s w i ll start to obscur e the b a s ic Glyp h interface . It b e c o m e s hard to see that a g l y p h ' s ma in purpos e is to defin e and structur e object s that have appearance and shape—that interface gets lost in the noise. ptgSECTION 2 . 8 SPELLING C H E C K I N G A N D HYPHENATION 7 1 E n c a p s u l a t i n g t he Analysis F r om a ll i n d i c a t i o n s , we n e ed to e n c a p s u l a t e t he a n a l y s i s in a s e p a r a t e o b j e c t , much l i ke we've done many t i m es before . We c o u ld put the machiner y for a g i v en analysi s into its own c l a s s. We c o u ld use an instanc e of this c l a ss in conjunctio n with an appropriat e iterator . The iterato r woul d \" c a r r y \" the instanc e to e a ch glyph in the structure . The analysi s o b j e c t c o u ld then perfor m a p i e ce of the analysi s at e a ch point in the traversal . T he a n a l y z e r a c c u m u l a t e s informatio n of i n t e r e s t ( c h a r a c t e r s in t h is c a s e) as t he t r a v e r s a l p r o c e e d s : The f u n d a m e n t a l questio n with this approac h is how the analysi s objec t distinguishe s differen t kinds of g l y p h s withou t resortin g to type tests or downcasts . We don't want a S p e l l i n g C h e c k e r c l a ss to includ e (pseudo)cod e l i k e v o id S p e l l i n g C h e c k e r : : C h e c k ( G l y p h * g l y p h ) { C h a r a c t e r * c ; R o w* r; I m a g e * i ; i f ( c = d y n a m i c _ c a s t < C h a r a c t e r * > ( g l y p h ) ) { / / a n a l y z e t h e c h a r a c t e r } e l s e i f ( r = d y n a m i c _ c a s t < R o w * > ( g l y p h ) ) { / / p r e p a r e t o a n a l y z e r ' s children ptg72 A CASE STUDY: DESIGNING A DOCUMENT EDITOR CHAPTER 2 } else if (i = dynamic_cast<Image*>(glyph) ) { // do n o t h i ng } } T h is c o de is p r e t t y u g l y. It r e l i es on fairly e s o t e r i c c a p a b i l i t i e s like type-saf e c a s t s . I t 's h a rd to e x t e n d as well. W e ' l l h a ve to r e m e m b e r to c h a n g e t he b o dy of t h is f u n c t i o n w h e n e v e r we c h a n g e t he G l y p h c l a ss h i e r a r c h y . In fact, t h is is t he k i nd of c o de t h at o b j e c t - o r i e n t e d l a n g u a g e s w e re i n t e n d e d to e l i m i n a t e . We want to avoid s u ch a b r u t e - f o r c e a p p r o a c h , b ut h o w? L e t 's c o n s i d e r w h at h a p p e n s w h en we a dd t he followin g a b s t r a c t o p e r a t i o n to t he G l y p h c l a s s : v o id C h e c k M e ( S p e l l i n g C h e c k e r & ) We defin e C h e c k M e in e v e ry Glyp h s u b c l a s s as follows: v o id G l y p h S u b c l a s s : : C h e c k M e ( S p e l l i n g C h e c k e r k c h e c k e r ) { c h e c k e r . C h e c k G l y p h S u b c l a s s ( t h i s ) ; } w h e r e G l y p h S u b c l a s s woul d be r e p l a c e d by t he n a me of t he g l y ph s u b c l a s s . N o te that w h en C h e c k M e is c a l l e d , t he s p e c i f i c Glyp h s u b c l a s s is known—afte r a l l, w e ' re in o ne of i ts o p e r a t i o n s . In t u r n, t he S p e l l i n g C h e c k e r c l a ss interfac e i n c l u d e s an o p e r a t i o n like C h e c k G l y p h S u b c l a s s for e v e ry Glyp h subclass 10: c l a s s S p e l l i n g C h e c k e r { p u b l i c : S p e l l i n g C h e c k e r ( ) ; v i r t u a l v o id C h e c k C h a r a c t e r ( C h a r a c t e r * ) ; v i r t u a l v o id C h e c k R o w ( R o w * ) ; v i r t u a l v o id C h e c k l m a g e ( I m a g e * ) ; // ... a nd so f o r t h L i s t < c h a r * > & G e t M i s s p e l l i n g s ( ) ; p r o t e c t e d : virtual bool IsMisspelled(cons t char*); private: c h ar _ c u r r e n t W o r d [ M A X _ W O R D _ S I Z E ] ; L i s t < c h a r * > _ m i s s p e l l i n g s ; } ; S p e l l i n g C h e c k e r ' s c h e c k i n g o p e r a t i o n for C h a r a c t e r g l y p h s m i g h t l o ok s o m e - t h i ng like t h i s : 10 We c o u ld u se functio n o v e r l o a d i n g to give e a ch of t h e se m e m b e r f u n c t i o n s t he s a me n a m e , s i n ce t h e ir p a r a m e t e r s alread y differentiat e t h e m . W e ' v e g i v en t h em differen t n a m e s h e re to e m p h a s i z e t h e ir d i f f e r e n c e s , especially when they're called. ptgSECTION 2 . 8 SPELLING CHECKING A N D H Y P H E N A T I O N 73 v o id S p e l l i n g C h e c k e r : : C h e c k C h a r a c t e r ( C h a r a c t e r * c) { c o n st c h ar ch = c->GetCharCode(); if ( i s a l p h a ( c h ) ) { // a p p e nd a l p h a b e t i c c h a r a c t e r to _ c u r r e n t W o r d } e l se { / / we hit a n o n a l p h a b e t i c c h a r a c t e r if ( I s M i s s p e l l e d ( _ c u r r e n t W o r d ) ) { // a dd _ c u r r e n t W o r d to _ m i s s p e l l i n g s _ m i s s p e l l i n g s . A p p e n d ( s t r d u p ( _ c u r r e n t W o r d ) ) ; } _ c u r r e n t W o r d [ 0 ] = ' \\ 0' ; // rese t _ c u r r e n t W o r d to chec k n e xt word } } N o t i c e we've define d a s p e c i a l G e t C h a r C o d e operatio n on j u st the C h a r a c t e r c l a s s. The s p e l l i n g c h e c k e r can deal with s u b c l a s s - s p e c i f i c operation s withou t resortin g to type t e s ts or c a s t s — i t l e ts us treat object s s p e c i a l l y . C h e c k C h a r a c t e r accumulate s alphabeti c character s into the _ c u r r e n t W o r d buffer . When it encounter s a nonalphabeti c character , s u ch as an u n d e r s c o r e , it u s es the I s M i s s p e l l e d operatio n to c h e ck the s p e l l i n g of the word in _ c u r r e n t W o r d . n If the word is m i s s p e l l e d , then C h e c k C h a r a c t e r adds the word to the l i st of m i s s p e l l e d w o r d s . T h en it must c l e ar out the _ c u r r e n t W o r d b u f f e r to ready it for the next word . When t he traversa l is o v e r, y ou c an retriev e t he l i st of m i s s p e l l e d word s with t he G e t M i s s p e l l i n g s operation. Now we can travers e the glyph structure , c a l l i n g C h e c k M e on e a ch glyph with t he s p e l l i n g c h e c k e r as an argument . T h is effectivel y identifie s e a ch g l y ph to t he S p e l l i n g C h e c k e r a nd p r o m p t s t he c h e c k e r to do t he n e xt i n c r e m e n t in t he s p e l l i n g c h e c k . S p e l l i n g C h e c k e r S p e l l i n g C h e c k e r ; C o m p o s i t i o n * c; // . . . G l y p h* g; P r e o r d e r l t e r a t o r i ( c ) ; 11 I s M i s s p e l l e d implement s the s p e l l i n g algorithm , whic h we won' t detai l h e re b e c a u s e we've made it i n d e p e n d e n t of L e x i ' s d e s i g n . We can suppor t differen t algorithm s by s u b c l a s s i n g S p e l l i n g C h e c k e r ; alternatively , we can apply the Strateg y ( 3 1 5) patter n (as we did for formattin g in S e c t i o n 2 . 3) to s u p p o r t different spelling checking a l g o r i t h m s . ptg7 4 A CASE S T U D Y - DESIGNING A D O C U M E N T EDITOR CHAPTER 2 for ( i. First ( ); ! i . I s D o ne () ; i.NextO ) { g = i.Currentltem() ; g->CheckMe(spellingChecker); } The followin g interactio n diagra m illustrate s how C h a r a c t e r g l y p h s and the S p e l l i n g C h e c k e r o b j e c t work together: T h is approac h work s for findin g s p e l l i n g e r r o r s , but how d o es it help us s u p - port multipl e kinds of a n a l y s i s ? It l o o ks l i ke we have to add an operatio n l i ke C h e c k M e ( S p e l 1 i n g C h e c k e r &) to Glyp h and its s u b c l a s s e s wheneve r we add a new kind of analysis . That' s true if we i n s i st on an independent c l a ss for e v e ry a n a l y s i s . But there' s no reaso n why we can't g i ve all a n a l y s i s c l a s s e s the same interface . D o i n g so l e ts us use them polymorphically . That mean s we can r e p l a c e a n a l y s i s - s p e c i f i c o p e r - ation s l i ke C h e c k M e ( S p e l l i n g C h e c k e r & ) with an analysis-independen t operatio n that takes a more genera l parameter. Visito r C l a ss a nd S u b c l a s s e s W e ' ll use the term visito r to refer generall y to c l a s s e s of o b j e c t s that \" v i s i t \" other o b j e c t s durin g a traversa l and do somethin g appropriate. 12 In this c a se we can defin e a V i s i t o r class that defines an abstract interface for visiting glyphs in a structure. 12 \" V i s i t \" is just a slightl y more genera l term for \" a n a l y z e . \" It foreshadow s the terminolog y we use in the d e s i g n pattern we're leading to. ptgSECTION 2.8 SPELLING CHECKING AND HYPHENATION 75 class Visitor { public: v i r t u al v o id V i s i t C h a r a c t e r ( C h a r a c t e r * ) { } virtual void VisitRow(Row* ) { } virtual void VisitImage(Image*) { } // . . . a n d s o forth C o n c r e t e s u b c l a s s e s of V i s i t o r perfor m differen t a n a l y s e s . For e x a m p l e , we c o u ld h a ve a S p e l l i n g C h e c k i n g V i s i t o r s u b c l a s s f or c h e c k i n g s p e l l i n g , a nd a H y p h e n a t i o n V i s i t o r s u b c l a s s f or hyphenation . S p e l l i n g C h e c k i n g V i s i t o r woul d be implemente d exactl y as we i m p l e m e n t e d Spel 1 i n g C h e c k e r a b o v e , e x c e p t t he o p e r a t i o n n a m e s w o u l d r e f l e c t t he m o re g e n e r a l V i s i t o r i n t e r f a c e . F or e x a m p l e , C h e c k C h a r a c t e r woul d be c a l l ed V i s i t C h a r a c t e r . S i n ce C h e c k M e isn't appropriat e for v i s i t o r s that don't c h e ck anything , w e ' ll g i ve it a more genera l name : A c c e p t . Its argumen t must a l so chang e to take a V i s i t o r & , r e f l e c t i n g t he fact that it c an a c c e p t a ny v i s i t o r . N ow a d d i n g a n ew a n a l y s i s r e q u i r e s just definin g a new s u b c l a s s of v i s i t o r — w e don't have to touch any of the g l y ph c l a s s e s . We suppor t all f u t u r e analyse s by addin g this one operatio n to G l y p h and its s u b c l a s s e s . W e ' v e a l r e a d y s e en h ow s p e l l i n g c h e c k i n g w o r k s . We u se a s i m i l a r a p p r o a c h in H y p h e n a t i o n V i s i t o r to accumulat e text. But o n ce H y p h e n a t i o n V i s i t o r ' s V i s i t C h a r a c t e r operatio n has a s s e m b l e d an e n t i re w o r d , it work s a l i t t le differ- e n t l y. I n s t e a d of c h e c k i n g t he w o rd f or m i s s p e l l i n g , it a p p l i e s a h y p h e n a t i o n a l g o r i t h m to determin e the potentia l hyphenatio n point s in the word , if a n y. T h en at e a ch hyphen- ation p o i n t , it i n s e r t s a discretionar y g l y ph i n to t he c o m p o s i t i o n . D i s c r e t i o n a r y g l y p h s are i n s t a n c e s of D i s c r e t i o n a r y , a s u b c l a s s of G l y p h . A discretionar y g l y ph has one of two p o s s i b l e appearance s d e p e n d i n g on whethe r or not it is the last characte r on a l i n e. If it's the l a st character , then the discretionar y l o o ks l i ke a h y p h e n ; if i t 's n ot at t he e nd of a l i n e, then t he d i s c r e t i o n a r y h as no a p p e a r a n c e whatsoever . T he discretionar y c h e c k s i ts paren t (a R ow object ) to s ee if it is t he l a st c h i l d . The discretionar y make s this c h e ck wheneve r it's c a l l ed on to draw i t s e lf or calculat e i ts b o u n d a r i e s . T he formattin g s t r a t e g y t r e a ts d i s c r e t i o n a r i e s t he s a me as w h i t e s p a c e , makin g them candidate s for e n d i n g a l i n e. The followin g diagra m s h o w s how an e m b e d d e d d i s c r e t i o n a r y can appear. ptg76 A C A S E S T U D Y : D E S I G N I N G A D O C U M E N T E D I T O R CHAPTER 2 V i s i t o r P a t t e r n Wha t we've d e s c r i b e d h e re is an a p p l i c a t i o n of t he Visito r ( 3 3 1) pattern . T he Visito r c l a ss and its s u b c l a s s e s d e s c r i b e d earlie r are the key participant s in the pattern . The Visito r patter n capture s the techniqu e we've used to a l l ow an open-ende d numbe r of analyse s of g l y ph structure s withou t havin g to chang e t he g l y ph c l a s s e s t h e m s e l v e s . Anothe r n i ce featur e of v i s i t o r s is that t h ey c an be a p p l i e d n ot just to c o m p o s i t e s l i ke o ur g l y p h s t r u c t u r e s b ut to a ny o b j e c t structure . T h at i n c l u d e s s e t s, l i s t s, e v en d i r e c t e d - a c y c l i c g r a p h s . Furthermore , the c l a s s e s that a v i s i t o r can v i s it needn' t be relate d to each other throug h a c o m m o n paren t c l a s s. That mean s v i s i t o r s can work a c r o s s c l a ss hierarchies. An importan t q u e s t i o n to ask y o u r s e l f befor e applyin g the V i s i t o r patter n is, W h i c h c l a ss h i e r a r c h i e s chang e most o f t e n ? The patter n is most suitabl e when you want to be a b le to do a variet y of differen t t h i n g s to o b j e c t s that have a s t a b le c l a ss structure . A d d i n g a n ew k i nd of v i s i t o r r e q u i r e s no c h a n g e to that c l a ss s t r u c t u r e , w h i ch is e s p e c i a l l y importan t when the c l a ss structur e is l a r g e . But wheneve r you add a s u b c l a s s to the structure , you'l l a l so have to updat e all your visito r interface s to includ e a V i s i t . . . operatio n for that s u b c l a s s . In our exampl e that mean s addin g a new G l y p h s u b c l a s s c a l l ed Foo w i ll r e q u i r e c h a n g i n g V i s i t o r and all its s u b c l a s s e s to i n c l u d e a V i s i t F o o o p e r a t i o n . B ut g i v en o ur d e s i g n c o n s t r a i n t s , w e ' re m u ch m o re l i k e ly to a dd a n ew k i nd of a n a l y s i s to L e xi than a n ew k i nd of G l y p h . So t he V i s i t o r patter n is w e l l - s u i t e d to o ur n e e d s . 2 . 9 Summary W e ' v e applied eight different p a t t e r n s to Lexi's design: 1 . C o m p o s i t e (163) to represent the document's physical structure, 2. S t r a t e g y ( 3 1 5 ) to allow different f o r m a t t i n g algorithms, ptgSECTION 2.9 SUMMARY 77 3. Decorato r ( 1 7 5) for embellishin g the user interface, 4. Abstrac t Factor y ( 8 7) for supportin g multipl e look-and-fee l standards, 5. Bridg e ( 1 5 1) to allow multipl e windowin g platforms, 6. Comman d ( 2 3 3) f or undoabl e us er operations, 7. Iterato r ( 2 5 7) for a c c e s s i n g and traversin g objec t structures , and 8. Visito r ( 3 3 1) f or allowin g an o p e n - e n d e d numbe r of analytica l c a p a b i l i t i e s withou t complicatin g the documen t structure' s implementation. None of these d e s i g n i s s u e s is limite d to documen t editin g application s l i ke L e x i. Indeed , most nontrivia l application s w i ll have o c c a s i o n to use many of these pat- t e r n s , thoug h perhap s to do differen t things . A financia l analysi s applicatio n migh t use Composit e to defin e investmen t portfolio s made up of subportfolio s and account s of d i f f e r e n t sorts . A c o m p i l e r migh t use the Strateg y patter n to a l l ow differen t r e g i s t e r allocatio n s c h e m e s for differen t targe t machines . Application s with a graphica l user interfac e w i ll probabl y apply at least Decorato r and Comman d just as we have h e r e . Whil e we'v e c o v e r e d severa l majo r problem s in L e x i ' s d e s i g n , there are lots of other s we haven' t d i s c u s s e d . T h en again , this book d e s c r i b e s more t h an j u st the e i g ht pattern s we've u s ed h e r e. So as you study the remainin g patterns , think abou t how you migh t use each one in Lexi. Or better yet, think about using them in your own designs! ptg This page intentionally left blank ptgD e s i g n Pattern Catalog 7 9 ptg This page intentionally left blank ptgC h a p t e r 3 C r e a t i o n a l P a t t e r n s Creationa l d e s i g n pattern s abstrac t the instantiatio n p r o c e s s . T h ey help make a s y s t e m i n d e p e n d e n t of h ow i ts o b j e c t s a re c r e a t e d , c o m p o s e d , a nd r e p r e s e n t e d . A c l a ss c r e - ationa l patter n u s es inheritanc e to vary the c l a ss that's instantiated , wherea s an o b j e c t creationa l patter n w i ll delegat e instantiatio n to anothe r object. Creationa l pattern s becom e importan t as system s e v o l v e to depen d more on o b j e c t c o m p o s i t i o n than c l a ss i n h e r i t a n c e . As that h a p p e n s , e m p h a s i s shifts away from hard- c o d i n g a fixed set of behavior s towar d definin g a s m a l l e r set of fundamenta l behavior s that can be c o m p o s e d into any numbe r of more c o m p l e x o n e s. T h us creatin g object s with p a r t i c u l a r b e h a v i o r s r e q u i r e s m o re than s i m p l y i n s t a n t i a t i n g a c l a s s . T h e re a re t wo r e c u r r i n g t h e m e s in t h e se patterns . F i r s t, t h ey a ll e n c a p s u l a t e k n o w l e d g e abou t w h i c h c o n c r e t e c l a s s e s t he s y s t e m u s e s. S e c o n d , they h i de h ow instance s of t h e se c l a s s e s are create d and put t o g e t h e r . All the syste m at l a r ge know s abou t the object s is t h e ir i n t e r f a c e s as define d by a b s t r a c t c l a s s e s . C o n s e q u e n t l y , t he c r e a t i o n a l pattern s g i ve you a lot of flexibilit y in what g e ts c r e a t e d , who c r e a t e s it, how it g e ts created , and when. T h ey let you configur e a syste m with \" p r o d u c t \" o b j e c t s that vary w i d e l y in structur e a nd f u n c t i o n a l i t y . C o n f i g u r a t i o n c an be static (that i s, s p e c i f i e d at c o m p i l e - t i m e ) or dynamic (at run-time). S o m e t i m e s creationa l pattern s are competitors . For e x a m p l e , there are c a s es when eithe r Prototyp e ( 1 1 7) or Abstrac t Factor y ( 8 7) c o u ld be u s ed profitably . At other t i m es they are complementary : Builde r ( 9 7) can use one of the other pattern s to implemen t w h i c h component s g et built. Prototyp e ( 1 1 7) c an u se S i n g l e t o n ( 1 2 7) in i ts implementation. B e c a u s e the creationa l pattern s are c l o s e l y related , we'll study all five of them togethe r to h i g h l i g h t their s i m i l a r i t i e s a nd d i f f e r e n c e s . W e ' ll a l so u se a c o m m o n e x a m p l e — buildin g a maze for a compute r game—t o illustrat e their implementations . The maze and the game w i ll vary s l i g h t l y from patter n to pattern . Sometime s the game w i ll be s i m p l y to f i nd your w ay o ut of a m a z e ; in that c a se t he p l a y e r w i ll p r o b a b l y o n ly have a local view of the maze. Sometimes mazes contain problems t o solve and d a n g e r s t o 8 1 ptg8 2 CREATIONAL PATTERNS CHAPTER 3 o v e r c o m e , and these game s may provid e a map of the part of the maze that has b e en e x p l o r e d . W e ' ll i g n o r e many d e t a i l s of what can be in a maze and whethe r a maze game has a s i n g le or multipl e pla y ers . Instead , we'll j u st focus on how maze s get created . We defin e a maze as a set of r o o m s . A r o om know s its n e i g h b o r s ; p o s s i b l e neighbor s are anothe r r o o m , a w a l l, or a d o or to anothe r r o o m . The c l a s s e s R o o m , D o o r , and W a ll defin e the component s of the maze u s ed in all our e x a m p l e s . We defin e o n ly t he parts of t h e se c l a s s e s that a re importan t f or c r e a t i n g a maze . W e ' ll i g n o r e p la y ers , operation s for displayin g and wanderin g aroun d in a maze , and other important functionality that isn't relevant to building the maze. The following diagram shows the relationships between these classes: Each r o om has f o ur s i d e s . We use an enumeratio n D i r e c t ! on in C++ implementation s to specif y the north , south , e a s t, and west s i d es of a r o o m : e n um Directio n { N o r t h, South, East, West}; T he S m a l l t a l k implementation s u se correspondin g s y m b o l s to r e p r e s e n t t h e se d i r e c - t i o n s . The c l a ss M a p S i t e is the commo n abstrac t c l a ss for all the component s of a maze . To simplif y the e x a m p l e , M a p S i t e define s only one operation , E n t e r . Its meanin g d e p e n d s on what you'r e entering . If you enter a r o o m , then your locatio n c h a n g e s . If y ou t ry to enter a d o o r, then o ne of t wo t h i n g s happen : If t he door is o p e n , y ou go i n to the next room . If the door is c l o s e d , then you hurt your n o s e . c l a s s M a p S i t e { p u b l i c : v i r t u a l v o id E n t e r ( ) E n t e r p r o v i d e s a s i m p l e b a s is for more s o p h i s t i c a t e d game operations . For e x a m p l e , if you are in a r o om and say \"Go E a s t , \" the game can s i m p l y determin e whic h M a p S i t e is immediately t o t h e e a s t a n d t h e n c a l l E n t e r o n i t . T h e s u b c l a s s - s p e c i f i c E n t e r ptgCREATIONAL PATTERNS 83 operatio n will f i g u r e o ut w h e t h e r y o ur locatio n c h a n g e d or y o ur n o se g ot h u r t. In a r e al g a m e , E n t e r c o u ld take t he p l a y e r o b j e c t that' s m o v i n g a b o u t as an a r g u m e n t . R o om is the c o n c r e t e s u b c l a s s of M a p S i t e that define s the key r e l a t i o n s h i p s b e t w e e n c o m p o n e n t s in the maze . It m a i n t a i n s r e f e r e n c e s to o t h er M a p S i t e o b j e c t s and s t o r e s a r o om n u m b e r . T he n u m b e r will identif y r o o m s in t he maze. c l a s s R o om : p u b l i c M a p S i t e { p u b l i c : R o o m ( i n t r o o m N o ) ; MapSite* GetSide(Direction ) const; void SetSide(Direction , MapSite*); virtual void Enter(); private: MapSite* _sides[4] ; i nt _roomNumber; } ; T he followin g c l a s s e s r e p r e s e n t t he wall or d o or that o c c u r s on e a ch s i de of a r o o m . class Wall : public MapSite { public: WallO ; virtual void Enter(); } ; class D o or : public MapSite { public: Door(Room * = 0, Room* = 0); virtual void Enter(); Room* OtherSideFrom(Room*); private: Room* _rooml; Room* _room2; b o ol _isOpen; } ; We n e ed to k n ow a b o u t m o re t h an j u st t he p a r ts of a maze . W e ' l l a l so defin e a M a z e class to r e p r e s e n t a c o l l e c t i o n of r o o m s . M a z e can a l so find a p a r t i c u l a r r o om g i v en a r o o m n u m b e r using its RoomNo operation. ptg84 CREATIONAL PATTERNS CHAPTER 3 c l a ss M a ze { public: Maze(); void AddRoom(Room * ) ; Room* RoomNo(int ) const; private: // . . . } ; RoomN o c o u ld do a l o o k - u p u s i ng a linea r s e a r c h , a h a sh t a b l e , or e v en a s i m p l e a r r a y . B ut we w o n ' t w o r r y a b o u t s u ch detail s h e r e. I n s t e a d , w e ' ll f o c us on h ow to specif y t he c o m p o n e n t s of a maze object. A n o t h e r c l a ss we defin e is M a z e G a m e , w h i c h c r e a t e s the maze . One s t r a i g h t f o r w a r d way to c r e a t e a maze is with a s e r i e s of o p e r a t i o n s that add c o m p o n e n t s to a m a ze a nd t h en i n t e r c o n n e c t t h e m . F or e x a m p l e , t he f o l l o w i n g m e m b e r f u n c t i o n will c r e a t e a maze consistin g of t wo r o o m s with a d o or betwee n t h e m : Maze* MazeGame::CreateMaz e () { Maze* a M a ze = new Maze; Room* rl = new Room(l); R o o m* r2 = n ew Room ( 2 ) ; D o o r* t h e D o or = n ew Door(rl, r2); aMaze->AddRoom(rl) ; aMaze->AddRoom(r2); rl->SetSide(North , new Wall); rl->SetSide(East , t h e D o o r ) ; rl->SetSide(South , new Wall); rl->SetSide(West , new Wall); r2->SetSide(North , new Wall); r2->SetSide(East , new Wall); r2->SetSide(South , new Wall); r2->SetSide(West , t h e D o o r ) ; r e t u rn aMaze; } T h is f u n c t i o n is prett y c o m p l i c a t e d , c o n s i d e r i n g that a ll it d o es is c r e a t e a m a ze with t wo r o o m s . T h e r e a re o b v i o u s ways to m a ke it s i m p l e r . F or e x a m p l e , t he R o om c o n - s t r u c t o r c o u ld initializ e t he s i d es with walls a h e a d of time. B ut t h at j u st m o v e s t he c o de s o m e w h e r e e l s e. T he r e al p r o b l e m wit h t h is m e m b e r functio n i s n 't i ts s i ze b ut i ts inflexibility. It h a r d - c o d e s t he m a ze layout . C h a n g i n g t he l a y o u t m e a n s c h a n g i n g t h is m e m b e r function , e i t h e r by o v e r r i d i n g it—whic h m e a n s r e i m p l e m e n t i n g t he w h o l e t h i n g — o r by changing parts of it—which is error-prone a n d doesn't promote reuse. ptgCREATIONAL PATTERNS 8 5 T he c r e a t i o n a l pattern s s h ow h ow to make t h is d e s i g n m o re f l e x i b l e , n ot n e c e s s a r i l y s m a l l e r . In particular , they w i ll m a ke it easy to chang e the c l a s s e s t h at defin e the c o m p o n e n t s of a maze. S u p p o s e you wante d to reuse an e x i s t i n g maze layou t for a new game containin g (of all things ) enchante d mazes . The enchante d maze game has new kinds of components , like D o o r N e e d i n g S p e l l , a door t h at can be l o c k e d and o p e n e d subsequentl y o n ly with a s p e l l; and E n c h a n t e d R o o m , a r oom that can have unconventiona l items in it, like magi c keys or s p e l l s . How can you chang e C r e a t e M a z e e a s i ly so that it c r e a t e s maze s with these n ew c l a s s e s of o b j e c t s ? In this c a s e, the b i g g e s t barrie r to c h a n g e l i es in hard-codin g the c l a s s e s that get instan- tiated. The creationa l pattern s provid e d i f f e r e n t ways to remov e e x p l i c i t reference s to c o n c r e t e c l a s s e s from c o de that n e e ds to instantiat e t h e m : • If C r e a t e M a z e c a l ls virtua l function s i n s t e a d of c o n s t r u c t o r c a l ls to c r e a te t he r o o m s , w a l l s , and doors it r e q u i r e s , then you can chang e the c l a s s e s t h at get i n s t a n t i a t e d by makin g a s u b c l a s s of M a z e G a m e and r e d e f i n i n g t h o se virtua l functions . T h is approac h is an exampl e of the Factor y Metho d ( 1 0 7) pattern. • If C r e a t e M a z e is passe d an objec t as a paramete r to use to c r e a t e r o o m s , w a l l s , and doors , then you can chang e the c l a s s e s of r o o m s , walls , and doors by passin g a differen t parameter . T h is is an exampl e of the Abstrac t Factor y ( 8 7) pattern. • I f C r e a t e M a z e i s p a s s e d an o b j e c t that can creat e a new maze in its entiret y using operation s for addin g r o o m s , d o o r s , and walls to the maze it b u i l d s , then you can use inheritanc e to c h a n g e parts of the maze or the way the maze is built. T h is is an exampl e of the Builde r ( 9 7) pattern. • If C r e a t e M a z e is parameterize d by variou s prototypica l r o o m , door, and wall o b j e c t s , w h i c h it then c o p i e s a nd adds to t he m a z e , then y ou c an c h a n g e t he maze' s compositio n by replacin g these prototypica l object s with differen t one s. T h is is an e x a m p l e of t he Prototyp e ( 1 1 7) pattern. T he r e m a i n i n g c r e a t i o n a l pattern , S i n g l e t o n ( 1 2 7 ) , c an e n s u r e t h e r e ' s o n ly o ne maze per game and that all game o b j e c t s have ready a c c e s s to it—withou t resortin g to g l o b a l v a r i a b l e s or functions . S i n g l e t o n a l so m a k e s it e a sy to e x t e n d or r e p l a c e t he maze without touching existing code. ptg This page intentionally left blank ptgA B S T R A C T FACTORY 87 A B S T R A C T F A C T O R Y O b j e c t Creational I n t e n t Provid e an interfac e for creatin g familie s of relate d or dependen t object s withou t s p e c i f y i n g their concrete classes. Also Known A s Kit Motivation C o n s i d e r a user interfac e toolki t t h at support s multipl e look-and-fee l standards , such as Moti f and Presentatio n Manager . Differen t look-and-feel s defin e differen t appearance s and behavior s for user interfac e \" w i d g e t s \" l i ke s c r o ll bars, windows , and buttons . To be portabl e a c r o s s look-and-fee l standards , an applicatio n shoul d not hard-cod e its widget s for a particula r l o ok and feel. Instantiatin g l o o k - a n d - f eel-specifi c c l a s s e s of widget s throughou t the applicatio n make s it hard to chang e the l o ok and feel later. We c an s o l ve t h is p r o b l e m by d e f i n i n g an a b s t r a c t W i d g e t F a c t o r y c l a ss that d e - c l a r es an interfac e for creatin g e a ch b a s ic kind of widget . T h e r e ' s a l so an abstrac t c l a ss for e a ch kind of widget , and concret e s u b c l a s s e s implemen t widget s for specifi c look-and-fee l standards . WidgetFactory' s interfac e has an operatio n that return s a new widge t objec t for each abstrac t widge t c l a s s. Client s c a ll these o p e r - a t i o n s to obtai n widge t instances , b ut c l i e n t s aren' t awar e of t he c o n c r e t e c l a s s e s they're using. Thus clients stay independent of the prevailing look and f e e l . ptg8 8 CREATIONAL PATTERNS CHAPTER 3 T h e re is a c o n c r e t e s u b c l a s s of WidgetFactor y for each look-and-fee l standard . Each s u b c l a s s implement s the operation s to creat e the appropriat e widge t for the l o ok and feel. For e x a m p l e , the C r e a t e S c r o l l B a r operatio n on the MotifWidgetFac- tory instantiate s and return s a M o t if s c r o ll bar, while the c o r r e s p o n d i n g operatio n on the PMWidgetFactor y return s a s c r o ll bar for Presentatio n Manager . C l i e n t s creat e widget s s o l e ly throug h the WidgetFactor y interfac e and have no knowl- e d ge of the c l a s s e s that implemen t widget s for a particula r l o ok and feel. In other w o r d s , c l i e n t s o n ly have to commi t to an interfac e define d by an abstrac t c l a s s, not a particula r c o n c r e t e c l a s s . A WidgetFactor y a l so enforce s d e p e n d e n c i e s betwee n the c o n c r e t e widge t c l a s s e s . A M o t if s c r o ll bar s h o u l d be used with a M o t if butto n and a Motif text e d i t o r , and that constraint is enforced a u t o m a t i c a l l y a s a consequence of using a M o t i f W i d - g e t F a c t o r y . Applicability Use the Abstrac t Factor y patter n when • a syste m s h o u l d be independen t of how its product s are created , c o m p o s e d , and represented. • a syste m shoul d be configure d with one of multipl e familie s of products. • a famil y of relate d produc t object s is d e s i g n e d to be u s ed together , and you n e ed to enforc e this constraint. • you want to provid e a c l a ss librar y of products , and you want to r e v e a l just their interfaces, n o t their implementations. S t r u c t u r e ptgA B S T R A C T FACTORY 89 P a r t i c i p a n t s • AbstractFactor y (WidgetFactory) - d e c l a r e s an interfac e for operation s that creat e abstrac t produc t objects. • ConcreteFactor y (MotifWidgetFactory , PMWidgetFactory) - implement s the operation s to creat e c o n c r e t e produc t o b j e c t s . • AbstractProduc t ( W i n d o w , S c r o l l B a r ) - d e c l a r e s an interfac e for a type of produc t object. • ConcreteProduc t (MotifWindow , MotifScrollBar) - define s a produc t o b j e c t to be c r e a t e d by the correspondin g c o n c r e t e factory. - implement s the AbstractProduc t interface. • Client - u s es only interface s declare d by AbstractFactor y and AbstractProduc t c l a s s e s . C o l l a b o r a t i o n s • Normall y a s i n g l e instanc e of a ConcreteFactor y c l a ss is c r e a t e d at run-time . T h is concret e factor y c r e a t e s produc t o b j e c t s havin g a particula r implementa- tion. To creat e differen t produc t objects , c l i e n t s shoul d use a differen t concret e factory. • AbstractFactory defers creation of p r o d u c t o b j e c t s to its ConcreteFactory sub - c l a s s . C o n s e q u e n c e s The Abstrac t Factor y patter n has the followin g benefit s and l i a b i l i t i e s : 1. It isolates concrete classes. The Abstrac t Factor y patter n h e l ps you contro l the c l a s s e s of object s t h at an applicatio n c r e a t e s . B e c a u s e a factor y encapsulate s the r e s p o n s i b i l i t y and the p r o c e s s of creatin g produc t o b j e c t s , it i s o l a t e s c l i e n t s f r om implementatio n c l a s s e s . C l i e n t s manipulat e instance s throug h their abstrac t interfaces . Produc t c l a ss name s are i s o l a t e d in the implementatio n of the c o n c r e t e factory ; they do not appea r in c l i e nt c o d e . 2. It makes exchanging product families easy. The c l a ss of a c o n c r e t e factor y appear s o n ly o n ce in an application—tha t is, wher e it's instantiated . T h is make s it e a sy to chang e the concret e factor y an applicatio n u s e s. It can use differen t produc t configuration s simpl y by changin g the concret e factory . B e c a u s e an a b s t r a c t factor y c r e a t e s a c o m p l e t e famil y of p r o d u c t s , t he w h o l e produc t famil y c h a n g e s at o n c e. In our user interfac e e x a m p l e , we can switc h from M o t i f widget s to Presentatio n Manage r widget s simpl y by s w i t c h i n g the corresponding f a c t o r y objects and recreating the interface. ptg90 CREATIONAL PATTERNS CHAPTER 3 3. It promotes consistency among products. Whe n produc t object s in a famil y are d e s i g n e d to work t o g e t h e r , i t 's importan t that an a p p l i c a t i o n u se o b j e c t s from only one famil y at a time. AbstractFactor y make s this easy to enforce. 4.Supporting new kinds of products is difficult. Extendin g abstrac t factorie s to produc e new kinds of Product s isn't e a s y. That' s becaus e the AbstractFactor y interfac e fixes the set of product s that c an be created . Supportin g new kinds of product s r e q u i r e s extendin g the f a c t o r y interface , whic h i n v o l v e s changin g t he AbstractFactor y c l a ss a nd a ll of i ts s u b c l a s s e s . We d i s c u s s o ne s o l u t i o n to this problem in the Implementation section. I m p l e m e n t a t i o n H e re are s o me usefu l technique s for implementin g the Abstrac t Factor y pattern. 1. Factories as singletons. An applicatio n t y p i c a l l y needs o n ly o ne instanc e of a ConcreteFactor y p er produc t family . So it's usuall y b e st implemente d as a S i n g l e t o n ( 1 2 7 ) . 2.Creating the products. AbstractFactor y only d e c l a r e s an interface for creatin g products . It's up to ConcreteProduc t s u b c l a s s e s to actuall y c r e a t e them . The most commo n way to do this is to defin e a factor y metho d ( s ee Factor y Metho d ( 1 0 7 ) ) for each product . A concret e factor y w i ll s p e c i f y its product s by overridin g the f a c t o r y metho d for e a c h. Whil e this implementatio n is s i m p l e , it r e q u i r e s a new c o n c r e t e factor y s u b c l a s s for each produc t family , e v en if the produc t familie s d i f f er o n ly s l i g h t l y . If many produc t familie s are p o s s i b l e , the c o n c r e t e f a c t o r y can be i m p l e - mente d using the Prototyp e ( 1 1 7) pattern . The concret e f a c t o r y is initialize d with a prototypica l instanc e of e a ch produc t in the family , and it c r e a t e s a new produc t by c l o n i n g its prototype . The Prototype-base d approac h e l i m i n a t e s the n e ed for a new c o n c r e t e factor y c l a ss for e a ch new produc t family. H e r e ' s a way to implemen t a Prototype-base d factor y in Smalltalk . The c o n c r e t e factor y s t o r e s t he p r o t o t y p e s to be c l o n e d in a d i c t i o n a r y c a l l ed p a r t C a t a l o g . The m e t h o d make: r e t r i e v e s the prototype and clones it: make: partName (partCatalog at: partName) copy The concrete factory has a method for adding parts to the catalog. addPart: partTemplat e named: partName partCatalog a t : partName put: partTemplate Prototypes are added t o t h e factory by identifying them with a symbol: aFactory a d d P a r t : aPrototype named: #ACMEWidget A variatio n on the Prototype-base d approac h is p o s s i b l e in l a n g u a g e s that treat classes as first-class objects (Smalltalk a n d Objective C , f o r example). You ptgA B S T R A C T F A C T O R Y 9 1 can think of a c l a ss in these language s as a degenerat e factor y t h at create s o n ly one kind of product . You can store classes i n s i d e a c o n c r e t e f a c t or y that creat e the variou s concret e product s in v a r i a b l e s , much l i ke prototypes . T h e se c l a s s e s creat e new instance s on behal f of the concret e factory . You defin e a new f a c t o r y by initializin g an instanc e of a c o n c r e t e factor y with classes of product s rathe r than by s u b c l a s s i n g . T h is approac h takes advantag e of languag e characteristics , wherea s the pure Pr ot oty pe -b as e d approac h is language-independent. L i ke the Prototype-base d factor y in Smalltal k just d i s c u s s e d , the c l a s s - b a s e d v e r s i o n w i ll have a s i n g le instanc e variabl e p a r t C a t a l o g , whic h is a d i c t i o - nary whos e key is the name of the p a r t. Instea d of storin g prototype s to be c l o n e d , p a r t C a t a l o g s t o r e s the c l a s s e s of the products . The metho d m a k e : now looks like this: make: partName (partCatalog at: partName) new 3.Defining extensible factories. AbstractFactor y usuall y define s a differen t op- eratio n for e a ch kind of produc t it can produce . The kinds of product s are e n c o d e d in the operatio n signatures . Addin g a new kind of produc t r e q u i r e s changin g the AbstractFactor y interfac e and all the c l a s s e s that d e p e n d on it. A m o re fl exib l e but l e ss safe d e s i g n is to add a paramete r to operation s that creat e objects . T h is paramete r s p e c i f i e s the kind of o b j e c t to be c r e a t e d . It c o u ld be a c l a ss identifier , an i n t e g e r , a s t r i n g , or anything e l se that identifie s the k i nd of product . In f a ct with this approach , AbstractFactor y o n ly n e e ds a s i n g le \" M a k e \" operatio n with a paramete r indicatin g the k i nd of o b j e c t to c r e a t e . T h is is the techniqu e used in the Prototype - and the c l a s s - b a s e d abstrac t factorie s d i s c u s s e d e a r l i e r . T h is variatio n is e a s i e r to u se in a dynamicall y typed languag e l i ke S m a l l t a l k than in a staticall y typed languag e l i ke C++. You can use it in C++ o n ly when all o b j e c t s have the same abstrac t ba se c l a ss or when the produc t o b j e c t s can be safely c o e r c e d to the c o r r e c t type by the c l i e nt t h at r e q u e s t e d them . The implementatio n s e c t i o n of F a c t o r y Metho d ( 1 0 7) s h o w s h ow to implemen t such parameterize d operation s in C++. But e v en when no c o e r c i o n is needed , an inheren t proble m r e m a i n s : A ll product s are returne d to the c l i e nt with the same abstrac t interfac e as g i v en by the retur n type. The c l i e nt w i ll not be a b le to differentiat e or make safe assumption s abou t the c l a ss of a product . If c l i e n t s n e ed to perfor m s u b c l a s s - s p e c i f i c o p e r a t i o n s , they won' t be a c c e s s i b l e throug h the abstrac t interface . Althoug h the c l i e nt c o u ld perfor m a downcas t ( e . g ., with d y n a m i c - c a s t in C++) , that's not alway s feasibl e or safe, becaus e the downcas t can fail. T h is is the classic trade-off f o r a highly flexible and e x t e n s i b l e interface. ptg92 CREATIONAL PATTERNS CHAPTER 3 S a m p l e C o d e W e ' l l a p p ly t he Abstrac t F a c t o r y p a t t e r n to c r e a t i n g t he m a z e s we d i s c u s s e d at t he b e g i n n i n g of t h is c h a p t e r . C l a ss M a z e F a c tory c an c r e a t e c o m p o n e n t s of m a z e s . It b u i l d s r o o m s , w a l l s , a nd d o o r s betwee n r o o m s . It m i g h t be u s ed by a p r o g r a m that r e a d s p l a ns f or m a z e s f r om a file a nd b u i l d s t he c o r r e s p o n d i n g maze . Or it m i g h t be u s ed by a p r o g r a m t h at b u i l d s m a z e s r a n d o m l y . P r o g r a m s t h at b u i ld m a z e s t a ke a M a z e F a c t o r y as an a r g u m e n t so that t he p r o g r a m m e r c an specif y t he classe s of r o o m s , walls , a nd d o o r s to c o n s t r u c t . class MazeFactor y { public: MazeFactory(); virtual Maze* MakeMaze O const { return new Maze; } virtual Wall* MakeWall( ) const { return new Wall; } virtual Room* MakeRoom(in t n) const { return new Room(n); } virtual Door* MakeDoor(Room* rl, Room* r2) const { return new Door(rl, r2); } Recal l that the m e m b e r functio n C r e a t e M a z e ( p a ge 84) b u i l d s a s m a l l maze c o n s i s t i n g of t wo r o o m s w i th a d o or b e t w e e n t h e m . C r e a t e M a z e h a r d - c o d e s t he c l a s s names, making it difficult t o create mazes with different components. H e r e ' s a v e r s i o n o f C r e a t e M a z e t h a t r e m e d i e s t h a t s h o r t c o m i n g b y t a k i n g a M a z e F a c t o r y as a p a r a m e t e r : Maze* MazeGame::CreateMaz e (MazeFactory k factory) { Maze* a M a ze = f a c t o r y . M a k e M a z e ( ) ; Room* rl = factory.MakeRoom(1); Room* r2 = factory.MakeRoom(2); Door* aDoor = factory.MakeDoor(rl , r2); aMaze->AddRoom(rl) ; aMaze->AddRoom(r2); rl->SetSide(North , factory.MakeWall()) ; rl->SetSide(East , aDoor); rl->SetSide(South , factory.MakeWall( ) ) ; rl->SetSide(West, factory.MakeWall()); ptgA B S T R A C T FACTORY 93 r2->SetSide(North , factory.MakeWall()) ; r2->SetSide(East , factory.MakeWall()) ; r2->SetSide(South , factory.MakeWall()) ; r2->SetSide(West , aDoor); return aMaze; } We can creat e E n c h a n t e d M a z e F a c t o r y , a factor y for enchante d mazes , by s u b - c l a s s i n g M a z e F a c t o r y . E n c h a n t e d M a z e F a c t o r y w i ll overrid e differen t mem- ber function s and retur n d i f f e r e n t s u b c l a s s e s of Room , W ai 1, e t c . class EnchantedMazeFactor y : public MazeFactor y { public: EnchantedMazeFactory(); virtual Room* MakeRoom(in t n) const { return new EnchantedRoom(n , CastSpell()) ; } virtual Door* MakeDoor(Room * rl, Room* r2) const { return new DoorNeedingSpell(rl , r2) ; } protected: Spell* CastSpell( ) const; } ; Now suppos e we want to make a maze game in whic h a room can have a bomb set in it. If the bomb g o es o f f, it w i ll damag e the walls (at least) . We can make a subclas s of R o om keep track of whethe r the room has a bomb in it and whethe r the bomb has g o ne o f f. W e ' l l a l so need a s u b c l a s s of W ai 1 to keep track of the damag e done to the wall. W e ' ll c a ll these c l a s s e s R o o m W i t h A B o m b and B o m b e d W a l l . The l a st c l a ss we'll defin e is B o m b e d M a z e F a c t o r y , a s u b c l a s s of M a z e F a c t o r y t h at e n s u r e s walls are of c l a ss B o m b e d W a l l and room s are of c l a ss R o o m W i t h A B o m b . B o m b e d M a z e F a c t o r y o n ly needs to overrid e two functions: Wall* BombedMazeFactory::MakeWal l () const { return new BombedWall; } Room* BombedMazeFactory::MakeRoom(in t n) const { return new RoomWithABomb(n); } To build a s i m p l e maze that can contai n b o m b s , we simpl y c a ll G r e a t e M a z e with a B o m b e d M a z e F a c t o r y . MazeGame game; BombedMazeFactory factory; game.CreateMaze ( f a c t o r y ) ,• ptg94 CREATIONAL PATTERNS CHAPTER 3 C r e a t e M a z e can take an i n s t a n c e of E n c h a n t e d M a z e F a c t o r y just as w e ll to b u i ld enchante d mazes. N o t i c e that t he M a z e F a c t o r y is just a c o l l e c t i o n of factor y m e t h o d s . T h is is t he m o st c o m m o n way to implemen t the Abstrac t Factor y pattern . A l so note that M a z e F a c t o r y is not an abstrac t c l a s s; thus it a c ts as both the AbstractFactor y and t he C o n c r e t e F a c t o r y . T h is is anothe r commo n implementatio n for s i m p l e a p p l i c a - t i o ns of the Abstrac t Factor y pattern . B e c a u s e the M a z e F a c t o r y is a c o n c r e t e c l a ss c o n s i s t i n g e n t i r e l y of factor y methods , it's e a sy to make a new M a z e F a c t o r y by makin g a s u b c l a s s and overridin g the operation s that n e ed to c h a n g e . C r e a t e M a z e used the S e t S i d e operatio n on r o o m s to s p e c i f y their s i d e s . If it c r e a t e s r o o m s with a B o m b e d M a z e F a c t o r y , then the maze w i ll be made up of R o o m W i t h A B o m b o b j e c t s with B o m b e d W a l l s i d e s . If R o o m W i t h A B o m b had to a c c e s s a s u b c l a s s - s p e c i f i c membe r of B o m b e d W a l l , then it woul d have to c a st a r e f e r e n c e to its w a l ls from W a l l * to B o m b e d W a l l * . T h is d o w n c a s t i n g is safe as l o ng as the argumen t is in fact a B o m b e d W a l l , w h i c h is guarantee d to be true if w a l ls are built s o l e ly w i th a B o m b e d M a z e F a c t o r y . D y n a m i c a l l y typed language s s u ch as Smalltal k don't r e q u i r e d o w n c a s t i n g , of c o u r s e , but they m i g h t produc e run-tim e error s if they encounte r a W a ll wher e t h ey e x p e c t a subclass of Wa 1 1. U s i ng Abstrac t Factor y to b u i ld w a l ls h e l ps preven t t h e se r u n - t i m e error s by e n s u r i n g that o n ly certai n k i n ds of w a l ls c an be c r e a t e d . Let's c o n s i d e r a S m a l l t a l k v e r s i o n of M a z e F a c t o r y , one with a s i n g le m a ke operatio n that takes the k i nd of o b j e c t to make as a parameter . M o r e o v e r , the c o n c r e t e factory stores the classes of the products it creates. F i r s t , we'll write an equivalent of CreateMaze in Smalltalk: CreateMaze : a F a c t o ry | r o o ml r o o m2 a D o or | r o o ml := ( a F a c t o ry m a k e: # r o o m) n u m b e r: 1. r o o m2 := ( a F a c t o ry make: # r o o m) n u m b e r: 2. a D o or := ( a F a c t o ry make: # d o o r) f r o m: r o o ml to: r o o m 2. r o o ml atSide: t t n o r th put: ( a F a c t o ry make: # w a l l ). r o o ml atSide: #east put: a D o o r. r o o ml atSide: t t s o u th put: ( a F a c t o ry m a k e: # w a l l ). r o o ml atSide: t t w e st put: ( a F a c t o ry m a k e: # w a l l ). r o o m2 atSide: # n o r th put: ( a F a c t o ry make: # w a l l ). r o o m2 atSide: # e a st put: ( a F a c t o ry make: # w a l l ). r o o m2 atSide: t t s o u th put: ( a F a c t o ry m a k e: # w a l l ). r o o m2 atSide: f t w e st put: a D o o r. ~ Maze new addRoom: rooml; addRoom: r o o m 2 ; yourself As we d i s c u s s e d in t he Implementatio n s e c t i o n , M a z e F a c t o r y n e e ds o n ly a s i n g le i n s t a n c e variabl e p a r t C a t a l o g to provid e a dictionar y whos e key is the c l a ss of t h e component. Also recall how we implemented t h e make: m e t h o d : make: partName ( p a r t C a t a l o g a t : partName) n e w ptgA B S T R A C T F A C T O R Y 9 5 Now we can creat e a M a z e F a c t o r y and use it to implemen t c r e a t e M a z e . W e ' ll create the factory using a method createMazeFactory of class MazeGame. createMazeFactor y \" ( M a z e F a c t o r y new addPart: Wall n a m e d: #wall; addPart: Room n a m e d: #room; addPart: D o or named: #door; yourself) A B o m b e d M a z e F a c t o r y or E n c h a n t e d M a z e F a c t o r y is create d by a s s o c i a t i n g differen t c l a s s e s with the keys. For e x a m p l e , an E n c h a n t e d M a z e F a c t o r y c o u ld be created like this: createMazeFactor y ( M a z e F a c t o r y n ew addPart: Wall n a m e d: ttwall; addPart: EnchantedRoo m n a m e d: #room; addPart: DoorNeedingSpel l n a m e d: #door; yourself) K n o w n U s e s I n t e r v i e w s u s es the \" K i t\" s u f f ix [ L i n 9 2 ] to denot e AbstractFactor y c l a s s e s . It de- fines WidgetKi t and DialogKi t abstrac t factorie s for generatin g l o o k - a n d - f e e l - specifi c user interfac e objects . I n t e r v i e w s also i n c l u d e s a LayoutKi t that g e n e r a t e s differen t compositio n o b j e c t s dependin g on the layou t d e s i r e d . For e x a m p l e , a layou t that is conceptuall y horizonta l may requir e differen t compositio n object s d e p e n d i n g on the document' s orientatio n (portrai t or landscape). ET++ [ W G M 8 8 ] u s es the Abstrac t Factor y patter n to a c h i e v e portabilit y a c r o s s differen t windo w s y s t e m s (X W i n d o w s and S u n V i e w , for example) . The W i n - dowSyste m abstrac t b a se c l a ss define s the interfac e for c r e a t i n g o b j e c t s that r e p r e - s e nt windo w s y s t e m r e s o u r c e s (MakeWindow , MakeFont , M a k e C o l o r , for exam- ple). Concret e s u b c l a s s e s implemen t the interface s for a s p e c i f i c windo w s y s t e m . At run-time , ET++ create s an i n s t a n c e of a c o n c r e t e W i n d o w S y s t e m s u b c l a s s that creates concrete system resource objects. Related P a t t e r n s AbstractFactor y c l a s s e s are o f t en implemente d with f a c t o r y method s (Factor y Method (107)), but they can also be implemented using Prototype (117). A concrete factory is often a singleton (Singleton (127)). ptg This page intentionally left blank ptgBUILDER 97 BUILDER O b j e c t Creational Intent Separat e the constructio n of a c o m p l e x objec t from its representatio n so that the same construction process can create different r e p r e s e n t a t i o n s . M o t i v a t i o n A reade r f or the RTF (Rich T e xt Format ) documen t exchang e f o r m a t shoul d be able to conver t RTF to many text formats . The reade r migh t conver t RTF document s into plain A S C I I text or into a text widge t that can be e d i t e d i n t e r a c t i v e l y . The p r o b l e m , h o w e v e r , is that t he n u m b e r of p o s s i b l e c o n v e r s i o n s is o p e n - e n d e d . So it shoul d be e a sy to add a new conversio n withou t modifyin g the reader. A solutio n is to configur e the RTFReade r c l a ss with a TextConverte r o b j e c t that convert s RTF to anothe r textua l representation . As the R T F R e a d e r parse s the RTF document , it u s es the TextConverte r to perfor m the c o n v e r s i o n . Wheneve r the R T F R e a d e r r e c o g n i z e s an RTF token (eithe r plain text or an RTF c o n t r o l word) , it i s s u e s a reques t to the TextConverte r to conver t the token . TextConverte r o b j e c t s are r e s p o n s i b l e both for performin g the data c o n v e r s i o n and for representin g the token in a p a r t i c u l a r format. S u b c l a s s e s of T e x t C o n v e r t e r s p e c i a l i z e in differen t c o n v e r s i o n s a nd formats . F or e x a m p l e , an A S C I I C o n v e r t e r i g n o r e s request s to conver t anythin g e x c e p t plain text. A T e X C o n v e r t e r , on the other hand , w i ll implemen t operation s for all request s in order to produc e a T p ^X representatio n that capture s all the s t y l i s t i c informatio n in the text. A TextWidgetConverte r w i ll produc e a comple x user interfac e o b j e c t that lets the user see and edit the text. ptg9 8 CREATIONAL PATTERNS CHAPTER 3 Each kind of converte r c l a ss takes the mechanis m for creatin g and a s s e m b l i n g a comple x o b j e c t and puts it behin d an abstrac t interface . The converte r is separat e from the reader , whic h is r e s p o n s i b l e for parsin g an RTF document. T he B u i l d e r patter n capture s a ll these relationships . Each converte r c l a ss is c a l l ed a builde r in the pattern , and the reade r is c a l l ed the director . A p p l i e d to t h is example , the Builde r patter n separate s the algorith m for interpretin g a textual f o r m a t (that is, the parse r for RTF documents ) from how a converte d f o r m a t g e ts create d and represented . T h is lets us r e u se the RTFReader' s parsin g algorith m to creat e differen t text representation s f r om RTF documents—jus t configur e the R T F R e a d e r with different s u b c l a s s e s of T e x t C o n v e r t e r . Applicability Use the Builde r patter n when • the algorith m for creatin g a c o m p l e x o b j e c t s h o u l d be i n d e p e n d e n t of the parts that make up the objec t and how they'r e a s s e m b l e d . • the constructio n p r o c e s s m u st a l l ow differen t representation s for the o b j e c t that's c o n s t r u c t e d . S t r u c t u r e Participants • Builder (TextConverter) - specifies an abstract interface for creating parts of a Product object. ptgBUILDER 9 9 • ConcreteBuilde r (ASCIIConverter , TeXConverter , TextWidgetConverter) - construct s and a s s e m b l e s parts of the produc t by implementin g the B u i l d e r interface. - define s and keep s track of the representatio n it creates. - provide s an interfac e for retrievin g the produc t ( e . g ., G e t A S C I I T e x t , G e t - T e xt Widget). • Directo r (RTFReader) - construct s an objec t using the Builde r interface. • P r o d u c t ( A S C I I T e x t , T e X T e x t , TextWidget) - represent s the comple x o b j e c t unde r construction . ConcreteBuilde r build s the product' s interna l representatio n and define s the p r o c e s s by w h i c h it's assembled. - include s c l a s s e s that defin e the constituen t parts , includin g interface s for a s s e m b l i n g the parts into the final result. C o l l a b o r a t i o n s • The c l i e n t create s the D i r e c t o r objec t and configure s it with the d e s i r e d Builde r object. •D i r e c t o r notifie s the builde r wheneve r a part of the produc t s h o u l d be built. •Builde r handle s request s from the directo r and adds parts to the product. •T he c l i e nt r e t r i e v e s t he produc t from t he b u i l d e r . The followin g interactio n diagra m illustrate s how Builde r and Directo r cooperat e with a client. ptg100 CREATIONAL PATTERNS CHAPTER 3 C o n s e q u e n c e s H e re are key c o n s e q u e n c e s of the Builde r pattern: 1. It lets you vary a product's internal representation. The Builde r o b j e c t provide s the directo r with an abstrac t interfac e for constructin g the product . The in- terfac e lets the builde r h i de the representatio n and interna l structur e of the product . It a l so h i d es how the produc t g e ts a s s e m b l e d . B e c a u s e the produc t is constructe d throug h an abstrac t interface , all you have to do to chang e the product' s interna l representatio n is defin e a new kind of b u i l d e r . 2. It isolates code for construction and representation. The B u i l d e r patter n i m p r o v e s modularit y by encapsulatin g the way a comple x o b j e c t is constructe d and represented . C l i e n t s needn' t know anythin g abou t the c l a s s e s t h at defin e the product' s interna l structure ; such c l a s s e s don't appea r in Builder' s interface. Each C o n c r e t e B u i l d e r contain s all the c o de to creat e and a s s e m b l e a partic- ular kind of product . The c o de is writte n o n c e; then differen t D i r e c t o r s can reuse it to build Produc t variant s from the same set of parts . In the e a r l i e r RTF e x a m p l e , we c o u ld defin e a reade r for a f o r m a t other than R T F, s a y, an S G M L R e a d e r , and use the same TextConverter s to generat e A S C I I T e x t , T e X T e x t , a nd T e x t W i d g e t rendition s of S G M L documents. 3. It gives you finer control over the construction process. U n l i k e creationa l pat- terns that construc t product s in one s h o t, the B u i l d e r patter n construct s the produc t step by step unde r the director' s c o n t r o l . Only when the produc t is finishe d d o es the directo r retriev e it f r om the b u i l d e r . H e n c e the B u i l d e r interfac e reflect s the p r o c e s s of constructin g the produc t more than other c r e - ationa l patterns . T h is g i v es you finer contro l over the constructio n p r o c e s s and consequently the internal structure of the resulting product. I m p l e m e n t a t i o n T y p i c a l l y there' s an abstrac t Builde r c l a ss that define s an operatio n for e a ch c o m - ponen t t h at a directo r may ask it to c r e a t e . The operation s do nothin g by default . A C o n c r e t e B u i l d e r c l a ss override s operation s for component s it's intereste d in c r e a t i n g . H e re are other implementatio n i s s u e s to c o n s i d e r : 1. Assembly a nd construction interface. B u i l d e r s c o n s t r u c t t h e ir p r o d u c t s in s t e p - b y - s t e p fashion . Therefor e the B u i l d e r c l a ss interfac e must be genera l enoug h to allow the constructio n of product s for all kinds of concret e builders. A key d e s i g n i s s ue c o n c e r n s the mode l for the constructio n and a s s e m b l y p r o c e s s . A mode l wher e the result s of constructio n request s are simpl y ap- pende d to the produc t is usuall y sufficient . In the RTF example , the builde r convert s and append s the next token to the text it has converte d so far. B ut s o m e t i m e s y ou m i g h t n e ed a c c e s s to parts of t he produc t c o n s t r u c t e d e a r l i e r . In the Maze example w e present in the Sample Code, the M a z e B u i l d e r ptgBUILDER 1 0 1 interfac e l e ts you add a d o or betwee n existin g rooms . T r ee structure s such as parse trees t h at are built bottom-u p are anothe r example . In that c a s e, the builde r woul d retur n c h i ld n o d e s to the d i r e c t o r , whic h then woul d pass them back to the builde r to build the paren t n o d e s . 2. Why no abstract class for products? In the commo n c a s e, the product s produce d by the c o n c r e t e builder s d i f f er so greatl y in their representatio n t h at there is little to gain f r om g i v i n g differen t product s a commo n paren t c l a s s . In the RTF example , the A S C I I T e x t and the T e x t W i d g e t object s are unlikel y to have a commo n interface , nor do they n e ed o n e. B e c a u s e the c l i e n t usuall y configure s the directo r with the prope r c o n c r e t e builder , the c l i e nt is in a positio n to know whic h concret e s u b c l a s s of B u i l d e r is in use and can handl e i ts p r o d u c t s a c c o r d i n g l y . 3.Empty methods as default in Builder. In C++, the build method s are intention- a l ly not d e c l a r e d pure virtua l membe r functions . They'r e define d as empt y methods instead, letting clients override only the operations they're inter - e s t e d in. Sample C o d e W e ' ll defin e a varian t of the C r e a t e M a z e membe r functio n (page 84) that takes a builde r of c l a ss M a z e B u i l d e r as an argument. The M a z e B u i l d e r c l a ss define s the followin g interfac e for buildin g mazes: class MazeBuilde r { public: virtual void BuildMaze O { } virtual void BuildRoom(in t room) { } virtual void BuildDoor(in t roomFrom , int roomTo) { } virtual Maze* GetMaze( ) { return 0; } protected: MazeBuilder() ; } ; T h is interfac e can creat e three things : (1) the maze , (2) room s with a particula r room number , and (3) d o o rs betwee n numbere d rooms . The G e t M a z e operatio n return s the maze to the client . S u b c l a s s e s of M a z e B u i l d e r w i ll overrid e this operatio n to r e t u r n the maze that they build. All the maze-buildin g operation s of Ma z e Bu i 1 de r do nothin g by default . T h e y ' r e not d e c l a r e d pure virtua l to let derive d c l a s s e s overrid e only those method s in whic h they'r e interested. Give n the M a z e B u i l d e r interface , we can chang e the C r e a t e M a z e membe r function to take this b u i l d e r as a parameter. ptg102 CREATIONAL PATTERNS CHAPTER 3 Maze* MazeGame::CreateMaz e ( M a z e B u i l d e r & builder) { builder.BuildMaze(); builder.BuildRoom(1) ; buiIder.BuiIdRoom(2) ; builder.BuildDoor(1 , 2); return builder.GetMaze() ; } C o m p a r e t h is v e r s i o n of C r e a t e M a z e with t he o r i g i n a l . N o t i c e h ow t he b u i l d e r h i d es t he i n t e r n a l r e p r e s e n t a t i o n of t he Maze—tha t i s, t he c l a s s e s t h at defin e r o o m s , d o o r s , a nd walls—an d h ow t h e se p a r ts a re a s s e m b l e d to c o m p l e t e t he f i n al maze . S o m e o n e m i g h t g u e ss that t h e re a re c l a s s e s f or r e p r e s e n t i n g r o o m s a nd d o o r s , b ut t h e re is no h i nt of o ne f or walls . T h is m a k e s it e a s i e r to c h a n g e t he way a m a ze is r e p r e s e n t e d , s i n ce n o ne of the c l i e n t s of M a z e B ui I d er has to be c h a n g e d . L i ke t he o t h er c r e a t i o n a l p a t t e r n s , t he B u i l d e r p a t t e r n e n c a p s u l a t e s h ow o b - jects g et c r e a t e d , in t h is c a se t h r o u g h t he i n t e r f a c e d e f i n e d by M a z e B u i l d e r . T h at m e a n s we c an r e u se M a z e B u i l d e r to b u i ld d i f f e r e n t k i n d s of mazes . T he C r e a t e C o m p l e x M a z e o p e r a t i o n g i v es an e x a m p l e : Maze* MazeGame::CreateComplexMaz e ( M a z e B u i l d e r & builder) { buiIder.BuiIdRoom(1); // . . . b u i I d e r . B u i I d R o o m ( 1 0 0 1 ) ; return builder.GetMaze() ; } N o te that M a z e B u i l d e r d o es n ot c r e a t e m a z e s itself ; i ts m a in p u r p o s e is j u st to defin e an i n t e r f a c e f or c r e a t i n g m a z e s . It d e f i n e s e m p t y i m p l e m e n t a t i o n s p r i m a r i l y f or c o n v e n i e n c e . S u b c l a s s e s of M a z e B u i l d e r do t he a c t u a l w o r k . T he s u b c l a s s S t a n d a r d M a z e B u i l d e r is an i m p l e m e n t a t i o n t h at b u i l d s s i m p l e mazes . It k e e p s t r a ck of t he m a ze it's b u i l d i n g in t he v a r i a b l e _ c u r r e n t M a z e . class StandardMazeBuilde r : public MazeBuilde r { public: StandardMazeBuilder(); virtual void BuildMaze() ; virtual void BuildRoom(int) ; virtual void BuildDoor(int , int); virtual Maze* GetMaze (),- private: Directio n CommonWall(Room* , Room*); Maze* _currentMaze; } ; ptgBUILDER 1 0 3 C o m m o n W a l l is a utility operatio n that determine s the d i r e c t i o n of the commo n wall betwee n two r o o m s . The S t a n d a r d M a z e B u i l d e r c o n s t r u c t o r s i m p l y initialize s _ c u r r e n t M a z e . S t a n d a r d M a z e B u i l d e r : : S t a n d a r d M a z e B u i l d e r () { _ c u r r e n t M a z e = 0; } B u i l d M a z e instantiates a Maze that other operations will assemble a n d e v e n t u - ally return to the client (with GetMaze). void StandardMazeBuilder::BuildMaz e () { _currentMaz e = new Maze; } M a z e* S t a n d a r d M a z e B u i l d e r : : G e t M a z e () { r e t u r n _currentMaze; } The BuildRoom operation creates a room and builds the walls around it: void StandardMazeBuilder::BuildRoo m ( i nt n) { if ( ! _ c u r r e n t M a z e - > R o o m N o ( n ) ) { Room* r o om - new Room(n); _currentMaze->AddRoom(room); r o o m - > S e t S i d e ( N o r t h , n ew W a l l ); room->SetSide(South , new Wall); room->SetSide(East , new Wall); room->SetSide(West , new Wall); } } To build a d o or b e t w e e n t wo r o o m s , S t a n d a r d M a z e B u i l d e r l o o ks up b o th r o o m s in the maze and finds their adjoining wall: void StandardMazeBuilder:rBuildDoo r ( i nt nl, int n2) { Room* rl = _currentMaze->RoomNo(nl); Room* r2 = _currentMaze->RoomNo(n2) ; D o o r* d = new Door(rl, r2); r l - > S e t S i d e ( C o m m o n W a l l ( r l , r 2 ) , d ); r2->SetSide(CommonWall(r2,rl), d); } C l i e n t s c an n ow u se C r e a t e M a z e in c o n j u n c t i o n w i th S t a n d a r d M a z e B u i l d e r t o create a maze: ptg104 CREATIONAL PATTERNS CHAPTER 3 Maze* maze; MazeGame game; StandardMazeBuilde r builder; game.CreateMaze(builder) ; maze = builder.GetMaze(); We c o u ld h a ve put all the S t a n d a r d M a z e B u i l d e r o p e r a t i o n s in M a z e and let e a ch M a z e b u i ld itself . But m a k i n g M a z e s m a l l e r m a k e s it e a s i e r to u n d e r s t a n d and modify , and S t a n d a r d M a z e B u i l d e r is e a sy to s e p a r a t e f r om M a z e . M o st i m p o r t a n t l y , s e p a r a t i n g the two l e ts you h a ve a variet y of M a z e B u i l d e r s , e a ch u s i ng differen t c l a s s e s f or r o o m s , walls , a nd d o o r s . A m o re e x o t i c M a z e B u i l d e r is C o u n t i n g M a z e B u i l d e r . T h is b u i l d e r d o e s n ' t c r e a t e a m a ze at a l l; it j u st c o u n t s t he d i f f e r e n t k i n d s of c o m p o n e n t s t h at w o u l d h a ve b e en c r e a t e d . class CountingMazeBuilde r : public MazeBuilde r { public: CountingMazeBuilder(); virtual void BuildMaze() ; virtual void BuildRoom(int) ; virtual void BuildDoor(int , int); virtual void AddWall(int , Direction); void GetCounts(int& , i n t &) const; private: int _doors; int _rooms; } ; T he c o n s t r u c t o r initialize s t he c o u n t e r s , a nd t he o v e r r i d d e n M a z e B u i l d e r o p e r - a t i o n s i n c r e m e n t t h em a c c o r d i n g l y . CountingMazeBuilder::CountingMazeBuilde r () { _rooms = _doors = 0; } void CountingMazeBuilder::BuildRoo m ( i n t) { _rooms++ ; } void CountingMazeBuilder::BuildDoo r ( i n t, int) { _doors++ ; } void CountingMazeBuilder::GetCount s ( i n t& rooms, i n t& d o o r s ) c o n st { r o o ms = _rooms; d o o r s = _doors; } ptgBUILDER 105 H e r e ' s how a client might use a Count ingMazeBuilder: int rooms, doors; MazeGame game; CountingMazeBuilde r builder; game.CreateMaze(builder) ; builder.GetCounts(rooms , doors); cout « \" T he maze has \" « rooms « \" r o o ms and \" « doors « \" doors\" « endl; Known U s e s The RTF converte r applicatio n is from ET++ [ W G M 8 8 ] . Its text buildin g b l o ck u s es a builde r to p r o c e s s text s t o r ed in the RTF f o r m a t . Builde r is a commo n patter n in S m a l l t a l k - 8 0 [ P a r 9 0 ] : • The Parse r c l a ss in the c o m p i l e r subsyste m is a Directo r that takes a P r o - gramNodeBuilde r o b j e c t as an argument . A Parse r o b j e c t notifie s its P r o - gramNodeBuilde r o b j e c t e a ch time it r e c o g n i z e s a syntacti c construct . Whe n the parse r is d o n e , it a s ks the builde r for the parse tree it built and return s it to the client. • C l a s s B u i l d e r is a builde r that C l a s s e s use to c r e a te s u b c l a s s e s for themselves . In this c a se a C l a ss is both the D i r e c t o r and the Product. • B y t e C o d e S t r e a m is a builde r that create s a c o m p i l e d metho d as a byte ar- r a y. B y t e C o d e S t r e a m is a nonstandar d use of the Builde r pattern , b e c a u s e the comple x o b j e c t it build s is e n c o d e d as a byte array , not as a norma l S m a l l t a l k object . But the interfac e to B y t e C o d e S t r e a m is typica l of a b u i l d e r , and it woul d be e a sy to r e p l a c e B y t e C o d e S t r e a m with a differen t c l a ss that represente d program s as a composit e object. The S e r v i c e Configurator f r a m e w o r k from the Adaptiv e Communication s E n v i - ronmen t uses a b u i l d e r to construc t networ k s e r v i c e component s that are l i n k e d into a s e r v e r at run-tim e [ S S 9 4 ] . The component s are d e s c r i b e d with a config- uratio n languag e that's p a r s e d by an L A L R ( l ) parser . The semanti c a c t i o n s of the parse r perfor m operation s on the builde r that add informatio n to the s e r v i c e component. In this case, the parser is the Director. Related Patterns Abstrac t Factor y ( 8 7) is s i m i l a r to B u i l d e r in that it too may construc t c o m p l e x o b j e c t s . The primar y differenc e is that the B u i l d e r patter n focuse s on constructin g a c o m p l e x o b j e c t step by s t e p. Abstrac t Factory' s e m p h a s i s is on familie s of produc t o b j e c t s ( e i t h e r s i m p l e o r c o m p l e x ) . B u i l d e r r e t u r n s t h e p r o d u c t a s a f i n a l step, ptg1 06 CREATIONAL PATTERNS CHAPTER 3 but as far as the Abstrac t Factor y patter n is c o n c e r n e d , the produc t g e ts returne d immediately. A Composite (163) i s what the builder often b u i l d s . ptgFACTORY M E T H O D 107 F A C T O R Y METHOD C l a s s C r e a t i o n a l Intent Defin e an interfac e for creatin g an o b j e c t , but let s u b c l a s s e s d e c i d e w h i c h c l a ss to instantiate. Factory Method lets a class defer instantiation to subclasses. Also Known As Virtual Constructor Motivation Framework s use abstrac t c l a s s e s to defin e and maintai n r e l a t i o n s h i p s betwee n objects . A f r a m e w o r k is often r e s p o n s i b l e for creatin g t h e se object s as w e l l . C o n s i d e r a framewor k for application s that can p r e s e n t multipl e document s to t he u s e r. T wo k ey abstraction s in t h is framewor k a re t he c l a s s e s Applicatio n a nd Document . Both c l a s s e s are abstract , and c l i e n t s have to s u b c l a s s them to r e a l i z e their application-specifi c implementations . To creat e a drawin g a p p l i c a t i o n , for e x a m p l e , we defin e t he c l a s s e s DrawingApplicatio n a nd D r a w i n g D o c u m e n t . T he Applicatio n c l a ss is r e s p o n s i b l e f or managin g D o c u m e n t s a nd w i ll c r e a t e them as required—whe n the u ser s e l e c t s O p en or New from a menu , for example. B e c a u s e t he particula r D o c u m e n t s u b c l a s s to instantiat e is a p p l i c a t i o n - s p e c i f i c , t he Applicatio n c l a ss can't predic t t he s u b c l a s s of Documen t to instantiate—th e A p - plicatio n c l a ss o n ly know s when a new documen t s h o u l d be c r e a t e d , not what kind of D o c u m e n t to c r e a t e . T h is c r e a t e s a d i l e m m a : The framewor k must instantiat e c l a s s e s , but it o n ly know s abou t abstrac t c l a s s e s , whic h it c a n n o t instantiate. The Factor y M e t h o d patter n o f f e r s a s o l u t i o n . It encapsulate s the knowledg e of whic h D o c u m e n t s u b c l a s s to creat e a nd move s this knowledg e o ut of t he framework. ptg1 0 8 CREATIONAL PATTERNS CHAPTER 3 Applicatio n s u b c l a s s e s redefin e an abstrac t CreateDocumen t operatio n on A p p l i - c a t i o n to retur n the appropriat e Documen t s u b c l a s s . O n ce an Applicatio n s u b - c l a ss is instantiated , it c an then instantiat e a p p l i c a t i o n - s p e c i f i c D o c u m e n t s with- out knowin g t h e ir c l a s s . We c a ll CreateDocumen t a factor y metho d becaus e i t 's r e s p o n s i b l e for \"manufacturing\" a n object. A p p l i c a b i l i t y U se t he F a c t o r y M e t h o d patter n w h e n • a c l a ss can't anticipat e the c l a ss of object s it must create. • a c l a ss want s its s u b c l a s s e s to specif y the o b j e c t s it c r e a t e s . • c l a s s e s delegat e r e s p o n s i b i l i t y to one of severa l helpe r s u b c l a s s e s , and you want to localize the knowledge of which helper subclass is the delegate. S t r u c t u r e Participants Produc t (Document) - define s the interfac e of object s the factor y metho d creates. C o n c r e t e P r o d u c t ( M y D o c u m e n t ) - implement s the Produc t interface. Creato r (Application) - d e c l a r e s the factor y method , w h i c h return s an o b j e c t of type Product . C r e - ator may a l so defin e a d e f a u l t implementatio n of the factor y metho d that returns a default ConcreteProduct object. - may c a l l the factory method to create a Product o b j e c t . ptgFACTORY M E T H O D 109 • ConcreteCreator (MyApplication) - overrides the factory method to return an instance of a C o n c r e t e P r o d u c t . C o l l a b o r a t i o n s • Creato r r e l i es on its s u b c l a s s e s to defin e the factor y metho d so t h at it return s an instance of the appropriate ConcreteProduct. C o n s e q u e n c e s Factor y method s eliminat e the n e ed to bind application-specifi c c l a s s e s into your c o d e. The c o de o n ly deals with the Produc t interface ; therefor e it can work with any user-define d ConcreteProduc t c l a s s e s . A potentia l disadvantag e of f a c t o r y method s is that c l i e n t s m i g h t have to s u b c l a s s the Creato r c l a ss j u st to creat e a particula r ConcreteProduc t object . S u b c l a s s i n g is fine when the c l i e n t has to subclas s the Creato r c l a ss anyway , but otherwis e the c l i e nt now must deal with anothe r point of evolution. Here are two additiona l c o n s e q u e n c e s of the Factor y Metho d pattern: 1. Provides hooks for subclasses. Creatin g object s i n s i d e a c l a ss with a f a c t or y metho dis alway s m o re f l e x i b l e than c r e a t i n g an o b j e c t d i r e c t l y . F a c t o r y Metho dg i v es s u bcla ss e s a hook for providin g an extende d versio n of an object. In the Documen t e x a m p l e , the Documen t c l a ss c o u ld defin e a f a c t o r y metho d c a l l ed C r e a t e F i l e D i a l o g that c r e a t e s a defaul t file d i a l o g o b j e c t f or openin g an existin g document . A Documen t subclas s can defin e an application-specifi c file dialo g by overridin g this f a c t o r y method . In this c a se the f a c t o r y metho d is not abstrac t but provide s a reasonabl e defaul t implementation. 2.Connects parallel class hierarchies. In the example s we'v e c o n s i d e r e d so far, the f a c t o r y metho d is only c a l l ed by Creators . But this doesn' t have to be the c a s e; client s can find factor y method s useful , e s p e c i a l l y in the c a se of paralle l c l a ss h i e r a r c h i e s . Paralle l c l a ss hierarchie s resul t when a c l a ss delegate s s o me of i ts r e s p o n s i b i l - i t i es to a separat e c l a s s. Conside r graphica l figure s t h at can be manipulate d interactively ; that is, they can be stretched , m o v e d , or rotate d using the mouse . Implementin g such interaction s isn't alway s e a s y. It o f t en r e q u i r e s storin g and updatin g informatio n that record s the state of the manipulatio n at a g i v en time. T h is state is neede d only durin g manipulation ; therefor e it needn' t be kept in the figur e object . M o r e o v e r , differen t figure s behav e differentl y when the u s er manipulate s them . For e x a m p l e , stretchin g a l i ne figur e migh t have the effec t of movin g an endpoint , wherea s stretchin g a text figur e may chang e its l i ne s p a c i n g . With t h e se c o n s t r a i n t s , i t 's bette r to use a s e p a r a t e Manipulato r o b j e c t that implements the interaction a n d keeps track o f a n y manipulation-specific state ptg1 1 0 CREATIONAL PATTERNS CHAPTER 3 that's needed . Differen t figure s w i ll use differen t Manipulato r s u b c l a s s e s to handl e particula r interactions . The resultin g Manipulato r c l a ss hierarch y parallels (at least partially) the Figure class hierarchy: The F i g u r e c l a ss provide s a CreateManipulato r factor y metho d that l e ts c l i e n t s c r e a t e a F i g u r e ' s correspondin g Manipulator . F i g u r e s u b c l a s s e s o v e r - ride this metho d to retur n an instanc e of the Manipulato r s u b c l a s s that's right for them . Alternatively , the F i g u r e c l a ss may implemen t CreateManipulato r to retur n a defaul t Manipulato r instance , and F i g u r e s u b c l a s s e s may s i m p l y inheri t that default . The F i g u r e c l a s s e s that do so n e ed no correspondin g Manipulato r subclass—henc e the hierarchie s are o n ly partiall y parallel. Notic e how the f a c t or y metho d define s the connectio n betwee n the two c l a ss h i e r a r c h i e s . It localizes knowledge of which classes belong together. I m p l e m e n t a t i o n Conside r the followin g i s s u e s when applyin g the Factor y Metho d pattern: 1.Two major varieties. The two main variations of the Factor y Metho d patter n are (1) the c a se when the Creato r c l a ss is an abstrac t c l a ss and d o es not provid e an implementatio n for the factor y metho d it d e c l a r e s , and (2) the c a se w h en the Creato r is a c o n c r e t e c l a ss and provide s a defaul t implementatio n for the factor y method . It's a l so p o s s i b l e to have an abstrac t c l a ss that define s a defaul t implementation , but this is l e ss common. The first c a se requires s u b c l a s s e s to defin e an implementation,becaus e there' s no reasonabl e default . It g e ts aroun d the dilemm a of havin g to instantiate unforeseeabl e c l a s s e s . In the s e c o n d c a s e, the concret e Creato r u s es the fac- tory metho d primaril y for f l e x i b i l i t y . It's followin g a rule that s a y s, \" C r e a t e object s in a separat e operatio n so that s u b c l a s s e s can overrid e the way they'r e c r e a t e d . \" T h is rule e n s u r e s t h at d e s i g n e r s of s u b c l a s s e s c an chang e t he c l a ss o f objects their parent class instantiates if necessary. 2.Parameterized f a c t o r y m e t h o d s . Another variation o n t h e p a t t e r n l e t s the fac- tory method create multiple k i n d s of products. T h e factory m e t h o d t a k e s a ptgFACTORY METHOD 1 1 1 paramete r that identifie s the kind of objec t to c r e a t e . All object s the f a c t o r y metho d create s w i ll s h a re the Produc t interface . In the Documen t e x a m p l e , Applicatio n migh t suppor t differen t kinds of Documents . You pass Create- Documen t an extra paramete r to specif y the kind of documen t to create. The Unidra w graphica l editin g f r a m e w o r k [ V L 9 0 ] u s es this approac h for reconstructin g object s s a v ed on d i s k. Unidra w define s a C r e a t o r c l a ss with a f a c t o r y metho d C r e a t e that takes a c l a ss identifie r as an argument . The c l a ss identifie r s p e c i f i e s the c l a ss to instantiate . Whe n Unidra w s a v es an o b j e c t to d i s k, it write s out the c l a ss identifie r f i r st and then its instanc e variables . Whe n it reconstruct s the o b j e c t f r om disk, it reads the c l a ss identifie r first. O n ce the c l a ss identifie r is r e a d, the framewor k c a l ls C r e a t e , p a s s i n g the identifie r as the parameter . C r e a t e l o o ks up the constructo r for the c o r r e - spondin g c l a ss and uses it to instantiat e the object . Last, C r e a t e c a l ls the object' s R e ad operation , whic h reads the remainin g informatio n on the d i sk and initialize s the object' s instanc e variables. A parameterize d f a c t o r y metho d has the followin g genera l form , wher e M y P r o d u c t and YourProduct are subclasses of Product: class Creator { public: virtual Product* Create(Productld) ; } ; Product* Creator::Creat e (Productl d id) { if (id == MINE) return new MyProduct ; if (id == YOURS) return new YourProduct ; // repeat for remainin g products... return 0; } Overridin g a parameterize d factor y metho d l e ts you e a s i ly and s e l e c t i v e l y exten d or chang e the product s t h at a Creato r produces . You can introduc e n ew i d e n t i f i e r s f or n ew k i n ds of p r o d u c t s , or y ou c an a s s o c i a t e e x i s t i n g identifiers with different p r o d u c t s . For example, a subclass MyCreator could swap MyProduct and Y o u r P r o d - uct and support a new TheirProduct s u b c l a s s : Product* MyCreator::Creat e (Productl d id) { if (id == YOURS) return new MyProduct ; if ( id == MINE) return new YourProduct; // N.B.: switched YOURS and MINE if (id == THEIRS) return new TheirProduct; return Creator::Create(id) ; // called if all others fail } Notic e that the last thing this operatio n d o es is c a ll C r e a t e on the paren t c l a s s . T h a t ' s b e c a u s e MyCreator : : C r e a t e handles only YOURS, MINE, and ptg1 12 CREATIONAL PATTERNS CHAPTER 3 T H E I R S differentl y than the paren t c l a s s. It i s n 't i n t e r e s t e d in other c l a s s e s . H e n c e M y C r e a t o r extends the k i n ds of product s c r e a t e d , and it defer s re- s p o n s i b i l i t y for c r e a t i n g all but a few product s to its parent. 3.Language-specific variants a nd issues. Differen t l a n g u a g e s l e nd t h e m s e l v e s to other i n t e r e s t i n g variation s and caveats. S m a l l t a l k program s often use a metho d that return s the c l a ss of the o b j e c t to be instantiated . A Creato r f a c t o r y metho d can use t h is value to c r e a t e a product , and a ConcreteCreato r may store or e v en comput e t h is value . T he r e s u l t is an e v en later b i n d i n g f or t he type of C o n c r e t e P r o d u c t to be instantiated. A S m a l l t a l k v e r s i o n of the D o c u m e n t exampl e can defin e a d o c u m e n t C l a s s metho d on A p p l i c a t i o n . The d o c u m e n t C l a s s metho d return s the prope r D o c u m e n t c l a ss for instantiatin g d o c u m e n t s . The i m p l e m e n t a t i o n of d o c u m e n t C l a s s in M y A p p l i c a t i o n return s the M y D o c u m e n t c l a s s. T h us in class A p p l i c a t i o n we have clientMethod d o c u m e nt := s e lf documentClas s n e w . documentClas s s e l f subclassResponsibility In class MyApplication we have d o c u m e n t C l a s s ~ MyDocument w h i c h return s the c l a ss M y D o c u m e n t to be instantiate d to A p p l i c a t i o n . An e v en more flexibl e approac h a k in to parameterize d factor y method s is to store the c l a ss to be c r e a t e d as a c l a ss variabl e of A p p l i c a t i o n . T h at way you don't have to s u b c l a s s A p p l i c a t i o n to vary the product. Factor y method s in C++ are a l w a y s virtua l function s and are often pure v i r - tual. Just be carefu l not to c a ll factor y method s in the Creator' s constructor — the factor y metho d in the ConcreteCreato r won' t be a v a i l a b l e yet. Y ou c an a v o id t h is by b e i ng carefu l to a c c e s s product s s o l e ly throug h a c c e s - sor operation s that creat e the produc t on demand . Instea d of c r e a t i n g the c o n c r e t e produc t in t he constructor , t he constructo r m e r e l y i n i t i a l i z e s it to 0. The a c c e s s o r return s the product . But first it c h e c k s to make s u re the produc t e x i s t s , a nd if it d o e s n ' t , t he a c c e s s o r c r e a t e s i t. T h is t e c h n i q u e is s o m e t i m e s c a l l e d l a z y i n i t i a l i z a t i o n . T h e following code shows a typical implementa - t i o n : ptgFACTORY M E T H O D 113 class Creato r { public: P r o d u c t* GetProduct() ; protected: virtual Product* CreateProduct() ; private: Product* _product ; } ; Product* Creator::GetProduc t () { if ( _ p r o d u ct = =0) { _product = CreateProduct() ; } return _product ; } 4. Using templates to avoid subclassing. As w e ' v e m e n t i o n e d , a n o t h e r p o t e n t i a l p r o b l e m with f a c t o r y m e t h o d s is that t h ey m i g h t f o r ce y ou to s u b c l a s s j u st to c r e a t e t he a p p r o p r i a t e P r o d u c t o b j e c t s . A n o t h e r w ay to g et a r o u n d t h is in C ++ is to p r o v i d e a templat e s u b c l a s s of C r e a t o r t h a t ' s parameterize d by t he P r o d u c t c l a s s : c l a ss C r e a t or { public: virtual Product* CreateProduct( ) = 0 ; } ; template <class T h e P r o d u c t > class StandardCreator : public Creator { public: virtual Product* CreateProduct() ; } ; template <class TheProduct> Product* StandardCreator<TheProduct>::CreateProduc t () { return new TheProduct ; } With t h is template , t he c l i e n t s u p p l i e s just t he p r o d u c t class—n o s u b c l a s s i n g of C r e a t o r is r e q u i r e d . class MyProduc t : public Product { public: MyProduct(); // . . . } ; StandardCreator<MyProduct > myCreator; 5.Naming conventions. I t 's g o od p r a c t i c e to u se n a m i n g c o n v e n t i o n s that m a ke it c l e ar y o u ' r e u s i ng f a c t o r y m e t h o d s . F or e x a m p l e , t he M a c A p p M a c i n t o s h applicatio n framewor k [ A p p 8 9 ] alway s d e c l a r e s t he abstrac t o p e r a t i o n t h at d e f i n e s t he f a c t o r y m e t h o d as C l a s s * D o M a k e C l a s s () , w h e r e C l a s s is t h e Product class. ptg1 1 4 CREATIONAL P A T T E R N S CHAPTER 3 S a m p l e Code The functio n C r e a t e M a z e (page 84) b u i l d s and return s a maze . One p r o b l e m with t h is functio n is that it h a r d - c o d e s t he c l a s s e s of m a z e , r o o m s , d o o r s , a nd w a l l s . W e ' ll introduc e factor y method s to let s u b c l a s s e s c h o o s e these c o m p o n e n t s . F i r st w e ' ll defin e factor y m e t h o d s in M az eGam e f or c r e a t i n g t he m a z e , r o o m , w a l l, and door objects: class MazeGame { public: Maze* CreateMaze(); // factory methods: virtual Maze* MakeMaze( ) c o n s t { return new Maze; } virtual R o o m* M a k e R o o m ( i n t n) c o n s t { return new Room(n); } virtual Wall* MakeWall( ) const { r e t u rn new Wall; } virtual Door* MakeDoor(Room* rl, Room* r2) const { return new Door(rl, r2); } E a ch factor y metho d return s a maz e componen t of a g i v en t y p e. M a z e G a m e p r o - v i d es defaul t i m p l e m e n t a t i o n s that retur n t he s i m p l e s t k i n ds of m a z e , r o o m s , w a l l s , and doors. N o w we can rewrite CreateMaze to use these factory methods: Maze* MazeGame::CreateMaz e () { Maze* aMaze = MakeMaze (),- Room* rl = MakeRoom ( 1) , - Room* r2 = MakeRoom(2); Door* t h e D o or = MakeDoor(rl , r2); aMaze->AddRoom(rl) ; aMaze->AddRoom(r2); rl->SetSide(North , MakeWall()) ; rl->SetSide(East , theDoor) ; r l - > S e t S i d e ( S o u t h , M a k e W a l l ( ) ) ; rl->SetSide(West , MakeWall()); r2->SetSide(North , MakeWall()) ; r2->SetSide(East , MakeWall()) ; r2->SetSide(South , MakeWall()) ; r2->SetSide(West, theDoor); ptgF A C T O R Y M E T H O D 115 return aMaze; } Differen t game s can s u b c l a s s Ma z e G a m e to s p e c i a l i z e parts of the maze . Ma z e G a m e s u b c l a s s e s can redefin e s o me or all of the factor y method s to specif y variation s in p r o d u c t s . For e x a m p l e , a BombedMazeGam e can r e d e f i n e the Room and W a ll products t o return the bombed varieties: class BombedMazeGam e : public MazeGame { public: BombedMazeGame(); virtual Wall* MakeWall( ) const { r e t u rn new BombedWall ; } virtual Room* MakeRoom(in t n) const { return new RoomWithABomb(n) ; } } ; An Enchant edMaz e G a m e variant might be defined like this: class EnchantedMazeGam e : public MazeGame { public: EnchantedMazeGame(); virtual Room* MakeRoom(in t n) c o n s t { return new EnchantedRoom(n , CastSpell()) ; } virtual Door* MakeDoor(Room * rl, Room* r2) const { r e t u rn new D o o r N e e d i n g S p e l l ( r l , r 2 ); } protected: Spell* CastSpell( ) const; } ; K n o w n Uses Factor y method s pervad e toolkit s and frameworks . The precedin g documen t ex- ampl e is a t y p i c a l u se in MacAp p a nd ET++ [ W G M 8 8 ] . T he manipulato r ex amp l e is from Unidraw. C l a ss V i ew in the S m a l l t a l k - 8 0 Model/View/Controlle r framewor k has a metho d defaultControlle r that create s a c o n t r o l l e r , and this migh t appea r to be a factor y metho d [ P a r 9 0 ] . But s u b c l a s s e s of V i ew specif y the c l a ss of their defaul t c o n t r o l l e r by definin g d e f a u l t C o n t r o l l e r C l a s s , w h i c h return s t he c l a ss from w h i c h default- C o n t r o l l e r create s instances . So defaultControllerClas s is t he r e al factor y method , t K at is, the metho d that s u b c l a s s e s s h o u l d o v e r r i d e . A more e s o t e r i c exampl e in S m a l l t a l k - 8 0 is the factor y metho d p a r s e r C l a s s define d b y Behavior (a superclass of all objects representing classes). This enables a class ptg1 16 CREATIONAL PATTERNS CHAPTER 3 to use a c u s t o m i z e d parse r for its s o u r c e c o d e. For e x a m p l e , a c l i e nt can defin e a c l a ss S Q L P a r s e r to analyz e the sourc e c o de of a c l a ss with embedde d SQL statements . The B e h a v i o r c l a ss implement s parserClas s to retur n the standar d S m a l l t a l k Parse r c l a s s. A c l a ss t h at i n c l u d e s embedde d S QL statement s o v e r r i d e s this metho d (as a c l a ss method ) and return s the S Q L P a r s e r c l a s s . The Orbix ORB syste m from IONA T e c h n o l o g i e s [ I O N 9 4 ] uses Factor y Metho d to generat e an appropriat e type of proxy ( s ee Prox y (207) ) when an o b j e c t r e q u e s t s a r e f e r e n c e to a r e m o t e o b j e c t . F a c t o r y M e t h o d m a k e s it e a sy to r e p l a c e t he defaul t proxy with one that uses client-side caching, for example. Related Patterns Abstrac t Factor y ( 8 7) is o f t en implemente d with f a c t o r y methods . The Motivatio n exampl e in the Abstrac t Factor y patter n illustrate s Factor y Metho d as w e l l . F a c t o r y m e t h o d s a re u s u a l l y c a l l e d withi n T e m p l a t e M e t h o d s ( 3 2 5 ) . In t he d o c u - ment exampl e a b o v e , NewDocumen t is a templat e method. Prototype s ( 1 1 7) don't requir e s u b c l a s s i n g Creator . However , they often r e q u i r e an Initializ e operatio n on the Produc t c l a s s . Creato r u s es Initializ e to i n i t i a l i z e the object. Factory Method doesn't require such an operation. ptgPROTOTYPE 117 P R O T O T Y P E Object Creational Intent Specif y the kinds of object s to creat e using a prototypica l instance , and creat e new objects by copying this prototype. Motivation You c o u ld build an edito r for musi c s c o r e s by customizin g a genera l framewor k f or g r a p h i c a l e d i t o r s a nd a d d i n g n ew o b j e c t s that r e p r e s e n t n o t e s , r e s t s, a nd staves . The edito r f r a m e w o r k may have a palett e of t o o ls for addin g these musi c object s to the s c o r e . The palett e woul d a l so includ e t o o ls for s e l e c t i n g , moving , a nd o t h e r w i s e manipulatin g m u s i c o b j e c t s . U s e rs w i ll c l i ck on t he quarter-not e tool and use it to add quarte r notes to the s c o r e . Or they can use the move tool to move a note up or down on the s t a f f, thereb y changin g its pitch. L e t 's a s s u m e t he framewor k p r o v i d e s an a b s t r a c t Graphi c c l a ss f or g r a p h i c a l c o m - ponents , like notes and staves . M o r e o v e r , it'll provid e an abstrac t T o ol c l a ss for definin g t o o ls l i ke those in the palette . The f r a m e w o r k a l so predefine s a Graphic- T o ol s u b c l a s s f or t o o ls that c r e a te i n s t a n c e s of g r a p h i c a l o b j e c t s a nd a dd th em to the document. But GraphicToo l present s a proble m to the framewor k d e s i g n e r . The c l a s s e s for notes and stave s are s p e c i f i c to our application , but the G r a p h i c T o o l c l a ss b e l o n g s to the framework . GraphicToo l doesn' t know how to creat e instance s of our musi c c l a s s e s to add to the s c o r e . We c o u ld s u b c l a s s GraphicToo l for e a ch kind of musi c o b j e c t , b ut that w o u l d p r o d u c e l o ts of s u b c l a s s e s that differ o n ly in t he k i nd of musi c objec t they instantiate . We know objec t compositio n is a fl e xib l e alternativ e to s u b c l a s s i n g . The questio n is, how can the framewor k use it to parameteriz e i n s t a n c e s of G r a p h i c T o o l by t he class of Graphi c they'r e s u p p o s e d to c r e a t e ? The solutio n l i es in makin g GraphicToo l creat e a new Graphi c by copyin g or \" c l o n i n g \" an instanc e of a Graphi c s u b c l a s s . We c a ll this instanc e a prototype . G r a p h i c T o o l is p a r a m e t e r i z e d by t he prototyp e it s h o u l d c l o ne a nd a dd to t he document . If all Graphi c s u b c l a s s e s suppor t a C l o n e operation , then the Graphic- T o ol can c l o ne a ny kind of Graphic. So in o ur musi c e d i t o r , e a ch tool f or creatin g a musi c o b j e c t is an instanc e of GraphicToo l that's initialize d with a differen t prototype . Each G r a p h i c T o o l in- stanc e w i ll produc e a musi c o b j e c t by c l o n i n g its prototyp e and addin g the c l o ne to the score. ptg1 1 8 CREATIONAL PATTERNS CHAPTER 3 We can use the Prototyp e pattern to r e d u c e the numbe r of c l a s s e s e v en further . We have separat e c l a s s e s for whol e notes and h a lf n o t e s , but that's p r o b a b l y u n n e c e s s a r y . Instea d they c o u ld be instance s of t he same c l a ss i n i t i a l i z e d with differen t bitmap s and durations . A tool for c r e a t i n g whol e n o t es b e c o m e s just a G r a p h i c T o o l w h o s e prototyp e is a M u s i c a l N o t e i n i t i a l i z e d to be a w h o l e n o t e. T h is c an r e d u c e t he numbe r of c l a s s e s in t he s y s t e m dramatically . It a l so make s it e a s i e r to add a new kind of note to the music editor. Applicability Use the Prototyp e patter n when a syste m s h o u l d be independen t of how its product s are c r e a t e d , c o m p o s e d , and r e p r e s e n t e d ; and • when the c l a s s e s to instantiat e are s p e c i f i e d at run-time , for e x a m p l e , by dynami c l o a d i n g ; or • to a v o id b u i l d i n g a c l a ss hierarch y of factorie s that p a r a l l e l s the c l a ss hierar- c hy of p r o d u c t s ; o r • when i n s t a n c e s of a c l a ss can have one of o n ly a few differen t combination s of state. It may be more c o n v e n i e n t to i n s t a l l a c o r r e s p o n d i n g numbe r of prototype s and c l o ne them rathe r than instantiatin g the c l a ss manually , e a ch time with the appropriate state. ptgPROTOTYPE 119 S t r u c t u r e Participants • Prototype (Graphic) - declares an interface for cloning itself. • ConcretePrototype ( S t a f f , WholeNote, HalfNote) - implements an o p e r a t i o n for cloning itself. • Client ( G r a p h i c T o o l ) - creates a new object by asking a prototype to clone itself. C o l l a b o r a t i o n s • A client asks a prototype to clone itself. C o n s e q u e n c e s Prototyp e has many of the s a me c o n s e q u e n c e s that Abstrac t Factor y ( 8 7) and B u i l d e r ( 9 7) h a v e: It h i d es t he c o n c r e t e produc t c l a s s e s from t he c l i e n t , t h e r e b y reducin g the numbe r of name s c l i e n t s know about . M o r e o v e r , t h e se pattern s let a c l i e nt work with application-specifi c c l a s s e s withou t modification. Additiona l benefit s of the Prototyp e patter n are l i s t ed b e l o w . 1. Adding and removing products at run-time. Prototype s let you incorporat e a new c o n c r e t e produc t c l a ss into a syste m s i m p l y by r e g i s t e r i n g a prototyp- i c al instanc e with the c l i e n t . That' s a bit m o re flexibl e than other creationa l patterns, because a client can install and remove prototypes at run-time. 2. S p e c i f y i n g new objects b y varying v a l u e s . Highly dynamic systems let you de - fine new behavior through object composition—by specifying values for an ptg1 20 CREATIONAL PATTERNS CHAPTER 3 object' s v a r i a b l e s , for example—an d not by definin g new c l a s s e s . You ef- f e c t i v e l y d e f i n e n ew k i n ds of o b j e c t s by i n s t a n t i a t i n g e x i s t i n g c l a s s e s a nd registerin g t he i n s t a n c e s as prototype s of c l i e nt objects . A c l i e nt c an e x h i b i t new behavio r by d e l e g a t i n g r e s p o n s i b i l i t y to the prototype. T h is k i nd of d e s i g n l e ts users defin e n ew \" c l a s s e s \" withou t programming . In fact, c l o n i n g a prototyp e is s i m i l a r to instantiatin g a c l a s s . The Prototyp e patter n can greatl y reduc e the numbe r of c l a s s e s a syste m n e e d s . In our musi c editor , o ne G r a p h i c T o o l c l a ss c an c r e a t e a l i m i t l e s s variet y of m u s i c o b j e c t s . 3.Specifying new objects by varying structure. Many application s build o b j e c t s f r om parts and subparts . Editor s for c i r c u i t d e s i g n , for e x a m p l e , b u i ld c i r - c u i ts o ut of s u b c i r c u i t s . 1 F or c o n v e n i e n c e , s u ch a p p l i c a t i o n s often l et y ou instantiat e c o m p l e x , user-define d structures , s a y, to use a s p e c i f i c s u b c i r c u i t a g a in a nd a g a i n . T he Prototyp e patter n support s t h is as w e l l. We s i m p l y a dd this s u b c i r c u i t as a prototyp e to the palett e of availabl e c i r c u i t e l e m e n t s . As l o ng as the c o m - posit e c i r c u i t o b j e c t implement s C l o n e as a deep c o p y , c i r c u i t s with differen t structure s can be prototypes. 4.Reduced subclassing. Factor y Metho d ( 1 0 7) often produce s a hierarch y of C r e - ator c l a s s e s that p a r a l l e l s the produc t c l a ss h i e r a r c h y . The Prototyp e patter n l e ts you c l o ne a prototyp e instea d of a s k i n g a factor y metho d to make a new object . H e n c e you don't n e ed a Creato r c l a ss hierarch y at all. T h is benefi t applie s primaril y to language s like C++ that don't treat c l a s s e s as first-clas s objects . Language s that d o, l i ke Smalltal k a nd O b j e c t i v e C, deriv e l e ss b e n e - fit, s i n ce you can alway s use a c l a ss objec t as a c r e a t o r . C l a ss o b j e c t s alread y a ct l i ke prototype s in t h e se languages. 5.Configuring an application with classes dynamically. S o me run-tim e e n v i r o n - ment s l et y ou l o ad c l a s s e s into an applicatio n d y n a m i c a l l y . T he Prototyp e patter n is the key to e x p l o i t i n g s u ch facilitie s in a languag e l i ke C++. An applicatio n that want s to creat e i n s t a n c e s of a dynamicall y l o a d e d c l a ss won' t be a b le to r e f e r e n c e i ts c o n s t r u c t o r s t a t i c a l l y . I n s t e a d , t he r u n - t i m e e n v i - ronmen t c r e a t e s an instanc e of e a ch c l a ss automaticall y when i t 's l o a d e d , a nd it r e g i s t e r s the i n s t a n c e with a prototyp e manage r ( s ee the Implementatio n s e c t i o n ) . T h en the applicatio n can ask the prototyp e manage r for i n s t a n c e s of newl y loade d c l a s s e s , c l a s s e s that weren' t l i n k e d with the progra m o r i g i n a l l y . The ET++ applicatio n framewor k [ W G M 8 8 ] has a run-tim e syste m that u s es t h is s c h e m e . The main liabilit y of the Prototyp e patter n is that e a ch s u b c l a s s of Prototyp e must implemen t the C l o n e operation , w h i c h may be difficult . For e x a m p l e , a d d i n g C l o n e is difficul t w h en t he c l a s s e s u n d e r c o n s i d e r a t i o n a l r e a d y e x i s t. I m p l e m e n t - ing C l o n e can be difficul t when t h e ir i n t e r n a l s i n c l u d e o b j e c t s that don't suppor t c o p y i n g or have circular references. 1Such applications reflect the Composite (163) a n d Decorator (175) p a t t e r n s . ptgPROTOTYPE 121 I m p l e m e n t a t i o n Prototyp e is particularl y usefu l with static language s l i ke C++, wher e c l a s s e s are not o b j e c t s , and little or no type informatio n is availabl e at run-time . It's l e ss importan t in language s l i ke S m a l l t a l k or O b j e c t i v e C that provid e what amount s to a prototyp e ( i . e ., a c l a ss object ) for creatin g instance s of each c l a s s. T h is patter n is b u i lt into p r o t o t y p e - b a s e d l a n g u a g e s l i ke S e lf [ U S 8 7 ] , in w h i c h a ll o b j e c t creatio n happen s by c l o n i n g a prototype. C o n s i d e r the followin g i s s u e s when implementin g prototypes: 1. Using a prototype manager. Whe n the numbe r of prototype s in a syste m isn't fixed (that is, they can be create d and d e s t r o y e d dynamically) , k e ep a registr y of a v a i l a b l e prototypes . C l i e n t s won' t manag e prototype s t h e m s e l v e s but w i ll store and retriev e them f r om the r e g i s t r y . A c l i e nt w i ll ask the registr y for a prototyp e befor e c l o n i n g it. We c a ll this registr y a prototyp e manager. A prototyp e manage r is an a s s o c i a t i v e store t h at return s the prototyp e match- ing a g i v en k e y. It has operation s for registerin g a prototyp e unde r a key and for unregisterin g it. C l i e n t s can chang e or even brows e throug h the registr y at run-time . T h is l e ts c l i e n t s exten d and take inventor y on the syste m withou t writin g c o d e . 2. Implementing the Clone operation. The hardes t part of the Prototyp e patter n is implementin g the C l o n e operatio n c o r r e c t l y . It's particularl y tricky when o b j e c t structure s contai n c i r c u l a r references. M o st language s provid e some suppor t for c l o n i n g o b j e c t s . For e x a m p l e , Smalltal k p r o v i d e s an implementatio n of copy that's inherite d by all s u b - c l a s s e s of Object . C++ p r o v i d e s a c o py constructor . But t h e se facilitie s don't s o l ve t he \" s h a l l o w c o py versu s d e ep c o p y\" p r o b l e m [ G R 8 3 ] . That i s, d o es c l o n i n g an objec t in turn c l o ne its instanc e v a r i a b l e s , or do the c l o ne and o r i g i n a l just share the variables? A s h a l l o w c o py is s i m p l e and often sufficient , and that's w h at Smalltal k p r o v i d e s by default . The defaul t c o py constructo r in C++ d o es a member- w i se c o p y, whic h mean s pointer s w i ll be share d betwee n the copy and the o r i g i n a l . But c l o n i n g prototype s with comple x structure s usuall y r e q u i r e s a d e ep c o p y, b e c a u s e the c l o ne and the o r i g i n a l must be independent . Therefor e you must ensur e that the c l o n e ' s component s are c l o n e s of the prototype' s components . C l o n i n g force s you to d e c i d e what if anythin g w i ll be shared. If object s in the syste m provid e S a ve and Load operations , then you can use them to provid e a defaul t implementatio n of C l o n e s i m p l y by s a v i n g the o b j e c t and loadin g it back immediately . The S a ve operatio n s a v es the o b j e c t into a memor y b u f f e r , and Load c r e a t e s a duplicat e by reconstructin g the o b j e c t f r om the buffer. 3. Initializing clones. W h i l e s o me c l i e n t s are perfectl y happ y with the c l o ne as is, others will want t o i n i t i a l i z e s o m e o r a l l o f i t s i n t e r n a l s t a t e t o v a l u e s ptg1 22 CREATIONAL PATTERNS CHAPTER 3 of t h e ir c h o o s i n g . Y ou g e n e r a l l y c a n 't pass t h e se value s in t he C l o ne o p e r - a t i o n , b e c a u s e t h e ir numbe r will vary betwee n c l a s s e s of prototypes . S o me prototype s migh t n e ed multipl e i n i t i a l i z a t i o n parameters ; other s won' t n e ed a n y. P a s s i n g parameter s in t he C l o ne operatio n p r e c l u d e s a unifor m c l o n i n g interface. It m i g h t be the c a se that your prototyp e c l a s s e s alread y d e f i n e operation s for (re)settin g k ey p i e c e s of state. If s o, c l i e n t s m ay u se t h e se operation s i m m e d i - ately a f t er c l o n i n g . If n o t, then you may have to i n t r o d u c e an I n i t i a l i z e operatio n ( s ee the S a m p l e C o de s e c t i o n ) that takes i n i t i a l i z a t i o n parame- ters as argument s a nd s e ts t he c l o n e ' s interna l state a c c o r d i n g l y . B e w a r e of d e e p - c o p y i n g C l o n e operations—th e c o p i e s may have to be d e l e t e d (eithe r e x p l i c i t l y or within Initialize) before you reinitialize them. S a m p l e C o d e W e ' ll defin e a M a z e P r o t o t y p e F a c t o r y s u b c l a s s of the M a z e F a c t o r y c l a ss ( p a ge 9 2 ). M a z e P r o t o t y p e F a c t o r y w i ll be i n i t i a l i z e d with prototype s of the o b j e c t s it w i ll creat e so that we don't have to s u b c l a s s it just to c h a n g e the c l a s s e s o f walls or rooms it creates. M a z e P r o t o t y p e F a c t o r y a u g m e n t s t h e M a z e F a c t o r y i n t e r f a c e w i t h a c o n- structor that takes t h e prototypes as arguments: c l a ss MazePrototypeFactor y : public MazeFactor y { public: MazePrototypeFactor y (Maze*, Wall*, Room*, D o o r * ) , - virtual Maze* MakeMaze( ) const; virtual Room* MakeRoom(int ) c o n s t; virtual Wall* MakeWall( ) const; virtual D o o r* MakeDoor(Room* , Room*) const; private: Maze* _prototypeMaze; Room* _prototypeRoom ; Wall* _prototypeWall ; D o o r * _prototypeDoor; T h e new constructor simply initializes its prototypes: MazePrototypeFactory::MazePrototypeFactor y ( Maze* m, Wall* w, Room* r, D o o r* d ) { _prototypeMaz e = m; _prototypeWal l = w; __prototypeRoo m = r; _prototypeDoor = d; } ptgPROTOTYPE 1 2 3 T he m e m b e r f u n c t i o n s f or c r e a t i n g walls , r o o m s , a nd d o o r s a re s i m i l a r : E a ch c l o n e s a p r o t o t y p e a nd t h en initialize s i t. H e re a re t he d e f i n i t i o n s of M a k e W a l l a nd M a k e D o o r : Wall* MazePrototypeFactory::MakeWal l () c o n st { return _prototypeWall->Clone(); } Door* MazePrototypeFactory::MakeDoo r ( R o o m* rl, Room *r2) c o n st { Door* door = _prototypeDoor->Clone() ; door->Initialize(rl , r2); return door; } We can use M a z e P r o t o t y p e F a c t o r y to c r e a t e a p r o t o t y p i c a l or d e f a u l t m a ze j u st by initializin g it with p r o t o t y p e s of b a s ic m a ze c o m p o n e n t s : Ma z eGame game; MazePrototypeFactor y simpleMazeFactory ( new Maze, new Wall, new Room, new D o o r Maze* maze = game.CreateMaze(simpleMazeFactory); To c h a n g e the type of m a z e , we initializ e M a z e P r o t o t y p e F a c t o r y with a dif- f e r e n t s et of p r o t o t y p e s . T he followin g c a ll c r e a t e s a m a ze with a BombedDoo r and a R o o m W i t h A B o m b : MazePrototypeFactor y bombedMazeFactory ( new Maze, new BombedWall , new RoomWithABomb , new Door ) ; An o b j e c t that c an be u s ed as a p r o t o t y p e , s u ch as an i n s t a n c e of W a l l , m u st s u p p o r t t he C l o n e o p e r a t i o n . It m u st a l so h a ve a c o py c o n s t r u c t o r f or c l o n i n g . It m ay a l so n e ed a s e p a r a t e o p e r a t i o n f or reinitializin g i n t e r n a l state . W e ' l l a dd t he I n i t i a l i z e o p e r a t i o n to D o or to let c l i e n t s initializ e the c l o n e ' s r o o m s . C o m p a r e t he followin g definitio n of Door to t he o ne on p a ge 8 3 : class D o or : public MapSite { public: Door(); Door(cons t D o o r & ) ; virtual void Initialize(Room* , Room*); virtual Door* Clone() const; ptg12 4 CREATIONAL PATTERNS CHAPTER 3 virtual void Enter(); Room* OtherSideFrom(Room*); private: Room* _rooml; Room* _room2; } ; Door::Doo r ( c o n st D o o r& other) { _rooml - other._rooml ; _room2 = other._room2; } void Door::Initializ e ( R o o m* rl, Room* r2) { _rooml = rl; _room2 = r2; } Door* Door::Clon e () const { return new Door(*this); } The B o m b e d W a 11 s u b c l a s s must overrid e C1 one and implemen t a correspondin g c o p y constructor. class BombedWal l : public Wall { public: BombedWall(); BombedWall(cons t BombedWa11&); virtual Wall* Clone() const; bool HasBomb(); private: b o ol _bomb; } ; BombedWall::BombedWal l ( c o n st BombedWall k other) : Wall(other ) { _bomb = other._bomb ; } Wall* BombedWall::Clon e () const { return new BombedWall(*this); } Althoug h B o m b e d W a l l : : C l o n e return s a W a l l * , its implementatio n return s a pointe r to a n ew instanc e of a s u b c l a s s , that i s, a BombedW a 11 *. We defin e C1 o ne l i ke this in the base c l a ss to ensur e that c l i e n t s that c l o ne the prototyp e don't have to know abou t their c o n c r e t e s u b c l a s s e s . C l i e n t s shoul d never n e ed to downcas t the retur n value of C l o n e to the d e s i r e d type. In S m a l l t a l k , you can r e u se the standar d copy metho d i n h e r i t e d from O b j e c t to c l o n e a n y MapSite. You can use M a z e F a c t o r y t o produce t h e p r o t o t y p e s ptgPROTOTYPE 1 2 5 you'l l n e e d; for e x a m p l e , you can creat e a room by supplyin g the name # r o o m . The M a z e F a c t o r y has a dictionar y that maps name s to prototypes . Its m a k e : method looks like this: make: partName (partCatalog a t : partName) copy Give n appropriat e method s for initializin g the M a z e F a c t o r y with prototypes , you could create a simple maze with the following code: CreateMaz e o n: (MazeFactor y n e w with: Door new named: ttdoor; with: Wall new named: ttwall; with: Room new named: ttroom; yourself) where the definition of the on: c l a s s m e t h o d for CreateMaze would be on: aFactory I rooml room2 I rooml := ( a F a c t o ry make: t t r o o m) location : 1 @ 1. room2 := ( a F a c t o ry make: ttroom) location : 2@1. door := ( a F a c t o ry make: #door) from: rooml to: room2. rooml at Side: atSide: atSide: atSide: room2 atSide: atSide: atSide: atSide : Maze new addRoom : addRoom : yourselittnorth #east #south #west #north tteast ttsouth ttwest : rooml : r o o m 2put : put : put put : put put : put put :: ( a F a c t o ry door; : ( a F a c t o ry ( a F a c t o r y : ( a F a c t o ry ( a F a c t o ry : ( a F a c t o r y door .make: make : make : make : make : make :: ttwall) : ttwall) ttwall) . : ttwall) #wall) ; : ttwall) Known Uses Perhap s the first exampl e of the Prototyp e patter n was in Ivan Sutherland' s S k e t c h - pad syste m [ S u t 6 3 ] . The first widel y know n applicatio n of the patter n in an o b j e c t - oriente d languag e was in ThingLab , wher e users c o u ld f o rm a composit e o b j e c t and then promot e it to a prototyp e by installin g it in a librar y of reusabl e ob- jects [ B o r 8 1 ] . Goldber g and Robso n mentio n prototype s as a p a t t e r n [ G R 8 3 1 , but C o p l i e n [ C o p 9 2 ] g i v es a much more complet e description . He d e s c r i b e s i d i o m s relate d to the Prototyp e patter n for C++ and g i v es many example s and variations. Etgd b is a debugge r front-en d based on ET++ t h at provide s a p o i n t - a n d - c l i c k interface t o different l i n e - o r i e n t e d d e b u g g e r s . E a c h debugger h a s a c o r r e s p o n d - ing Debugger A d a p t o r s u b c l a s s . For example, Gdb A d a p t o r a d a p t s e t g d b t o t h e ptg1 26 CREATIONAL PATTERNS CHAPTERS c o m m a n d synta x of G NU g d b, w h i le SunDbxAdapto r adapt s etgdb to S u n 's d bx d e b u g g e r . Etgd b d o es n ot have a s et of D e b u g g e r Adapto r c l a s s e s h a r d - c o d e d i n to it. I n s t e a d , it reads the name of the adapto r to use from an e n v i r o n m e n t vari- a b l e, l o o ks for a prototyp e with the s p e c i f i e d name in a g l o b a l t a b l e , and then c l o n e s the prototype . New d e b u g g e r s can be adde d to etgdb by l i n k i n g it with the DebuggerAdapto r that work s for that d e b u g g e r . T he \" i n t e r a c t i o n t e c h n i q u e library \" in M o d e C o m p o s e r s t o r e s prototype s of o b j e c t s that suppor t variou s interactio n t e c h n i q u e s [ S h a 9 0 ] . A ny i n t e r a c t i o n t e c h n i q u e c r e a t e d by the Mod e C o m p o s e r can be used as a prototyp e by p l a c i n g it in t h is l i b r a r y . T he Prototyp e patter n l e ts M o d e C o m p o s e r suppor t an u n l i m i t e d s et of i n t e r a c t i o n t e c h n i q u e s . T he m u s i c e d i t o r e xa mp l e d i s c u s s e d e a r l i e r is b a s ed on t he Unidra w drawin g framework [ V L 9 0 ] . Related Patterns Prototyp e a nd Abstrac t Factor y ( 8 7) a re c o m p e t i n g pattern s in s o me w a y s , as we d i s c u s s at t he e nd of t h is c h a p t e r . T h ey c an a l so be u s ed t o g e t h e r , h o w e v e r . An Abstrac t Factor y m i g h t s t o re a set of prototype s from w h i c h to c l o ne and retur n produc t o b j e c t s . D e s i g n s that make heav y u se of t he C o m p o s i t e ( 1 6 3) a nd Decorato r ( 1 7 5) pattern s often can benefit from Prototype as well. ptgSINGLETON 127 S I N G L E T O N O b j e c t Creational I n t e n t Ensure a class only has one instance, and provide a global point of access to it. Motivation It's importan t for s o me c l a s s e s to have exactl y one instance . Althoug h there can be many printer s in a s y s t e m , the re s h o u l d be o n ly o ne printe r s p o o l e r . T h e re s h o u l d be o n ly o ne f i le s y s t e m a nd o ne windo w manager . A d i g i t a l filter w i ll have o ne A/D c o n v e r t e r . An accountin g s y s t e m w i ll be d e d i c a t e d to s e r v i n g one c o m p a n y . How do we e n s u r e that a c l a ss has o n ly one instanc e and that the instanc e is e a s i ly a c c e s s i b l e ? A g l o b a l v a r i a b l e make s an o b j e c t a c c e s s i b l e , but it doesn' t k e ep you from instantiatin g multipl e o b j e c t s . A b e t t e r s o l u t i o n is to make t he c l a ss i t s e lf r e s p o n s i b l e for k e e p i n g t r a ck of i ts s o le instance . The c l a ss can e n s u r e that no other instanc e can be c rea te d (by i n t e r c e p t i n g r e q u e s t s to c r e a t e new o b j e c t s ) , and it can p r o v i d e a way to a c c e s s the instance . T h i s is the Singleton pattern. Applicability Use the S i n g l e t o n patter n when • there must be e x a c t l y one instanc e of a c l a s s, and it must be a c c e s s i b l e to c l i e n t s from a well-know n a c c e s s point. • when the s o le instanc e s h o u l d be e x t e n s i b l e by s u b c l a s s i n g , and c l i e n t s s h o u l d be able to use an extended instance without modifying their code. S t r u c t u r e ptg1 2 8 CREATIONAL PATTERNS CHAPTER 3 P a r t i c i p a n t s • Singleton - define s an Instanc e operatio n t h at l e ts c l i e n t s a c c e s s its uniqu e i n s t a n c e . Instanc e is a c l a ss operatio n ( t h at is, a c l a ss metho d in Smalltal k and a static member function i n C++). - may b e r e s p o n s i b l e f o r creating its own u n i q u e i n s t a n c e . C o l l a b o r a t i o n s • Clients access a Singleton instance solely through Singleton's Instance opera - tion. C o n s e q u e n c e s T he S i n g l e t o n patter n h as s e v e r a l b e n e f i t s : 1. Controlled access to sole instance. Becaus e the S i n g l e t o n c l a ss encapsulate s its s o le instance , it can have stric t contro l o v er how and when c l i e n t s a c c e s s it. 2. Reduced name space. T he S i n g l e t o n pattern is an i m p r o v e m e n t o v er g l o b a l variables . It avoid s pollutin g the name s p a ce with g l o b a l variable s that store s o le instances. 3. Permits refinement of operations and representation. The S i n g l e t o n c l a ss may be s u b c l a s s e d , a nd i t 's e a sy to c o n f i g u r e an a p p l i c a t i o n with an i n s t a n c e of t h is extende d c l a s s . You can configur e the applicatio n with an instanc e of the c l a ss you n e ed at run-time. 4. Permits a variable number of instances. The patter n make s it e a sy to chang e your m i nd a nd a l l ow m o re than o ne i n s t a n c e of t he S i n g l e t o n c l a s s. M o r e o v e r , you can use the same approac h to contro l the numbe r of i n s t a n c e s that the applicatio n u s e s. O n ly the operatio n that grant s a c c e s s to the S i n g l e t o n instanc e need s to change. 5. More flexible than class operations. Anothe r way to packag e a s i n g l e t o n ' s func- tionalit y is to use c l a ss operation s (that i s, static membe r function s in C++ or c l a ss method s in Smalltalk) . But both of these languag e technique s make it hard to chang e a d e s i g n to allow more than one instanc e of a c l a s s. M o r e o v e r , s t a t ic m e m b e r function s in C ++ a re n e v er v i r t u a l , so s u b c l a s s e s c a n 't o v e r r i d e them polymorphically. Implementation Here are implementatio n i s s u e s to conside r when using the S i n g l e t o n pattern: 1. Ensuring a unique instance. The S i n g l e t o n patter n make s the s o le instanc e a normal instance of a class, but that class is written so that only one instance ptgSINGLETON 1 2 9 c an e v er be c r e a t e d . A c o m m o n w ay to do t h is is to h i de t he o p e r a t i o n that create s the instanc e behin d a c l a ss operatio n (that i s, eithe r a static membe r functio n or a c l a ss method ) that guarantee s o n ly one instanc e is created . T h is operatio n has a c c e s s to the variabl e t h at holds the uniqu e instance , and it e n s u r e s the variabl e is initialize d with the uniqu e instanc e befor e returnin g its value . T h is approac h e n s u r e s that a singleto n is c r e a t e d and i n i t i a l i z e d befor e its first u s e . You can defin e the c l a ss operatio n in C++ with a static membe r functio n I n s t a n c e of the S i n g l e t o n c l a s s. S i n g l e t on a l so define s a static membe r variable -instance that contains a pointer to its unique instance. The Singleton class is declared as class Singleto n { public: static Singleton * Instance() ; protected: S i n g l e t o n ( ) ; private: static Singleton * _instance ; } ; T h e corresponding implementation is Singleton * Singleton::_instanc e = 0; Singleton * Singleton::Instanc e () { if ( _ i n s t a n c e == 0) { _instanc e = new Singleton ; } return _instance ; } C l i e n t s a c c e s s the s i n g l e t o n e x c l u s i v e l y throug h the I n s t a n c e m e m b e r func- tion. The variabl e - i n s t a n c e is i n i t i a l i z e d to 0, and the static membe r func- t i on I n s t a n c e return s i ts v a l u e , i n i t i a l i z i n g it with t he uniqu e i n s t a n c e if it is 0. I n s t a n c e u s es lazy initialization ; the value it return s isn't create d and s t o r ed until it's first a c c e s s e d . Notic e t h at the constructo r is protected . A c l i e nt that t r i es to instantiat e S i n g l e t o n directl y w i ll get an e r r or at c o m p i l e - t i m e . T h is e n s u r e s t h at o n ly one instanc e can e v er get created. M o r e o v e r , s i n ce the - i n s t a n c e is a pointe r toa S i n g l e t o n object , the I n s t a n c e m e m b e r functio n c an a s s i g n a p o i n t e rto a s u b c l a s s of S i n g l e - t on to this v a r i a b l e . W e ' ll g i ve an exampl e of this int he S a m p l e C o d e . T h e r e ' s anothe r thing to note abou t the C++ implementation . It isn't enoug h to defin e the s i n g l e t o n as a g l o b a l or static objec t and then r e ly on automati c initialization . T h e re are three reason s for t h i s : (a) We can't guarante e that only one instanc e of a static objec t w i ll e v er be d e c l a r e d . ptg1 30 CREATIONAL PATTERNS CHAPTER 3 (b) We migh t not have e n o u g h informatio n to instantiat e e v e ry s i n g l e t o n at static initializatio n time. A s i n g l e t o n migh t r e q u i r e v a l u e s that are compute d later in the program' s e x e c u t i o n . (c) C++ doesn' t defin e the or d er in whic h constructor s for g l o b a l o b j e c t s are c a l l ed a c r o s s translatio n units [ E S 9 0 ] . T h is mean s that no d e p e n d e n c i e s c an e x i st betwee n s i n g l e t o n s ; if a ny d o, then e r r o r s a re i n e v i t a b l e . An adde d (albei t small ) l i a b i l i t y of the global/stati c o b j e c t approac h is that it force s all s i n g l e t o n s to be c r ea te d whethe r they are u s ed or not. U s i ng a static membe r functio n avoid s all of these p r o b l e m s . In S m a l l t a l k , t he functio n that r e t u r n s t he u n i q u e i n s t a n c e is i m p l e m e n t e d as a c l a ss metho d on t he S i n g l e t o n c l a s s . To e n s u r e that o n ly o ne i n s t a n c e is created , overrid e the new operation . The r e s u l t i n g S i n g l e t o n c l a ss migh t have the followin g two c l a ss methods , wher e S o l e l n s t a n c e i s a c l a ss variabl e that is not used anywhere else: n e w self e r r o r: ' c a n n ot create new object' default Solelnstance isNil ifTrue: [ S o l e l n s t a n c e : = super new]. Solelnstance 2. Subclassing the Singleton class. The main i s s ue is not so much definin g the s u b c l a s s but installin g its uniqu e instanc e so that c l i e n t s w i ll be a b le to use it. In e s s e n c e , the variabl e t h at refers to the s i n g l e t o n i n s t a n c e must get initialize d with an instanc e of the s u b c l a s s . The s i m p l e s t techniqu e is to determin e whic h s i n g l e t o n you want to use in the S i n g l e t o n ' s I n s t a n c e operation . An exampl e in the S a m p l e C o de show s how to implemen t t h is techniqu e with environmen t v a r i a b l e s . Anothe r way to c h o o s e the s u b c l a s s of S i n g l e t o n is to take the implementatio n of I n s t a n c e o ut of t he paren t c l a ss ( e . g ., M a z e F a c t o r y ) a nd p ut it in t he s u b c l a s s . That l e ts a C++ programme r d e c i d e the c l a ss of s i n g l e t o n at l i n k - time ( e . g ., by linkin g in an o b j e c t file containin g a differen t implementation ) but k e e ps it hidde n f r om the client s of the s i n g l e t o n . T he link approac h f i x es t he c h o i c e of s i n g l e t o n c l a ss at l i n k - t i m e , w h i c h make s it hard to c h o o s e the s i n g l e t o n c l a ss at run-time . U s i ng c o n d i t i o n a l statement s to determin e the s u b c l a s s is more f l e x i b l e , but it h a r d - w i r e s the s et of p o s s i b l e S i n g l e t o n c l a s s e s . Neithe r approac h is fl e xib l e enoug h in a ll c a s e s . A more f l e x i b l e approac h u s es a registr y of s i n g l e t o n s . Instea d of havin g I n s t a n c e defin e t he s et of p o s s i b l e S i n g l e t o n c l a s s e s , t he S i n g l e t o n c l a s s e s can registe r their s i n g l e t o n instanc e by name in a well-know n r e g i s t r y . The registr y maps betwee n string name s and s i n g l e t o n s . Whe n I n s t a n c e n e e d s a singleton, it consults the registry, asking for the singleton by name. ptgSINGLETON 1 3 1 The registr y looks up the correspondin g singleto n (if it exists ) and return s it. T h is approac h frees I n s t a n c e f r om knowin g all p o s s i b l e S i n g l e t o n c l a s s e s or i n s t a n c e s . All it require s is a commo n interfac e for all S i n g l e t o n c l a s s e s that i n c l u d e s operation s for the registry: c l a ss Singleton { public: static void Register(cons t c h a r* name, Singleton*) ; static Singleton * Instance(); protected : static Singleton * L o o k u p ( c o n s t char* name); private: s t a t ic S i n g l e t o n * _ i n s t a n c e ; static List<NameSingletonPair>* _registry; } ; R e g i s t e r register s the S i n g l e t o n i n s t a n c e unde r the g i v en name . To keep t he r e g i s t r y s i m p l e , w e ' ll have it s t o re a l i st of Name s i n g le t o n P a i r o b j e c t s . Each N a m e S i n g l e t o n P a i r maps a name to a s i n g l e t o n . The L o o k u p op- e r a t i o n finds a s i n g l e t o n g i v en i ts n a m e . W e ' ll a s s u m e that an e n v i r o n m e n t variabl e specifie s the name of the singleto n desired. Singleton * Singleton::Instanc e () { if ( _ i n s t a n c e = =0) { c o n st c h a r* s i n g l e t o n N a m e = g e t e n v ( \" S I N G L E T O N \" ) ; // user or environmen t supplies this at startup _ i n s t a n ce = L o o k u p ( s i n g l e t o n N a m e ) ; // L o o k up returns 0 if t h e r e 's no s u ch singleton } r e t u r n _instance; } Wher e do S i n g l e t o n c l a s s e s r e g i s t e r themselves ? O ne possibilit y is in their constructor. For example, a MyS i n g l e t o n s u b c l a s s c o u l d do the f o l l o w i n g : MySingleton::MySingleton() { // . . . Singleton::Register(\"MySingleton\", this); } Of c o u r s e , the constructor won' t get c a l l ed u n l e s s s o m e o n e instantiate s the c l a s s, w h i c h e c h o e s t he p r o b l e m t he S i n g l e t o n p a t t e r n is trying to s o l v e ! We can get aroun d this proble m in C++ by definin g a static instanc e of M y S i n g l e t o n . For example, we can define static MySingleton theSingleton; in the file that contain s MyS i n g le t o n 's implementation. No l o n g e r is the S i n g l e t o n c l a ss responsibl e f or creatin g the s i n g l e t o n . I n s t e a d , its primary responsibility is to make the singleton object of choice accessible ptg1 32 CREATIONAL PATTERNS CHAPTER 3 in the system . The static o b j e c t approac h s t i ll has a potentia l drawback — namel y that i n s t a n c e s of a ll p o s s i b l e S i n g l e t o n s u b c l a s s e s must be c r e a t e d , or e l s e t h e y won't get r e g i s t e r e d . S a m p l e C o d e S u p p o s e we d e f i n e a M a z e F a c t o r y c l a ss f or b u i l d i n g m a z e s as d e s c r i b e d on page 92. M a z e F a c t o r y define s an interfac e for buildin g differen t parts of a maze . S u b c l a s s e s c an r e d e f i n e t he o p e r a t i o n s to retur n i n s t a n c e s of s p e c i a l i z e d p r o d u c t c l a s s e s , l i ke B o m b e d W a l l o b j e c t s i n s t e a d of p l a in W a ll o b j e c t s . What' s relevan t h e re is that the Maze applicatio n needs o n ly one instanc e of a maze factory , and that instanc e s h o u l d be a v a i l a b l e to c o de that build s any part of t he maze . T h is is wher e t he S i n g l e t o n patter n c o m e s i n. By makin g t he M a z e F a c t o r y a s i n g l e t o n , we make the maze o b j e c t g l o b a l l y a c c e s s i b l e withou t r e s o r t i n g to g l o b a l v a r i a b l e s . F or s i m p l i c i t y , l e t 's assum e w e ' ll n e v er s u b c l a s s M a z e F a c t o r y . ( W e ' l l c o n s i d e r the alternativ e in a moment. ) We make it a S i n g l e t o n c l a ss in C++ by addin g a static I n s t a n c e o p e r a t i o n and a static - i n s t a n c e membe r to h o ld the one and o n ly instance . We must a l so protec t the constructo r to preven t accidenta l instantiation , w h i c h m i g h t l e a d to more than one instance. class MazeFactor y { public: static MazeFactory * Instance(); // e x i s t i ng interfac e g o es h e re protected: MazeFactory() ; private: static MazeFactory * _instance ; } ; T h e corresponding implementation i s M a z e F a c t o r y * M a z e F a c t o r y : : _ i n s t a n c e = 0 ; MazeFactory * MazeFactory::Instanc e () { if ( _ i n s t a n c e = =0) { _instanc e = new MazeFactory ; } r e t u r n _ i n s t a n c e ; } N ow l e t 's c o n s i d e r what h a p p e n s w h en t h e re a re s u b c l a s s e s of Ma z eFac t ory, a nd t he applicatio n must d e c i d e whic h o ne to u s e. W e ' ll s e l e ct t he k i nd of maze throug h an e n v i r o n m e n t v a r i a b l e a nd a dd c o de that i n s t a n t i a t e s t he p r o p e r M a z e F a c t o r y s u b c l a s s b a s ed on the environmen t variable' s v a l u e . The I n s t a n c e operatio n is a good place to put this code, because it already instantiates M a z e F a c t o r y : ptgSINGLETON 133 MazeFactory * MazeFactory::Instanc e () { if ( _ i n s t a n c e = =0) { const char* mazeStyl e - getenv(\"MAZESTYLE\"); if ( s t r c m p ( m a z e S t y l e , \"bombed\" ) == 0) { _instanc e = new BombedMazeFactory; } else if (strcmp(mazeStyle , \"enchanted\" ) == 0) { _instanc e = new EnchantedMazeFactory; // . .. other possible subclasses } else { // default _instanc e = new MazeFactory ; } } return _instance; } Note that I n s t a n c e must be modifie d wheneve r you defin e a new s u b c l a s s of M a z e F a c t o r y . That migh t not be a proble m in this a p p l i c a t i o n , but it migh t be for abstrac t factorie s define d in a framework. A p o s s i b l e solutio n woul d be to use the registr y approac h d e s c r i b e d in the I m p l e - mentatio n s e c t i o n . Dynami c linkin g c o u ld be usefu l here as w e l l — i t woul d k e ep the application from having to load all the subclasses that are not used. Known Uses An exampl e of the S i n g l e t o n patter n in S m a l l t a l k - 8 0 [ P a r 9 0 ] is the set of c h a n g e s to the c o d e, whic h is C h a n g e S e t c u r r e n t . A more subtl e exampl e is the r e l a t i o n - s h ip betwee n c l a s s e s a nd their metaclasses . A metaclas s is the c l a ss of a c l a s s, and e a ch m e t a c l a s s has one instance . M e t a c l a s s e s do not have name s ( e x c e p t i n d i r e c t l y throug h thei r s o le instance) , but they k e ep track of their s o le instanc e and w i ll not normall y creat e another. The Interview s user interfac e toolki t [LCI +92] u s es the S i n g l e t o n patter n to a c c e s s t he uniqu e instanc e of i ts S e s s i o n a nd WidgetKi t c l a s s e s , amon g others . S e s s i o n define s the application' s main event dispatc h l o o p, s t o r e s the user' s database of stylisti c preferences , and manage s c o n n e c t i o n s to one or more physica l d i s p l a y s . WidgetKi t is an Abstrac t Factor y ( 8 7) for definin g the l o ok and feel of u s er interfac e widgets . T he W i d g e t K i t : : i n s t a n c e ( ) operatio n determine s t he particula r WidgetKi t s u b c l a s s that's instantiate d based on an environmen t variabl e that S e s s i o n defines . A s i m i l a r operatio n on S e s s i o n determine s whethe r monochrom e or c o l or display s are supporte d and configure s the s i n g l e t o n S e s s i o n instanc e a c c o r d i n g l y . ptg1 3 4 CREATIONAL PATTERNS CHAPTER 3 Related P a t t e r n s Many pattern s can be implemente d using the S i n g l e t o n pattern . See Abstrac t Factory (87), Builder (97), and P r o t o t y p e ( 1 1 7 ) . ptgDISCUSSION O F CREATIONAL PATTERNS 135 Discussion of Creational Patterns T h e re are two commo n ways to parameteriz e a syste m by the c l a s s e s of o b j e c t s it c r e a t e s . One way is to s u b c l a s s the c l a ss that c r e a t e s the o b j e c t s ; this correspond s to u s i ng the Factor y Metho d ( 1 0 7) pattern . The main drawbac k of this approac h is that it can r e q u i r e creatin g a new s u b c l a s s just to c h a n g e the c l a ss of the product . S u ch change s can c a s c a d e . For e x a m p l e , when the produc t creato r is i t s e lf c r e a t e d by a f a c t or y method , then you have to o v e r r i d e its c r e a t o r as w e l l . The other way to parameteriz e a syste m r e l i es more on o b j e c t c o m p o s i t i o n : Defin e an objec t that's r e s p o n s i b l e for knowin g the c l a ss of the produc t o b j e c t s , and make it a paramete r of t he system . T h is is a k ey a s p e c t of t he Abstrac t Factor y ( 8 7 ), Builde r ( 9 7 ), and Prototyp e ( 1 1 7) patterns . All three i n v o l v e creatin g a new \"factor y o b j e c t \" whos e r e s p o n s i b i l i t y is to c r e a t e produc t o b j e c t s . Abstrac t Factor y has the f a c t o r y o b j e c t p r o - ducin g object s of s e v e r a l c l a s s e s . B u i l d e r has the f a c t o r y objec t buildin g a c o m p l e x p r o d u c t i n c r e m e n t a l l y u s i ng a c o r r e s p o n d i n g l y c o m p l e x p r o t o c o l . P r o t o t y p e h as t he factor y o b j e c t buildin g a produc t by c o p y i n g a prototyp e object . In this c a s e, the f a c t o r y o b j e c t and the prototyp e are the same o b j e c t , b e c a u s e the prototyp e is r e s p o n s i b l e for r e t u r n i n g t he p r o d u c t . C o n s i d e r the drawin g e d i t o r framewor k d e s c r i b e d in the Prototyp e pattern . T h e re are s e v e r a l ways to parameteriz e a GraphicToo l by the c l a ss of product: • By applyin g the Factor y Metho d pattern , a s u b c l a s s of G r a p h i c T o o l w i ll be c r e a t e d for e a ch s u b c l a s s of Graphi c in the palette . G r a p h i c T o o l w i ll have a NewGraphi c operatio n t h a t e a ch G r a p h i c T o o l s u b c l a s s w i ll redefine. • By applyin g the Abstrac t F a c t o r y pattern , there w i ll be a c l a ss hierarch y of Graph- i c s F a c t o r i e s , one for e a ch Graphi c s u b c l a s s . E a ch factor y create s j u st one produc t in this c a s e: C i r c l e F a c t o r y w i ll creat e C i r c l e s , L i n e F a c t o r y w i ll creat e L i n e s , a nd so on. A G r a p h i c T o o l w i ll be parameterize d with a factor y for creatin g the appro- priate kind of Graphics. • By a p p l y i n g the Prototyp e pattern , e a ch s u b c l a s s of Graphic s w i ll implemen t the C l o n e o p e r a t i o n , and a G r a p h i c T o o l w i ll be parameterize d with a prototyp e of the Graphi c it c r e a t e s . W h i c h patter n is b e st d e p e n d s on many factors . In o ur d r a w i n g e d i t o r framework , t he F a c t o r y Metho d patter n is e a s i e s t to use at first. I t 's e a sy to defin e a new s u b c l a s s of G r a p h i c T o o l , and the i n s t a n c e s of G r a p h i c T o o l are create d only when the palett e is d e f i n e d . T he m a in d i s a d v a n t a g e h e re is that G r a p h i c T o o l s u b c l a s s e s p r o l i f e r a t e , a nd none of them d o es very much. Abstrac t Factor y d o e s n ' t o f f er much of an improvement , becaus e it require s an e q u a l l y l a r ge G r a p h i c s F a c t o r y c l a ss h i e r a r c h y . Abs t rac t F a c t o r y w o u l d be p r e f e r a b l e to F a c t o r y Metho d only if there w e re alread y a GraphicsFactor y c l a ss hierarchy—eithe r becaus e t he c o m p i l e r p r o v i d e s it automaticall y ( as in S m a l l t a l k or Objectiv e C) or becaus e it's n e e d e d i n another part of the system. ptg1 36 CREATIONAL PATTERNS CHAPTER 3 O v e r a l l , the Prototyp e patter n is probabl y the b e st for the drawin g e d i t o r framework , becaus e it o n ly r e q u i r e s implementin g a C l o ne operatio n on e a ch Graphic s c l a s s. That r e d u c e s the numbe r of c l a s s e s , and C l o n e can be u s ed for p u r p o s e s o t h er than pure instantiatio n ( e . g ., a Duplicat e menu operation). Factor y Metho d make s a d e s i g n m o re customizabl e and o n ly a little m o re c o m p l i c a t e d . Othe r d e s i g n pattern s requir e new c l a s s e s , wherea s Factor y Metho d o n ly r e q u i r e s a new operation . P e o p l e often use Factor y Metho d as the standar d way to creat e o b j e c t s , but it isn't n e c e s s a r y when the c l a ss that's instantiate d n e v er c h a n g e s or when instantiatio n takes place in an operatio n that s u b c l a s s e s can e a s i ly o v e r r i d e , s u ch as an initializatio n operation. D e s i g n s that use Abstrac t F a c t o r y , Prototype , or Bu ild e r are e v en m o re f l e x i b l e than those that use Factor y Method , but they'r e a l so more c o m p l e x . Often , d e s i g n s start out using Factor y Metho d and e v o l v e towar d the other creationa l pattern s as the d e s i g n e r d i s c o v e r s wher e m o re flexibilit y is needed . Knowin g many d e s i g n pattern s g i v es y ou more choices when trading off one design criterion against another. ptgC h a p t e r 4 S t r u c t u r a l Patterns Structura l pattern s are c o n c e r n e d with how c l a s s e s and object s are c o m p o s e d to f o rm l a r g e r structures . Structura l class pattern s use inheritanc e to c o m p o s e interface s or im- plementations . As a s i m p l e e x a m p l e , c o n s i d e r how multipl e inheritanc e m i x e s two or m o re c l a s s e s into o n e. T he resul t is a c l a ss that c o m b i n e s t he propertie s of i ts paren t c l a s s e s . T h is patter n is particularl y usefu l for makin g independentl y d e v e l o p e d c l a ss librarie s work together . Anothe r exampl e is the c l a ss f o rm of the Adapte r ( 1 3 9) pat- tern. In g e n e r a l , an adapte r make s one interfac e (the adaptee's ) confor m to another , thereb y providin g a u n i f o r m abstractio n of differen t interfaces . A c l a ss adapte r a c c o m - p l i s h e s this by inheritin g privatel y f r om an adapte e c l a s s. The adapte r then e x p r e s s e s its interfac e in terms of the adaptee's. Rathe r than composin g interface s or implementations , structura l object pattern s de- s c r i be ways to c o m p o s e object s to r e a l i z e new functionality . The adde d fl exibi lit y of o b j e c t c o m p o s i t i o n c o m e s from the a b i l i t y to chang e the compositio n at run-time , whic h is i m p o s s i b l e with static c l a ss composition. Composit e ( 1 6 3) is an exampl e of a structura l o b j e c t pattern . It d e s c r i b e s how to build a c l a ss hierarch y made up of c l a s s e s for two kinds of objects : primitiv e and c o m p o s i t e . The composit e object s let you c o m p o s e primitiv e and other composit e object s into a r b i t r a r i l y c o m p l e x s t r u c t u r e s . In t he P r o xy ( 2 0 7) p a t t e r n , a p r o xy a c ts as a c o n v e n i e n t surrogat e or placeholde r for anothe r object . A proxy can be used in many ways . It can act as a l o c al representativ e for an o b j e c t in a remot e addres s s p a c e . It can represen t a l a r ge objec t that shoul d be loade d on demand . It migh t protec t a c c e s s to a s e n s i t i v e object . P r o x i e s provid e a l e v el of indirectio n to specifi c p r o p e r t i e s of o b j e c t s . Henc e they can r e s t r i c t , enhance , or alter these p r o p e r t i e s . The Flyweigh t ( 1 9 5) patter n define s a structur e for sharin g objects . Object s are share d for at l e a st two r e a s o n s : efficienc y and c o n s i s t e n c y . F l y w e i g h t focuse s on sharin g for s p a ce efficiency . Application s that use lots of object s must pay carefu l attentio n to t he c o st of e a ch object . Substantia l s a v i n g s c an be h ad by sharin g object s instea d of replicating them. But objects can be shared only if they don't define context-dependent 1 3 7 ptg1 38 STRUCTURAL PATTERNS CHAPTER 4 state. F l y w e i g h t object s have no such state. Any additiona l informatio n they n e ed to perfor m their task is p a s s e d to them when n e e d e d . With no context-dependen t state, F l y w e i g h t object s may be s h a r e d f r e e l y . Wherea s F l y w e i g h t s h o w s h ow to make l o ts of little o b j e c t s , Facad e ( 1 8 5) s h o w s h ow to make a s i n g l e o b j e c t r e p r e s e n t an e n t i re s u b s y s t e m . A facad e is a representativ e for a set of o b j e c t s . The f a c a d e c a r r i e s out its r e s p o n s i b i l i t i e s by forwardin g m e s s a g e s to the object s it represents . T he B r i d g e ( 1 5 1) patter n separate s an o b j e c t ' s abstractio n from i ts implementatio n so that you can vary them independently. Decorato r ( 1 7 5) d e s c r i b e s h ow to a dd r e s p o n s i b i l i t i e s to o b j e c t s d y n a m i c a l l y . Decorato r is a structura l patter n that c o m p o s e s o b j e c t s r e c u r s i v e l y to a l l ow an o p e n - e n d e d numbe r of additiona l r e s p o n s i b i l i t i e s . F or e x a m p l e , a Decorato r o b j e c t c o n t a i n i n g a u s er interfac e componen t can add a decoratio n l i ke a borde r or shado w to the c o m p o n e n t , or it can add functionalit y l i ke s c r o l l i n g and zooming . We can add two decoration s s i m p l y by nestin g o ne Decorato r o b j e c t withi n another , a nd so on f or additiona l d e c o r a t i o n s . To a c c o m p l i s h t h i s, each Decorato r o b j e c t must confor m to the interfac e of its componen t and must forwar d m e s s a g e s to it. The Decorato r can do its job (such as drawin g a borde r aroun d the component ) eithe r befor e or after forwardin g a m e s s a g e . Many structura l pattern s are r e l a t e d to s o me d e g r e e . W e ' ll d i s c u s s t h e se r e l a t i o n s h i p s at the end of the chapter. ptgA D A P T E D 139 ADAPTER Class, Object Structural I n t e n t Conver t the interfac e of a c l a ss into anothe r interfac e c l i e n t s e x p e c t . Adapte r l e ts c l a s s e s w o r k t o g e t h e r t h a t c o u l d n ' t o t h e r w i s e b e c a u s e of incompatible interfaces. A l s o Known As Wrapper Motivation S o m e t i m e s a toolki t c l a ss that's d e s i g n e d for r e u se i s n 't reusabl e o n ly becaus e its interfac e doesn' t matc h the domain-specifi c interfac e an applicatio n r e q u i r e s . C o n s i d e r f or exampl e a drawin g e d i t o r that l e ts u s e rs draw and arrang e graphica l e l e m e n t s ( l i n e s , p o l y g o n s , t e x t, e t c .) into p i c t u r e s and diagrams . The drawin g editor' s key abstractio n is the graphica l o b j e c t , whic h has an e d i t a b l e shape and can draw itself . The interfac e for graphica l o b j e c t s is define d by an abstrac t c l a ss c a l l ed S h a p e . The edito r define s a s u b c l a s s of S h a p e for e a ch k i nd of graphica l object : a L i n e S h a p e c l a ss for l i n e s, a P o l y g o n S h a p e c l a ss for p o l y g o n s , and so forth. C l a s s e s for elementar y geometri c s h a p e s l i ke L i n e S h a p e and P o l y g o n S h a p e are rathe r easy to i m p l e m e n t , becaus e their drawin g and editin g c a p a b i l i t i e s are inherentl y l i m i t e d . But a T e x t S h a p e s u b c l a s s that can d i s p l a y and edit text is c o n s i d e r a b l y more difficul t to implement , s i n ce e v en b a s ic text editin g i n v o l v e s c o m p l i c a t e d s c r e e n u p d a t e and b u f f e r management . Meanwhile , an off-the-shel f user interfac e toolki t migh t alread y provid e a sophisticate d T e x t V i e w c l a ss for displayin g and editin g text. I d e a l l y we'd like to r e u se T e x t V i e w to implemen t T e x t S h a p e , b ut t he toolki t wasn' t d e s i g n e d with S h a p e c l a s s e s in mind . So we can't use T e x t V i e w and S h a p e o b j e c t s interchangeably. How can existin g and unrelate d c l a s s e s like T e x t V i e w work in an applicatio n that e x p e c t s c l a s s e s with a differen t and incompatibl e interface ? We c o u ld chang e the T e x t V i e w c l a ss so that it conform s to the Shap e interface , but that isn't an optio n unles s we have the toolkit' s s o u r c e c o d e. Even if we d i d, it wouldn' t make s e n se to chang e T e x t V i e w ; the toolki t shouldn' t have to adop t domain-specifi c interface s just to make one applicatio n work. Instead , we c o u ld defin e T e x t S h a p e so that it adapts the T e x t V i e w interfac e to S h a p e ' s . We can do this in one of two ways : (1) by inheritin g S h a p e ' s interfac e and T e xt View' s implementatio n or (2) by c o m p o s i n g a T e x t V i e w instanc e withi n a TextShape a n d implementing TextShape i n terms of Text V i e w ' s i n t e r f a c e . T h e s e ptg1 4 0 STRUCTURAL PATTERNS CHAPTER 4 two approache s correspon d to the c l a ss and o b j e c t v e r s i o n s of the Adapte r pattern . W e call TextShape an adapter. T h is diagra m illustrate s t he o b j e c t adapte r c a s e. It s h o w s h ow B o u n d i n g B o x r e - q u e s t s , d e c l a r e d in c l a ss S h a p e , a re converte d to GetExten t r e q u e s t s define d in T e xt V i e w . S i n ce T e x t S h a p e adapt s T e xt V i ew to t he S h a p e interface , t he drawin g edito r c an r e u se t he oth erw is e incompatibl e T e xt V i ew c l a s s . Often the adapte r is r e s p o n s i b l e for functionalit y the adapte d c l a ss d o e s n ' t p r o - v i d e. The diagra m s h o w s how an adapte r can fulfil l s u ch r e s p o n s i b i l i t i e s . The user s h o u l d be a b le to \" d r a g \" e v e ry S h a p e o b j e c t to a n ew l o c a t i o n i n t e r a c t i v e l y , but T e xt V i ew i s n 't d e s i g n e d to do that. T e x t S h a p e can add this m i s s i n g function- ality by implementin g S h a p e ' s CreateManipulato r operation , whic h return s an instanc e of the appropriat e Manipulato r s u b c l a s s . Manipulato r is an abstrac t c l a ss for o b j e c t s that know how to animat e a S h a p e in r e s p o n s e to user input , l i ke draggin g the shape to a new location . T h e re are s u b - c l a s s e s of Manipulato r for differen t s h a p e s ; TextManipulator , for e x a m p l e , is the correspondin g s u b c l a s s for T e x t S h a p e . By returnin g a TextManipulato r i n s t a n c e , T e x t S h a p e adds the functionality that Text V i e w lacks but Shape requires. Applicability Use the Adapte r patter n when • you w a nt to use an e x i s t i n g c l a s s, and its interfac e d o es not matc h the one y ou n e e d . • you want to creat e a r e u s a b l e c l a ss that cooperate s with unrelate d or unfore- s e en c l a s s e s , that is, c l a s s e s t h at don't n e c e s s a r i l y have compatibl e interfaces. • (object adapter only) you need to use s e v e r a l e x i s t i n g s u b c l a s s e s , but it's un- p r a c t i c a l to adap t t h e ir i n t e r f a c e by s u b c l a s s i n g e v e ry o n e. An o b j e c t a d a p t e r can adapt the interface of its parent class. ptgADAPTER 141 S t r u c t u r e A class adapter uses multiple inheritance to adapt one interface to another: An object adapter relies on object composition: P a r t i c i p a n t s • Target (Shape) - defines the d o m a i n - s p e c i f i c interface that Client uses. • C l i e n t ( D r a w i n g E d i t o r ) - collaborates with objects conforming to the T a r g e t i n t e r f a c e . • Adaptec ( T e x t V i e w ) - defines an e x i s t i n g i n t e r f a c e t h a t n e e d s a d a p t i n g . • Adapter ( T e x t S h a p e ) - adapts the interface of A d a p t e c to the Target i n t e r f a c e . C o l l a b o r a t i o n s • C l i e n t s c a ll o p e r a t i o n s on an Adapte r i n s t a n c e . In turn, t he a d a p t e r c a l ls Adaptec operations that carry out the request. ptg1 4 2 STRUCTURAL P A T T E R N S CHAPTER 4 C o n s e q u e n c e s C l a ss and objec t adapter s have differen t trade-offs . A c l a ss adapter • adapt s Adapte e to T a r g e t by committin g to a c o n c r e t e Adapte e c l a s s . As a c o n s e q u e n c e , a c l a ss adapte r won' t work w h en we want to adap t a c l a ss and a ll i ts s u b c l a s s e s . • l e ts Adapte r o v e r r i d e s o m e of A d a p t e e ' s b e h a v i o r , s i n ce Adapte r is a s u b c l a s s of Adaptee. • introduce s o n ly one object , and no additiona l pointe r i n d i r e c t i o n is n e e d e d to get to the adaptee. An objec t adapter • l e ts a s i n g le Adapte r work with many Adaptees—tha t i s, t he A d a p t e e i t s e lf and all of its s u b c l a s s e s (if any). The Adapte r can a l so add functionalit y to a ll A d a p t e e s at o n c e . • make s it harde r to overrid e Adapte e behavior . It w i ll requir e s u b c l a s s i n g Adapte e a nd m a k i n g Adapte r refer to t he s u b c l a s s rathe r t h an t he A d a p t e e itself. Here are other issue s to conside r when using the Adapte r pattern: 1. H ow much adapting does Adapter do ? Adapter s vary in t he amoun t of work t h ey do to adap t Adapte e to the Targe t interface . Ther e is a spectru m of p o s s i b l e work , f r om s i m p l e interfac e conversion—fo r example , c h a n g i n g the name s of operations—t o supportin g an entirel y differen t set of o p e r a t i o n s . The amoun t of work A d a p t e r d o es depend s on how s i m i l a r the T a r g e t interfac e is to Adaptee's. 2. Pluggable adapters. A c l a ss is more reusabl e when you minimiz e the assump- t i o ns other c l a s s e s must make to use it. By b u i l d i n g interfac e adaptatio n i n to a c l a s s , you eliminat e the assumptio n that other c l a s s e s see the same i n t e r - face. P ut a n o t h e r way, interfac e adaptatio n l e ts us i n c o r p o r a t e o ur c l a ss i n to existin g s y s t e m s that migh t expec t d i f f e r e n t interface s to the c l a s s . Object- Works\\Smalltal k [ P a r 9 0 ] u s es the term pluggabl e adapte r to d e s c r i b e c l a s s e s with built-i n interfac e adaptation. C o n s i d e r a T r e e D i s p l a y widge t that can displa y tree structure s g r a p h i c a l l y . If this were a special-purpos e widget for use in j u st one application , then we migh t requir e the object s that it display s to have a specifi c interface ; that is, all must d e s c e n d f r om a T r ee abstrac t c l a s s . But if we wante d to make T r e e D i s p l a y more reusabl e (say we wante d to make it part of a toolki t of usefu l w i d g e t s ) , t h en that r e q u i r e m e n t woul d be u n r e a s o n a b l e . A p p l i c a t i o n s will defin e their own c l a s s e s for tree structures . T h e y shouldn' t be force d to use our T r ee abstrac t c l a s s . Differen t tree structure s w i ll have differen t interfaces. ptgA D A P T E D 1 4 3 In a d i r e c t o r y h i e r a r c h y , f or e x a m p l e , c h i l d r e n m i g h t be a c c e s s e d with a GetSubdirectorie s operation , wherea s in an inheritanc e hierarchy , the c o r r e - spondin g operatio n migh t be c a l l ed G e t S u b c l a s s e s . A reusabl e T r e e D i s p l a y widge t must be a b le to displa y both kinds of h i e r a r c h i e s e v en if they use differen t interfaces . In other w o r d s , the T r e e D i s p l a y shoul d have interfac e adaptatio n built into it. W e ' ll l o ok at differen t ways to build interfac e adaptatio n into c l a s s e s in the Implementatio n s e c t i o n . 3. Using two-way adapters to provide transparency. A potentia l proble m with adapter s is that they aren' t transparen t to all c l i e n t s . An adapte d objec t no l o n g e r conform s to the Adapte c interface , so it can't be u s ed as is whereve r an Adapte c o b j e c t c a n. Two-wa y adapter s can provid e such transparency . S p e c i f i c a l l y , they'r e usefu l when two differen t c l i e n t s n e ed to v i ew an o b j e c t differently. C o n s i d e r the two-wa y adapte r that integrate s Unidraw , a graphica l e d i - t or framewor k [ V L 9 0 ] , a nd Q O C A , a constraint-solvin g t o o l k i t [ H H M V 9 2 ] . Both s y s t e m s have c l a s s e s that represen t variable s e x p l i c i t l y : Unidra w has State V a r i a b l e , and Q O C A has ConstraintVariable . To make Unidra w work with Q O C A , ConstraintVariabl e must be adapte d to State Variable ; to let Q O C A propagat e solution s to Unidraw , State Variabl e must be adapte d to C o n s t r a i n t V a r i a b l e . The solutio n i n v o l v e s a two-wa y c l a ss adapte r ConstraintStateVariable , a s u b c l a s s of both State Variabl e and ConstraintVariable , that adapt s the two interface s to e a ch o t h e r . M u l t i p l e inheritanc e is a v i a b l e solutio n in t h is c a se becaus e the interface s of the adapte d c l a s s e s are substantiall y different . The two-wa y c l a ss adapte r conform s to both of the adapte d c l a s s e s and can work i n either system. I m p l e m e n t a t i o n Althoug h the implementatio n of A d a p t e r is usuall y straightforward , here are s o m e issues to keep in mind: ptg1 4 4 STRUCTURAL PATTERNS CHAPTER 4 1. Implementing class adapters in C++. In a C++ implementatio n of a c l a ss adapter , Adapte r woul d inheri t publicl y f r om T a r g e t and privatel y from Adaptec . T h us Adapte r woul d be a subtyp e of T a r g e t but not of Adaptec. 2. Pluggable adapters. Let's l o ok at t h r ee ways to implemen t p l u g g a b l e adapter s for the T r e e D i s p l a y widge t d e s c r i b e d e a r l i e r , w h i c h can lay out and displa y a h i e r a r c h i c a l structur e automatically. T he first s t e p, w h i c h is commo n to a ll t hree of t he implementation s d i s c u s s e d h e r e, is to find a \" n a r r o w \" i n t e r f a c e f or A d a p t e c , that i s, t he s m a l l e s t s u b s e t of operation s that l e ts us do the adaptation . A narro w interfac e c o n s i s t i n g of o n ly a c o u p l e of operation s is eas ie r to adap t than an interfac e with dozen s of operations . F or T r e e D i s p l a y , t he adapte e is a ny h i e r a r c h i c a l structure . A m i n i m a l i s t interfac e m i g h t i n c l u d e two operations , one that define s how to presen t a n o de in the h i e r a r c h i c a l structur e g r a p h i c a l l y , and anothe r that retrieve s the node' s c h i l d r e n . The narro w interfac e l e a ds to three implementatio n approaches: (a) Using abstract operations. Defin e c o r r e s p o n d i n g abstrac t operation s f or the narro w Adapte e interfac e in t he T r e e D i s p l a y c l a s s. S u b c l a s s e s must i m - plemen t the abstrac t operation s and adap t the h i e r a r c h i c a l l y structure d object . F or e x a m p l e , a D i r e c t o r y T r e e D i s p l a y s u b c l a s s w i ll i m p l e m e n t t h e s e o p e r a t i o n s by accessing the directory structure. D i r e c t o r y T r e e D i s p l a y s p e c i a l i z e s t he narro w interfac e so that it c an d i s - play director y structures made up of F i l e S y s t e m E n t i t y objects. (b) Using delegate objects. In t h is approach , T r e e D i s p l a y forward s r e q u e s t s for a c c e s s i n g the h i e r a r c h i c a l structur e to a delegat e object . T r e e D i s p l a y can use a differen t adaptatio n strateg y by substitutin g a differen t delegate. For example , s u p p o s e there e x i s ts a D i r e c t o r y B r o w s e r that u s es a T r e e - D i s p l a y . D i r e c t o r y B r o w s e r m i g h t make a g o od d e l e g a t e f or a d a p t i n g T r e e D i s p l a y to the hierarchica l director y structure . In dynamicall y typed language s l i ke S m a l l t a l k or O b j e c t i v e C, t h is approac h o n ly r e q u i r e s an interface for registering the delegate with the adapter. Then TreeDisplay ptgA D A P T E D 1 4 5 simpl y f o r w a r d s the request s to the delegate . N E X T S T E P [Add94 ] u s e s t h is approac h heavil y to reduc e s u b c l a s s i n g . Staticall y typed language s l i ke C++ requir e an explici t interfac e defin- i t i on for the de le ga te . We can specif y such an interfac e by puttin g the narro w interfac e that T r e e D i s p l a y require s into an abstrac t T r e e A c c e s - sorDelegat e c l a s s . T h en we can mix this interfac e into the delegat e of o ur ch oic e—D ire ct ory Br ow se r in t h is case—usin g inheritance . We u se s i n g le inheritanc e if the DirectoryBrowse r has no existin g paren t c l a s s, multipl e inheritanc e if it d o e s. M i x i n g c l a s s e s togethe r l i ke t h is is e a s - i er than i n t r o d u c i n g a n ew T r e e D i s p l a y s u b c l a s s a nd i m p l e m e n t i n g i ts operations individually. (c)Parameterized adapters. The usual way to suppor t pluggabl e adapter s in Smalltal k is to parameteriz e an adapte r with one or more blocks . The b l o ck c o n s t r u c t s u p p o r t s adaptatio n withou t s u b c l a s s i n g . A b l o ck c an adap t a r e q u e s t , and the adapte r can store a block for each individua l request . In our example , t h is mean s T r e e D i s p l a y s t o r e s one block for c o n v e r t i n g a n o de i n to a G r a p h i c N o d e a nd a n o t h e r b l o ck f or a c c e s s i n g a n o d e ' s c h i l d r e n . For e x a m p l e , to creat e T r e e D i s p l a y on a director y hierarchy , we write d i r e c t o r y D i s p l a y := ( T r e e D i s p l a y o n: treeRoot ) getChildrenBlock: [mode | node getSubdirectories ] createGraphicNodeBlock: [ : n o de | n o de createGraphicNode]. If you'r e buildin g interfac e adaptatio n into a c l a s s, this approac h offer s a convenient alternative to subclassing. ptg146 STRUCTURAL P A T T E R N S CHAPTER 4 S a m p l e C o d e W e ' l l g i ve a b r i ef s k e t c h of t he i m p l e m e n t a t i o n of c l a ss a nd o b j e c t a d a p t e r s f or t he M o t i v a t i o n e x a m p l e b e g i n n i n g w i th t he c l a s s e s S h a p e a nd Text V i e w . class S h a pe { public: Shape(); virtual void B o u n d i n g B o x ( P o i n t& bottomLeft , P o i n t& topRight ) const; virtual Manipulator * CreateManipulator( ) const; class TextView { public: T e x t V i e w ( ) ; void GetOrigin(Coord k x, C o o r d& y) const; void GetExtent(Coord k width, C o o r d& height) const; virtual b o ol IsEmptyO c o n s t ; } ; Shap e a s s u m e s a b o u n d i n g b ox d e f i n e d by i ts o p p o s i n g c o r n e r s . In c o n t r a s t , T e x t V i e w is define d by an o r i g i n , h e i g h t , a nd width . Shap e a l so d e f i n e s a C r e a t e M a n i p u l a t o r o p e r a t i o n for c r e a t i n g a M a n i p u l a t o r o b j e c t , w h i c h k n o w s h ow to a n i m a t e a s h a p e w h en t he u s er m a n i p u l a t e s it.1 T e x t V i e w h as no e q u i v a l e n t o p e r a t i o n . T he c l a ss Text Shap e is an a d a p t e r b e t w e e n t h e se dif- f e r e n t i n t e r f a c e s . A c l a ss a d a p t e r u s es m u l t i p l e i n h e r i t a n c e to a d a p t interfaces . T he k ey to c l a ss a d a p t e r s is to u se o ne i n h e r i t a n c e b r a n c h to i n h e r i t t he i n t e r f a c e a nd a n o t h e r b r a n c h to i n h e r i t t he i m p l e m e n t a t i o n . T he u s u a l w ay to m a ke t h is d i s t i n c t i o n in C ++ is to i n h e r i t t he interfac e p u b l i c l y a nd i n h e r i t t he i m p l e m e n t a t i o n p r i v a t e l y . W e ' l l u se t h is c o n v e n t i o n to d e f i n e t he T e xt Shap e a d a p t e r . c l a ss TextShape : public S h a p e, private TextView { public: TextShape(); virtual void BoundingBox( Pointk bottomLeft , P o i n t& topRight ) c o n s t; virtual b o ol IsEmptyO const; virtual Manipulator* CreateManipulator() const; The B o u n d i n g B o x o p e r a t i o n c o n v e r t s T e x t v i e w ' s i n t e r f a c e t o c o n f o r m t o Shape's. 1 C r e a t e M a n i p u l a t o r i s a n e x a m p l e o f a Factory Method (107). ptgADAPTER 147 void TextShape::BoundingBo x ( P o i n t& bottomLeft , Point& topRight ) const { Coord bottom, left, width, height; GetOrigin(bottom , left); GetExtent(width , height); bottomLef t = Point(bottom , left); topRight = Point(bottom + height, left + width); T he I sEmpt y o p e r a t i o n d e m o n s t r a t e s t he d i r e c t f o r w a r d i n g of r e q u e s t s c o m m o n i n adapter implementations: bool TextShape::IsEmpt y () const { return TextView::IsEmpty(); } F i n a l l y , we d e f i n e C r e a t e M a n i p u l a t o r ( w h i c h i s n 't s u p p o r t e d by T e x t V i e w ) f r om s c r a t c h . A s s u m e w e ' v e a l r e a d y i m p l e m e n t e d a T e x t M a n i p u l a t o r c l a ss t h a t supports manipulation of a TextShape. Manipulator * TextShape::CreateManipulato r () c o n st { return new TextManipulator(this); } T h e object adapter u s e s object composition to combine classes with different inter - faces. In t h i s a p p r o a c h , the a d a p t e r T e x t S h a p e m a i n t a i n s a p o i n t e r to T e x t V i e w . class TextShap e : public S h a pe { public: TextShape(TextView*); virtual void BoundingBox( P o i n t& bottomLeft , Point& topRight ) const; virtual bool IsEmpty( ) const; virtual Manipulator * CreateManipulator( ) const; private: TextView * _text; } ; T e x t S h a p e m u st i n i t i a l i z e t he p o i n t e r to t he T e x t V i e w i n s t a n c e , a nd it d o es so in t he c o n s t r u c t o r . It m u st a l so c a ll o p e r a t i o n s on i ts T e x t V i e w o b j e c t w h e n e v e r i ts o wn o p e r a t i o n s a re c a l l e d . In t h is e x a m p l e , a s s u m e t h at t he c l i e n t c r e a t e s t he T e x t V i e w o b j e c t a n d passes it to the TextShape constructor: TextShape::TextShap e ( T e x t V i e w * t) { _text = t; } ptg1 4 8 STRUCTURAL P A T T E R N S CHAPTER 4 void TextShape::BoundingBo x ( Point& bottomLeft , Points topRight ) c o n st { Coord bottom, left, width, height; _text->GetOrigin(bottom , left); __text->GetExten t (width, height) ; bottomLef t = Point(bottom , left); topRight = Point(botto m + height, left + width); } bool TextShape::IsEmpt y () c o n st { return _text->IsEmpty(); } C r e a t e M a n i p u la t o r 's implementatio n doesn' t chang e f r om the c l a ss adapte r v e r s i o n , s i n ce it's implemente d f r om scratc h and doesn' t r e u se any e x i s t i n g T e x t V i e w functionality. Manipulator * TextShape::CreateManipulato r () const { return new TextManipulator(this); } Compar e this c o de to the c l a ss adapte r c a s e. The objec t adapte r r e q u i r e s a l i t t le more e f f o r t to write , but it's more f l e x i b l e . For e x a m p l e , the objec t adapte r v e r s i o n of T e x t S h a p e w i ll work e q u a l l y w e ll with s u b c l a s s e s of T e xt View—th e c l i e nt s i m p l y p a s s e s an instance o f a Text V i e w subclass to the TextShape constructor. K n o w n Uses The Motivatio n exampl e c o m e s from ET++Draw , a drawin g applicatio n b a s ed on ET++ [ W G M 8 8 ] . ET++Dra w r e u s e s the ET++ c l a s s e s for text e d i t i n g by using a T e x t S h a p e adapte r c l a s s . Interview s 2.6 define s an Interacto r abstrac t c l a ss for user interfac e e l e m e n t s s u ch as s c r o ll bars, buttons , a nd menu s [ V L 8 8 ] . It a l so define s a Graphi c abstrac t c l a ss for structure d graphi c object s such as l i n e s, c i r c l e s , p o l y g o n s , and s p l i n e s . B o th Interactor s and Graphic s have graphica l appearances , but they have differen t interface s and implementation s (they share no commo n paren t c l a s s) and are therefor e incompatible—yo u can't e m b e d a structure d graphi c o b j e c t in, s a y, a d i a l o g b ox d i r e c t l y . Instead , I n t e r v i e w s 2 .6 define s an o b j e c t adapte r c a l l ed G r a p h i c B l o c k , a s u b c l a s s of Interacto r that c o n t a i n s a Graphi c instance . The G r a p h i c B l o c k adapt s the interfac e of the Graphi c c l a ss to t h at of Interactor . The GraphicBloc k l e ts a Graphi c instanc e be d i s p l a y e d , s c r o l l e d , and z o o m e d withi n an Interacto r structure. Pluggabl e adapter s are commo n in ObjectWorks\\Smalltal k [ P a r 9 0 ] . Standar d S m a l l t a l k d e f i n e s a ValueModel class for views that display a single value. Val- ueModel defines a value, value: i n t e r f a c e f o r accessing the value. These are ptgADAPTER 1 4 9 abstrac t methods . Applicatio n writer s a c c e s s the value with more domain-specifi c name s l i ke w i d t h and w i d t h : , but they shouldn' t have to s u b c l a s s V a l u e M o d e l to adap t s u ch application-specifi c name s to the ValueMode l interface. I n s t e a d , O b j e c t W o r k s \\ S m a l l t a l k i n c l u d e s a s u b c l a s s of V a l u e M o d e l c a l l ed P l u g - gableAdaptor . A PluggableAdapto r o b j e c t adapt s other object s to the V a l u e M o d e l interfac e ( v a l u e , v a l u e : ) . It can be parameterize d with b l o c k s for gettin g and settin g the d e s i r e d value . PluggableAdapto r u s es t h e se b l o c k s internall y to im- plemen t the v a l u e , v a l u e : interface . PluggableAdapto r a l so l e ts you pass in t he s e l e c t o r n a m e s ( e . g ., w i d t h , w i d t h : ) d i r e c t l y f or s y n t a c t i c c o n v e n i e n c e . It converts these selectors into the corresponding blocks automatically. Anothe r exampl e from ObjectWorks\\Smalltal k is the TableAdapto r c l a s s. A TableAdapto r can adap t a s e q u e n c e of o b j e c t s to a tabula r presentation . The table d i s p l a y s o ne o b j e c t p er r o w. T he c l i e n t parameterize s TableAdapto r with t he s et of m e s s a g e s that a table can use to get the colum n value s from an o b j e c t . S o me c l a s s e s in N e X T ' s AppKi t [ A d d 9 4 ] u se d e l e g a t e o b j e c t s to perfor m i n t e r f a c e adaptation . An ex ampl e is the NXBrowse r c l a ss that can displa y h i e r a r c h i c a l l i s ts of data. NXBrowse r u s es a delegat e o b j e c t for a c c e s s i n g and adaptin g the data. Meyer' s \" M a r r i a g e of C o n v e n i e n c e \" [ M e y 8 8 ] is a f o rm of c l a ss adapter . Meye r d e s c r i b e s how a F i x e d S t a c k c l a ss adapt s the implementatio n of an Arra y c l a ss to t he interface of a S t a ck c l a s s. T he r e s u lt is a stack c o n t a i n i n g a f i x ed numbe r of entries. Related Patterns B r i d g e ( 1 5 1) h as a s t r u c t u r e s i m i l a r to an o b j e c t a d a p t e r , b ut B r i d g e h as a differen t intent : It is mean t to separat e an interfac e from its implementatio n so that they can be varie d e a s i ly and independently . An adapte r is mean t to chang e the interfac e of an existing object. D e c o r a t o r (175) e n h a n c e s a n o t h e r o b j e c t without changing its interface. A deco - rator is thus more transparent t o t h e application than an adapter i s . A s a c o n s e - ptg1 50 STRUCTURAL PATTERNS CHAPTER 4 q u e n c e , D e c o r a t o r support s r e c u r s i v e c o m p o s i t i o n , w h i c h isn't p o s s i b l e with pure adapters. P r o xy ( 2 0 7) d e f i n e s a r e p r e s e n t a t i v e or s u r r o g a t e f or anothe r o b j e c t a nd d o es n ot c h a n g e its interface. ptgBRIDGE 151 B R I D G E Object Structural I n t e n t Decouple an abstraction from i t s implementation so that the two can vary inde - pendently. Also Known As Handle/Body M o t i v a t i o n When an abstractio n can have one of s e v e r a l p o s s i b l e implementations , the usual way to accommodat e them is to use inheritance . An abstrac t c l a ss define s the in- terfac e to the abstraction , and c o n c r e t e s u b c l a s s e s implemen t it in differen t ways . B ut t h is a p p r o a c h i s n 't alway s f l e x i b l e e n o u g h . I n h e r i t a n c e b i n ds an i m p l e m e n - tation to the abstractio n permanently , w h i c h make s it difficul t to modify , e x t e n d , and r e u se abstraction s and implementation s independently. C o n s i d e r the implementatio n of a portabl e Windo w abstractio n in a user interfac e toolkit . T h is abstractio n shoul d e n a b l e us to write application s that work on both the X W i n d o w S y s t e m and I B M ' s Presentatio n Manage r (PM) , for example . U s i ng inheritance , we could defin e an abstrac t c l a ss W i n d o w and s u b c l a s s e s X W i n d o w and P M W i n d o w that i m p l e m e n t the W i n d o w interfac e for the differen t platforms . But this approac h has two drawbacks: 1. I t 's i n c o n v e n i e n t to exten d t he W i n d o w abstractio n to c o v er differen t k i n ds of window s or n ew platforms . Imagin e an I c on Windo w subclas s of Windo w that s p e c i a l i z e s t he W i n d o w a b s t r a c t i o n f or i c o n s . To s u p p o r t I c on W i n d o w s for both platforms , we have to implemen t two new c l a s s e s , XlconWindo w and P M I c o n W i n d o w . W o r s e , we'll have to defin e two c l a s s e s for every kind of w i n d o w . Supportin g a t h i rd p l a t f o r m require s yet anothe r new W i n d o w subclass for every kind of window. ptg1 5 2 STRUCTURAL PATTERNS CHAPTER 4 2. It m a k e s c l i e nt c o de p l a t f o r m - d e p e n d e n t . W h e n e v e r a c l i e nt c r e a t e s a w i n - d o w, it instantiate s a c o n c r e t e c l a ss that h as a s p e c i f i c i m p l e m e n t a t i o n . F or e x a m p l e , c r e a t i n g an X W i n d o w o b j e c t b i n ds t he W i n d o w abs tr act io n to t he X W i n d o w i m p l e m e n t a t i o n , w h i c h make s t he c l i e nt c o de d e p e n d e n t on t he X W i n d o w i m p l e m e n t a t i o n . T h i s, in turn, make s it harde r to port t he c l i e nt c o de to o t h er platforms. C l i e n t s s h o u l d be a b le to c r e a t e a windo w withou t c o m m i t t i n g to a c o n - c r e te implementation . O n ly t he windo w implementatio n s h o u l d d e p e n d on t he platfor m on w h i c h t he applicatio n r u n s. T h e r e f o r e c l i e nt c o de s h o u l d instantiat e window s withou t m e n t i o n i n g s p e c i f i c platforms. T he B r i d g e patter n a d d r e s s e s t h e se p r o b l e m s by puttin g t he W i n d o w abstractio n a nd i ts implementatio n in separat e c l a ss h i e r a r c h i e s . T h e re is o ne c l a ss h i e r a r c h y f or windo w interface s ( W i n d o w , I c o n W i n d o w , T r a n s i e n t W i n d o w ) and a separat e hierarch y for platform-specifi c w i n d o w i m p l e m e n t a t i o n s , with Windowlm p as its r o o t. T he X W i n d o w I m p s u b c l a s s , f or e x a m p l e , p r o v i d e s an i m p l e m e n t a t i o n b a s ed o n t h e X W i n d o w S y s t e m . A ll operation s on W i n d o w s u b c l a s s e s a re i m p l e m e n t e d in terms of abstrac t o p e r - a t i o n s from t he W i n d o w l m p i n t e r f a c e . T h is d e c o u p l e s t he w i n d o w a b s t r a c t i o n s from the variou s platform-specifi c i m p l e m e n t a t i o n s . We refer to the r e l a t i o n s h i p b e t w e e n W i n d o w a nd Windowlm p as a b r i d g e , b e c a u s e it b r i d g e s t he abstractio n a n d its implementation, letting them vary independently. ptgBRIDGE 153 Applicability Use the Bridg e patter n when • you w a nt to avoid a permanen t bindin g betwee n an abstractio n and its im- plementation . T h is m i g h t be the c a s e, for example , when the implementatio n must be s e l e c t e d or s w i t c h e d at run-time. •both the abstraction s and their implementation s s h o u l d be e x t e n s i b l e by s u b c l a s s i n g . In t h is c a s e, t he B r i d g e patter n l e ts y ou c o m b i n e t he differen t abstraction s and implementation s and exten d them independently. • c h a n g e s in t he implementatio n of an abstractio n s h o u l d have no impac t on c l i e n t s ; that i s, t h e ir c o de s h o u l d n ot have to be r e c o m p i l e d . • (C++ ) you want to h i de the implementatio n of an abstractio n c o m p l e t e l y f r om c l i e n t s . In C ++ t he representatio n of a c l a ss is v i s i b l e in t he c l a ss interface. • you have a proliferatio n of c l a s s e s as s h o w n e a r l i e r in the first Motivatio n diagram . S u ch a c l a ss hierarch y i n d i c a t e s the n e ed for splittin g an objec t into t wo p a r t s . Rumbaug h u s es t he t e rm \" n e s t e d g e n e r a l i z a t i o n s \" [ R B P + 9 1 ] to refer to s u ch c l a ss hierarchies. • y ou want to s h a re an i m p l e m e n t a t i o n a m o n g m u l t i p l e o b j e c t s ( p e r h a p s u s i ng referenc e c o u n t i n g ) , and t h is fact shoul d be hidde n f r om the client . A s i m p l e exampl e is C o p l i e n ' s S t r i ng c l a ss [ C o p 9 2 ] , in whic h multipl e object s c an share the same string representation (StringRep). S t r u c t u r e ptg1 5 4 STRUCTURAL P A T T E R N S CHAPTER 4 Participants • Abstractio n (Window) - define s the abstraction' s interface. - maintain s a referenc e to an objec t of type Implementor. • RefmedAbstractio n (IconWindow) - Extend s the interfac e define d by Abstraction. • Implemento r (Windowlmp) - define s the interfac e for implementatio n c l a s s e s . T h is interfac e d o e s n ' t have to correspon d exactl y to Abstraction' s interface ; in fact the two i n t e r - faces can be quite d i f f e r e n t . T y p i c a l l y the Implemento r interfac e provide s o n ly primitiv e operations , and Abstractio n define s h i g h e r - l e v e l operation s b a s e d on these primitives. • Concretelmplementor ( X W i n d o w I m p , P M W i n d o w I m p ) - implements the I m p l e m e n t o r interface and defines i t s c o n c r e t e i m p l e m e n - tation. C o l l a b o r a t i o n s • Abstraction forwards client requests to its Implementor object. C o n s e q u e n c e s The B r i d g e patter n has the followin g c o n s e q u e n c e s : 1.Decoupling interface a nd implementation. An implementatio n is n ot boun d per- manentl y to an interface . The implementatio n of an abstractio n can be config- ured at run-time . It's e v en p o s s i b l e for an objec t to c h a n g e its implementatio n at run-time. D e c o u p l i n g Abstractio n and Implemento r also eliminate s c o m p i l e - t i m e dependencie s on the implementation . Changin g an implementatio n c l a ss doesn' t r e q u i r e r e c o m p i l i n g the Abstractio n c l a ss and its c l i e n t s . T h is prop- erty is essentia l when you must ensur e binar y compatibilit y betwee n differ- ent v e r s i o n s of a c l a ss library. Furthermore , this decouplin g encourage s layerin g that can l e ad to a better- structure d system . The h i g h - l e v e l part of a syste m o n ly has to know abou t Abstraction and Implementor. 2.Improved e x t e n s i b i l i t y . You can extend the Abstraction and Implementor hier - a r c h i e s i n d e p e n d e n t l y . 3.Hiding i m p l e m e n t a t i o n d e t a i l s from c l i e n t s . You can s h i e l d c l i e n t s from i m p l e - mentation details, like the sharing of implementor objects and the accompa - nying reference count mechanism (if a n y ) . ptgBRIDGE 155 I m p l e m e n t a t i o n C o n s i d e r the followin g implementatio n i s s u e s whe n applyin g the B r i d g e pattern: 1. Only o ne Implementor. In situation s wher e t h e r e ' s o n ly o ne implementation , c r e a t i n g an abstrac t Implemento r c l a ss i s n 't n e c e s s a r y . T h is is a d e g e n e r a t e c a se of t he B r i d g e pattern ; t h e r e ' s a o n e - t o - o n e r e l a t i o n s h i p betwee n A b - stractio n a nd I m p l e m e n t o r . N e v e r t h e l e s s , t h is separatio n is s t i ll usefu l w h en a c h a n g e in the implementatio n of a c l a ss must not a f f e c t its e x i s t i n g c l i e n t s — that is, they shouldn' t have to be r e c o m p i l e d , j u st r e l i n k e d . Carola n [ C a r 8 9 ] u s es t he term \" C h e s h i r e Cat\" to d e s c r i b e t h is separation . In C++, t he c l a ss interfac e of t he Implemento r c l a ss c an be define d in a privat e heade r f i le that isn't provide d to c l i e n t s . T h is l e ts you h i de an implementatio n of a c l a ss c o m p l e t e l y f r om i ts c l i e n t s . 2.Creating the right Implementor object. H o w , w h e n , and wher e do you d e c i d e w h i c h Implemento r c l a ss to instantiat e w h en there' s more than o n e ? If Abstractio n know s abou t a ll C o n c r e t e l m p l e m e n t o r c l a s s e s , t h en it c an instantiat e o ne of them in i ts c o n s t r u c t o r ; it c an d e c i d e b e t w e e n t h em b a s ed on parameter s p a s s e d to its c o n s t r u c t o r . If, for e x a m p l e , a c o l l e c t i o n c l a ss support s multipl e i m p l e m e n t a t i o n s , t he d e c i s i o n c an be b a s ed on t he s i ze of t he c o l l e c t i o n . A l i n k e d l i st implementatio n c an be u s ed f or s m a l l c o l l e c t i o n s and a hash table for l a r g e r o n e s . Anothe r approac h is to c h o o s e a defaul t implementatio n i n i t i a l l y and c h a n g e it later a c c o r d i n g to u s a g e . F or e x a m p l e , if t he c o l l e c t i o n g r o w s b i g g e r than a certai n t h r e s h o l d , then it s w i t c h e s its implementatio n to one that's m o r e appropriat e for a large numbe r of i t e m s . I t 's a l so p o s s i b l e to d e l e g a t e t he d e c i s i o n to anothe r o b j e c t a l t o g e t h e r . In the Window/Windowlm p e x a m p l e , we can introduc e a factor y o b j e c t ( s ee Abstrac t Factor y ( 8 7 )) w h o s e s o le duty is to e n c a p s u l a t e platform-specifics . The factor y know s what k i nd of Windowlm p objec t to c r e a t e for the platfor m in u s e; a W i n d o w s i m p l y a s ks it for a W i n d o w l m p , and it return s the right kind. A benefi t of t h is approac h is that Abstractio n is n ot c o u p l e d d i r e c t l y to a ny of t he Implemento r c l a s s e s . 3.Sharing implementors. C o p l i e n illustrate s how the Handle/Bod y i d i om in C++ c an be u s ed to s h a re i m p l e m e n t a t i o n s a m o n g s e v e r a l o b j e c t s [ C o p 9 2 ] . T he B o dy s t o r e s a referenc e coun t that the Handl e c l a ss i n c r e m e n t s and d e c r e - ments . The c o de for a s s i g n i n g handle s with s h a r e d b o d i e s has the followin g g e n e r a l form: ptg156 STRUCTURAL P A T T E R N S C H A P T E R 4 H a n d l e& Handle::operator = ( c o n st H a n d l e& other) { other._body->Ref() ; _body->Unref(); if (_body->RefCount( ) == 0) { d e l e te _body; } _body = other._body; r e t u r n *this; 4. Using multiple inheritance. Y ou c an u se multipl e i n h e r i t a n c e in C ++ to c o m b i n e an i n t e r f a c e with i ts i m p l e m e n t a t i o n [ M a r 9 1 ] . F or e x a m p l e , a c l a ss c an i n h e r i t publicl y f r om Abstractio n a nd privatel y from a C o n c r e t e l m p l e m e n t o r . B ut b e c a u s e t h is a p p r o a c h r e l i es on static i n h e r i t a n c e , it b i n d s an i m p l e m e n t a t i o n p e r m a n e n t l y to i ts interface . T h e r e f o r e y ou c a n 't i m p l e m e n t a t r ue B r i d g e with multiple inheritance—at least not in C + + . S a m p l e C o d e T he f o l l o w i n g C ++ c o de i m p l e m e n t s t he W i n d o w / W i n d o w l m p e x a m p l e f r om t he Motivatio n s e c t i o n . T he W i n d o w c l a ss d e f i n e s t he w i n d o w a b s t r a c t i o n f or c l i e n t applicat ions: class W i n d ow { public: W i n d o w ( V i e w * contents); / '/ r e q u e s ts h a n d l ed by w i n d ow virtual void D r a w C o n t e n t s ( ) ; virtual void Open(); virtual void Close(); virtual void IconifyO ; virtual void Deiconify(); // r e q u e s ts f o r w a r d ed to implementatio n v i r t u al v o id S e t O r i g i n ( c o n s t P o i n ts a t ); virtual void SetExtent(cons t P o i n t& extent); virtual void Raise(); virtual void L o w e r ( ) ; virtual void D r a w L i n e ( c o n s t P o i n t &, c o n st P o i n t & ); virtual void DrawRect(cons t P o i n t &, c o n st P o i n t & ); virtual void D r a w P o l y g o n ( c o n s t Point[], int n); virtual void DrawText(const char*, const Point&); p r o t e c t e d : Windowlmp* GetWindowImp(); View* GetViewO; ptgBRIDGE 157 private: Windowlmp* _imp; View* _contents; // the window's contents } ; W i n d o w maintain s a referenc e to a W i n d o w l m p , the abstrac t c l a ss t h at d e c l a r e s an interface to the underlying windowing system. c l a ss W i n d o w l m p { public: virtual void ImpTop() = 0; virtual void ImpBottom( ) = 0; virtual void ImpSetExtent(cons t Point&) = 0; virtual void ImpSetOrigin(cons t Point&) = 0; virtual void DeviceRect(Coord , Coord, Coord, Coord) = 0 ; virtual void DeviceText(cons t char*, Coord, Coord) = 0; v i r t u al v o id D e v i c e B i t m a p ( c o n s t char*, Coord, C o o r d) = 0; // lots more function s for d r a w i ng on windows... protected: Windowlmp() ; } ; S u b c l a s s e s of W i n d o w defin e the differen t kinds of window s the applicatio n migh t u s e, s u ch as applicatio n windows , i c o n s , transien t window s for d i a l o g s , floatin g palette s of t o o l s, a nd so o n . For example , A p p l i c a t i o n W i n d o w w i l l implemen t D r a w C o n t e n t s to draw the V i e w instance it stores: class ApplicationWindo w : public Window { public: // . . . virtual void DrawContents(); } ; void ApplicationWindow::DrawContent s () { GetView()->DrawOn(this) ; } I c o n W i n d o w stores the name of a bitmap for the icon it displays... class IconWindo w : public Window { public: // . . . virtual void DrawContents(); private: const c h a r * _bitmapName; } ; . . . a n d it implements DrawContents to draw the bitmap on the window: ptg1 5 8 STRUCTURAL P A T T E R N S CHAPTER 4 void I c o n W i n d o w : : D r a w C o n t e n t s ( ) { W i n d o w l m p * imp - G e t W i n d o w I m p ( ) ; if ( i mp != 0) { imp->DeviceBitmap(_bitmapName , 0 . 0, 0 . 0 ); } } M a ny o t h er variation s of W i n d o w are p o s s i b l e . A T r a n s i e n t W i n d o w may n e ed to c o m m u n i c a t e with t he windo w that c r e a t e d it durin g t he d i a l o g ; h e n ce it k e e ps a r e f e r e n c e to that w i n d o w . A Pa 1 e 11 e W i n d o w a l w a y s f l o a ts a b o v e other w i n d o w s . An I c o n D o c k W i n d o w h o l d s I c o n W i n d o w s and a r r a n g e s them n e a t l y . W i n d o w o p e r a t i o n s are define d in terms of the W i n d o w l m p interface . For e x a m p l e , DrawRe c t e x t r a c t s four c o o r d i n a t e s from its two P o i n t p a r a m e t e r s befor e c a l l i n g the Windowlmp operation that draws the rectangle in the window: void W i n d o w : : D r a w R e c t ( c o n st P o i n ts pi, c o n st P o i n t& p 2) { W i n d o w l m p * imp = G e t W i n d o w I m p ( ) ; imp->DeviceRect(pl.X() , p l . Y O , p2.X(), p 2 . Y ( » ; } C o n c r e t e s u b c l a s s e s of W i n d o w l m p suppor t differen t w i n d o w s y s t e m s . T he X W i n d o w I m p subclass supports the X W i n d o w S y s t e m : c l a ss X W i n d o w I m p : public W i n d o w l m p { p u b l i c : X W i n d o w I m p () , - virtual void DeviceRect(Coord , Coord, C o o r d, C o o r d ); // r e m a i n d er of public interface... private: // l o ts of X w i n d ow s y s t e m - s p e c i f i c state, i n c l u d i n g : D i s p l a y* _dpy; D r a w a b le _winid; // w i n d ow id GC _gc; // w i n d o w graphic context } ; For Presentation Manager (PM), we define a PMWindowlmp class: c l a ss P M W i n d o w l m p : public W i n d o w l m p { p u b l i c : P M W i n d o w l m p ( ) ; virtual v o id DeviceRect(Coord , Coord, Coord, Coord); // r e m a i n d er of public interface.. . private: // l o ts of PM w i n d ow s y s t e m - s p e c i f i c state, i n c l u d i n g : HPS _hps; } ; T h e se s u b c l a s s e s i m p l e m e n t W i n d o w l m p o p e r a t i o n s in terms of w i n d o w s y s t e m p r i m i t i v e s . F o r example, DeviceRect is implemented f o r X a s follows: ptgBRIDGE 159 void XWindowImp::DeviceRec t ( C o o rd xO, Coord yO, Coord xl, Coord yl ) { int x = round(min(xO , xl)); int y = round(min(yO , yl)); int w = r o u n d ( a b s ( x O - xl)); int h = r o u n d ( a b s ( y O - yl)); XDrawRectangle(_dpy, _winid, _gc, x, y, w, h); } T h e PM implementation might look like this: void PMWindowImp::DeviceRec t ( Coord xO, C o o rd yO, C o o rd xl, Coord yl ) { Coord left = min(xO, xl) ; Coord r i g ht = max(xO, xl); Coord bottom = min(yO, yl) ; Coord top = maxfyO, yl) ; P P O I N TL point[4]; point[0]. x = left;p o i n t [ 0 ] . y = top; point[l]. x = right;p o i n t [ 1 ] . y = top; point[2]. x = right;point[2]. y = bottom; p o i n t [ 3 ] . x = left;p o i n t [ 3 ] . y = bottom; if ( (GpiBeginPath(_hps , 1 L) == false) || ( G p i S e t C u r r e n t P o s i t i o n ( _ h p s , & p o i n t [ 3 ] ) == false) ( G p i P o l y L i n e ( _ h p s , 4 L, point) == GPI_ERROR ) || ( G p i E n d P a t h ( _ h p s ) == false) ) { // report e r r o r } e l se { GpiStrokePath(_hps , 1L, OL); } How d o es a windo w obtai n an i n s t a n c e of the right W i n d o w l m p s u b c l a s s ? W e ' ll a s s u m e W i n d o w has that r e s p o n s i b i l i t y in this e x a m p l e . Its G e t W i n d o w I m p op- eratio n g e ts the right i n s t a n c e f r om an abstrac t factor y ( s ee Abstrac t Factor y ( 8 7 )) that effectively e n c a p s u l a t e s all window system s p e c i f i c s . Windowlmp * W i n d o w : : G e t W i n d o w I m p () { if ( _ i mp = =0) { _imp = WindowSystemFactory::Instance()->MakeWindowImp() ; } r e t u rn _imp; } ptg1 6 0 STRUCTURAL P A T T E R N S CHAPTER 4 W i n d o w S y s t e m F a c t o r y : : I n s t a n c e () r e t u r n s an abstract factory that manu - f a c t u r e s a l l window system-specific objects. F o r simplicity, we've made it a Sin- gleton (127) a n d have let the Window class access t h e factory directly. K n o w n Uses The Windo w exampl e abov e come s f r om ET++ [ W G M 8 8 ] . In ET++ , Windowlm p is called \"WindowPort \" and has subclasse s s u ch as XWindowPor t and S u n W i n - dowPort . The Windo w objec t create s its correspondin g Implemento r o b j e c t by requestin g it f r om an abstrac t f a c t o r y c a l l ed \" W i n d o w S y s t e m . \" WindowSyste m provide s an interfac e for creatin g platform-specifi c object s such as fonts , cursors , b i t m a p s , a nd so forth. The ET++ Window/WindowPor t d e s i g n extend s the Bridg e patter n in that the WindowPor t also keep s a referenc e back to the W i n d o w . The WindowPor t i m - plemento r c l a ss uses this referenc e to n o t i f y Windo w abou t WindowPort-specifi c e v e n t s : the arriva l of input events , windo w r e s i z e s , etc. Both Coplie n [ C o p 9 2 ] a nd Stroustru p [ S t r 9 1 ] mentio n Handl e c l a s s e s a nd g i ve some examples . T h e ir example s emphasiz e memor y managemen t i s s u e s like s h a r - ing string representation s and suppor t for variable-size d objects . Our focus is more on supportin g independen t extensio n of both an abstractio n and its implementa- t i o n . libg+ + [ L e a 8 8 ] define s c l a s s e s that implemen t commo n data structures , s u ch as S e t, L i n k e d S e t , H a s h S e t , LinkedList , a nd HashTable . S et is an abstrac t c l a ss that define s a set abstraction , while LinkedLis t and HashTabl e are concret e implementor s for a l i n k e d l i st and a hash table , r e s p e c t i v e l y . L i n k e d S e t and HashSe t are Set implementor s t h at bridg e betwee n Set and their concret e counterpart s LinkedLis t and HashTable . T h is is an example of a degenerat e bridge , becaus e there' s no abstrac t Implemento r c l a s s . NeXT' s AppKi t [Add94 ] uses the Bridg e patter n in the implementatio n and d i s - play of graphica l images . An imag e can be represente d in severa l differen t ways . The optima l displa y of an imag e depend s on the propertie s of a displa y d e v i c e , specificall y its c o l or capabilitie s and its resolution . Withou t help from AppKit , developer s woul d have to determin e whic h implementatio n to use unde r variou s circumstance s in every application. To reliev e developer s of this responsibility , AppKi t provide s an NXIm- a g e / N X I m a g e R e p bridge . NXImag e define s the interfac e for handlin g images . T he implementatio n of image s is define d in a separat e NXImageRe p c l a ss h i - erarch y havin g s u b c l a s s e s s u ch as NXEPSImageRep , NXCachedlmageRep , and NXBitMapImageRep . NXImag e maintain s a referenc e to one or more NXIm- a g e R e p o b j e c t s . If t h e re is m o re than o ne i m a g e i m p l e m e n t a t i o n , t h en N X I m a g e s e l e c t s the most appropriat e one for the curren t displa y d e v i c e . NXImag e is e v en capable of converting one implementation to another if necessary. The interesting ptgBRIDGE 161 a s p e c t o f this Bridge variant i s that NXImage can store more than o n e N X I r n - ageRep implementation at a time. Related Patterns An Abstrac t Factor y ( 8 7) can creat e and configur e a particula r B r i d g e . The Adapte r ( 1 3 9) patter n is g e a r e d towar d makin g unrelate d c l a s s e s work to- g e t h e r . It is usuall y applie d to s y s t e m s a f t er they'r e d e s i g n e d . B r i d g e , on the other hand , is u s ed up-fron t in a d e s i g n to let abstraction s and implementation s vary independently. ptg This page intentionally left blank ptgCOMPOSITE 163 C O M P O S I T E O b j e c t Structural I n t e n t C o m p o s e objects into tree structures t o represent part-whole hierarchies. Com - posite lets clients treat individual objects and compositions of objects uniformly. M o t i v a t i o n Graphic s a p p l i c a t i o n s l i ke drawin g editor s a nd s c h e m a t i c captur e s y s t e m s l et u s e rs b u i ld c o m p l e x d i a g r a m s o ut of s i m p l e c o m p o n e n t s . T he u s er c an g r o up c o m p o n e n t s to form l a r g e r c o m p o n e n t s , w h i c h in turn c an be g r o u p e d to f o rm s t i ll l a r g e r c o m p o n e n t s . A s i m p l e implementatio n c o u ld defin e c l a s s e s for g r a p h i c a l p r i m i t i v e s s u ch as T e xt a nd L i n es plus o t h er c l a s s e s that a ct as c o n t a i n e r s f or t h e se p r i m i t i v e s . B ut t h e r e ' s a p r o b l e m w i th t h is a p p r o a c h : C o de t h at u s es t h e se c l a s s e s m u st treat primitiv e a nd c o n t a i n e r object s differently , e v en if m o st of t he t i me t he u s er treats t h em i d e n t i c a l l y . Havin g to d i s t i n g u i s h t h e se object s make s t he applicatio n m o re c o m p l e x . T he C o m p o s i t e pattern d e s c r i b e s h ow to u se r e c u r s i v e c o m p o s i t i o n so that clients don't have to make this distinction. T he k ey to t he C o m p o s i t e patter n is an abstrac t c l a ss that r e p r e s e n t s both primi- t i v es a nd their c o n t a i n e r s . F or t he g r a p h i c s s y s t e m , this c l a ss is Graphic . Graphi c d e c l a r e s o p e r a t i o n s l i ke Draw that a re s p e c i f i c to g r a p h i c a l o b j e c t s . It a l so d e c l a r e s o p e r a t i o n s that a ll c o m p o s i t e o b j e c t s s h a r e , s u ch as o p e r a t i o n s f or a c c e s s i n g a nd m a n a g i n g its children. ptg1 6 4 STRUCTURAL PATTERNS CHAPTER 4 T he s u b c l a s s e s L i n e, R e c t a n g l e , a nd T e xt ( s ee precedin g c l a ss diagram ) defin e primitiv e graphica l o b j e c t s . T h e se c l a s s e s implemen t Draw to draw l i n e s, r ec tan- g l e s, a nd text, r e s p e c t i v e l y . S i n ce primitiv e graphic s have no c h i ld g r a p h i c s , none of t h e se s u b c l a s s e s implement s c h i l d - r e l a t e d o p e r a t i o n s . T he Pictur e c l a ss define s an aggregat e of Graphi c o b j e c t s . Pictur e i m p l e m e n t s Draw to c a ll Draw on its c h i l d r e n , and it implement s c h i l d - r e l a t e d operation s ac- c o r d i n g l y . Becaus e the Pictur e interfac e conform s to the Graphi c interface , P i c t u r e o b j e c t s c an compos e o t h er P i c t u r e s r e c u r s i v e l y . The followin g diagra m show s a typica l c o m p o s i t e objec t structur e of recursivel y c o m p o s e d G r a p h i c o b j e c t s : A p p l i c a b i l i t y Use the C o m p o s i t e patter n when • you want to r e p r e s e n t part-whol e h i e r a r c h i e s of objects. • you want c l i e n t s to be a b le to i g n o r e the differenc e betwee n composition s of object s a nd individua l objects . C l i e n t s will treat a ll o b j e c t s in t he c o m p o s i t e structure uniformly. S t r u c t u r e ptgCOMPOSITE 165 A typical Composite o b j e c t structure might look like this: Participants • C o m p o n e n t ( G r a p h i c ) -d e c l a r e s t he i n t e r f a c e f or o b j e c t s in t he c o m p o s i t i o n . -i m p l e m e n t s defaul t b e h a v i o r f or t he i n t e r f a c e c o m m o n to a ll c l a s s e s , as appropriate. -d e c l a r e s an interfac e f or a c c e s s i n g a nd m a n a g i n g i ts c h i ld c o m p o n e n t s . - ( o p t i o n a l ) d e f i n e s an i n t e r f a c e f or a c c e s s i n g a c o m p o n e n t ' s p a r e n t in t he recursive structure, and implements it if that's appropriate. • Leaf ( R e c t a n g l e , L i n e , Text, e t c . ) - represents leaf objects in the composition. A leaf has no c h i l d r e n . - defines behavior for primitive objects in the c o m p o s i t i o n . • Composite ( P i c t u r e ) -d e f i n e s b e h a v i o r for components having children. -s t o r e s c h i l d c o m p o n e n t s . -i m p l e m e n t s c h i l d - r e l a t e d o p e r a t i o n s in the C o m p o n e n t i n t e r f a c e . • C l i e n t - manipulates objects i n t h e c o m p o s i t i o n t h r o u g h the C o m p o n e n t i n t e r f a c e . C o l l a b o r a t i o n s • C l i e n t s u se t he C o m p o n e n t c l a ss interfac e to interac t with o b j e c t s in t he c o m - posit e structure . If t he r e c i p i e n t is a Leaf, t h en t he r e q u e s t is handle d d i r e c t l y . If t he r e c i p i e n t is a C o m p o s i t e , then it usuall y forward s request s to i ts c h i ld c o m p o n e n t s , p o s s i b l y p e r f o r m i n g a d d i t i o n a l o p e r a t i o n s befor e and/o r after forwarding. ptg1 6 6 STRUCTURAL P A T T E R N S CHAPTER 4 C o n s e q u e n c e s The Composit e pattern • define s c l a ss hierarchie s c o n s i s t i n g of primitiv e object s a nd c o m p o s i t e o b - j e c t s. P r i m i t i v e o b j e c t s c an be c o m p o s e d i n to m o re c o m p l e x o b j e c t s , w h i ch in turn c an be c o m p o s e d , a nd so on r e c u r s i v e l y . W h e r e v e r c l i e nt c o de e x p e c t s a primitiv e o b j e c t , it c an a l so take a composit e o b j e c t . • m a k e s t he c l i e nt s i m p l e . C l i e n t s c an treat c o m p o s i t e s t r u c t u r e s a nd i n d i - vidua l object s uniformly. C l i e n t s normall y don't know (and shouldn' t care) whethe r they'r e d e a l i n g with a l e af or a c o m p o s i t e c o m p o n e n t . T h is s i m p l i f i e s c l i e nt c o d e, becaus e it avoid s havin g to write t a g - a n d - c a s e - s t a t e m e n t - s t y l e function s o v er the c l a s s e s that defin e the c o m p o s i t i o n . • make s it e a s i e r to a dd n ew k i n ds of c o m p o n e n t s . Newl y d e f i n e d C o m p o s i t e or Leaf s u b c l a s s e s work automaticall y with existin g structure s and c l i e nt code. C l i e n t s don't have to be change d for new Componen t c l a s s e s . • c an make your d e s i g n o v e r l y g e n e r a l . T he d i s a d v a n t a g e of m a k i n g it e a sy to add new component s is that it make s it harde r to restric t the c o m p o n e n t s of a composite . S o m e t i m e s you want a composit e to have o n ly certai n c o m - ponents . With C o m p o s i t e , you can't r e ly on the type s y s t e m to enforc e t h o se constraints for you. You'll have to use run-time checks instead. Implementation T h e re are many i s s u e s to c o n s i d e r when implementin g the Composit e pattern: 1. Explicit parent references. Maintainin g r e f e r e n c e s from c h i ld c o m p o n e n t s to t h e ir p a r e n t c an simplif y t he t r a v e r s a l a nd m a n a g e m e n t of a c o m p o s i t e s t r u c - ture. The paren t referenc e simplifie s movin g up the structur e and d e l e t i n g a component . Paren t reference s a l so h e lp suppor t t he C h a in of R e s p o n s i b i l - ity ( 2 2 3) pattern. T he usual place to defin e t he paren t referenc e is in t he Componen t c l a s s. L e af a nd C o m p o s i t e c l a s s e s c an i n h e r i t t he r e f e r e n c e a nd t he o p e r a t i o n s t h at manag e it. With paren t r e f e r e n c e s , it's e s s e n t i a l to maintai n the invarian t that all c h i l d r e n of a c o m p o s i t e have as t h e ir paren t the c o m p o s i t e that in turn has them as children . The e a s i e s t way to ensur e t h is is to c h a n g e a component' s paren t only w h en i t 's b e i ng a d d e d or r e m o v e d from a c o m p o s i t e . If t h is c an be implemente d o n ce in t he A dd a nd Remov e operation s of t he C o m p o s i t e c l a s s, t h en it c an be i n h e r i t e d by a ll t he s u b c l a s s e s , a nd t he i n v a r i a n t w i ll be maintaine d automatically. 2.Sharing components. It's o f t en usefu l to share c o m p o n e n t s , for e x a m p l e , to r e d u c e s t o r a g e r e q u i r e m e n t s . B ut w h en a c o m p o n e n t c an h a ve no m o re than one parent, sharing components becomes d i f f i c u l t . ptgCOMPOSITE 1 6 7 A p o s s i b l e solutio n is for c h i l d r e n to store multipl e parents . But that can l e ad to ambiguitie s as a r e q u e s t propagate s up the structure . The Flyweigh t ( 1 9 5) patter n s h o w s how to rewor k a d e s i g n to a v o id storin g parent s altogether . It work s in c a s es w h e r e c h i l d r e n can a v o id s e n d i n g paren t request s by exter- nalizin g s o me or a ll of their state. 3. Maximizing the Component interface. One of the g o a ls of the Composit e patter n is to make c l i e n t s unawar e of t he s p e c i f i c L e af or C o m p o s i t e c l a s s e s t h e y ' r e using . To attain t h is g o a l, t he Componen t c l a ss s h o u l d defin e as many com- mon operation s for C o m p o s i t e and L e af c l a s s e s as p o s s i b l e . The Componen t c l a ss usuall y provide s defaul t implementation s for t h e se operations , and Leaf and Composit e s u b c l a s s e s w i ll overrid e them. H o w e v e r , t h is g o al w i ll s o m e t i m e s conflic t with t he principl e of c l a ss hierar- chy d e s i g n that s a ys a c l a ss shoul d o n ly defin e operation s that are meaningfu l to its s u b c l a s s e s . T h e re are many operation s that Componen t support s that don't s e em to make s e n se for L e af c l a s s e s . How can Componen t provid e a defaul t implementatio n for them? S o m e t i m e s a little creativit y s h o w s how an operatio n that woul d appea r to make s e n se o n ly for C o m p o s i t e s can be implemente d for all Component s by movin g it to the Componen t c l a s s. For e x a m p l e , the interfac e for a c c e s s i n g c h i l d r e n is a fundamenta l part of a Composit e c l a ss but not n e c e s s a r i l y L e af c l a s s e s . But if we v i ew a Leaf as a Componen t that never has c h i l d r e n , then we can defin e a defaul t operatio n for c h i ld a c c e s s in the Componen t c l a ss that n e v e r returns any c h i l d r e n . L e af c l a s s e s can use the defaul t implementation , b ut C o m p o s i t e c l a s s e s w i ll r e i m p l e m e n t it to retur n t h e ir c h i l d r e n . The c h i ld managemen t operation s are more troublesom e and are d i s c u s s e d in t he next item. 4.Declaring the child management operations. Althoug h the C o m p o s i t e c l a ss imple- ments the Add and R e m o v e operation s for managin g c h i l d r e n , an importan t i s s ue in t he C o m p o s i t e patter n is whic h c l a s s e s declare t h e se operation s in t he C o m p o s i t e c l a ss h i e r a r c h y . S h o u l d we d e c l a r e t h e se operation s in t he C o m - ponen t and make them meaningfu l for Leaf c l a s s e s , or shoul d we declar e a nd defin e them o n ly in C o m p o s i t e a nd i ts s u b c l a s s e s ? The d e c i s i o n i n v o l v e s a trade-of f betwee n safet y and transparency: • Definin g the c h i ld managemen t interfac e at the root of the c l a ss hierarch y g i v es y ou t r a n s p a r e n c y , b e c a u s e y ou c an treat a ll c o m p o n e n t s u n i f o r m l y . It c o s ts you safety , h o w e v e r , b e c a u s e c l i e n t s may try to do m e a n i n g l e s s t h i n g s l i ke add and remov e object s from l e a v e s . • D e f i n i n g c h i ld managemen t in the Composit e c l a ss g i v es you safety , b e c a u s e any attemp t to add or r e m o v e o b j e c t s f r om leave s w i ll be caugh t at c o m p i l e - t i m e in a staticall y typed languag e l i ke C++. But you l o se transparency, because leaves and composites have different i n t e r f a c e s . ptg1 68 STRUCTURAL PATTERNS CHAPTER 4 We have emphasize d transparenc y o v er safet y in this pattern . If you opt for safety , then at t i m es you may l o se type informatio n and have to conver t a componen t into a composite . How can you do t h is withou t r e s o r t i n g to a type-unsaf e cast? O ne approac h is to d e c l a r e an operatio n C o m p o s i t e * G e t C o m p o s i t e ( ) in the Componen t c l a s s. Componen t p r o v i d e s a defaul t operatio n that return s a null pointer . The Composit e c l a ss redefine s this operatio n to retur n i t s e lf throug h the t h is pointer: c l a ss Composite; c l a ss C o m p o n e nt { public: //. . . virtual Composite * GetComposite( ) { r e t u rn 0; } } ; c l a ss Composit e : public Component { public: void Add(Component*) ; // . . . virtual Composite * GetComposite( ) { r e t u rn this; } } ; c l a ss Leaf : public C o m p o n e nt { // . . . } ; G e t C o m p o s i t e l e ts you query a componen t to see if i t 's a c o m p o s i t e . You can perfor m Add and R e m o v e safely on the c o m p o s i t e it returns. Composite * aComposit e = new Composite ; Leaf* a L e af = new Leaf; C o m p o n e nt * a C o m p o n e n t ; Composite * test; a C o m p o n e n t = aComposite ; if ( t e st = aComponent->GetComposite() ) { test->Add(ne w Leaf); } a C o m p o n e n t = a L e af , - if ( t e st = aComponent->GetComposite() ) { test->Add(ne w Leaf); // will not add leaf } S i m i l a r tests for a Composit e can be d o ne using the C++ d y n a m i c - c a s t construct. Of c o u r s e , t he proble m h e re is that we don't treat a ll component s uniformly . We have to rever t to t e s t i n g f or differen t t y p es befor e takin g the appropriat e action. ptgCOMPOSITE 1 6 9 The o n ly way to provid e transparenc y is to defin e defaul t Add and Remov e operation s in Component . That create s a new problem : T h e r e ' s no way to im- p l e m e n t C o m p o n e n t : : A dd withou t i n t r o d u c i n g t he p o s s i b i l i t y of it f a i l i n g . You c o u ld make it do nothing , but that i g n o r e s an importan t consideration ; that i s, an attemp t to add somethin g to a leaf probabl y indicate s a bug. In that c a s e, the Add operatio n produce s garbage . You c o u ld make it d e l e t e its argument , but that migh t not be w h at c l i e n t s expect. U s u a l l y i t 's bette r to make Add and Remov e fail by defaul t (perhap s by raisin g an exception ) if the componen t isn't allowe d to have childre n or if the argumen t of Remov e isn't a c h i ld of the component , r e s p e c t i v e l y . Anothe r alternativ e is to chang e t he meanin g of \" r e m o v e \" s l i g h t l y . If the componen t maintain s a paren t r e f e r e n c e , then we could redefin e C o m p o n e n t : : R e m o v e to remov e i t s e lf from its parent . However , there s t i ll isn't a meaningfu l interpretatio n for a correspondin g Add. 5. Should Component implement a list of Components? You migh t be tempte d to defin e the set of c h i l d r e n as an instanc e variabl e in the Componen t c l a ss wher e the c h i ld a c c e s s and managemen t operation s are declared . But puttin g the c h i ld pointe r in the base c l a s s incur s a s p a ce penalt y for every leaf, e v en thoug h a l e af n e v er has children . T h is is worthwhil e o n ly if there are relativel y few c h i l d r e n in the structure. 6. Child ordering. Many d e s i g n s specif y an orderin g on the c h i l d r e n of Com- p o s i t e . In t he e a r l i e r G r a p h i c s e x a m p l e , o r d e r i n g m ay reflec t front-to-bac k o r d e r i n g . If C o m p o s i t e s represen t parse t r e e s, then compoun d statement s can be instance s of a C o m p o s i t e w h o s e childre n must be ordere d to reflec t the program. Whe n c h i ld orderin g is an i s s u e , you must d e s i g n c h i ld a c c e s s and man- agemen t interface s carefull y to manag e t he s e q u e n c e of c h i l d r e n . T he Itera- tor ( 2 5 7) p a t t e r n can guide you in this. 7. Caching to improve performance. If y ou n e ed to t r a v e r s e or s e a r c h c o m p o s i t i o n s frequently , the Composit e c l a ss can cache traversa l or s e a r c h informatio n abou t its c h i l d r e n . The Composit e can c a c he actua l result s or j u st informatio n that l e ts it short-circui t the traversa l or s e a r c h . For example , the Pictur e c l a ss f r om the Motivatio n exampl e c o u ld cache the boundin g box of its children . D u r i n g drawin g or s e l e c t i o n , t h is c a c h e d b o u n d i n g b ox l e ts t he P i c t u r e a v o id drawin g or s e a r c h i n g when its c h i l d r e n aren' t v i s i b l e in the curren t window. C h a n g e s to a c o m p o n e n t w i ll r e q u i r e i n v a l i d a t i n g t he c a c h e s of i ts p a r e n t s . T h is work s best when component s know their parents . So if you'r e using c a c h i n g , you n e ed to defin e an interfac e for t e l l i n g composite s that their c a c h e s a re i n v a l i d . 8. Who should delete components? In language s withou t garbag e c o l l e c t i o n , it's usuall y b e st to make a C o m p o s i t e r e s p o n s i b l e for d e l e t i n g its c h i l d r e n w h en it's destroyed . An exceptio n to t h is rule is when Leaf object s are immutabl e and thus can be shared. ptg1 70 STRUCTURAL PATTERNS CHAPTER 4 9. What's the best data structure for storing components? C o m p o s i t e s may use a variet y of data structures to s t o re their c h i l d r e n , i n c l u d i n g l i n k e d l i s t s, t r e e s, arrays , a nd hash t a b l e s . T he c h o i c e of data structur e d e p e n d s ( as always ) on efficiency . In fact, it i s n 't e v en n e c e s s a r y to use a general-purpos e data struc- ture at a l l. S o m e t i m e s c o m p o s i t e s have a variabl e for e a ch c h i l d , althoug h t h is require s e a ch s u b c l a s s of C o m p o s i t e to implemen t i ts o wn managemen t interface. S e e Interpreter (243) f o r a n example. Sample Code Equipmen t s u ch as computer s and s t e r eo component s are often organize d into part-whol e or containmen t h i e r a r c h i e s . F or e x a m p l e , a c h a s s i s c an c o n t a i n d r i v e s and plana r b o a r d s , a bus can contai n c a r d s , and a c a b i n e t can c o n t a i n c h a s s i s , b u s e s , and so forth . S u ch structure s can be m o d e l e d naturall y with the Composit e pattern. E q u i p m e n t c l a ss define s an interfac e for all equipmen t in the part-whol e hierar- c h y . class Equipment { public: virtual \" E q u i p m e n t ( ) ; c o n st c h a r* N a m e () { r e t u rn _name; } virtual Watt P o w e r ( ); virtual C u r r e n cy NetPrice() ; virtual C u r r e n cy DiscountPrice(); virtual void Add(Equipment*) ; virtual void Remove(Equipment*) ; virtual Iterator<Equipment*> * Createlterator(); p r o t e c t e d : E q u i p m e n t ( c o n s t char*); private: c o n st c h a r* _name; } ; E q u i p m e n t d e c l a r e s operation s that retur n the attribute s of a p i e ce of equipment , like i ts powe r consumptio n a nd c o s t. S u b c l a s s e s i m p l e m e n t t h e se o p e r a t i o n s f or s p e c i f i c kinds of equipment . E q u i p m e n t a l so d e c l a r e s a C r e a t e l t e r a t o r op- eratio n that return s an I t e r a t o r ( s ee Appendi x C) for a c c e s s i n g its parts . The defaul t implementatio n for t h is operatio n return s a Nulllterator , whic h iterate s o v er the empt y s e t . S u b c l a s s e s of E q u i p m e n t m i g h t i n c l u d e L e af c l a s s e s that represen t d i sk d r i v e s , integrated circuits, and switches: ptgCOMPOSITE 171 c l a ss F l o p p y D i s k : public Equipmen t { public: F l o p p y D i s k ( c o n s t c h a r * ); virtual \" F l o p p y D i s k ( ) ; virtual Watt P o w e r ( ); virtual C u r r e n cy NetPrice() ; v i r t u a l C u r r e n c y DiscountPrice(); } ; C o m p o s i t e E q u i p m e n t is the base c l a s s for e q u i p m e n t t h a t c o n t a i n s o t h e r e q u i p - ment. It's also a subclass o f E q u i p m e n t . c l a ss CompositeEquipmen t : public Equipmen t { p u b l i c : virtual ~CompositeEquipment(); virtual Watt P o w e r ( ); virtual C u r r e n cy NetPrice() ; virtual C u r r e n cy DiscountPrice(); virtual void Add(Equipment*) ; virtual void Remove(Equipment*) ; virtual Iterator<Equipment*> * Createlterator(); protected: CompositeEquipment(cons t char*); private: List<Equipment* > _equipment ; } ; C o m p o s i t e E q u i p m e n t define s the operation s for a c c e s s i n g and managin g subequipment . The operation s Add and Remov e i n s e r t and d e l e t e equip- ment f r om the l i st of equipmen t store d in the .equipmen t m e m b e r . The o p e r a t i o n C r e a t e l t e r a t o r return s an iterato r ( s p e c i f i c a l l y , an i n s t a n c e of L i s t l t e r a t o r ) that w i ll travers e this l i s t . A defaul t implementatio n of N e t P r i c e migh t use C r e a t e l t e r a t o r to sum the net prices of the subequipment 2: C u r r e n cy CompositeEquipment::NetPric e () { Iterator<Equipment*> * i = Createlterator() ; C u r r e n cy total = 0 ; f or ( i - > F i r s t ( ) ; ! i - > I s D o n e ( ) ; i - > N e x t ( ) ) { total += i->Current!tem()->NetPrice(); } delete i; r e t u rn total; } 2 It's e a sy to forge t to d e l e t e the iterato r o n ce you'r e d o ne with it. The Iterato r patter n s h o w s how to guard a g a i n s t s u c h b u g s on page 266. ptg1 72 STRUCTURAL PATTERNS CHAPTER 4 Now we can r e p r e s e n t a compute r c h a s s i s as a s u b c l a s s of Compo s i t e E q u i p m e n t c a l l e d C h a s s i s . C h a s s i s i n h e r i t s t h e c h i l d - r e l a t e d o p e r a t i o n s f r o m C o m - pos i t e E q u i p m e n t . c l a ss C h a s s is : public C o m p o s i t e E q u i p m e n t { public: C h a s s i s ( c o n s t c h a r * ); virtual \" C h a s s i s ( ) ; virtual Watt P o w e r ( ); virtual C u r r e n cy NetPrice() ; virtual C u r r e n cy DiscountPrice(); } ; We can defin e o t h er equipmen t c o n t a i n e r s s u ch as C a b i n e t and Bus in a s i m i l a r w a y. T h at g i v es us e v e r y t h i n g we n e ed to a s s e m b l e equipmen t i n to a (prett y s i m p l e ) p e r s o n a l c o m p u t e r : Cabinet* c a b i n et = new Cabinet(\"P C Cabinet\") ; C h a s s i s* c h a s s is = n ew Chassis(\"P C Chassis\"); cabinet->Add(chassis); B u s* b us = n ew B u s ( \" M CA Bus\"); b u s - > A d d ( n e w Card(\"16Mb s T o k en Ring\")); chassis->Add(bus) ; c h a s s i s - > A d d ( n e w FloppyDisk(\"3.Bin Floppy\")); c o u t « \"The n e t p r i c e i s \" « c h a s s i s - > N e t P r i c e ( ) « e n d l ; K n o w n Uses Example s of t he C o m p o s i t e patter n c an be found in a l m o s t a ll o b j e c t - o r i e n t e d s y s t e m s . T he o r i g i n a l V i ew c l a ss of S m a l l t a l k M o d e l / V i e w / C o n t r o l l e r [ K P 8 8 ] was a C o m p o s i t e , and nearl y e v e ry u s er interfac e toolki t or framewor k has fol- lowe d in i ts s t e p s , i n c l u d i n g ET++ (with i ts V O b j e c t s [ W G M 8 8 ] ) a nd I n t e r v i e w s ( S t y l e s [ L C I + 9 2 ] , Graphic s [ V L 8 8 ] , a nd G l y p h s [ C L 9 0 ] ) . It's i n t e r e s t i n g to note that t he o r i g i n a l V i ew of Model/View/Controlle r h ad a s et of s u b v i e w s ; in o t h er w o r d s , V i ew w as both t he C o m p o n e n t c l a ss a nd t he C o m p o s i t e c l a s s. R e l e a s e 4 .0 of S m a l l t a l k - 8 0 r e v i s e d Model/View/Controlle r with a VisualComponen t c l a ss that h as s u b c l a s s e s V i ew a nd C o m p o s i t e V i e w . T he R TL S m a l l t a l k c o m p i l e r framewor k [ J M L 9 2 ] u s es t he C o m p o s i t e patter n e x - t e n s i v e l y . R T L E x p r e s s i o n is a Componen t c l a ss f or parse t r e e s. It h as s u b c l a s s e s , s u ch as B i n a r y E x p r e s s i o n , that c o n t a i n c h i ld R T L E x p r e s s i o n o b j e c t s . T h e se c l a s s e s defin e a c o m p o s i t e structur e for parse t r e e s. RegisterTransfe r is the C o m p o n e n t c l a ss f or a program' s i n t e r m e d i a t e S i n g l e S t a t ic A s s i g n m e n t ( S S A ) form . L e af s u b c l a s s e s of RegisterTransfer define different s t a t i c a s s i g n m e n t s s u c h as ptgCOMPOSITE 1 7 3 • primitiv e assignment s that p e r f o r m an operatio n on two register s and a s s i g n the resul t to a third; • an assignmen t with a s o u r c e r e g i s t e r but no destinatio n register , whic h i n d i - c a t es that t he r e g i s t e r is u s ed after a r o u t i n e r e t u r n s ; a n d • an a s s i g n m e n t with a destinatio n registe r but no source , whic h indicate s that the registe r is a s s i g n e d befor e the routin e starts. A n o t h e r s u b c l a s s , R e g i s t e r T r a n s f e r S e t , is a C o m p o s i t e c l a ss f or r e p r e s e n t i n g a s - s ig nment s that chang e severa l register s at o n c e . A n o t h e r e x a m p l e of t h is patter n o c c u r s in t he f i n a n c i a l d o m a i n , w h e r e a portfoli o aggregate s individua l a s s e t s . You can suppor t comple x aggregation s of a s s e t s by i m p l e m e n t i n g a portfoli o as a C o m p o s i t e that conform s to the interfac e of an individua l a s s et [ B E 9 3 ] . T he Comman d ( 2 3 3) patter n d e s c r i b e s h ow Comman d o b j e c t s c an be compose d and sequenced with a MacroCommand Composite class. Related Patterns Often the component-paren t link is u s ed for a Chain of Responsibilit y ( 2 2 3 ) . D e c o r a t o r ( 1 7 5) is often u s ed with C o m p o s i t e . W h en d e c o r a t o r s a nd c o m p o s i t e s are u s ed together , they will usuall y have a commo n paren t c l a s s. So decorator s w i ll have to s u p p o r t t he C o m p o n e n t i n t e r f a c e with o p e r a t i o n s l i ke A d d, R e m o v e , and GetChild. F l y w e i g h t ( 1 9 5) l e ts y ou s h a re c o m p o n e n t s , b ut t h ey c an no l o n g e r refer to t h e ir parents. Iterato r ( 2 5 7) can be used to travers e composites. Visito r ( 3 3 1) localize s operation s and behavio r that woul d otherwis e be distribute d a c r o s s Composite and L e a f c l a s s e s . ptg This page intentionally left blank ptgDECORATOR 175 D E C O R A T O R O b j e c t Structural I n t e n t Attac h additiona l r e s p o n s i b i l i t i e s to an o b j e c t d y n a m i c a l l y . D e c o r a t o r s p r o v i d e a f l e x i b l e alternative to subclassing f o r extending functionality. A l s o Known As Wrapper Motivation S o m e t i m e s we want to a dd r e s p o n s i b i l i t i e s to i n d i v i d u a l o b j e c t s , n ot to an e n t i re c l a s s. A graphica l u s er interfac e t o o l k i t , for e x a m p l e , s h o u l d let you add p r o p e r t i e s l i ke b o r d e r s or behavior s l i ke s c r o l l i n g to any u s er interfac e component. One way to add r e s p o n s i b i l i t i e s is with inheritance . Inheritin g a borde r from anothe r c l a ss puts a b o r d e r aroun d e v e ry s u b c l a s s i n s t a n c e . T h is is i n f l e x i b l e , h o w e v e r , b e c a u s e t he c h o i c e of b o r d e r is m a de s t a t i c a l l y . A c l i e nt can't c o n t r o l how and when to decorat e the componen t with a b o r d e r . A m o re f l e x i b l e a p p r o a c h is to e n c l o s e t he c o m p o n e n t in a n o t h e r o b j e c t that a d ds t he b o r d e r . T he e n c l o s i n g o b j e c t is c a l l ed a d e c o r a t o r . T he decorato r conform s to t he interfac e of t he componen t it decorate s so that i ts p r e s e n c e is transparen t to t he component' s c l i e n t s . The d e c o r a t o r forward s r e q u e s t s to the componen t and may perfor m additiona l a c t i o n s (such as drawin g a border ) befor e or a f t er forwarding . T r a n s p a r e n c y l e ts y ou n e st d e c o r a t o r s r e c u r s i v e l y , thereb y a l l o w i n g an unlimite d number of added responsibilities. ptg1 7 6 STRUCTURAL PATTERNS CHAPTER 4 For e x a m p l e , suppos e we have a T e xt V i ew o b j e c t that display s text in a w i n d o w . T e xt V i ew has no s c r o ll bars by default , b e c a u s e we migh t not alway s n e ed them . Whe n we do, we can use a S c r o l l D e c o r a t o r to add them . S u p p o s e we a l so want to add a thick b l a ck b o r d e r aroun d the T e xt V i e w . We can use a BorderDecorato r to a dd this as w e l l. We s i m p l y c o m p o s e t he d e c o r a t o r s with t he T e xt V i ew to produc e the d e s i r e d result. The followin g o b j e c t diagra m show s how to c o m p o s e a T e xt V i ew o b j e c t with BorderDecorato r and S c r o l l D e c o r a t o r object s to produc e a b o r d e r e d , s c r o l l a b l e text view: T he S c r o l l D e c o r a t o r a nd BorderDecorato r c l a s s e s a re s u b c l a s s e s of Decorator , an abstract class for visual components that decorate other visual components. V i s u a l C o m p o n e n t is t he abstrac t c l a ss f or v i s u a l o b j e c t s . It define s t h e ir drawin g and event handlin g interface . Note how the D e c o r a t o r c l a ss s i m p l y forward s draw request s to its component , and how Decorato r s u b c l a s s e s can e x t e n d this operation. Decorato r s u b c l a s s e s are free to add operation s for s p e c i f i c functionality . For ex- a m p l e , S c r o l l D e c o r a t o r ' s S c r o l l T o operatio n l e ts other object s s c r o ll t he interfac e if they know the re happen s to be a S c r o l l D e c o r a t o r o b j e c t in the interface . The important aspect of this pattern is that it lets decorators appear anywhere a Vi- sualComponent can. That way clients generally can't tell the difference b e t w e e n ptgDECORATOR 1 7 7 a decorate d componen t and an undecorate d o n e, and so they don't depen d at all o n the d e c o r a t i o n . Applicability U se D e c o r a t o r • to add r e s p o n s i b i l i t i e s to i n d i v i d u a l o b j e c t s dynamicall y and transparently , that is, withou t affectin g other objects. • for r e s p o n s i b i l i t i e s that can be withdrawn. • when e x t e n s i o n by s u b c l a s s i n g is i m p r a c t i c a l . S o m e t i m e s a l a r ge numbe r of independen t extension s are possibl e and woul d produc e an e x p l o s i o n of s u b c l a s s e s to suppor t every combination . Or a c l a ss definitio n m a y b e h i d d e n or otherwise unavailable for subclassing. S t r u c t u r e P a r t i c i p a n t s • Componen t ( V i s u a l C o m p o n e n t ) - define s the interfac e for object s that can have responsibilitie s adde d to them dynamically. • C o n c r e t e C o m p o n e n t (TextView) - d e f i n e s an o b j e c t to w h i ch a d d i t i o n a l r e s p o n s i b i l i t i e s c an be attached. • Decorator - maintain s a referenc e to a Componen t objec t and define s an interfac e that conforms to Component's i n t e r f a c e . ptg1 7 8 STRUCTURAL P A T T E R N S CHAPTER 4 • ConcreteDecorator ( B o r d e r D e c o r a t o r , ScrollDecorator) - adds responsibilities to the c o m p o n e n t . C o l l a b o r a t i o n s • Decorator forwards requests to its Component object. It may optionally per- f o r m additional operations before and a f t e r forwarding t h e request. C o n s e q u e n c e s The Decorato r patter n has at l e a st two key benefit s and two l i a b i l i t i e s : 1. More flexibility than static inheritance. T he Decorato r patter n p r o v i d e s a more flexibl e way to add r e s p o n s i b i l i t i e s to object s than can be had with static ( m u l t i p l e ) i n h e r i t a n c e . W i th d e c o r a t o r s , r e s p o n s i b i l i t i e s c an be a d d e d a nd remove d at run-tim e s i m p l y by attachin g and d e t a c h i n g them . In contrast , i n h e r i t a n c e r e q u i r e s c r e a t i n g a n ew c l a ss f or e a ch a d d i t i o n a l r e s p o n s i b i l - i ty ( e . g ., B o r d e r e d S c r o l l a b l e T e x t V i e w , BorderedTextView) . T h is g i v es r i se to many c l a s s e s a nd i n c r e a s e s t he c o m p l e x i t y of a s y s t e m . Furthermore , p r o v i d - ing differen t Decorato r c l a s s e s for a s p e c i f i c Componen t c l a ss l e ts you mix and matc h r e s p o n s i b i l i t i e s . Decorator s also make it e a sy to add a propert y twice . For example , to g i ve a T e xt V i ew a doubl e border , s i m p l y attac h two BorderDecorators . I n h e r i t i n g f r om a B o r d e r c l a ss twice is error-pron e at best. 2. Avoids feature-laden classes high up in the hierarchy. D e c o r a t o r offer s a p a y - a s - y o u - g o approac h to addin g r e s p o n s i b i l i t i e s . Instea d of tryin g to suppor t a ll f o r e s e e a b l e feature s in a c o m p l e x , c u s t o m i z a b l e c l a s s, y ou c an d e f i n e a s i m p l e c l a ss and add functionalit y incrementall y with Decorato r objects . Functionalit y c an be c o m p o s e d from s i m p l e p i e c e s . As a r e s u l t , an applicatio n needn' t pay for feature s it doesn' t u s e. I t 's a l so easy to defin e new k i n ds of Decorator s independentl y f r om the c l a s s e s of object s they extend , e v en for unforesee n e x t e n s i o n s . Extendin g a c o m p l e x c l a ss tends to e x p o s e d e t a i l s unrelate d to the r e s p o n s i b i l i t i e s you'r e adding. 3. A decorator and its component aren't identical. A decorato r acts as a transparen t e n c l o s u r e . But from an objec t identit y point of v i e w , a decorate d c o m p o n e n t is not identica l to the componen t itself . H e n c e you shouldn' t r e ly on o b j e c t identit y when you use decorators. 4.Lots of little objects. A d e s i g n that u s es Decorato r often result s in s y s t e m s c o m p o s e d of l o ts of l i t t le o b j e c t s that a ll l o ok a l i k e. T he o b j e c t s differ o n ly in t he w ay they a re i n t e r c o n n e c t e d , n ot in their c l a ss or in t he value of t h e ir v a r i a b l e s . A l t h o u g h t h e se s y s t e m s a re e a sy to c u s t o m i z e by t h o se w ho understand them, they can be hard to learn and debug. ptgDECORATOR 179 Implementation S e v e r a l i s s u e s s h o u l d be c o n s i d e r e d when applyin g the Decorato r pattern: 1.Interface conformance. A d e c o r a t o r o b j e c t ' s interfac e must c o n f o r m to t he i n t e r - f a ce of the componen t it decorates . ConcreteDecorato r c l a s s e s must therefor e i n h e r i t from a c o m m o n c l a ss ( at l e a st in C++). 2. Omitting the abstract Decorator class. T h e r e ' s no n e ed to defin e an abstrac t Decorato r c l a ss when you o n ly n e ed to add one r e s p o n s i b i l i t y . That' s often the c a se when you'r e dealin g with an e x i s t i n g c l a ss hierarch y rathe r than d e s i g n i n g a new o n e. In that c a s e, you can m e r g e Decorator' s r e s p o n s i b i l i t y for forwardin g request s to the componen t into the C o n c r e t e D e c o r a t o r . 3. Keeping Component classes lightweight. To ensur e a conformin g interface , c o m - p o n e n t s a nd d e c o r a t o r s must d e s c e n d from a c o m m o n C o m p o n e n t c l a s s. It's importan t to keep this c o m m o n c l a ss lightweight ; that is, it s h o u l d fo- c us on d e f i n i n g an interface , n ot on s t o r i n g data . T he d e f i n i t i o n of t he data representatio n shoul d be deferre d to s u b c l a s s e s ; o t h e r w i s e the c o m p l e x i t y of t he C o m p o n e n t c l a ss m i g h t make t he d e c o r a t o r s t oo h e a v y w e i g h t to u se in quantity . Puttin g a lot of functionalit y into Componen t a l so i n c r e a s e s the p r o b a b i l i t y that c o n c r e t e s u b c l a s s e s w i ll p ay f or feature s t h ey d o n 't n e e d . 4. Changing the skin of an object versus changing its guts. We can think of a d e c o - rator as a s k in over an objec t that change s its behavior . An alternativ e is to chang e t he object' s guts. T he Strateg y ( 3 1 5) patter n is a g o od exampl e of a patter n for c h a n g i n g the guts. S t r a t e g i e s are a bette r c h o i c e in situation s wher e the C o m p o n e n t c l a ss is intrinsicall y heavyweight , thereb y makin g the Decorato r patter n too c o s t ly to a p p l y . In the Strateg y pattern , the componen t forward s s o me of its b e h a v i o r to a separat e strateg y object . The Strateg y patter n l e ts us alter or exten d the component' s functionalit y by replacin g the strateg y object. For e x a m p l e , we can suppor t differen t borde r s t y l es by h a v i n g the c o m p o n e n t defer b o r d e r - d r a w i n g to a s e p a r a t e B o r d e r o b j e c t . T he B o r d e r o b j e c t is a Strateg y o b j e c t that encapsulate s a border-drawin g strategy . By e x t e n d i n g t he n u m b e r of s t r a t e g i e s from just o ne to an o p e n - e n d e d l i s t, we a c h i e v e t he same effec t as nestin g decorator s r e c u r s i v e l y . In M a c A p p 3 .0 [ A p p 8 9 ] a nd B e d r o c k [ S y m 9 3 a ] , f or e x a m p l e , g r a p h i c a l c o m - ponent s ( c a l l e d \" v i e w s \" ) maintai n a l i st of \"adorner \" o b j e c t s that can attac h a d d i t i o n a l adornment s l i ke b o r d e r s to a v i ew c o m p o n e n t . If a v i ew h as a ny adorner s attached , then it g i v es them a c h a n c e to draw additiona l e m b e l l i s h - m e n t s . MacAp p a nd B e d r o c k must u se t h is a p p r o a c h b e c a u s e t he V i ew c l a ss is heavyweight . It woul d be too e x p e n s i v e to use a full-fledge d V i ew just to add a b o r d e r . S i n ce the Decorato r patter n o n ly c h a n g e s a componen t f r om the o u t s i d e , the componen t d o e s n ' t have to know anythin g abou t its decorators ; that is, the decorators are transparent to the component: ptg1 8 0 STRUCTURAL P A T T E R N S CHAPTER 4 With strategies , t he componen t i t s e lf know s abou t p o s s i b l e e x t e n s i o n s . So it has to reference and maintain the corresponding strategies: The Strategy-base d approac h migh t r e q u i r e modifyin g the c o m p o n e n t to accommodat e new e x t e n s i o n s . On the other hand , a strateg y can have its own s p e c i a l i z e d interface , wherea s a decorator' s interfac e must confor m to the component's . A strateg y for r e n d e r i n g a border , for example , n e ed o n ly defin e the interfac e for renderin g a borde r (DrawBorder , GetWidth , e t c . ), whic h mean s that the strateg y can be lightweigh t e v en if the C o m p o n e n t c l a ss is heavyweight. MacAp p and B e d r o c k use this approac h for more than j u st adornin g views . T h ey a l so u se it to a u g m e n t t he e v e n t - h a n d l i n g b e h a v i o r of o b j e c t s . In b o th s y s t e m s , a v i ew maintain s a l i st of \" b e h a v i o r \" o b j e c t s that can modif y and intercep t e v e n t s . T he v i ew g i v es e a ch of t he r e g i s t e r e d behavio r object s a c h a n c e to h a n d l e t he e v e nt befor e n o n r e g i s t e r e d b e h a v i o r s , e f f e c t i v e l y o v e r - riding them . You can decorat e a v i ew with specia l keyboard-handlin g s u p - port, for example , by registerin g a behavio r objec t that intercept s and h a n d l e s k e y events. S a m p l e C o d e The followin g c o de s h o w s how to implemen t user interfac e decorator s in C++. W e ' l l assume there's a Component class called VisualComponent. c l a ss VisualComponen t { public: VisualComponent(); virtual void Draw(); virtual void Resize(); // . . . } ; ptgDECORATOR 181 W e define a subclass of V i s u a l C o m p o n e n t called Decorator, which we'll sub- c l a s s to obtain different d e c o r a t i o n s . class Decorato r : public VisualComponen t { public: Decorator(VisualComponent*); virtual void Draw(); virtual void Resize(); // . . - private: VisualComponent * _component ; } ; D e c o r a t o r decorate s the V i s u a l C o m p o n e n t reference d by the - c o m p o n e n t instanc e variable , whic h is initialize d in t he constructor . F or e a ch operatio n in V i s u a l C o m p o n e n t ' s interface , D e c o r a t o r define s a d e f a u l t implementatio n that passes the request on to -component: v o id D e c o r a t o r : : D r a w () { _component->Draw() ; } void Decorator::Resiz e () { _component->Resize() ; } S u b c l a s s e s of D e c o r a t o r d e f i n e s p e c i f i c d e c o r a t i o n s . F or e x a m p l e , t he c l a s s B o r d e r D e c o r a t o r a d ds a b o r d e r to its e n c l o s i n g c o m p o n e n t . B o r d e r - D e c o r a t o r is a s u b c l a s s of D e c o r a t o r t h at o v e r r i d e s t he Draw o p e r a t i o n to d r aw the b o r d e r . B o r d e r D e c o r a t o r a l so d e f i n e s a privat e D r a w B o r d e r h e l p e r o p e r a t i o n that does the drawing. The subclass inherits all other operation imple - m e n t a t i o n s from Decorator. c l a ss BorderDecorato r : public Decorato r { public: BorderDecorator(VisualComponent* , int borderWidth); virtual void D r a w ( ); p r i v a t e : void D r a w B o r d e r ( i n t ) ; private: int _width; } ; void BorderDecorator::Draw () { Decorator::Draw(); DrawBorder(_width); } ptg1 82 STRUCTURAL PATTERNS CHAPTER 4 A s i m i l a r implementatio n woul d follow for S c r o l l D e c o r a t o r and D r o p - S h a d o w D e c o r a t o r , w h i c h woul d a dd s c r o l l i n g a nd d r op s h a d o w c a p a b i l i t i e s to a v i s u a l component. N ow we c an c o m p o s e i n s t a n c e s of t h e se c l a s s e s to p r o v i d e differen t d e c o r a t i o n s . T he followin g c o de illustrate s h ow we c an u se decorator s to c r e a t e a bordere d s c r o l l a b l e T e xt View. F i r s t, we n e ed a way to put a visua l c o m p o n e n t i n to a w i n d o w o b j e c t . W e ' ll a s s u m e our Window class provides a SetContents operation for this purpose: void W i n d o w : : S e t C o n t e n t s ( V i s u a l C o m p o n e n t * c o n t e n t s) { // . - . } N o w we can create the text view and a window to put it in: W i n d o w * window = new Window; T e x t V i e w * t e x t V i e w = new TextView; T e x t V i e w is a VisualComponent, w h i c h l e t s us put it into t h e w i n d o w : w i n d o w - > S e t C o n t e n t s ( t e x t V i e w ) ; B ut we want a b o r d e r e d a nd s c r o l l a b l e TextView . So we d e c o r a t e it a c c o r d i n g l y before putting it in the window. w i n d o w - > S e t C o n t e n t s ( n e w BorderDecorator( new ScrollDecorator(textView), 1 B e c a u s e W i n d o w a c c e s s e s its c o n t e n t s t h r o u g h the V i s u a l C o m p o n e n t interface , i t 's unawar e of t he decorator' s p r e s e n c e . Y o u, as t he c l i e n t , c an s t i ll k e ep track of t he text v i ew if y ou have to interac t with it d i r e c t l y , f or e x a m p l e , w h en y ou n e ed to i n v o k e o p e r a t i o n s that aren't part of the V i s u a l C o m p o n e n t interface . C l i e n t s that rely on the component's identity should refer to it directly as well. K n o w n Uses M a ny o b j e c t - o r i e n t e d u s er interfac e t o o l k i t s use decorator s to add g r a p h i - c al e m b e l l i s h m e n t s to w i d g e t s . E x a m p l e s i n c l u d e I n t e r v i e w s [ L V C 8 9 , L C I + 9 2 ] , ET++ [ W G M 8 8 ] , a nd t he O b j e c t W o r k s \\ S m a l l t a l k c l a ss librar y [ P a r 9 0 ] . M o re e x - o t ic a p p l i c a t i o n s of D e c o r a t o r a re t he D e b u g g i n g G l y p h from I n t e r v i e w s a nd t he P a s s i v i t y W r a p p e r f r o m P a r c P l a c e S m a l l t a l k . A DebuggingGlyph prints o u t d e - b u g g i n g i n f o r m a t i o n b e f o r e and a f t e r i t forwards a layout request to its compo - n e n t . T h i s t r a c e i n f o r m a t i o n can be u s e d to analyze and debug the layout behavior ptgDECORATOR 1 8 3 of object s in a comple x composition . The Passivit y Wrappe r can enabl e or disabl e u s er i n t e r a c t i o n s with t he c o m p o n e n t . But the Decorato r patter n is by no mean s limite d to graphica l user interfaces , as the followin g exampl e ( b a s e d on t he ET++ streamin g c l a s s e s [ W G M 8 8 ] ) illustrates. Stream s are a f u n d a m e n t a l abstractio n in most I/O facilities . A strea m can provid e an interfac e for convertin g object s into a s e q u e n c e of bytes or characters . T h at l e ts us transcrib e an objec t to a file or to a string in memor y for retrieva l later. A straightforwar d way to do this is to defin e an abstrac t Strea m c l a ss with s u b c l a s s e s MemoryStrea m and FileStream . But suppos e we also want to be able to do the following: • C o m p r e s s t he s t r e am data u s i ng differen t c o m p r e s s i o n a l g o r i t h m s ( r u n - lengt h e n c o d i n g , Lempel-Ziv , etc.). • Reduc e the strea m data to 7 - b it A S C I I character s so that it can be transmitte d over an A S C I I communicatio n channel. The Decorato r p a t t e r n g i v es us an elegan t way to add t h e se r e s p o n s i b i l i t i e s to streams. The diagram below shows one solution to the problem: The Strea m abstrac t c l a ss maintain s an interna l b u f f e r and provide s operation s for s t o r i n g data o n to t he s t r e am ( P u t l n t , P u t S t r i n g ) . W h e n e v e r t he b u f f e r is full, S t r e a m c a l ls the abstrac t operatio n HandleBufferFull , whic h d o es the a c t u a l data transfer . T he F i l e S t r e a m v e r s i o n of t h is o p e r a t i o n o v e r r i d e s t h is o p e r a t i o n to transfe r t he b u f f e r to a file. T he key c l a ss h e re is StreamDecorator , w h i c h maintain s a referenc e to a c o m - ponen t stream and forward s request s to it. StreamDecorato r s u b c l a s s e s overrid e HandleBufferFull a n d p e r f o r m a d d i t i o n a l a c t i o n s b e f o r e c a l l i n g S t r e a m D e c o r a - tor's HandleBufferFull o p e r a t i o n . ptg1 84 STRUCTURAL PATTERNS CHAPTER 4 F or e x a m p l e , t he C o m p r e s s i n g S t r e a m s u b c l a s s c o m p r e s s e s t he data, a nd t he A S C I I 7 S t r e a m c o n v e r t s t he data i n to 7 - b it A S C I I . N o w , to creat e a F i l e S t r e a m that c o m p r e s s e s i ts data a nd c o n v e r t s t he c o m p r e s s e d binar y data to 7 - b it A S C I I , we decorat e a F i l e S t r e a m with a C o m p r e s s i n g S t r e a m and an A S C I I 7 S t r e a m : S t r e a m* a S t r e am = n ew C o m p r e s s i n g S t r e a m ( n ew A S C I I 7 S t r e a m ( n ew FileStream(\"aFileName\" ) ) ) ; a S t r e a m - > P u t ! n t ( 1 2 ) ; aStream->PutString(\"aString\"); R e l a t e d P a t t e r n s Adapte r ( 1 3 9 ) : A decorato r is differen t from an adapte r in that a decorato r o n ly c h a n g e s an object' s r e s p o n s i b i l i t i e s , n ot i ts interface ; an adapte r w i ll g i ve an o b j e c t a c o m p l e t e l y new interface. C o m p o s i t e ( 1 6 3 ) : A decorato r c an be v i e w e d as a degenerat e c o m p o s i t e with o n ly one c o m p o n e n t . H o w e v e r , a decorato r adds additiona l r e s p o n s i b i l i t i e s — i t isn't i n t e n d e d for o b j e c t aggregation. Strateg y ( 3 1 5 ) : A decorato r l e ts y ou c h a n g e t he s k in of an o b j e c t ; a strateg y l e ts y o u change the guts. These are two alternative ways of c h a n g i n g an object. ptgFACADE 185 F A C A D E O b j e c t Structural I n t e n t P r o v i d e a unifie d interfac e to a set of interface s in a s u b s y s t e m . Facad e define s a h i g h e r - l e v e l i n t e r f a c e t h a t m a k e s the subsystem easier to use. Motivation Structurin g a syste m i n to subsystem s h e l ps reduc e c o m p l e x i t y . A commo n d e s i g n g o al is to m i n i m i z e t he communicatio n a nd d e p e n d e n c i e s betwee n subsystems . One way to a c h i e v e t h is g o a l is to introduc e a facad e objec t that provide s a s i n g l e , s i m p l i f i e d interface to the more general facilities of a subsystem. C o n s i d e r f or e x a m p l e a programmin g e n v i r o n m e n t that g i v es a p p l i c a t i o n s a c c e s s to i ts c o m p i l e r s u b s y s t e m . T h is subsyste m c o n t a i n s c l a s s e s s u ch as S c a n n e r , Parser , ProgramNode , B y t e c o d e S t r e a m , and ProgramNodeBuilde r that implemen t the c o m p i l e r . S o me s p e c i a l i z e d a p p l i c a t i o n s m i g h t n e ed to a c c e s s t h e se c l a s s e s d i r e c t l y . But m o st c l i e n t s of a compile r g e n e r a l l y don't c a re abou t detail s l i ke parsin g and c o de g e n e r a t i o n ; they m e r e l y want to c o m p i l e s o me c o d e. For t h e m , the p o w e r f u l but l o w - l e v e l interface s in the c o m p i l e r s u b s y s t e m o n ly complicat e their task. To provid e a h i g h e r - l e v e l interfac e that c an s h i e ld c l i e n t s from t h e se c l a s s e s , t he c o m p i l e r subsyste m a l so i n c l u d e s a C o m p i l e r c l a s s . T h is c l a ss d e f i n e s a unifie d interfac e to the compiler' s functionality . The C o m p i l e r c l a ss acts as a facade : It offer s c l i e n t s a s i n g l e , s i m p l e interfac e to the compile r subsystem . It g l u es togethe r the c l a s s e s that implemen t c o m p i l e r functionalit y withou t h i d i n g them c o m p l e t e l y . The c o m p i l e r facad e make s life e a s i e r for most programmer s withou t h i d i n g the l o w e r - l e v e l f u n c t i o n a l i t y from the few that need it. ptg1 8 6 STRUCTURAL PATTERNS CHAPTER 4 A p p l i c a b i l i t y Use the Facad e patter n when • you w a nt to provid e a s i m p l e interfac e to a comple x subsystem . S u b s y s t e m s o f t en get more comple x as they e v o l v e . M o st patterns , when applied , r e s u l t in more and s m a l l e r c l a s s e s . T h is make s the subsyste m more reusabl e and e a s i e r to customize , but it also b e c o m e s harde r to use for c l i e n t s that don't n e ed to customiz e it. A facad e can provid e a s i m p l e defaul t view of the subsyste m that is g o od enoug h for most c l i e n t s . O n ly c l i e n t s needin g more customizabilit y will n e ed to l o ok beyon d the facade. • there are many d e p e n d e n c i e s betwee n c l i e n t s and the implementatio n c l a s s e s of an abstraction . Introduc e a facad e to d e c o u p l e the subsyste m from c l i e n t s and other subsystems , thereb y promotin g subsyste m i n d e p e n d e n c e and portability. • you want to layer your subsystems . Use a facad e to defin e an entry point to each s u b s y s t e m l e v e l . If subsystem s are dependent , then you can simplif y the d e p e n d e n c i e s betwee n them by makin g them communicat e with e a ch other solely through their facades. ptgF A C A D E 187 S t r u c t u r e P a r t i c i p a n t s • Facade ( C o m p i l e r ) - knows which subsystem classes are r e s p o n s i b l e for a request. - delegates client requests to a p p r o p r i a t e s u b s y s t e m objects. • subsystem classes ( S c a n n e r , Parser, ProgramNode, etc.) -i m p l e m e n t s u b s y s t e m functionality. -handle w o r k assigned by the F a c a d e object. -have no knowledge of t h e facade; that is, t h e y k e e p no references to it. C o l l a b o r a t i o n s • C l i e n t s c o m m u n i c a t e with t he s u b s y s t e m by s e n d i n g r e q u e s t s to F a c a d e , w h i c h forward s them to the appropriat e s u b s y s t e m o b j e c t ( s ) . A l t h o u g h the s u b s y s t e m o b j e c t s perfor m the actua l work , the facad e may have to do work of its own to translate its interface to subsystem interfaces. • Clients that use the facade don't have to access its subsystem objects d i r e c t l y . C o n s e q u e n c e s The F a c a d e patter n offer s the f o l l o w i n g benefits: 1. It s h i e l d s c l i e n t s from s u b s y s t e m c o m p o n e n t s , thereb y r e d u c i n g t he numbe r of o b j e c t s that c l i e n t s d e al with a nd makin g t he s u b s y s t e m e a s i e r to u s e . 2. It p r o m o t e s weak c o u p l i n g b e t w e e n t he s u b s y s t e m a nd i ts c l i e n t s . Often t he c o m p o n e n t s in a s u b s y s t e m a re s t r o n g l y c o u p l e d . Weak c o u p l i n g l e ts y ou vary the components of the subsystem without affecting i t s clients. Facades ptg1 88 STRUCTURAL PATTERNS CHAPTER 4 h e lp layer a syste m and the d e p e n d e n c i e s betwee n objects . T h ey can e l i m i - nate c o m p l e x or circula r d e p e n d e n c i e s . T h is can be an importan t c o n s e q u e n c e when the c l i e n t and the subsyste m are implemente d i n d e p e n d e n t l y . Reducin g compilatio n d e p e n d e n c i e s is vital in large softwar e s y s t e m s . Y ou want to s a ve time by minimizin g recompilatio n when subsyste m c l a s s e s c h a n g e . Reducin g compilatio n d e p e n d e n c i e s with facade s can l i m it the re- compilatio n n e e d e d for a smal l c h a n g e in an importan t subsystem . A facad e can a l so simplif y portin g system s to other platforms , becaus e it's l e ss l i k e ly that buildin g one subsyste m r e q u i r e s buildin g all others. 3. It d o e s n ' t preven t application s f r om using subsyste m c l a s s e s if they n e ed t o. T h u s you can choose between ease of use and generality. Implementation C o n s i d e r the followin g i s s u e s when implementin g a facade: 1. Reducing client-subsystem coupling. T he couplin g betwee n c l i e n t s a nd t he s u b - syste m can be r e d u c e d e v en f u r t h e r by makin g Facad e an abstrac t c l a ss with c o n c r e t e s u b c l a s s e s for differen t implementation s of a subsystem . T h en c l i e n t s can communicat e with the subsyste m throug h the interfac e of the ab- strac t Facad e c l a s s . T h is abstrac t c o u p l i n g keep s c l i e n t s f r om knowin g whic h implementatio n of a subsyste m is u s e d . An alternativ e to s u b c l a s s i n g is to configur e a Facad e o b j e c t with differen t subsyste m objects . To customiz e t he facade , s i m p l y r e p l a c e o ne or more of its s u b s y s t e m objects. 2. Public versus private subsystem classes. A subsyste m is a n a l o g o u s to a c l a ss in that both have interfaces , and both encapsulat e something— a c l a ss e n c a p s u - lates state and operations , w h i le a subsyste m encapsulate s c l a s s e s . And just as it's usefu l to think of the publi c and privat e interfac e of a c l a s s, we can think of the publi c and privat e interfac e of a subsystem. The p u b l i c interfac e to a subsyste m c o n s i s t s of c l a s s e s that all c l i e n t s can a c c e s s ; the privat e interfac e is j u st for subsyste m extenders . The Facad e c l a ss is part of the publi c interface , of c o u r s e , but it's not the o n ly part. O t h e r subsyste m c l a s s e s a re usuall y publi c as well. F or e x a m p l e , t he c l a s s e s Parse r and S c a n n e r in the c o m p i l e r subsyste m are part of the publi c interface. Makin g subsyste m c l a s s e s privat e woul d be useful , but few o b j e c t - o r i e n t e d language s suppor t it. B o th C++ and Smalltal k traditionall y have had a g l o b a l name space for c l a s s e s . Recently , h o w e v e r , the C++ standardizatio n c o m m i t - tee adde d name s p a c e s to the languag e [ S t r 9 4 ] , whic h will let you e x p o s e j u st the public subsystem classes. S a m p l e Code L e t ' s t a k e a closer look at how to put a facade on a compiler subsystem. ptgFACADE 1 8 9 The c o m p i l e r subsyste m define s a B y t e c o d e S t r e a m c l a ss that implement s a strea m of B y t e c o d e objects . A B y t e c o d e objec t encapsulate s a bytecode , w h i c h can specif y m a c h i n e instructions . The subsyste m a l so define s a T o k e n c l a ss for o b j e c t s that encapsulat e token s in the programmin g language. The S c a n n e r c l a ss takes a stream of character s and produce s a stream of t o k e n s , one token at a time. class S c a n n er { public: Scanner(istream&) ; virtual \"Scanner(); virtual T o k e n& Scan(); private: i s t r e a m& _inputStream ; } ; The c l a ss P a r s e r u s es a P r o g r a m N o d e B u i l d e r to construc t a parse tree f r om a S c a n n e r ' s tokens. class P a r s er { p u b l i c : Parser() ; virtual \" P a r s e r ( ) ; virtual void Parse(Scanners , ProgramNodeBuilder&) ; } ; P a r s e r calls back on ProgramNodeBuilder t o build t h e parse tree incremen - t a l l y . These classes interact according to the Builder (97) pattern. class ProgramNodeBuilde r { public: ProgramNodeBuilder(); virtual ProgramNode * NewVariable ( c o n st char* variableName ) const; v i r t u al P r o g r a m N o d e * N e w A s s i g n m e n t ( ProgramNode * variable , ProgramNode * expressio n ) const; virtual ProgramNode * NewReturnStatement( ProgramNode * value ) const; virtual ProgramNode * NewCondition ( ProgramNode * condition , ProgramNode * truePart , ProgramNode * falsePart ) const; // . . . ptg1 9 0 STRUCTURAL P A T T E R N S CHAPTER 4 P r o g r a m N o d e * GetRootNode() ; private: P r o g r a m N o d e * _node; } ; The parse tree is made up of i n s t a n c e s of P r o g r a m N o d e s u b c l a s s e s such as S t a t e m e n t Node , E x p r e s s i o n N o d e , and so forth . The P r o g r a m N o d e hierarch y is an exampl e of the Composit e ( 1 6 3) pattern . P r o g r a m N o d e define s an interfac e for m a n i p u l a t i n g t h e program node a n d i t s children, if a n y . c l a ss P r o g r a m N o d e { public: // p r o g r am n o de manipulatio n virtual void GetSourcePosition(int & line, i n t& i n d e x ); // . . . // child manipulatio n virtual void Add(ProgramNode*) ; virtual void Remove(ProgramNode*) ; // . . . virtual void T r a v e r s e ( C o d e G e n e r a t o r & ) ; protected: P r o g r a m N o d e ( ) ; } ; The T r a v e r s e operatio n takes a C o d e G e n e r a t o r object . P r o g r a m N o d e s u b - c l a s s e s use t h is objec t to generat e machin e c o de in the f o rm of B y t e c o d e o b j e c t s on a BytecodeS t r e a m . T h e c l a s s CodeGenerator is a visitor (see Visitor ( 3 3 1 ) ) . c l a ss C o d e G e n e r a t o r { public: virtual void Visit(StatementNode*) ; virtual void Visit(ExpressionNode*); // . . . protected: C o d e G e n e r a t o r ( B y t e c o d e S t r e a m & ) ; protected: BytecodeStream k _output; } ; C o d e G e n e r a t o r has s u b c l a s s e s , for example , S t a c k M a c h i n e C o d e G e n e r a t o r and R I S C C o d e G e n e r a t o r , that generat e m a c h i n e c o de for differen t hardwar e a r c h i t e c t u r e s . E a ch s u b c l a s s of P r o g r a m N o d e implement s T r a v e r s e to c a ll T r a v e r s e on its c h i ld P r o g r a m N o d e o b j e c t s . In turn, e a ch c h i ld d o es the same for its c h i l d r e n , and so on recursively. For example, ExpressionNode defines Traverse as follows: ptgF A C A D E 191 void ExpressionNode::Travers e ( C o d e G e n e r a t o r & eg) { eg.Visit(this); ListIterator<PrograinNode* > i ( _ c h i l d r e n ) ; for ( i. First ( ); ! i . I s D o ne () ; i.NextO) { i.Currentltem()->Traverse(eg) ; } The c l a s s e s we've d i s c u s s e d so far make up the c o m p i l e r subsystem . Now we'll in- troduc e a C o m p i l e r c l a s s, a facad e that p u ts all t h e se p i e c e s together . C o m p i l e r p r o v i d e s a simple interface f o r compiling source and g e n e r a t i n g c o d e for a par- ticular machine. class Compiler { public: Compiler(); virtual void Compile(istream& , BytecodeStream&) ; } ; void Compiler::Compil e ( i s t r e a m& i n p u t, BytecodeStream k o u t p u t ) { S c a n n er scanner(input); ProgramNodeBuilde r builder; P a r s er parser; parser.Parse(scanner , builder); RISCCodeGenerato r generator(output) ; P r o g r a m N o d e * p a r s e T r e e = builder.GetRootNode() ; parseTree->Traverse(generator); T h is i m p l e m e n t a t i o n h a r d - c o d e s t he type of c o de generato r to u se so that program- mers aren' t require d to specif y the targe t architecture . That migh t be r e a s o n a b l e if there' s o n ly e v er one targe t architecture . If that's not the c a s e, then we migh t want to c h a n g e the C o m p i l e r constructo r to take a C o d e G e n e r a t o r parameter . T h en programmer s can specif y the generato r to use when they instantiat e C o m p i l e r . The compile r facad e can parameteriz e other participant s such as S c a n n e r and P r o g r a m N o d e B u i l d e r as w e l l, whic h adds flexibility , but it a l so detract s f r om the Facad e pattern' s m i s s i o n , whic h is to simplif y the interfac e for the commo n case. K n o w n Uses The compiler example in the Sample Code section was i n s p i r e d b y t h e O b j e c t - Works\\Smalltalk compiler system [Par90]. ptg1 9 2 STRUCTURAL PATTERNS CHAPTER 4 In the ET++ applicatio n f r a m e w o r k [ W G M 8 8 ] , an applicatio n can have built-i n browsin g t o o ls for i n s p e c t i n g its object s at run-time . T h e se browsin g t o o ls are implemente d in a separat e subsyste m that include s a Facad e c l a ss c a l l ed \" P r o - grammingEnvironment. \" T h is f a c a d e define s operation s s u ch as I n s p e c t O b j e c t and InspectClas s for a c c e s s i n g the browsers. An ET++ applicatio n can a l so forgo built-i n browsin g support . In that c a s e, P r o - grammingEnvironmen t implement s t h e se request s as null operations ; that i s, they do nothing . O n ly t he ETProgrammingEnvironmen t subclas s implement s t h e se r e - q u e s t s with o p e r a t i o n s that d i s p l a y t he c o r r e s p o n d i n g b r o w s e r s . T he a p p l i c a t i o n has no knowledg e of whethe r a browsin g environmen t is availabl e or not; t h e r e ' s abstrac t c o u p l i n g betwee n the applicatio n and the browsin g subsystem. The C h o i c e s operatin g syste m [ C I R M 9 3 ] uses facade s to compos e many frame- work s into o n e. The key abstraction s in C h o i c e s are p r o c e s s e s , storage , and ad- d r e ss s p a c e s . F or each of t h e se abstraction s t h e re is a c o r r e s p o n d i n g s u b s y s t e m , implemente d as a f r a m e w o r k , that support s portin g C h o i c e s to a variet y of dif- feren t hardwar e platforms . Two of these subsystem s have a \"representative \" ( i . e ., facade). These representatives are FileSystemlnterface (storage) a n d Domain (ad - dress spaces). For example , the virtua l memor y f r a m e w o r k has Domai n as its facade . A Domai n represent s an addres s s p a c e . It provide s a mappin g betwee n virtua l a d d r e s s e s a nd offset s i n to m e m o r y o b j e c t s , f i l e s, or b a c k i n g s t o r e. T he m a in o p e r a t i o n s on Domai n suppor t addin g a memor y objec t at a particula r a d d r e s s , r e m o v i n g a memory object, and handling a page f a u l t . As the preceding diagram shows, the virtual memory subsystem uses the follow - ing components internally: ptgF A C A D E 193 • MemoryObjec t represent s a data store. • MemoryObjectCach e c a c h e s the data of MemoryObject s in physica l m e m o r y . MemoryObjectCach e is actuall y a Strateg y ( 3 1 5) that localize s the c a c h i n g p o l i c y . • AddressTranslatio n encapsulate s the addres s translatio n hardware. The RepairFaul t operatio n is c a l l ed wheneve r a page f a u lt interrup t occurs . The Domai n finds the memor y objec t at the addres s causin g the f a u lt and delegate s the RepairFaul t operatio n to the c a c he a s s o c i a t e d with that memor y object . D o m a i n s can be customized by changing their components. Related P a t t e r n s Abstrac t Factor y ( 8 7) can be u s ed with Facad e to provid e an interfac e for creatin g subsyste m o b j e c t s in a subsystem-independen t way. Abstrac t Factor y can also be used as an alternativ e to Facad e to hide platform-specifi c c l a s s e s . Mediato r ( 2 7 3) is s i m i l a r to Facad e in that it abstract s functionalit y of e x i s t i n g c l a s s e s . H o w e v e r , Mediator' s purpos e is to abstrac t arbitrar y communicatio n be- twee n colleagu e o b j e c t s , often centralizin g functionalit y that doesn' t belon g in any one of them . A mediator' s c o l l e a g u e s are awar e of and communicat e with the mediato r instea d of communicatin g with e a ch other d i r e c t l y . In contrast , a facad e merel y abstract s the interfac e to subsyste m object s to make them easie r to u s e; it doesn't define new functionality, and subsystem classes don't know about it. Usually only one Facade object is required. Thus Facade objects are often Single - tons (127). ptg This page intentionally left blank ptgFLYWEIGHT 195 F L Y W E I G H T Object S t r u c t u r a l Intent Use sharing to support large numbers of fine-grained objects e f f i c i e n t l y . Motivation S o me application s could benefi t f r om using object s throughou t their d e s i g n , but a naive implementatio n woul d be prohibitivel y expensive. For example , most documen t edito r implementation s have text f o r m a t t i n g and editin g facilitie s t h at are modularize d to som e extent . Object-oriente d documen t editor s typicall y use object s to represen t embedde d element s like table s and fig- ures. However , they usuall y stop short of using an objec t for each characte r in the document , even thoug h doing so woul d promot e flexibilit y at the fines t l e v e ls in the application . Character s and embedde d element s c o u ld then be treate d uni- f o r m l y with r e s p e c t to how they are d r a w n and f o r m a t t e d . The applicatio n c o u ld be extende d to suppor t new characte r s e ts withou t disturbin g other functionality . The application' s objec t structur e could mimi c the document' s physica l structure . The followin g diagra m s h o w s how a documen t edito r can use object s to represen t characters. The drawbac k of such a d e s i g n is its cost. Even moderate-size d document s may r e q u i r e hundred s of thousand s of characte r objects , whic h will consum e lots of memor y and may incur unacceptabl e run-tim e overhead . The Flyweigh t p a t t e r n d e s c r i b e s how to share object s to allow their use at fine granularitie s withou t prohibitive cost. ptg1 96 STRUCTURAL PATTERNS CHAPTER 4 A flyweigh t is a s h a r e d o b j e c t that c an be u s ed in multipl e context s s i m u l t a n e o u s l y . The flyweigh t a c ts as an independen t objec t in e a ch context—it' s i n d i s t i n g u i s h - able from an instanc e of the o b j e c t that's not shared . F l y w e i g h t s canno t make assumption s abou t the contex t in whic h they operate . The key c o n c e p t h e re is the d i s t i n c t i o n betwee n i n t r i n s i c a nd e x t r i n s i c state. Intrinsi c state is s t o r e d in t he flyweight ; it c o n s i s t s of informatio n that's independen t of the flyweight' s context , thereb y makin g it sharable . Extrinsi c state d e p e n d s on and v a r i e s with the fly- weight' s c o n t e x t and therefor e can't be s h a r e d . C l i e n t o b j e c t s are r e s p o n s i b l e for passin g e x t r i n s i c state to the flyweigh t when it n e e ds it. F l y w e i g h t s mode l c o n c e p t s or e n t i t i e s that are normall y too plentifu l to r e p r e s e n t with objects . For e x a m p l e , a documen t edito r can creat e a flyweigh t for e a ch letter of the alphabet . E a ch flyweigh t s t o r e s a characte r c o d e, but its coordinat e p o s i t i o n in the documen t and its typographi c s t y le can be determine d from the text layou t algorithm s and formattin g command s in effec t whereve r the characte r appears . T h e character code is intrinsic state, while the other information i s extrinsic. L o g i c a l l y there is an object for every occurrence of a given character in the d o c u - ment: P h y s i c a l l y , h o w e v e r , there is o ne s h a r e d f l y w e i g h t o b j e c t p er character , a nd it appear s in differen t context s in the documen t structure . E a ch o c c u r r e n c e of a par- ticula r characte r o b j e c t refers to the same instanc e in the s h a r e d p o ol of flyweigh t o b j e c t s : ptgFLYWEIGHT 1 9 7 The c l a ss structur e for t h e se o b j e c t s is s h o w n next. Glyp h is the abstrac t c l a ss for g r a p h i c a l o b j e c t s , s o me of w h i c h m ay be flyweights . O p e r a t i o n s that m ay d e p e n d on extrinsi c state have it passe d to them as a parameter . For e x a m p l e , Draw and Intersects must know which context the glyph is in before they can do their job. A flyweigh t representin g the letter \"a\" o n ly s t o r e s the correspondin g characte r c o d e; it d o e s n ' t n e ed to s t o re i ts l o c a t i o n or font. C l i e n t s suppl y t he context- dependen t informatio n that the flyweigh t n e e ds to draw itself . For e x a m p l e , a R ow g l y ph k n o w s w h e r e i ts c h i l d r e n s h o u l d d r aw t h e m s e l v e s so that t h ey a re t i l ed horizontally . T h us it can pass each c h i ld its locatio n in the draw request. B e c a u s e the numbe r of differen t characte r o b j e c t s is far l e ss than the numbe r of character s in the document , the total numbe r of o b j e c t s is substantiall y l e ss than what a n a i ve implementatio n woul d u s e. A documen t in whic h all character s ap- pear in t he same font a nd c o l or w i ll allocat e on t he ord er of 1 00 characte r o b j e c t s (roughl y t he s i ze of t he A S C I I characte r set) r e g a r d l e s s of t he document' s l e n g t h . A nd s i n ce m o st document s u se no more than 10 differen t font-colo r c o m b i n a - t i o n s , t h is numbe r won' t g r ow appreciabl y in practice . An objec t abstractio n thus b e c o m e s practical f o r individual characters. Applicability The F l y w e i g h t pattern' s effectivenes s depend s heavil y on how and wher e it's used. Appl y the Flyweigh t patter n when all of the followin g are true: •An a p p l i c a t i o n u s es a l a r ge numbe r of o b j e c t s . •S t o r a g e c o s ts a re h i gh becaus e of t he s h e er quantit y of o b j e c t s . •M o st objec t state can be made e x t r i n s i c . •Many g r o u p s of o b j e c t s may be r e p l a c e d by r e l a t i v e l y few s h a r e d object s o n ce e x t r i n s i c state is removed. •T he applicatio n d o e s n ' t d e p e n d on objec t identity . S i n ce flyweigh t o b j e c t s m a y be s h a r e d , i d e n t i t y tests w i l l r e t u r n t r u e for c o n c e p t u a l l y distinct objects. ptg1 9 8 STRUCTURAL PATTERNS S t r u c t u r eCHAPTER 4 P a r t i c i p a n t s Flyweigh t (Glyph) - d e c l a r e s an interfac e throug h whic h f l y w e i g h t s c an r e c e i v e a nd a ct on e x t r i n s i c s t a t e . ptgF L Y W E I G H T 199 • C o n c r e t e F l y w e i g h t ( C h a r a c t e r ) - implement s the F l y w e i g h t interfac e and adds storag e for i n t r i n s i c state, if a n y. A C o n c r e t e F l y w e i g h t objec t must be sharable . A ny state it s t o r e s must be i n t r i n s i c ; that i s, it must be i n d e p e n d e n t of t he C o n c r e t e F l y w e i g h t object' s context. • U n s h a r e d C o n c r e t e F l y w e i g h t ( R o w , C o l u m n ) - n ot a ll F l y w e i g h t s u b c l a s s e s n e ed to be shared . T he F l y w e i g h t interfac e enables s h a r i n g ; it d o e s n ' t enforc e it. It's c o m m o n for UnsharedConcrete- F l y w e i g h t object s to have C o n c r e t e F l y w e i g h t o b j e c t s as c h i l d r e n at s o me l e v el in t he flyweigh t o b j e c t structur e ( as t he R ow a nd Colum n c l a s s e s h a v e ) . • FlyweightFactory - c r e a t e s and manage s flyweigh t objects. - e n s u r e s that flyweight s are s h a r e d p r o p e r l y . W h e n a c l i e nt r e q u e s t s a fly- w e i g h t , t he F l y w e i g h t F a c t o r y o b j e c t s u p p l i e s an e x i s t i n g i n s t a n c e or c r e a t e s o n e , if none exists. • C l i e n t - maintains a reference to flyweight(s). - computes or s t o r e s the e x t r i n s i c s t a t e of flyweight(s). C o l l a b o r a t i o n s • State that a flyweigh t n e e ds to functio n must be characterize d as eithe r i n t r i n s i c or e x t r i n s i c . Intrinsi c state is s t o r e d in t he C o n c r e t e F l y w e i g h t o b j e c t ; e x t r i n s i c state is s t o r e d or c o m p u t e d by C l i e n t o b j e c t s . C l i e n t s pass t h is state to t he flyweigh t w h en they i n v o k e its operations. • C l i e n t s s h o u l d not instantiat e C o n c r e t e F l y w e i g h t s d i r e c t l y . C l i e n t s must obtai n C o n c r e t e F l y w e i g h t o b j e c t s e x c l u s i v e l y f r om the FlyweightFactor y o b j e c t to e n s u r e t h e y are shared properly. C o n s e q u e n c e s F l y w e i g h t s m ay i n t r o d u c e r u n - t i m e c o s ts a s s o c i a t e d with transferring , f i n d i n g , a n d / o r computin g e x t r i n s i c s t a t e, e s p e c i a l l y if it was formerl y store d as i n t r i n s i c state. H o w e v e r , s u ch c o s ts are o f f s e t by s p a ce s a v i n g s , whic h i n c r e a s e as m o re flyweights are shared. S t o r a g e savings are a function of several factors: • the reduction in the total number of i n s t a n c e s t h a t c o m e s from s h a r i n g • the amount of i n t r i n s i c s t a t e per object ptg200 STRUCTURAL PATTERNS CHAPTER 4 • whethe r extrinsi c state is compute d or stored. T he more f l y w e i g h t s a re shared , t he greate r t he storag e s a v i n g s . T he s a v i n g s i n c r e a s e with the amoun t of s h a r e d state. The greates t s a v i n g s o c c ur when the object s use substantia l quantitie s of both i n t r i n s i c and e x t r i n s i c state, and the extrinsi c state can be compute d rathe r than stored . T h e n you s a ve on storag e in two ways : S h a r i n g reduce s the c o st of i n t r i n s i c state, and you trade e x t r i n s i c state for computatio n time. The Flyweigh t patter n is often c o m b i n e d with the Composit e ( 1 6 3) patter n to represen t a hierarchica l structur e as a graph with s h a r e d leaf nodes . A c o n s e q u e n c e of s h a r i n g is that flyweigh t l e af n o d e s c a n n o t s t o re a p o i n t e r to t h e ir parent . R a t h e r , the paren t pointe r is passe d to the flyweigh t as part of its extrinsi c state. T h is has a major impact on how the objects in the hierarchy communicate with each other. Implementation C o n s i d e r the followin g i s s u e s when implementin g the F l y w e i g h t pattern: 1. Removing extrinsic state. T he pattern' s applicabilit y is determine d l a r g e l y by how e a sy it is to identif y e x t r i n s i c state and r e m o v e it f r om s h a r e d o b j e c t s . Removin g extrinsi c state won' t help reduc e storag e c o s ts if there are as many differen t kinds of e x t r i n s i c state as the re are o b j e c t s befor e s h a r i n g . I d e a l l y , e x t r i n s i c state can be compute d from a separat e o b j e c t structure , one with far s m a l l e r storag e requirements. In our documen t e d i t o r , for example , we can s t o re a map of typographi c informatio n in a separat e structur e rathe r than s t o re the font and type s t y le with e a ch characte r object . The map k e e ps track of runs of character s with the s a me typographi c attributes . W h en a characte r draw s itself , it r e c e i v e s its typographic attribute s as a side-effec t of the draw traversal . B e c a u s e d o c - ument s normall y use j u st a few differen t fonts and s t y l e s , s t o r i n g t h is infor- matio n externall y to e a ch characte r objec t is far more efficien t than storin g it internally. 2. Managing shared objects. B e c a u s e object s are s h a r e d , c l i e n t s shouldn' t i n s t a n t i - ate them d i r e c t l y . FlyweightFactor y lets c l i e n t s locat e a particula r flyweight . FlyweightFactor y o b j e c t s often use an associativ e s t o re to let c l i e n t s l o ok up flyweight s of interest . For e x a m p l e , the flyweigh t f a c t o r y in the documen t edito r exampl e can k e ep a table of flyweight s i n d e x e d by characte r c o d e s . The manage r return s the prope r flyweigh t g i v en its c o d e, creatin g the flyweigh t if it d o es n ot alread y e x i s t . Sharabilit y a l so i m p l i e s s o me f o rm of referenc e countin g or garbag e c o l l e c t i o n to r e c l a i m a f l y w e i g h t ' s s t o r a g e w h en i t 's no l o n g e r n e e d e d . H o w e v e r , n e i t h e r is n e c e s s a r y if t he numbe r of f l y w e i g h t s is fixed a nd small ( e . g ., f l y w e i g h t s for the A S C I I characte r set). In that c a s e, the flyweight s are wort h k e e p i n g around permanently. ptgFLYWEIGHT 201 S a m p l e C o d e Returnin g to our documen t formatte r example , we can defin e a G l y p h base c l a ss for flyweigh t graphica l o b j e c t s . L o g i c a l l y , g l y p h s are Composite s ( s ee C o m p o s - ite ( 1 6 3 ) ) that have graphica l attribute s and can draw t h e m s e l v e s . H e re we focus on j u st the f o nt attribute , but the same approac h can be u s ed for any other graphica l attributes a glyph might have. c l a ss G l y ph { public: virtual ~ G l y p h ( ) ; virtual void D r a w ( W i n d o w * , G l y p h C o n t e x t & ) ; v i r t u al void S e t F o n t ( F o n t * , G l y p h C o n t e x t k ) ; virtual Font* GetFont(GlyphContext&); virtual void First(GlyphContext&) ; virtual void Next(GlyphContext&) ; virtual bool I s D o n e ( G l y p h C o n t e x t & ) ; virtual G l y p h* Current(GlyphContextk); virtual void I n s e r t ( G l y p h * , G l y p h C o n t e x t & ) ; v i r t u al v o id R e m o v e ( G l y p h C o n t e x t k ) ; protected: G l y p h ( ); } ; The Character subclass just stores a character code: c l a ss Characte r : public G l y ph { public: Character(char); virtual void Draw(Window* , GlyphContext&) ; p r i v a t e : c h ar _charcode ; } ; To keep f r om allocatin g s p a ce for a f o nt attribut e in every g l y p h , we'll s t o re the attribut e extrinsicall y in a G l y p h C o n t e x t object . G l y p h C o n t e x t acts as a repositor y of extrinsi c state. It maintain s a compac t mappin g betwee n a g l y ph and its font (and any other graphica l attribute s it migh t have ) in differen t contexts . Any operatio n that n e e ds to know the g l y p h ' s font in a g i v en contex t will have a G l y p h C o n t e x t instanc e passe d to it as a parameter . The operatio n can then query the G l y p h C o n t e x t for the font in that context . The contex t depend s on the glyph' s locatio n in the g l y ph structure . Therefor e G l y p h ' s c h i ld iteratio n and manipulatio n operation s must updat e the G l y p h C o n t e x t wheneve r they'r e used. ptg2 0 2 STRUCTURAL PATTERNS CHAPTER 4 class GlyphContex t { public: GlyphContext() ; virtual ~ G l y p h C o n t e x t ( ) ; virtual void Next(int step = 1); virtual void Insert(in t quantity = 1); virtual Font* GetFont{) ; virtual void SetFont(Font* , int s p an = 1 ) ; private: int _index; BTree* _fonts; } ; G l y p h C o n t e x t must be kept informe d of the c u r r e n t p o s i t i o n in the g l y ph s t r u c - ture durin g traversal . G l y p h C o n t e x t : : N e xt i n c r e m e n t s .inde x as the traversa l p r o c e e d s . Glyp h s u b c l a s s e s that h a ve c h i l d r e n ( e . g ., R ow a nd C o l u m n ) m u st i m - plemen t N e xt so that it c a l ls G l y p h C o n t e x t: : N e xt at e a ch point in the traversal. G l y p h C o n t e x t : : G e t F o n t u s es the i n d ex as a key into a B T r e e structur e that s t o r e s the glyph-to-fon t mapping . E a ch n o de in the tree is l a b e l e d with the lengt h of t he s t r i ng for w h i ch it g i v es font i n f o r m a t i o n . L e a v e s in t he t r ee p o i nt to a font, while interior nodes break the string into substrings, one for each child. C o n s i d e r the following excerpt from a glyph composition: The BTree structure for font information might look like ptgFLYWEIGHT 203 I n t e r i o r n o d e s defin e r a n g e s of g l y ph i n d i c e s . BTr ee is update d in r e s p o n s e to font c h a n g e s and w h e n e v e r g l y p h s are adde d to or r e m o v e d from the g l y ph structure . F or e x a m p l e , a s s u m i n g we're at i n d ex 1 02 in t he traversal , t he followin g c o de s e ts the font of e a ch characte r in the word \" e x p e c t \" to that of the surroundin g text (that is, times 1 2 , a n instance of Font for 12-point Times Roman): G l y p h C o n t e x t gc; Font* t i m e s !2 = new Font(\"Times-Roman-12\"); F o n t* t i m e s l t a l i c ! 2 = new Font(\"Times-Italic-12\") ; // - . . gc.SetFont(timesl2, 6); T h e new BTree structure (with changes shown in black) looks like ptg204 STRUCTURAL PATTERNS CHAPTER 4 S u p p o s e we add the word \" d o n ' t \" ( i n c l u d i n g a trailin g s p a c e ) in 1 2 - p o i n t T i m e s I t a l ic befor e \" e x p e c t . \" T he f o l l o w i n g c o de i n f o r m s t he gc of t h is e v e n t , a s s u m i n g it is s t i ll at i n d ex 1 0 2 : gc.Insert(6) ; gc.SetFont(timesltalic!2, 6); The BTree structure becomes When the G l y p h C o n t e x t is q u e r i e d for the font of the curren t g l y p h , it d e s c e n d s the BTree , addin g up i n d i c e s as it g o es until it finds the font for the curren t i n d e x . B e c a u s e t he frequenc y of f o nt c h a n g e s is r e l a t i v e l y l o w, t he t r ee stays s m a ll relativ e to t he s i ze of t he g l y ph structure . T h is keeps storag e c o s ts down withou t an inordinat e i n c r e a s e in look-u p t i m e . 3 T he last objec t we n e ed is a FlyweightFactor y that c r e a t e s g l y p h s a nd e n s u r e s they'r e s h a r e d p r o p e r l y . C l a ss G l y p h F a c t o ry instantiate s C h a r a c t e r and other k i n ds of g l y p h s . We o n ly s h a re C h a r a c t e r o b j e c t s ; c o m p o s i t e g l y p h s a re f ar l e ss plentiful , a nd t h e ir importan t stat e ( i . e ., t h e ir c h i l d r e n ) is i n t r i n s i c anyway. c o n st int NCHARCODE S = 128; c l a ss G l y p h F a c t o r y { public: G l y p h F a c t o r y ( ) ; virtual ~GlyphFactory ( ) ; 3 L o o k - u p time in t h is s c h e m e is proportiona l to the font chang e frequency . W o r s t - c a s e performanc e occur s when a font change occurs on every character, but that's unusual in practice. ptgF L Y W E I G H T 205 virtual Character * CreateCharacter(char) ; virtual Row* CreateRow() ; virtual Column* CreateColumn(); // . . . private: Character * _character[NCHARCODES] ; } ; The .character array contains pointers to Character glyphs indexed by c h a r- acter code. The array is initialized to zero in the constructor. G l y p h F a c t o r y : : G l y p h F a c t o r y () { for ( i nt i = 0; i < NCHARCODES ; ++i) { _character[i ] = 0; } } C r e a t e C h a r a c t e r l o o ks up a characte r in the characte r glyph in the array , and it return s t he c o r r e s p o n d i n g g l y ph if it e x i s t s . If it d o e s n ' t , t h en C r e a t e C h a r a c t e r creates the glyph, puts it in the array, and returns it: Character * GlyphFactory::CreateCharacte r ( c h ar c) { if (!_character[c] ) { _ c h a r a c t e r [ c ] = n ew C h a r a c t e r ( c ) ; } r e t u rn _character[c] ; } The other operation s simpl y instantiat e a new objec t e a ch time they'r e c a l l e d , s i n c e noncharacter glyphs won't be shared: Row* GlyphFactory::CreateRo w () { r e t u rn n ew Row; } Column* G l y p h F a c t o r y : : C r e a t e C o l u m n () { r e t u r n new Column; } We could o m it t h e se operation s a nd l et c l i e n t s instantiat e unshare d g l y p h s d i r e c t l y . H o w e v e r , if we d e c i d e to make t h e se g l y p h s s h a r a b l e l a t e r, w e ' ll h a ve to c h a n g e c l i e n t code that creates them. Known Uses T he c o n c e p t of f l y w e i g h t o b j e c t s w as first d e s c r i b e d a nd e x p l o r e d as a d e s i g n techniqu e in I n t e r v i e w s 3 .0 [ C L 9 0 ] . I ts d e v e l o p e r s built a powerfu l documen t editor called Doc as a proof of concept [ C L 9 2 ] . Doc uses glyph objects to repre - s e n t e a c h c h a r a c t e r in the d o c u m e n t . The editor builds o n e Glyph instance for ptg206 STRUCTURAL PATTERNS CHAPTER 4 each characte r in a particula r style (whic h define s its graphica l attributes) ; h e n ce a c h a r a c t e r ' s intrinsi c s t a te c o n s i s t s of the characte r c o de and its style informa- t i on ( an i n d ex i n to a s t y le t a b l e ) . 4 That m e a n s o n ly p o s i t i o n is e x t r i n s i c , makin g Doc f a s t. Document s are represente d by a c l a ss Document , whic h a l so acts as the FlyweightFactory . Measurement s on Doc have show n that sharin g flyweigh t char- acter s is quite effective . In a typica l c a s e, a documen t containin g 1 8 0 , 0 0 0 character s require d allocatio n of only 480 characte r objects. ET++ [ W G M 8 8 ] uses flyweight s to suppor t look-and-fee l i n d e p e n d e n c e . 5 T he look-and-fee l standar d a f f e c t s the layou t of user interfac e element s ( e . g ., s c r o ll bars, buttons , menus—know n c o l l e c t i v e l y as \" w i d g e t s \" ) and their d e c o r a t i o n s ( e . g ., shadows , beveling) . A widge t delegate s all its layou t and drawin g behavio r to a separat e Layou t object . Changin g the Layou t objec t c h a n g e s the l o ok and feel, e v en at run-time. For each widge t c l a ss there is a correspondin g Layou t c l a ss ( e . g ., S c r o l l b a r L a y o u t , MenubarLayout , e t c . ). An o b v i o u s p r o b l e m with t h is approac h is that using s e p - arate layou t object s double s the numbe r of user interfac e o b j e c t s : For e a ch user interfac e objec t there is an additiona l Layou t object . To avoid this overhead , L a y - out object s are implemente d as flyweights . T h ey make g o od flyweight s becaus e they deal mostl y with definin g behavior , and it's easy to p a ss them what little extrinsi c state they need to lay out or draw an o b j e c t . The L a y o u t object s are create d and manage d by L o ok objects . The L o ok c l a ss is an Abstrac t F a c t o r y ( 8 7) that r e t r i e v e s a s p e c i f i c Layou t o b j e c t with o p e r a t i o n s like GetButtonLayout , GetMenuBarLayout , and so f o r t h . For each look-and-fee l s t a n d a r d there is a correspondin g Look s u b c l a s s ( e . g ., MotifLook , OpenLook ) that supplie s the appropriat e Layou t objects. By the way, Layou t object s are essentiall y strategie s ( s ee Strateg y ( 3 1 5 ) ) . They are an example of a strategy object implemented a s a flyweight. Related Patterns The Flyweigh t p a t t e r n is o f t en combine d with the Composit e ( 1 6 3) patter n to i m p l e m e n t a l o g i c a l l y h i e r a r c h i c a l structur e in terms of a d i r e c t e d - a c y c l i c g r a ph with shared leaf n o d e s . It's often best to implement State (305) a n d Strategy (315) objects as flyweights. 4 In the Sampl e C o de given earlier , style informatio n is made extrinsic , leavin g the characte r c o de as the only intrinsic state. 5 S e e A b s t r a c t F a c t o r y ( 8 7 ) for another approach t o look-and-feel independence. ptgPROXY 207 P R O X Y Object Structural I n t e n t P r o v i d e a surrogate or placeholder for another object to control access to it. Also Known As S u r r o g a t e M o t i v a t i o n O ne r e a s o n f or c o n t r o l l i n g a c c e s s to an objec t is to defer t he full c o st of i ts c r e a t i o n and initializatio n until we actuall y n e ed to use it. C o n s i d e r a documen t edito r that c an e m b e d g r a p h i c a l o b j e c t s in a document . S o me graphica l o b j e c t s , l i ke l a r ge raste r i m a g e s , can be e x p e n s i v e to c r e a t e . But o p e n i n g a documen t shoul d be fast, so we s h o u l d a v o id c r e a t i n g a ll t he e x p e n s i v e o b j e c t s at o n ce w h en t he d o c u m e n t is o p e n e d . T h is i s n 't n e c e s s a r y anyway , becaus e n ot a ll of t h e se o b j e c t s w i ll be v i s i b l e in t he documen t at t he same t i m e . T h e se constraint s woul d s u g g e s t creatin g e a ch e x p e n s i v e o b j e c t on demand, w h i c h in t h is c a se o c c u r s when an i m a g e b e c o m e s v i s i b l e . But what do we put in the d o c u m e n t in p l a ce of t he i m a g e ? A nd h ow c an we h i de t he fact that t he i m a g e is create d on deman d so that we don't complicat e the editor' s implementation ? T h is optimizatio n shouldn' t impac t the r e n d e r i n g and formattin g c o d e, for example. The s o l u t i o n is to use anothe r o b j e c t , an i m a g e p r o x y , that acts as a s t a n d - i n for the real image . The proxy acts j u st l i ke the imag e and takes care of instantiatin g it w h e n it's required. T he i m a g e proxy c r e a t e s t he r e al i m a g e o n ly when t he documen t edito r asks it to d i s p l a y i t s e lf by i n v o k i n g its Draw operation . The proxy forward s s u b s e q u e n t request s d i r e c t l y to the image . It must therefor e keep a r e f e r e n c e to the i m a g e a f t er creatin g i t . L e t 's a s s u m e t h at i m a g e s a re s t o r ed in s e p a r a t e f i l e s. In t h is c a se we c an u se t he file name as the reference to the real object. The proxy also stores its extent, that ptg2 0 8 STRUCTURAL PATTERNS CHAPTER 4 is, its width and height . The exten t l e ts the proxy r e s p o n d to r e q u e s t s for its s i ze f r o m t h e formatter without actually instantiating the image. The following class diagram illustrates this example in more detail. The documen t edito r a c c e s s e s e m b e d d e d i m a g e s throug h the interfac e define d by the abstrac t Graphi c c l a s s. ImageProx y is a c l a ss for i m a g e s that are c rea te d on demand . I m a g e P r o x y maintain s the file name as a referenc e to the i m a g e on d i s k. The file name is passe d as an argument to the ImageProx y constructor. ImageProx y a l so s t o r e s the boundin g box of the i m a g e and a referenc e to the real Imag e i n s t a n c e . T h is referenc e won' t be valid until the proxy instantiate s t he r e al i m a g e . T he D r aw o p e r a t i o n m a k e s s u re t he i m a g e is i n s t a n t i a t e d befor e forwardin g it the request . GetExten t forward s the r e q u e s t to the imag e o n ly if it's instantiated; otherwise ImageProxy returns the extent it stores. Applicability Proxy is applicabl e wheneve r there is a n e ed for a more versatil e or sophisticate d referenc e to an objec t than a s i m p l e p o i n t e r . H e re are severa l commo n situation s in whic h t he Prox y patter n is applicable: 1. A remot e proxy provide s a l o c al representativ e for an o b j e c t in a differen t addres s s p a c e . N E X T S T E P [ A d d 9 4 ] u s es the c l a ss NXProx y for t h is purpose . C o p l i e n [ C o p 9 2 ] c a l ls this kind of proxy an \" A m b a s s a d o r . \" 2. A virtua l proxy create s e x p e n s i v e object s on demand . The ImageProx y de - s c r i b e d in t he Motivatio n is an exampl e of such a proxy. 3. A protectio n proxy c o n t r o l s a c c e s s to the origina l object . P r o t e c t i o n p r o x i e s are u s e f u l w h e n o b j e c t s s h o u l d h a v e d i f f e r e n t a c c e s s r i g h t s . F o r example, ptgPROXY 2 0 9 K e r n e l P r o x i e s in the C h o i c e s operatin g syste m [ C I R M 9 3 ] provid e protecte d a c c e s s to o p e r a t i n g s y s t e m o b j e c t s . 4. A s m a r t referenc e is a r e p l a c e m e n t for a bare p o i n t e r that perform s a d d i t i o n a l action s when an objec t is a c c e s s e d . T y p i c a l u s es include • countin g the numbe r of reference s to the r e al o b j e c t so t h at it can be f r e ed automaticall y w h en t h e re a re no m o re r e f e r e n c e s ( a l so c a l l ed s m a r t pointer s [Ede92]). • loadin g a persisten t objec t into memor y when it's first referenced. • checkin g that the real objec t is l o c k e d befor e it's a c c e s s e d to ensur e that no other object can change it. S t r u c t u r e P a r t i c i p a n t s • Proxy (ImageProxy) -maintain s a r e f e r e n c e that l e ts t he p r o xy a c c e s s t he r e al s u b j e c t . P r o xy m ay refer to a S u b j e c t if the RealSubjec t and S u b j e c t interface s are the same. -provide s an interfac e identica l to Subject' s so that a proxy can by substi- tuted for the r e al s u b j e c t . -control s a c c e s s to the real subjec t and may be r e s p o n s i b l e for creatin g and deleting it. ptg210 STRUCTURAL PATTERNS CHAPTER 4 - other r e s p o n s i b i l i t i e s depen d on the k i nd of proxy: • remote proxies are r e s p o n s i b l e for en codi n g a reques t and its argument s and for s e n d i n g the e n c o d e d reques t to the real subjec t in a differen t addres s s p a c e . • virtual proxies may c a c he a d d i t i o n a l informatio n a b o u t the r e al s u b j e c t so that they can postpon e a c c e s s i n g it. For example , the ImageProx y f r om the Motivatio n c a c h e s the real image' s extent. • protection proxies c h e ck that the c a l l er has the a c c e s s permission s re- q u i r e d to perfor m a r e q u e s t . • Subjec t (Graphic) - define s the commo n interfac e for RealSubjec t and Prox y so that a Proxy c a n be used anywhere a RealSubject is expected. • RealSubject ( I m a g e ) - defines the r e a l object that the p r o x y r e p r e s e n t s . C o l l a b o r a t i o n s • P r o xy forward s r e q u e s t s to R e a l S u b j e c t w h en a p p r o p r i a t e , d e p e n d i n g on t he k i n d of p r o x y . C o n s e q u e n c e s T he Proxy patter n introduce s a l e v el of i n d i r e c t i o n when a c c e s s i n g an object . T he additiona l indirectio n has many u s e s, dependin g on the k i nd of proxy: 1. A remot e proxy can h i de the f a ct that an objec t r e s i d e s in a differen t addres s s p a c e . 2. A virtua l proxy can p e r f o r m optimization s s u ch as creatin g an objec t on d e m a n d . 3. Both protectio n proxie s and smar t reference s a l l ow additiona l h o u s e k e e p i n g tasks w h en an o b j e c t is a c c e s s e d . T h e r e ' s anothe r optimizatio n that the Proxy patter n can hide f r om the c l i e n t . It's c a l l ed copy-on-write , and it's relate d to creatio n on demand . Copyin g a large and c o m p l i c a t e d objec t c an be an e x p e n s i v e operation . If t he c o py is never modified , then there' s no n e ed to incur this cost. By u s i ng a proxy to postpon e the c o p y i n g p r o c e s s , we e n s u r e that we pay the price of c o p y i n g the objec t o n ly if it's modified. To make copy-on-writ e work , the subjec t must be referenc e counted . C o p y i n g the proxy w i ll do nothin g more than incremen t t h is referenc e count . O n ly when the c l i e nt request s an operatio n that modifie s the subjec t d o es the proxy actuall y c o py it. In that c a se the proxy must a l so d e c r e m e n t the subject' s referenc e count . W h en the reference count goes to zero, the subject gets deleted. ptgPROXY 211 C o p y - o n - w r i t e c a n reduce t h e cost of copying heavyweight subjects significantly. I m p l e m e n t a t i o n T he Proxy patter n c an e x p l o i t t he f o l l o w i n g languag e features: 1. Overloading the member access operator in C++. C++ support s o v e r l o a d i n g o p e r a t o r - > , t he m e m b e r a c c e s s o p e r a t o r . O v e r l o a d i n g t h is operato r l e ts y ou perfor m a d d i t i o n a l work w h e n e v e r an o b j e c t is d e r e f e r e n c e d . T h is c an be helpfu l f or i m p l e m e n t i n g s o me k i n ds of p r o x y ; t he p r o xy b e h a v e s just l i ke a p o i n t e r . T he f o l l o w i n g e x a m p l e i l l u s t r a t e s h ow to u se t h is t e c h n i q u e to i m p l e m e n t a virtua l proxy c a l l ed I m a g e P t r . c l a ss I m a g e; e x t e rn I m a g e* L o a d A n l m a g e F i l e ( c o n s t c h a r * ) ; // e x t e r n al f u n c t i o n c l a ss I m a g e P tr { public: I m a g e P t r ( c o n s t c h a r* i m a g e F i l e ) ; virtual \" I m a g e P t r ( ) ; v i r t u al I m a g e* o p e r a t o r - > ( ) ; virtual I m a g e& operator*(); p r i v a t e : I m a g e* L o a d l m a g e ( ) ; private: I m a ge * _image; c o n st c h a r* _imageFile; } ; I m a g e P t r : : I m a g e P t r ( c o n st c h a r* t h e l m a g e F i l e ) { _imageFil e = t h e l m a g e F i l e ; _image = 0 ; } I m a g e* I m a g e P t r : : L o a d l m a g e () { if ( _ i m a ge = =0) { _image = L o a d A n l m a g e F i l e ( _ i m a g e F i l e ) ; } r e t u rn _image; } The o v e r l o a d e d -> and * o p e r a t o r s use L o a d l m a g e to retur n _ i m a g e to c a l l e r s ( l o a d i n g it if n e c e s s a r y ) . I m a g e* I m a g e P t r : : o p e r a t o r - > () { r e t u rn L o a d l m a g e ( ) ; } I m a g e& I m a g e P t r : : o p e r a t o r * () { r e t u r n *LoadImage(); } ptg212 STRUCTURAL PATTERNS CHAPTER 4 T h is approac h lets you call I m a g e operation s throug h I m a g e P t r object s withou t g o i ng to the troubl e of makin g the o p e r a t i o n s part of the I m a g e P t r interface: ImagePtr image = ImagePtr(\"anlmageFileName\") ; image->Draw(Point(50, 100)); / / ( i m a g e . o p e r a t o r - > ( ) ) - > D r a w ( P o i n t ( 5 0 , 100)) Notic e how the i m a g e prox y acts l i ke a pointer , but it's not declare d to be a pointe r to an I m a g e . That mean s you can't use it exactl y like a real pointe r to an I m a g e . Henc e client s m u st treat I m a g e and I m a g e P t r object s differentl y in t h is approach. Overloadin g the membe r a c c e s s operato r isn't a g o od solutio n for every kind of proxy . S o me proxie s need to know precisel y which operatio n is called , and overloadin g the membe r a c c e s s operato r doesn' t work in those cases. Conside r the virtua l prox y example in the Motivation . The imag e s h o u l d be loade d at a specifi c time—namel y when the Draw operatio n is called — and not wheneve r the imag e is referenced . Overloadin g the a c c e s s operato r doesn' t a l l ow this distinction . In that c a se we must manuall y implemen t each proxy operatio n that f o r w a r d s the reques t to the subject. T h e s e operation s are usuall y very simila r to each other , as the S a m p l e C o de demonstrates . Typicall y all operation s verif y that the reques t is l e g a l , that the origina l objec t e x i s t s , etc., befor e f o r w a r d i n g the reques t to the subject . I t 's tediou s to write t h is c o de again and again . So it's commo n to use a preprocesso r to generat e it automatically. 2. Using d o e s N o t U n d e r s t a n d in Smalltalk. Smalltal k provide s a hook that you can use to suppor t a u t o m a t i c f o r w a r d i n g of requests . Smalltal k c a l ls d o e s N o t U n d e r s t a n d : a M e s s a g e when a c l i e n t s e n ds a messag e to a receive r that has no correspondin g method . The Prox y c l a ss can redefin e d o e s N o t U n d e r s t a n d so that the m e s s a g e is forwarde d to its s u b j e c t . To ensur e that a reques t is f o r w a r d e d to the subjec t and not j u st absorbe d by the prox y s i l e n t l y , you can defin e a Prox y c l a ss that doesn' t understan d any m e s s a g e s . Smalltal k lets you do this by definin g Proxy as a c l a ss with no s u p e r c l a s s . 6 The main disadvantag e of d o e s N o t U n d e r s t a n d : is that most Smalltal k system s have a few s p e c i a l message s that are h a n d l e d d i r e c t l y by the virtua l m a c h i n e , and these do not cause the usua l metho d look-up . The o n ly one that's u s u a l l y i m p l e m e n t e d in O b j e c t (and so c an affec t p r o x i e s ) is t he i d e n t i t y operatio n = = . If you'r e g o i ng to use d o e s N o t U n d e r s t a n d : to implemen t P r o x y , t h en you must d e s i g n aroun d this problem . You can't e x p e c t identit y on prox- i es to m e an i d e n t i t y on t h e ir r e al s u b j e c t s . An adde d d i s a d v a n t a g e is that 6 The implementatio n of distribute d object s in N E X T S T E P [Add94 ] (specifically , the class NXProxy ) u s es t h i s technique. T h e implementation redefines f o r w a r d , the equivalent hook in NEXTSTEP. ptgPROXY 2 1 3 d o e s N o t U n d e r s t a n d : was develope d for error handling , not for buildin g p r o x i e s , and so it's generall y not very f a s t . 3.Proxy doesn't always have to know the type of real subject. If a Prox y c l a ss can deal with its subjec t s o l e ly throug h an abstrac t interface , then there' s no need to make a Prox y c l a ss for e a ch RealSubjec t c l a s s ; the prox y can deal with a ll R e a l S u b j e c t c l a s s e s u n i f o r m l y . B ut if P r o x i e s a re g o i ng to instantiat e RealSubject s (such as in a virtua l proxy) , then they have to know the c o n c r e t e c l a s s . A n o t h e r i m p l e m e n t a t i o n i s s ue i n v o l v e s h ow to refer to t he s u b j e c t befor e it's instantiated . S o me proxie s have to refer to their subjec t whethe r it's on disk or in memory . That mean s they must use some f o rm of addres s space-independen t object identifiers. W e u s e d a file name for this purpose in the Motivation. S a m p l e Code The followin g c o de implement s two kinds of proxy : the virtua l prox y d e s c r i b e d in the M o t i v a t i o n s e c t i o n , and a proxy i m p l e m e n t e d with d o e s N o t U n d e r s t a n d : 7 1. A virtual proxy. The G r a p h i c c l a ss define s the interfac e for graphica l objects: c l a ss G r a p h ic { public: virtual \" G r a p h i c ( ) ; virtual void D r a w ( c o n s t Point& at) = 0; v i r t u al void H a n d l e M o u s e ( E v e n t & e v e n t) = 0 ; virtual c o n st Point& GetExtent( ) = 0; virtual void Load(istream & from) = 0; virtual void S a v e ( o s t r e a m & to) = 0; protected: Graphic() ; } ; The I m a g e c l a ss implement s the G r a p h i c interfac e to displa y imag e files. I m a g e override s H a n d l e M o u s e to let users r e s i z e the imag e interactively. c l a ss I m a ge : public Graphic { p u b l i c : Image(cons t c h a r* file); // loads image f r om a file virtual ~Image(); virtual void D r a w ( c o n s t Point& at); virtual void H a n d l e M o u s e ( E v e n t & event); virtual const P o i n t s GetExtent(); 7Iterator (257) describes another kind of proxy on page 266. ptg2 1 4 STRUCTURAL P A T T E R N S C H A P T E R 4 v i r t u al v o id L o a d ( i s t r e a m & f r o m ); v i r t u al void S a v e ( o s t r e a m & t o ) ; private: // . . . } ; I m a g e P r o x y has the s a me interfac e as Image: c l a ss I m a g e P r o x y : public G r a p h ic { public: I m a g e P r o x y ( c o n s t c h a r* imageFile) ; virtual ~ I m a g e P r o x y ( ) ; virtual void D r a w ( c o n s t P o i n t& at); v i r t u al v o id H a n d l e M o u s e ( E v e n t & e v e n t ) ; v i r t u al c o n st P o i n t& GetExtent(); virtual void L o a d ( i s t r e a m & from); v i r t u al void S a v e ( o s t r e a m & to); protected: I m a g e* G e t l m a g e ( ) ; private: I m a g e* _image; P o i nt _extent; c h a r* _fileName; } ; T he c o n s t r u c t o r s a v es a l o c al c o py of t he name of t he file that s t o r es t he i m a g e , and it i n i t i a l i z e s - e x t e n t and -image: I m a g e P r o x y : : I m a g e P r o x y ( c o n st c h a r* f i l e N a m e) { _fileNam e = s t r d u p ( f i l e N a m e ) ; _extent = P o i n t : : Z e r o ; // d o n 't k n ow e x t e nt yet _image = 0 ; } I m a g e* I m a g e P r o x y : : G e t l m a g e ( ) { if ( _ i m a ge = = 0) { _image - new Image(_fileName) ; } r e t u rn _image; } T he i m p l e m e n t a t i o n of G e t E x t e n t return s t he c a c h e d e x t e n t if p o s s i b l e ; o t h e r w i s e t he i m a g e is l o a d e d from t he f i l e. D r aw l o a ds t he i m a g e , a nd H a n d l e M o u s e forward s the e v e nt to the r e al i m a g e . c o n st P o i n t& I m a g e P r o x y : : G e t E x t e n t () { if ( _ e x t e nt == P o i n t : : Z e r o ) { _extent = Getlmage()->GetExtent() ; } r e t u rn _extent; } ptgPROXY 215 void ImageProxy::Dra w ( c o n st Point& at) { GetImage()->Draw(at) ; } void ImageProxy::HandleMous e ( E v e n t& event) { Getlmage()->HandleMouse(event) ; } T he Save o p e r a t i o n s a v es t he c a c h e d i m a g e e x t e n t a nd t he i m a g e f i le n a me to a s t r e a m . L o ad r e t r i e v e s t h is i n f o r m a t i o n a nd initialize s t he c o r r e s p o n d i n g m e m b e r s . void ImageProxy::Sav e ( o s t r e a m & to) { to « _extent « _fileName; } void ImageProxy::Loa d ( i s t r e a m & from) { f r om » _extent » _fileName; } F i n a l l y , s u p p o s e we h a ve a c l a ss T e x t D o c u m e n t that can c o n t a i n G r a p h i c o b j e c t s : class TextDocumen t { public: TextDocument(); void Insert(Graphic*) ; // . . . } ; W e can insert an ImageProxy into a text document l i k e this: TextDocument * text = new TextDocument ; // . - . text->Insert(new ImageProxy(\"anlmageFileName\")); 2. Proxies that use d o e s N o t U n d e r s t a n d . You can m a ke g e n e r i c p r o x i e s in S m a l l t a l k by d e f i n i n g c l a s s e s w h o s e s u p e r c l a s s is n i l8 a nd d e f i n i n g t he d o e s N o t U n d e r s t a n d : m e t h o d to h a n d l e m e s s a g e s . T he followin g m e t h o d a s s u m e s t he p r o x y h as a r e al Sub j e ct m e t h o d t h at r e t u r n s i ts r e al s u b j e c t . In t he c a se of I m a g e P r o x y , t h is m e t h o d w o u l d c h e ck to s ee if t he t he I m a g e h ad b e en c r e a t e d , c r e a t e it if n e c e s s a r y , a nd f i n a l l y r e t u r n it. It u s es p e r f o r m : w i t h A r g u m e n t s : to p e r f o r m the m e s s a g e b e i ng t r a p p e d on the real subject. doesNotUnderstand : aMessage ~ self realSubjec t perform: aMessage selector withArguments: aMessage arguments 8 Almos t a ll c l a s s e s ultimatel y h a ve O b j e c t as their s u p e r c l a s s . H e n c e this is t he s a me as s a y i n g \" d e f i n i n g a class that doesn't have Object as its superclass.\" ptg216 STRUCTURAL PATTERNS CHAPTER 4 The argumen t to d o e s N o t U n d e r s t a n d : is an i n s t a n c e of M e s s a g e that represent s t he m e s s a g e n ot understoo d by t he p r o x y . So t he proxy r e s p o n d s to all m e s s a g e s by makin g s u re that the r e al subjec t e x i s ts befor e forwardin g the m e s s a g e to it. One of the advantage s of d o e s N o t U n d e r s t a n d : is it can perfor m arbitrar y p r o c e s s i n g . For e x a m p l e , we c o u ld produc e a p r o t e c t i o n proxy by s p e c i f y i n g a set l e g a l M e s s a g e s of m e s s a g e s to a c c e p t and then g i v i n g the proxy the f o l l o w i n g m e t h o d : d o e s N o t U n d e r s t a n d : a M e s s a ge ( l e g a l M e s s a g e s i n c l u d e s: a M e s s a ge selector ) i f T r u e: [ s e lf r e a l S u b j e c t p e r f o r m: a M e s s a ge s e l e c t or w i t h A r g u m e n t s : a M e s s a ge a r g u m e n t s ] ifFalse: [ s e lf e r r o r: ' I l l e g al o p e r a t o r ' ] T h is metho d c h e c k s to s ee that a m e s s a g e is l e g al befor e forwardin g it to t he r e al s u b j e c t . If it i s n 't l e g a l, t h en it w i ll s e nd e r r o r : to t he p r o x y , w h i ch w i ll resul t in an i n f i n i t e l o op of error s u n l e s s the proxy define s e r r o r : . C o n s e q u e n t l y , the d e f i n i t i o n of e r r o r : s h o u l d be c o p i e d from c l a ss O b j e c t a l o n g w i t h any methods it uses. Known U s e s The virtua l proxy exampl e in the Motivatio n s e c t i o n is f r om t he ET++ text buildin g b l o ck c l a s s e s . N E X T S T E P [ A d d 9 4 ] u s es p r o x i e s ( i n s t a n c e s of c l a ss N X P r o x y ) as l o c al r e p r e s e n - t a t i v e s for o b j e c t s that may be distributed . A s e r v e r c r e a t e s p r o x i e s for remot e o b j e c t s when c l i e n t s r e q u e s t t h e m . On r e c e i v i n g a m e s s a g e , t he prox y e n c o d e s it a l o ng with its argument s and then forward s the e n c o d e d m e s s a g e to the remot e s u b j e c t . S i m i l a r l y , t he s u b j e c t e n c o d e s a ny return r e s u l t s a nd s e n ds t h em b a ck to the NXProx y object. M c C u l l o u g h [ M c C 8 7 ] d i s c u s s e s using p r o x i e s in S m a l l t a l k to a c c e s s remot e o b - jects. P a s c o e [ P a s 8 6 ] d e s c r i b e s h ow to p r o v i d e side-effect s on metho d c a l ls a nd a c c e s s c o n t r o l w i t h \"Encapsulators.\" Related Patterns Adapte r ( 1 3 9 ) : An adapte r p r o v i d e s a differen t interfac e to the o b j e c t it adapts . In contrast , a proxy p r o v i d e s the s a me interfac e as its s u b j e c t . H o w e v e r , a proxy u s ed for a c c e s s protectio n m i g h t refus e to perfor m an operatio n that the subjec t w i l l p e r f o r m , s o i t s interface m a y b e effectively a subset of the subject's. Decorator (175): Although decorators can have similar implementations as prox - i e s , d e c o r a t o r s h a v e a different p u r p o s e . A decorator adds one or more responsi - b i l i t i e s to an object, whereas a proxy controls access to an object. ptgPROXY 2 1 7 P r o x i e s vary in the d e g r e e to w h i c h they are implemente d l i ke a d e c o r a t o r . A protectio n proxy migh t be i m p l e m e n t e d e x a c t l y l i ke a decorator . On t he o t h er hand , a remot e proxy w i ll not contai n a d i r e c t referenc e to its r e al subjec t but o n ly an i n d i r e c t r e f e r e n c e , s u ch as \" h o st ID a nd l o c al addres s on h o s t . \" A virtua l proxy w i ll start off with an i n d i r e c t referenc e s u ch as a file name but will eventuall y o b t a i n and use a direct reference. ptg This page intentionally left blank ptgDISCUSSION O F STRUCTURAL P A T T E R N S 219 D i s c u s s i o n of Structural Patterns Y ou m ay have n o t i c e d s i m i l a r i t i e s b et we e n t he structura l patterns , e s p e c i a l l y in t h e ir participant s a nd collaborations . T h is is so probabl y b e c a u s e structura l pattern s r e ly on t he same s m a ll s et of languag e m e c h a n i s m s f or structurin g c o de a nd o b j e c t s : s i n g le and multipl e i n h e r i t a n c e for c l a s s - b a s e d patterns , and o b j e c t c o m p o s i t i o n for o b j e c t patterns . But the s i m i l a r i t i e s b e l ie the differen t intent s amon g t h e se patterns . In t h is s e c t i o n we c o m p a r e a nd c o n t r a s t g r o u p s of structura l p a t t e r n s to g i ve y ou a f e el f or their relativ e merits. Adapte r v e r s u s Bridge T he Adapte r ( 1 3 9) a nd B r i d g e ( 1 5 1) pattern s have s o me c o m m o n attributes . B o th p r o - mote f l e x i b i l i t y by providin g a l e v el of i n d i r e c t i o n to anothe r o b j e c t . B o th i n v o l v e forwardin g r e q u e s t s to t h is o b j e c t from an interfac e o t h er than its o w n . T he k ey differenc e b e t w e e n t h e se pattern s l i es in t h e ir i n t e n t s . Adapte r f o c u s e s on r e s o l v i n g i n c o m p a t i b i l i t i e s betwee n t wo e x i s t i n g interfaces . It d o e s n ' t focus on h ow t h o se interface s a re i m p l e m e n t e d , n or d o es it c o n s i d e r h ow they m i g h t e v o l v e i n d e - p e n d e n t l y . I t 's a w ay of makin g t wo i n d e p e n d e n t l y d e s i g n e d c l a s s e s work t o g e t h e r withou t r e i m p l e m e n t i n g o ne or t he o t h e r . B r i d g e , on t he o t h er hand , b r i d g e s an a b - s tr ac ti o n and its ( p o t e n t i a l l y numerous ) i m p l e m e n t a t i o n s . It p r o v i d e s a s t a b le interfac e to c l i e n t s e v en as it l e ts y ou vary t he c l a s s e s that i m p l e m e n t i t. It a l so a c c o m m o d a t e s n ew implementation s as t he s y s t e m e v o l v e s . As a resul t of t h e se differences , Adapte r and B r i d g e are often u s ed at differen t p o i n t s in the softwar e l i f e c y c l e . An adapte r often b e c o m e s n e c e s s a r y when you d i s c o v e r that t wo incompatibl e c l a s s e s s h o u l d work t o g e t h e r , g e n e r a l l y to a v o id r e p l i c a t i n g c o d e. T he c o u p l i n g is u n f o r e s e e n . In contrast , t he u s er of a bridg e understand s up-fron t that an abstractio n mus t have s e v e r a l i m p l e m e n t a t i o n s , a nd both m ay e v o l v e i n d e p e n d e n t l y . T he A d a p t e r patter n m a k e s t h i n g s work after t h e y ' r e d e s i g n e d ; B r i d g e m a k e s t h em work before they are. T h at d o e s n ' t mean Adapte r is s o m e h o w inferio r to B r i d g e ; e a ch patter n merel y a d d r e s s e s a differen t p r o b l e m . Y ou m i g h t think of a facad e ( s ee F a c a d e ( 1 8 5 ) ) as an adapte r to a s et of o t h er o b j e c t s . B ut that interpretatio n o v e r l o o k s the fact that a facad e d e f i n e s a new interface , wherea s an adapte r r e u s e s an old interface . Remembe r that an adapte r make s two existing interface s work togethe r as o p p o s e d to d e f i n i n g an entirel y n ew o n e . C o m p o s i t e v e r s u s D e c o r a t o r v e r s u s P r o x y C o m p o s i t e ( 1 6 3) a nd Decorato r ( 1 7 5) have s i m i l a r structur e d i a g r a m s , r e f l e c t i n g t he f a ct that both r e ly on recursiv e c o m p o s i t i o n to o r g a n i z e an o p e n - e n d e d numbe r of o b j e c t s . T h i s c o m m o n a l i t y m i g h t t e m p t y o u t o t h i n k o f a d e c o r a t o r o b j e c t a s a d e g e n e r a t e ptg220 STRUCTURAL PATTERNS CHAPTER 4 c o m p o s i t e , but that m i s s e s the point of the Decorato r pattern . The similarit y e n ds at r e c u r s i v e c o m p o s i t i o n , again becaus e of differin g intents. Decorato r is d e s i g n e d to let you add r e s p o n s i b i l i t i e s to o b j e c t s withou t s u b c l a s s i n g . It avoid s the e x p l o s i o n of s u b c l a s s e s t h at can a r i se from tryin g to c o v e r e v e ry combinatio n of r e s p o n s i b i l i t i e s s t a t i c a l l y . Composit e has a differen t intent . It focuse s on structurin g c l a s s e s so t h at many relate d o b j e c t s can be treate d uniformly , and multipl e object s can be treate d as o n e. Its focus is not on embellishmen t but on representation. T h e s e intent s are distinc t but complementary . Consequently , the C o m p o s i t e and D e c o - rator pattern s are o f t en u s ed in c o n c e r t . Both l e ad to the kind of d e s i g n in whic h you can build application s just by pluggin g object s togethe r withou t definin g any new c l a s s e s . T h e re w i ll be an abstrac t c l a ss with some s u b c l a s s e s that are c o m p o s i t e s , s o me that are decorators , and s o me that implemen t the f u n d a m e n t a l buildin g b l o c k s of the system . In this c a s e, both c o m p o s i t e s and decorator s w i ll have a commo n interface . F r om the point of v i ew of the Decorato r pattern , a composit e is a ConcreteComponent . F r om the point of v i ew of the C o m p o s i t e pattern , a decorato r is a Leaf. Of c o u r s e , they don't have to be used togethe r and, as we have s e e n, their intent s are quite different. Anothe r patter n with a structur e s i m i l a r to Decorator' s is P r o x y ( 2 0 7 ) . Both pattern s d e s c r i b e how to provid e a l e v el of indirectio n to an o b j e c t , and the implementation s of both the prox y and decorato r o b j e c t keep a referenc e to anothe r o b j e c t to whic h they forwar d r e q u e s t s . O n ce a g a i n , however , they are intende d for differen t purposes. L i ke Decorator , the P r o x y patter n c o m p o s e s an objec t and p r o v i d e s an identica l in- terfac e to c l i e n t s . U n l i k e Decorator , the P r o x y patter n is not c o n c e r n e d with attachin g or detachin g propertie s dynamically , and i t 's not d e s i g n e d for r e c u r s i v e c o m p o s i t i o n . Its inten t is to provid e a stand-i n for a subjec t when it's inconvenien t or undesirabl e to a c c e s s the subjec t directl y because , for e x a m p l e , it l i v es on a remot e m a c h i n e , has restricte d a c c e s s , or is persistent. In the P r o x y pattern , the subjec t define s the key functionality , and the p r o xy p r o v i d e s (or refuses ) a c c e s s to it. In Decorator , the componen t p r o v i d e s o n ly part of the functionality , and one or more decorator s furnis h the r e s t. Decorato r a d d r e s s e s the situatio n wher e an object' s total functionalit y can't be determine d at c o m p i l e t i m e, at l e a st not c o n v e n i e n t l y . That o p e n - e n d e d n e s s make s r e c u r s i v e compositio n an e s s e n t i a l part of D e c o r a t o r . That isn't the c a se in P r o x y , becaus e P r o x y focuse s on one relationship—betwee n the proxy and its subject—an d that r e l a t i o n s h i p can be e x p r e s s e d s t a t i c a l l y . T h e s e difference s are significan t becaus e they captur e s o l u t i o n s to s p e c i f i c r e c u r r i n g p r o b l e m s in object-oriente d d e s i g n . But that doesn' t mean these pattern s can't be c o m - bined . You migh t e n v i s i o n a proxy-decorato r that adds functionalit y to a p r o x y , or a decorator-prox y that e m b e l l i s h e s a remot e object . Althoug h s u ch hybrid s might be usefu l (we don't have real example s handy) , they are d i v i s i b l e into pattern s that are useful. ptgC h a p t e r 5 B e h a v i o r a l P a t t e r n s Behaviora l pattern s are concerne d with algorithm s and the assignmen t of r e s p o n s i b i l i - ties betwee n objects . Behaviora l pattern s describ e not j u st pattern s of object s or c l a s s e s but also the pattern s of communicatio n betwee n them . T h e se pattern s characteriz e comple x contro l flow that's d i f f i c u l t to follow at run-time . T h ey shift your f o c us a w ay f r om flow of contro l to let you concentrat e j u st on the way object s are interconnected. Behaviora l c l a ss pattern s use inheritanc e to distribut e behavio r betwee n c l a s s e s . T h is chapte r include s two such patterns . Templat e Metho d ( 3 2 5) is the simple r and more commo n of the two. A templat e metho d is an abstrac t definitio n of an algorithm . It define s the algorith m step by step. Each step invoke s eithe r an abstrac t operatio n or a primitiv e operation . A subclas s fleshe s out the algorith m by definin g the abstrac t operations . The other behaviora l c l a ss p a t t e r n is Interprete r ( 2 4 3 ) , whic h represent s a gramma r as a c l a ss hierarch y and implement s an interprete r as an operatio n on i n s t a n c e s of t h e se c l a s s e s . Behaviora l objec t p a t t e r n s use objec t compositio n rathe r than inheritance . S o me de- s c r i be how a group of peer object s cooperat e to p e r f o r m a task that no s i n g le objec t can carry out by itself . An importan t issue here is how peer object s know abou t each o t h e r . P e e rs could maintai n explici t reference s to each other , but that woul d i n c r e a s e their coupling . In the extreme , every objec t woul d know abou t every other . The Me- diato r ( 2 7 3) p a t t e r n avoid s this by introducin g a mediato r objec t betwee n peers . The mediato r provide s the indirectio n neede d for l o o se coupling. Chain of Responsibilit y ( 2 2 3) provide s e v en l o o s e r coupling . It lets you s e nd request s to an objec t implicitl y throug h a chain of candidat e objects . Any candidat e may f u l f i l l the reques t dependin g on run-tim e conditions . The numbe r of candidate s is o p e n - e n d e d , and you can s e l e c t whic h candidate s participat e in the chain at run-time. The Observe r ( 2 9 3) p a t t e r n define s and maintain s a dependenc y betwee n objects . The classi c exampl e of Observe r is in Smalltal k Model/View/Controller , wher e all view s of the model are notified whenever the model's state changes. 2 2 1 ptg222 BEHAVIORAL PATTERNS CHAPTER 5 O t h e r b e h a v i o r a l o b j e c t pattern s a re c o n c e r n e d with e n c a p s u l a t i n g b e h a v i o r in an o b j e c t a nd d e l e g a t i n g r e q u e s t s to i t. T he S t r a t e g y ( 3 1 5) patter n e n c a p s u l a t e s an a l g o r i t h m in an o b j e c t . S t r a t e g y m a k e s it e a sy to s p e c i f y a nd c h a n g e t he a l g o r i t h m an o b j e c t u s e s. T he C o m m a n d ( 2 3 3) patter n e n c a p s u l a t e s a r e q u e s t in an o b j e c t so that it c an be p a s s e d as a parameter , s t o r ed on a h i s t o r y l i s t, or manipulate d in o t h er ways . T he S t a te ( 3 0 5) patter n e n c a p s u l a t e s t he s t a t es of an o b j e c t so that t he o b j e c t c an c h a n g e i ts b e h a v i o r w h en i ts state o b j e c t c h a n g e s . V i s i t o r ( 3 3 1) e n c a p s u l a t e s b e h a v i o r that w o u l d o t h e r w i s e be distribute d a c r o s s c l a s s e s , a nd Iterato r ( 2 5 7) abstract s t he w ay y ou a c c e s s a nd t r a v e r s e o b j e c t s in an aggregate. ptgCHAIN O F RESPONSIBILITY 223 CHAIN O F R E S P O N S I B I L I T Y object Behavioral Intent A v o i d c o u p l i n g the sende r of a reques t to its r e c e i v e r by g i v i n g more than one o b j e c t a chanc e to handl e the request . Chai n the r e c e i v i n g object s and pass the request along the chain until an object handles it. Motivation Conside r a context-sensitiv e help facilit y for a graphica l user interface . The user can obtai n help informatio n on any part of the interfac e just by c l i c k i n g on it. The help that's provide d depend s on the part of the interfac e that's s e l e c t e d and its context ; for e x a m p l e , a b u t t o n widge t in a d i a l o g box migh t have differen t help informatio n than a s i m i l a r b u t t o n in the main window . If no specifi c help informatio n exist s for that part of the interface , then the help syste m s h o u l d displa y a more genera l help messag e abou t the immediat e context—th e d i a l o g box as a whole , for example. Henc e it's natura l to organiz e help informatio n accordin g to its generality—fro m the most s p e c i f i c to the most g e n e r a l . Furthermore , it's c l e ar t h at a help r e q u e s t is handle d by one of s e v e r a l user interfac e o b j e c t s ; whic h one depend s on the contex t and how s p e c i f i c the availabl e help is. The proble m here is that the o b j e c t that ultimatel y provides the help isn't know n e x p l i c i t l y to the objec t ( e . g ., the button ) t h at initiates the help request . Wha t we n e ed is a way to d e c o u p l e the butto n that initiate s the help reques t from the o b j e c t s that migh t provid e help information . The Chai n of R e s p o n s i b i l i t y patter n define s how that happens. The i d ea of this patter n is to decoupl e sender s and r e c e i v e r s by g i v i n g multipl e object s a chanc e to handl e a request . The reques t gets p a s s e d along a chain of objects until one of them handles it. specific general ptg2 2 4 BEHAVIORAL PATTERNS CHAPTER 5 The f i r st objec t in the c h a in r e c e i v e s the r e q u e s t and eithe r handle s it or forward s it to t he n e xt c a n d i d a t e on t he c h a i n , w h i ch d o es l i k e w i s e . T he o b j e c t that made the reques t has no explici t knowledg e of who will handl e it—w e say the reques t has an implici t receiver. Let's assum e the user clicks for help on a butto n widge t marke d \" P r i n t . \" The butto n is c o n t a i n e d in an i n s t a n c e of P r i n t D i a l o g , w h i ch k n o w s t he a p p l i c a t i o n o b j e c t it b e l o n g s to ( s ee precedin g objec t diagram) . The followin g interactio n diagram illustrates how the help request gets forwarded along the chain: In this c a s e, neithe r aPrintButto n nor aPrintDialog handle s the r e q u e s t ; it stops at anApplication , whic h can handl e it or i g n o r e it. The c l i e n t that issue d the reques t has no d i r e c t referenc e to the objec t that ultimatel y fulfill s it. To forwar d the reques t a l o ng the c h a i n , and to ensur e r e c e i v e r s remai n i m p l i c i t , each o b j e c t on the c h a in s h a r e s a commo n interfac e for handlin g r e q u e s t s and for a c c e s s i n g i ts s u c c e s s o r on t he c h a i n . F or e x a m p l e , t he help s y s t e m migh t defin e a HelpHandle r c l a ss with a correspondin g HandleHel p operation . HelpHandle r can be the paren t c l a ss for candidat e objec t c l a s s e s , or it can be define d as a mixin c l a s s. T h en c l a s s e s that want to handl e help r e q u e s t s can make HelpHandle r a parent: ptgCHAIN OF RESPONSIBILITY 225 The Button , D i a l o g , and Applicatio n c l a s s e s use HelpHandle r operation s to handl e help r e q u e s t s . HelpHandler' s HandleHel p operatio n forward s the reques t to the s u c c e s s o r by default . S u b c l a s s e s can overrid e t h is operatio n to provid e help unde r the right c i r c u m s t a n c e s ; otherwis e they can use the defaul t implementatio n to f o r w a r d the request. Applicability U se C h a in of Responsibilit y when • m o re than o ne o b j e c t m ay h a n d l e a r e q u e s t , a nd t he h a n d l e r i s n 't k n o w n a priori. The handle r s h o u l d be ascertaine d automatically. • you want to i s s ue a reques t to one of s e v e r a l o b j e c t s withou t specifyin g the r e c e i v e r explicitly. • the set of objects that can handle a request should be specified dynamically. S t r u c t u r e A typical object structure might look like this: Participants • Handler ( H e l p H a n d l e r ) - defines an i n t e r f a c e for h a n d l i n g r e q u e s t s . - (optional) implements the s u c c e s s o r l i n k . ptg226 BEHAVIORAL PATTERNS CHAPTER 5 • ConcreteHandle r (PrintButton , PrintDialog) -handle s request s it is responsibl e for. -c an a c c e s s i ts s u c c e s s o r . -if the ConcreteHandle r can handl e the r e q u e s t , it d o es so; otherwis e it forwards the request to its successor. • C l i e n t - initiates the request to a ConcreteHandler object on the chain. C o l l a b o r a t i o n s • Whe n a c l i e n t i s s u e s a request , the reques t propagate s a l o ng the c h a in until a ConcreteHandler object takes responsibility for handling it. C o n s e q u e n c e s C h a i n of Responsibilit y has the followin g benefit s and l i a b i l i t i e s : 1. Reduced coupling. The patter n frees an o b j e c t f r om knowin g whic h other o b j e c t handle s a request . An objec t o n ly has to know that a reques t w i ll be handle d \"appropriately. \" B o th the r e c e i v e r and the s e n d e r have no e x p l i c i t knowledg e of e a ch o t h e r , and an o b j e c t in the c h a in doesn' t have to know abou t the c h a i n ' s structure. As a result , C h a in of Responsibilit y can simplif y objec t interconnections . Instea d of object s maintainin g reference s to all candidat e r e c e i v e r s , they keep a s i n g l e referenc e to their s u c c e s s o r . 2. Added flexibility in assigning responsibilities to objects. C h a i n of R e s p o n s i b i l i t y g i v es you adde d flexibilit y in distributin g r e s p o n s i b i l i t i e s amon g objects . You can add or c h a n g e responsibilitie s for handlin g a reques t by addin g to or otherwis e changin g the chain at run-time . You can c o m b i n e t h is with s u b c l a s s i n g to s p e c i a l i z e handler s statically. 3. Receipt isn't guaranteed. S i n ce a reques t has no e x p l i c i t r e c e i v e r , there' s no guarantee it'll be handled—th e reques t can f a ll off the end of the c h a in withou t e v er being handled . A reques t can also go unhandle d when the chain is not configured properly. Implementation Here are implementatio n i s s u e s to c o n s i d e r in C h a i n of R e s p o n s i b i l i t y : 1. Implementing the successor chain. T h e r e are two p o s s i b l e ways to implemen t t he s u c c e s s o r c h a i n : (a) Defin e new links (usuall y in the Handler , but ConcreteHandler s c o u ld define them instead). ptgCHAIN O F RESPONSIBILITY 227 ( b) U se e x i s t i n g l i n k s . O ur e x a m p l e s so f ar d e f i n e n ew l i n k s, b ut o f t en y ou c an u se e x i s t i n g o b j e c t r e f e r e n c e s to form t he s u c c e s s o r c h a i n . F or e x a m p l e , paren t r e f e r e n c e s in a part-whol e h i e r a r c h y can defin e a part's s u c c e s s o r . A widge t structur e migh t a l r e a d y have s u ch l i n k s. C o m p o s i t e ( 1 6 3) d i s c u s s e s paren t r e f e r e n c e s in more d e t a i l . U s i ng e x i s t i n g l i n ks work s w e ll when t he l i n ks suppor t t he c h a in y ou n e e d. It s a v es y ou from d e f i n i n g l i n ks e x p l i c i t l y , a nd it s a v es s p a c e . B ut if t he s t r u c t u r e d o e s n ' t r e f l e c t t he c h a in of r e s p o n s i b i l i t y your a p p l i c a t i o n r e q u i r e s , t h en y o u ' l l have to defin e redundan t l i n k s . 2. Connecting successors. If t h e re are no p r e e x i s t i n g r e f e r e n c e s for definin g a c h a i n , t h en you'l l h a ve to i n t r o d u c e them yourself . In that c a s e, t he Handle r n ot o n ly d e f i n e s t he i n t e r f a c e f or t he r e q u e s t s b ut u s u a l l y m a i n t a i n s t he s u c c e s s o r as w e l l. T h at l e ts the handle r provid e a defaul t implementatio n of H a n d l e R e q u e s t that forward s t he r e q u e s t to t he s u c c e s s o r ( if a n y ). If a C o n c r e t e H a n d l e r s u b c l a s s i s n 't i n t e r e s t e d in t he r e q u e s t , it d o e s n ' t have to o v e r r i d e the forwardin g o p e r a t i o n , s i n ce its defaul t implementatio n forward s u n c o n d i t i o n a l l y . H e r e ' s a HelpHandle r b ase c l a ss that maintain s a s u c c e s s o r l i n k : c l a ss H e l p H a n d l e r { public: H e l p H a n d l e r ( H e l p H a n d l e r * s) : _successor(s ) { } virtual void H a n d l e H e l p ( ) ; p r i v a t e : H e l p H a n d l e r * _successor ; } ; void H e l p H a n d l e r : : H a n d l e H e l p () { if ( _ s u c c e s s o r ) { _ s u c c e s s o r - > H a n d l e H e l p ( ) ; } } 3. Representing requests. Differen t option s are availabl e for r e p r e s e n t i n g r e q u e s t s . In t he s i m p l e s t form , t he r e q u e s t is a h a r d - c o d e d operatio n i n v o c a t i o n , as in t he c a se of HandleHelp . T h is is c o n v e n i e n t a nd safe, b ut y ou c an forwar d o n ly t he f i x ed s et of r e q u e s t s that t he Handle r c l a ss defines. An alternativ e is to use a s i n g le handle r functio n that takes a reques t c o de ( e . g ., an i n t e g e r constan t or a string ) as parameter . T h is support s an o p e n - e n d ed s et of r e q u e s t s . T he o n ly r e q u i r e m e n t is that t he s e n d e r a nd r e c e i v e r a g r ee on h ow t he r e q u e s t s h o u l d be e n c o d e d . T h is approac h is more f l e x i b l e , b ut it r e q u i r e s c o n d i t i o n a l statement s f or d i s p a t c h i n g t he r e q u e s t b a s ed on i ts c o d e. M o r e o v e r , there' s no type-saf e w ay to p a ss p a r a m e t e r s , so t h ey must be p a c k e d a nd u n p a c k e d m a n u a l l y . O b v i o u s l y this is less safe than invoking an operation directly. ptg228 BEHAVIORAL PATTERNS CHAPTERS To a d d r e s s t he parameter-passin g problem , we c an u se separat e r e q u e s t objects that bundl e r e q u e s t parameters . A R e q u e s t c l a ss can r e p r e s e n t re- quest s e x p l i c i t l y , a nd n ew k i n ds of request s c an be define d by s u b c l a s s i n g . S u b c l a s s e s can defin e differen t parameters . Handler s must know the k i nd of r e q u e s t (that i s, w h i c h R e q u e s t s u b c l a s s they'r e u s i n g ) to a c c e s s t h e se parameters. To identif y the r e q u e s t , R e q u e s t can defin e an a c c e s s o r functio n that return s an identifie r for the c l a s s. Alternatively , the r e c e i v e r can use run-tim e type informatio n if the implementatio n language s support s it. H e re is a s k e t c h of a dispatc h functio n that u s es r e q u e s t object s to identif y requests . A G e t K i n d operatio n define d in the base R e q u e s t c l a ss identifie s t h e kind of request: void H a n d l e r : : H a n d l e R e q u e s t ( R e q u e s t* theRequest ) { s w i t ch ( t h e R e q u e s t - > G e t K i n d ( ) ) { c a se Help: // c a st a r g u m e nt to appropriat e t y pe HandleHelp((HelpRequest* ) theRequest) ; b r e a k ; c a se P r i n t: HandlePrint((PrintRequest* ) theRequest) ; // . . . b r e a k ; default: // . . . b r e a k ; } } S u b c l a s s e s can exten d the dispatc h by o v e r r i d i n g H a n d l e R e q u e s t . The s u b c l a s s h a n d l e s o n ly t he request s in w h i c h i t 's i n t e r e s t e d ; o t h er request s a re forwarde d to t he paren t c l a s s. In t h is way, s u b c l a s s e s effectivel y e x - tend (rathe r than override ) the H a n d l e R e q u e s t operation . For e x a m p l e , h e r e ' s how an E x t e n d e d H a n d l e r s u b c l a s s extend s H a n d l e r ' s v e r s i o n of H a n d l e R e q u e s t : c l a ss E x t e n d e d H a n d l e r : public H a n d l er { public: virtual void H a n d l e R e q u e s t ( R e q u e s t * theRequest) ; // . . . } ; void E x t e n d e d H a n d l e r : : H a n d l e R e q u e s t ( R e q u e s t* theRequest ) { s w i t ch ( t h e R e q u e s t - > G e t K i n d ( ) ) { c a se P r e v i e w : // h a n d le t he P r e v i ew r e q u e st b r e a k ; ptgC H A I N OF RESPONSIBILITY 229 default: // l et Handler h a n d le o t h er r e q u e s ts Handler::HandleRequest(theRequest); } 4. Automatic forwarding in Smalltalk. You can use the d o e s N o t U n d e r s t a n d m e c h a n i s m in Smalltal k to f o r w a r d r e q u e s t s . M e s s a g e s that have no c o r r e s p o n d i n g m e t h o d s a re t r a p p e d in t he i m p l e m e n t a t i o n of d o e s N o t U n d e r s t a n d , w h i c h can be overridde n to forwar d the messag e to an object' s s u c c e s s o r . T h us it i s n 't n e c e s s a r y to i m p l e m e n t forwardin g manually ; t he c l a ss handle s o n ly t he r e q u e s t in whic h it's i n t e r e s t e d , a nd it r e l i e s on doesNotUnderstand t o forward all others. S a m p l e Code T he f o l l o w i n g e x a m p l e i l l u s t r a t e s h ow a c h a in of r e s p o n s i b i l i t y c an h a n d l e r e - quest s f or an o n - l i n e help s y s t e m l i ke t he o ne d e s c r i b e d e a r l i e r . T he h e lp reques t is an e x p l i c i t operation . W e ' ll u se e x i s t i n g paren t r e f e r e n c e s in t he widge t h i e r - archy to propagat e r e q u e s t s betwee n widget s in the c h a i n , and we'll defin e a referenc e in the Handle r c l a ss to propagat e help r e q u e s t s betwee n nonwidget s in t he c h a i n . The H e l p H a n d l e r c l a ss define s the interfac e for handlin g help r e q u e s t s . It main- t a i ns a h e lp t o p ic ( w h i c h is e m p t y by default ) a nd k e e ps a r e f e r e n c e to i ts s u c c e s s o r on t he c h a in of help handlers . T he k ey operatio n is H a n d l e H e l p , w h i c h s u b c l a s s e s override . H a s H e l p is a c o n v e n i e n c e operatio n for c h e c k i n g whethe r there is an a s s o c i a t e d help topic. t y p e d ef i nt T o p i c; c o n st T o p ic NO_HELP_TOPI C = -1; class HelpHandle r { public: HelpHandler(HelpHandler * = 0, T o p ic = NO_HELP_TOPIC) ; virtual bool HasHelp() ; virtual void SetHandler(HelpHandler* , Topic); virtual void HandleHelp(); private: HelpHandler * _successor; Topic _topic; } ; HelpHandler::HelpHandle r ( HelpHandler * h, Topic t ) : _successor(h) , _topic(t ) { } b o ol H e l p H a n d l e r : : H a s H e l p () { return _ t o p i c ! = NO_HELP_TOPIC; } ptg2 3 0 BEHAVIORAL P A T T E R N S CHAPTERS void HelpHandler::HandleHel p () { if ( _ s u c c e s s o r != 0) { _successor->HandleHelp() ; } } All widget s are s u b c l a s s e s of the W i d g e t abstrac t c l a s s. W i d g e t is a s u b c l a s s of H e l p H a n d l e r , s i n ce all user interfac e e l e m e n t s can have h e lp a s s o c i a t e d with them. (We could have used a mixin-based implementation just as w e l l . ) c l a ss Widget : public HelpHandle r { protected: Widget(Widget * p a r e n t, T o p ic t = N O _ H E L P _ T O P I C ) ; private: Widget* _parent; } ; Widget::Widge t ( W i d g e t* w, Topic t) : H e l p H a n d l e r ( w , t) { _parent = w; } In our example , a b u t t o n is the first handle r on the c h a i n . The B u t t o n c l a ss is a s u b c l a s s of W i d g e t . The B u t t o n constructo r takes two parameters : a referenc e to its enclosing widget and the help topic. c l a ss Button : public Widget { public: Button(Widget * d, Topic t = NO_HELP_TOPIC); virtual void HandleHelp() ; // Widget operations that Button overrides... } ; B u t t o n ' s versio n of H a n d l e H e l p first tests to see if there is a h e lp t o p ic for buttons . If the develope r hasn' t define d o n e, then the r e q u e s t g e ts forwarde d to the s u c c e s s o r u s i ng the H a n d l e H e l p operatio n in H e l p H a n d l e r . If t h e re is a help topic, then the button displays it, and the search ends. Button::Butto n ( W i d g e t* h, T o p ic t) : Widgetfh , t) { } void Button::HandleHel p () { if (HasHelpO ) { // offer help on the button } else { HelpHandler::HandleHelp() ; } } D i a l o g implement s a s i m i l a r s c h e m e , e x c e p t that its s u c c e s s o r is not a widge t but any h e lp h a n d l e r . In our applicatio n t h is s u c c e s s o r will be an i n s t a n c e of A p p l i c a t i o n . ptgCHAIN O F RESPONSIBILITY 231 c l a ss Dialog : public Widget { public: Dialog(HelpHandler * h, Topic t = NO_HELP_TOPIC) ; virtual void HandleHelp(); // Widget operation s that D i a l og overrides.. . // . . . } ; Dialog::Dialo g ( H e l p H a n d l e r * h, Topic t) : Widget(O ) { SetHandler(h , t); } void Dialog::HandleHel p () { if ( H a s H e l p O ) { // offer help on the dialog } else { HelpHandler::HandleHelp() ; } } At t he e nd of t he c h a in is an i n s t a n c e of A p p l i c a t i o n . T he a p p l i c a t i o n is n ot a w i d g e t , so A p p l i c a t i o n is s u b c l a s s e d d i r e c t l y f r om H e l p H a n d l e r . W h e n a h e lp r e q u e s t p r o p a g a t e s to t h is l e v e l , t he a p p l i c a t i o n c an s u p p l y i n f o r m a t i o n on t he a p p l i c a t i o n in g e n e r a l , or it c an offer a list of differen t h e lp t o p i c s : c l a ss Applicatio n : public HelpHandle r { public: Application(Topi c t) : HelpHandler(0 , t) { } virtual void HandleHelp() ; // application-specifi c operations... } ; void Application::HandleHel p () { // s h ow a list of h e lp topics } T he f o l l o w i n g c o de c r e a t e s a nd c o n n e c t s t h e se o b j e c t s . H e re t he d i a l o g c o n c e r n s p r i n t i n g , a nd so t he o b j e c t s h a ve p r i n t i n g - r e l a t e d t o p i c s a s s i g n e d . c o n st T o p ic P R I N T _ T O P I C - 1 ; c o n st T o p ic PAPER_ORIENTATION_TOPI C = 2; const T o p ic APPLICATION_TOPI C = 3; Application * applicatio n = new Application(APPLICATION_TOPIC) ; Dialog* dialog = new Dialog(application , PRINT_TOPIC) ; Button* button = new Button(dialog , PAPER_ORIENTATION_TOPIC); We c an i n v o k e t he h e lp r e q u e s t by c a l l i n g Hand l e He Ip on a ny o b j e c t on t he c h a i n . T o start the search at the button object, just call HandleHelp on it: ptg232 BEHAVIORAL P A T T E R N S CHAPTER 5 button->HandleHelp(); In t h is c a s e, the butto n will handl e the reques t i m m e d i a t e l y . Note that any H e l p H a n d l e r c l a ss could be made the s u c c e s s o r of D i a l o g . M o r e o v e r , its s u c - c e s s o r could be c h a n g e d dynamically . So no matte r wher e a dialo g is u s e d, you'l l get the proper context-dependent help information f o r i t . Known Uses S e v e r a l c l a ss librarie s use the C h a in of R e s p o n s i b i l i t y patter n to handl e user events . T h ey use differen t name s for the Handle r c l a s s, but the i d ea is the s a m e : When the user c l i c ks the mous e or p r e s s e s a k e y, an event g e ts generate d and p a s s e d a l o ng t he c h a i n . M a c A p p [ A p p 8 9 ] a nd ET++ [ W G M 8 8 ] c a ll it \" E v e n t - H a n d l e r , \" Symantec' s T CL librar y [ S y m 9 3 b ] c a l ls it \"Bureaucrat, \" a nd NeXT' s AppKi t [Add94 ] u s es the name \" R e s p o n d e r . \" The Unidra w f r a m e w o r k for graphica l editor s define s Comman d o b j e c t s that encapsulat e request s to Componen t and Componen t V i ew object s [ V L 9 0 ] . C o m - mand s are request s in the s e n se that a componen t or componen t v i ew may in- terpre t a comman d to p e r f o r m an operation . T h is correspond s to the \" r e q u e s t s as o b j e c t s \" approac h d e s c r i b e d in Implementation . Component s a nd componen t v i e w s may be structure d h i e r a r c h i c a l l y . A componen t or a componen t v i ew may f o r w a r d comman d interpretatio n to its parent , whic h may in turn f o r w a r d it to its parent , a nd so o n, thereb y formin g a c h a in of r e s p o n s i b i l i t y . ET++ uses C h a in of Responsibilit y to handl e graphica l update . A graphica l o b j e c t c a l ls the InvalidateRec t operatio n wheneve r it must updat e a part of its appear- a n c e. A graphica l objec t can't handl e InvalidateRec t by i t s e l f , b e c a u s e it d o e s n ' t know enoug h abou t its context . For example , a graphica l objec t can be e n c l o s e d in object s l i ke S c r o l l e r s or Zoomer s that t r a n s f o r m its coordinat e s y s t e m . T h at mean s the objec t migh t be s c r o l l e d or zoome d so that it's partiall y out of v i e w. Therefor e the d e f a u l t implementatio n of InvalidateRec t forward s the r e q u e s t to the e n c l o s i n g containe r object . The l a st objec t in the forwardin g c h a in is a W i n d o w instance . By t he time Windo w r e c e i v e s t he r e q u e s t , t he invalidatio n rectangl e is guarantee d to be transforme d properly . The W i n d o w h an dl e s InvalidateRec t by notifying the window system interface and requesting an update. Related P a t t e r n s Chain of Responsibilit y is often applie d in conjunctio n with Composit e ( 1 6 3 ) . T h e r e , a component's parent can act as its successor. ptgC O M M A N D 233 C O M M A N D O b j e c t Behavioral Intent Encapsulate a r e q u e s t as an o b j e c t , thereb y lettin g you parameteriz e c l i e n t s with different r e q u e s t s , queue or log requests, and support undoable operations. Also Known As Action, T r a n s a c t i o n Motivation S o m e t i m e s it's n e c e s s a r y to i s s ue r e q u e s t s to object s withou t knowin g anythin g abou t the operatio n bein g requeste d or the r e c e i v e r of the request . For example , user interfac e toolkit s includ e object s l i ke button s and menu s that carry out a r e q u e s t in r e s p o n s e to u s er input . B ut t he t o o l k i t c a n 't i m p l e m e n t t he r e q u e s t e x p l i c i t l y in the butto n or menu , b e c a u s e o n ly application s that use the toolki t know what shoul d be done on whic h object . As toolki t d e s i g n e r s we have no way of knowin g the r e c e i v e r of the r e q u e s t or the operation s that will carry it out. The Comman d patter n l e ts toolki t object s make r e q u e s t s of unspecifie d applica- tion object s by turnin g the reques t i t s e lf into an o b j e c t . T h is o b j e c t can be s t o r e d and p a s s e d aroun d like other o b j e c t s . The key to this patter n is an abstrac t C o m - mand c l a s s, w h i c h d e c l a r e s an interfac e for executin g operations . In the s i m p l e s t f o rm this interfac e include s an abstrac t Execut e operation . C o n c r e t e Comman d s u b c l a s s e s specif y a r e c e i v e r - a c t i o n pair by storin g the r e c e i v e r as an instanc e v a r i a b l e a nd by i m p l e m e n t i n g E x e c u t e to i n v o k e t he r e q u e s t . T he r e c e i v e r h as t he knowledge required to carry out the request. Menu s can be implemente d e a s i ly with Comman d objects . Each c h o i c e in a Menu is an instance of a Menultem class. An Application class creates these menus and ptg2 3 4 BEHAVIORAL PATTERNS CHAPTER 5 their menu i t e ms a l o ng with t he r e st of t he u s er interface . T he A p p l i c a t i o n c l a ss a l so k e e ps track of D o c u m e n t o b j e c t s that a user has o p e n e d . T he applicatio n configure s e a ch Menulte m with an i n s t a n c e of a c o n c r e t e C o m - mand s u b c l a s s . W h en t he u s er s e l e c t s a M e n u l t e m , t he Menulte m c a l ls Execut e on i ts command , a nd Execut e c a r r i e s o ut t he operation . M e n u l t e m s don't k n ow w h i c h s u b c l a s s of Comman d they u s e. Comman d s u b c l a s s e s s t o re t he r e c e i v e r of t he r e q u e s t a nd i n v o k e o ne or more operation s on t he r e c e i v e r . For example , PasteComman d support s pastin g text from the c l i p b o a r d i n to a Document . PasteCommand' s r e c e i v e r is t he D o c u m e n t objec t it is s u p p l i e d upon instantiation. The Execute operation invokes Paste on the receiving Document. OpenCommand' s Execut e o p e r a t i o n is different : it prompt s the u s er for a d o c u - ment n a m e , c r e a t e s a c o r r e s p o n d i n g D o c u m e n t o b j e c t , adds the documen t to the r e c e i v i n g application, and opens the document. S o m e t i m e s a Menulte m n e e ds to e x e c u t e a sequence of c o m m a n d s . For e x a m p l e , a Menulte m for c e n t e r i n g a page at norma l s i ze c o u ld be constructe d f r om a C e n - terDocumentComman d o b j e c t a nd a N o r m a l S i z e C o m m a n d o b j e c t . B e c a u s e i t 's c o m m o n to string commands together in this way, we can define a M a c r o C o m - mand class to allow a M e n u l t e m to execute a n open-ended number of c o m m a n d s . ptgC O M M A N D 2 3 5 MacroComman d is a c o n c r e t e Comman d s u b c l a s s that s i m p l y e x e c u t e s a s e q u e n c e of C o m m a n d s . MacroComman d h as no e x p l i c i t r e c e i v e r , b e c a u s e t he command s i t sequences define their own receiver. In e a ch of t h e se e x a m p l e s , n o t i ce h ow t he C o m m a n d patter n d e c o u p l e s t he o b j e c t that i n v o k e s the operatio n from the one h a v i n g the knowledg e to perfor m it. T h is g i v es us a l ot of f l e x i b i l i t y in d e s i g n i n g o ur u ser interface . An applicatio n c an provid e both a menu and a push butto n interfac e to a featur e just by makin g the men u and the push butto n s h a re an i n s t a n c e of the s a me c o n c r e t e Comman d s u b c l a s s . We can r e p l a c e command s d y n a m i c a l l y , whic h woul d be usefu l for i m p l e m e n t i n g c o n t e x t - s e n s i t i v e m e n u s . We c an a l so s u p p o r t c o m m a n d s c r i p t i n g by c o m p o s i n g command s into large r o n e s. A ll of t h is is p o s s i b l e b e c a u s e t he o b j e c t that i s s u e s a r e q u e s t o n ly n e e ds to know how to i s s ue it; it doesn' t n e ed to know how the request will be carried out. A p p l i c a b i l i t y Use the Comman d patter n when you want to • parameteriz e object s by an actio n to perform , as Menulte m object s did a b o v e . You can e x p r e s s s u ch parameterizatio n in a procedura l languag e with a callbac k function , that is, a functio n that's r e g i s t e r e d s o m e w h e r e to be c a l l ed at a later point . Command s are an o b j e c t - o r i e n t e d replacemen t for c a l l b a c k s . • s p e c i f y , q u e u e , and execut e request s at differen t t i m e s . A Comman d objec t can have a lifetim e independen t of the o r i g i n a l request . If the r e c e i v e r of a r e q u e s t can be r e p r e s e n t e d in an addres s space-independen t way, then you can transfe r a comman d objec t for the r e q u e s t to a differen t p r o c e s s and fulfil l the r e q u e s t t h e r e . • suppor t undo . The Command' s Execut e operatio n can s t o re state for r e v e r s - ing its e f f e c t s in the comman d itself . The Comman d interfac e must have an added Unexecute operation that reverses the effects o f a previous call to Ex- ptg2 3 6 BEHAVIORAL PATTERNS CHAPTER 5 ecute . Execute d command s are store d in a histor y l i s t. U n l i m i t e d - l e v e l undo and r e do is a c h i e v e d by traversin g this l i st backward s and forward s c a l l i n g Unexecut e and Execute , r e s p e c t i v e l y . • suppor t l o g g i n g c h a n g e s so that they can be r e a p p l i e d in c a se of a s y s t e m c r a s h . By augmentin g the Comman d interfac e with l o ad and s t o re opera- t i o n s , you can k e ep a persisten t log of c h a n g e s . R e c o v e r i n g from a crash i n v o l v e s r e l o a d i n g l o g g e d command s f r om d i sk and r e e x e c u t i n g them with the Execut e operation. • structur e a s y s t e m aroun d h i g h - l e v e l operation s built on primitive s opera- t i o n s . S u ch a structur e is c o m m o n in informatio n s y s t e m s that suppor t t r a n s - a c t i o n s . A transactio n encapsulate s a s et of c h a n g e s to data. T he Comman d patter n o f f e r s a way to m o d e l transactions . Command s have a commo n in- terface , lettin g you i n v o k e all transaction s the same way. The patter n also makes it easy to extend the system with new transactions. S t r u c t u r e Participants • C o m m a n d - declares an interface for e x e c u t i n g an operation. • ConcreteCommand ( P a s t e C o m m a n d , OpenCommand) - defines a b i n d i n g b e t w e e n a Receiver object and an a c t i o n . - implements E x e c u t e by invoking the corresponding operation(s) on Re - c e i v e r . • Client (Application) - creates a ConcreteCommand o b j e c t and s e t s its receiver. • Invoker (Menultem) - asks the c o m m a n d to c a r r y out the request. ptgC O M M A N D 237 • Receiver ( D o c u m e n t , A p p l i c a t i o n ) - knows how to perform t h e operations associated with carrying out a re - quest. Any class may serve as a Receiver. C o l l a b o r a t i o n s • T he c l i e nt create s a ConcreteComman d o b j e c t a nd s p e c i f i e s i ts r e c e i v e r . • An Invoke r objec t s t o r e s the ConcreteComman d object. • The invoke r i s s u e s a reques t by c a l l i n g Execut e on the command . Whe n c o m - mand s are u n d o a b l e , ConcreteComman d s t o r e s state for u n d o i n g the c o m - mand prior to invokin g Execute. • The ConcreteComman d o b j e c t i n v o k e s operation s on its r e c e i v e r to carry out the request. T he f o l l o w i n g d i a g r a m s h o w s t he i n t e r a c t i o n s b e t w e e n t h e se o b j e c t s . It i l l u s t r a t e s how Comman d d e c o u p l e s the i n v o k e r from the r e c e i v e r (and the reques t it carrie s out). C o n s e q u e n c e s The Comman d patter n has the followin g c o n s e q u e n c e s : 1. Comman d d e c o u p l e s the objec t that invoke s the operatio n from t he o ne that k n o w s h ow to perfor m i t . 2. Command s are first-clas s objects . T h ey can be manipulate d and extende d l i ke any other object. 3. Y ou c an a s s e m b l e command s into a c o m p o s i t e command . An exampl e is t he M a c r o C o m m a n d c l a ss d e s c r i b e d e a r l i e r . In g e n e r a l , c o m p o s i t e c o m m a n d s a re an i n s t a n c e of t he Composit e ( 1 6 3) pattern. 4. It's easy to add new Commands , becaus e you don't have to c h a n g e e x i s t i n g c l a s s e s . ptg2 3 8 BEHAVIORAL P A T T E R N S CHAPTERS I m p l e m e n t a t i o n C o n s i d e r t he f o l l o w i n g i s s u e s w h en i m p l e m e n t i n g t he C o m m a n d p a t t e r n : 1. H ow intelligent should a command b e? A comman d c an h a ve a wide r a n ge of a b i l i t i e s . At o ne extrem e it merel y define s a b i n d i n g b e t w e e n a r e c e i v e r a nd the a c t i o n s that carry out the r e q u e s t . At the o t h er e x t r e m e it i m p l e m e n t s e v e r y t h i n g i t s e lf withou t d e l e g a t i n g to a r e c e i v e r at a l l. T he latter e x t r e m e is usefu l when you want to defin e c o m m a n d s that are i n d e p e n d e n t of e x i s t i n g c l a s s e s , when no suitabl e r e c e i v e r e x i s t s , or w h en a comman d k n o w s i ts r e c e i v e r i m p l i c i t l y . F or e x a m p l e , a c o m m a n d that c r e a t e s a n o t h e r a p p l i c a t i o n windo w may be j u st as c a p a b l e of creatin g the w i n d o w as any o t h er o b j e c t . S o m e w h e r e in b e t w e e n t h e se e x t r e m e s a re c o m m a n d s t h at h a ve e n o u g h k n o w l e d g e to find t h e ir r e c e i v e r d y n a m i c a l l y . 2.Supporting undo and redo. Command s can suppor t undo and r e do c a p a b i l i t i e s if they provid e a way to r e v e r s e their e x e c u t i o n ( e . g ., an U n e x e c u t e or Undo operation) . A C o n c r e t e C o m m a n d c l a ss migh t n e ed to s t o re a d d i t i o n a l s t a te to do s o. T h is state c an i n c l u d e • t he R e c e i v e r o b j e c t , w h i c h actuall y c a r r i e s o ut o p e r a t i o n s in r e s p o n s e to the r e q u e s t , • the arguments to the operatio n performe d on the r e c e i v e r , and • any origina l value s in the r e c e i v e r that can c h a n g e as a r e s u l t of h a n d l i n g t he r e q u e s t . T he r e c e i v e r must p r o v i d e o p e r a t i o n s that l et t he comman d retur n the r e c e i v e r to its prior state. To suppor t o ne l e v el of undo , an applicatio n n e e ds to s t o re o n ly t he c o m - mand that was execute d l a s t. For m u l t i p l e - l e v e l undo and r e d o, the a p p l i c a - t i on n e e ds a histor y list of command s that h a ve b e en e x e c u t e d , w h e r e the maximu m lengt h of t he l i st determine s t he numbe r of undo/red o l e v e l s . T he histor y l i st s t o r e s s e q u e n c e s of command s that have b e en e x e c u t e d . T r a v e r s - i ng backwar d throug h t he l i st a nd r e v e r s e - e x e c u t i n g c o m m a n d s c a n c e l s t h e ir effect ; traversin g forwar d and e x e c u t i n g command s r e e x e c u t e s them. An undoabl e comman d m i g h t have to be c o p i e d befor e it c an be p l a c e d on t he histor y l i s t. That' s becaus e t he comman d o b j e c t that c a r r i e d o ut t he o r i g i n a l r e q u e s t , s a y, from a Menultem , will perfor m o t h er r e q u e s t s at later t i m e s . C o p y i n g is require d to d i s t i n g u i s h differen t i n v o c a t i o n s of t he s a me comman d if its state can vary a c r o s s i n v o c a t i o n s . For example , a DeleteComman d that d e l e t e s s e l e c t e d o b j e c t s must s t o re dif- feren t s e ts of o b j e c t s e a ch time i t 's e x e c u t e d . T h e r e f o r e t he D e l e t e C o m m a n d objec t must be c o p i e d followin g e x e c u t i o n , a nd t he c o py is p l a c e d on t he h i s - tory l i s t. If t he c o m m a n d ' s s t a te n e v er c h a n g e s on e x e c u t i o n , t h en c o p y i n g is n ot required—onl y a referenc e to t he comman d n e ed be p l a c e d on t he h i s t o r y list. Command s that must be c o p i e d befor e b e i ng p l a c e d on t he h i s t o r y l i st a c t as prototypes (see Prototype (117)). ptgCOMMAND 2 3 9 3. Avoiding error accumulation in the undo process. H y s t e r e s i s can be a proble m in ensurin g a r e l i a b l e , semantics-preservin g u n d o / r e d o mechanism . Error s can accumulat e as c o m m a n d s a re e x e c u t e d , u n e x e c u t e d , a nd r e e x e c u t e d r e p e a t - e d ly so that an application' s state eventuall y d i v e r g e s from origina l values . It may be necessar y therefor e to s t o re more informatio n in the comman d to ensur e that object s are restore d to their origina l state . The Mement o ( 2 8 3) pat- tern c an be a p p l i e d to g i ve t he c o m m a n d a c c e s s to t h is informatio n withou t exposin g the internal s of other objects. 4. Using C++ templates. For command s t h at (1) aren' t undoabl e and (2) don't r e q u i r e a r g u m e n t s , we c an u se C ++ t e m p l a t e s to a v o id c r e a t i n g a C o m m a n d s u b c l a s s for every kind of actio n and r e c e i v e r . We show how to do this in the S a m p l e C o d e s e c t i o n . S a m p l e Code The C++ code show n h e re s k e t c h e s the implementatio n of the Comman d c l a s s e s in the Motivatio n s e c t i o n . W e ' ll defin e O p e n C o m m a n d , P a s t e C o m m a n d , and MacroCommand. First the abstract Command class: class Command { public: v i r t u al \" C o m m a n d ( ) ; virtual void Execute( ) = 0; protected: Command() ; } ; O p e n C o m m a n d o p e n s a documen t w h o s e name is supplie d by the u s e r. An OpenComman d must be p a s s e d an A p p l i c a t i o n objec t in its constructor . A s k U s e r is an implementatio n routin e that prompt s the user for the name of the document to open. class O p e n C o m m a n d : public Command { public: OpenCommand(Application*); virtual void Execute() ; protected: virtual const c h a r* AskUser() ; private: Application * _application ; char* _response; } ; OpenCommand::OpenComman d (Application * a) { _applicatio n = a; } ptg240 BEHAVIORAL P A T T E R N S CHAPTERS void OpenCommand::Execut e () { c o n st c h a r* n a me = AskUser(); if ( n a me != 0) { Document * document = new Document(name) ; _application->Add(document) ; document->0pen(); } A Pas teCoiranan d must be p a s s e d a D o c u m e n t o b j e c t as its r e c e i v e r . The r e c e i v e r is given as a parameter t o PasteCommand's c o n s t r u c t o r . c l a ss P a s t e C o m m a n d : public C o m m a nd { public: P as t e C o m m a n d ( D o c u m e n t *); virtual void Execute() ; private: Document * _document ; } ; PasteCommand::PasteComman d ( D o c u m e n t * doc) { _documen t = doc; } void PasteCommand::Execut e () { _document->Paste() ; } For s i m p l e command s that aren' t undoabl e and don't requir e arguments , we can use a c l a ss templat e to parameteriz e the command' s r e c e i v e r . W e ' ll defin e a templat e s u b c l a s s S i m p l e C o m m a n d for s u ch commands . S i m p l e C o m m a n d is parameterize d by the R e c e i v e r type and maintain s a b i n d i n g betwee n a r e c e i v e r o b j e c t and an action stored as a pointer to a member function. template <class Receiver > c l a ss SimpleComman d : public C o m m a nd { public: t y p e d ef void ( R e c e i v e r : : * Action)(); SimpleCommand(Receiver * r, Action a) : _receiver(r) , _action(a ) { } virtual void Execute() ; private: Action _action; Receiver* _receiver; } ; T he constructo r s t o r e s t he r e c e i v e r a nd t he a c t i o n in t he c o r r e s p o n d i n g i n s t a n c e v a r i a b l e s . Execute simply applies the action t o t h e r e c e i v e r . ptgCOMMAND 241 template <class Receiver > void SimpleCommand<Receiver>::Execut e () { (_receiver->*_action)() ; } To c r e a t e a c o m m a n d t h at calls A c t i o n on an i n s t a n c e of c l a ss M y C l a s s , a c l i e n t s i m p l y w r i t e s MyClass* receiver = new MyClass; // . . . Command* aCommand = n ew SimpleCommand<MyClass>(receiver , &MyClass::Action) ; // . . . aCommand->Execute() ; K e ep in m i nd t h at t h is s o l u t i o n o n ly w o r k s f or s i m p l e c o m m a n d s . M o re c o m p l e x c o m m a n d s t h at k e ep t r a ck of n ot o n ly t h e ir r e c e i v e r s b ut a l so a r g u m e n t s a n d / o r u n do s t a te r e q u i r e a C o m m a n d s u b c l a s s . A MacroCommandmanage s a s e q u e n c e of s u b c o m m a n d s a nd p r o v i d e s o p e r a t i o n s f or a d d i n g a nd r e m o v i n g s u b c o m m a n d s . No explici t r e c e i v e r is r e q u i r e d , b e c a u s e t h e subcommands already define their receiver. c l a ss M a c r o C o m m a n d : p u b l ic C o m m a nd { public: MacroCommand() ; virtual \"MacroCommand(); virtual v o id A d d ( C o m m a n d * ) ; virtual void Remove(Command*); virtual void Execute() ; private: L i s t < C o m m a n d * > * _cmds; } ; T he k ey to t he MacroComman d is i ts E x e c u t e m e m b e r f u n c t i o n . T h is t r a v e r s e s a l l the subcommands and performs E x e c u t e on each of them. void MacroCommand::Execut e () { L i s t I t e r a t o r < C o m m a n d * > i(_cmds); for ( i. First ( ); ! i . I s D o ne () ; i.NextO ) { Command* c = i.Currentltem() ; c->Execute(); } N o te t h at s h o u l d t he MacroComman d i m p l e m e n t an U n e x e c u t e o p e r a t i o n , t h en i ts s u b c o m m a n d s m u st be u n e x e c u t e d in reverse o r d er relativ e to E x e c u t e ' s i m - p l e m e n t a t i o n . F i n a l l y , MacroComman d m u st p r o v i d e o p e r a t i o n s to m a n a g e i ts s u b c o m m a n d s . T h e MacroCommand is also responsible for deleting its s u b c o m m a n d s . ptg242 BEHAVIORAL P A T T E R N S CHAPTER 5 void M a c r o C o m m a n d : : A d d ( C o m m a n d* c) { _cmds->Append(c ) ; } void M a c r o C o m m a n d : : R e m o v e ( C o m m a n d* c) { _cmds->Remove(c) ; } Known Uses P e r h a p s the first e x a m p l e of the Comman d patter n appear s in a pape r by Lieberma n [ L i e 8 5 ] . MacAp p [ A p p 8 9 ] popularize d the notio n of command s for implementin g undoabl e operations . ET++ [ W G M 8 8 ] , I n t e r v i e w s [LCI+92] , and Unidra w [ V L 9 0 ] a l so d e f i n e c l a s s e s that f o l l ow t he C o m m a n d pattern . I n t e r v i e w s define s an A c t i o n abstrac t c l a ss that provide s comman d functionality . It also de- fines an ActionCallbac k template , parameterize d by actio n method , that can in- s t a n t i a t e c o m m a n d s u b c l a s s e s a u t o m a t i c a l l y . The THIN K c l a ss librar y [ S y m 9 3 b ] also uses command s to suppor t undoabl e actions . Command s in T H I N K are calle d \" T a s k s . \" T a sk object s are p a s s e d a l o ng a C h a in of R e s p o n s i b i l i t y ( 2 2 3) f or c o n s u m p t i o n . Unidraw' s comman d object s are uniqu e in that they can behav e like messages . A Unidra w comman d may be s e nt to anothe r o b j e c t for interpretation , and the resul t of the interpratio n varie s with the receivin g object . M o r e o v e r , the r e c e i v e r may delegat e the interpretatio n to anothe r object , typicall y the receiver' s paren t in a large r structur e as in a Chai n of R e s p o n s i b i l i t y . T he r e c e i v e r of a Unidra w c o m - mand is thus compute d rathe r than stored . Unidraw' s interpretatio n m e c h a n i s m depend s on run-tim e type information. C o p l i e n d e s c r i b e s h ow to i m p l e m e n t f u n c t o r s , o b j e c t s that a re f u n c t i o n s , in C++ [ C o p 9 2 ] . He a c h i e v e s a d e g r e e of transparenc y in their use by overload- ing the functio n call operato r ( o p e r a t o r ( )) . The Comman d patter n is different ; i ts focus is on m a i n t a i n i n g a binding between a r e c e i v e r a nd a functio n ( i . e ., a c t i o n ) , not just maintaining a f u n c t i o n . Related P a t t e r n s A Composit e ( 1 6 3) can be used to implemen t MacroCommands. A M e m e n t o ( 2 8 3) c an k e ep state t he c o m m a n d r e q u i r e s to undo i ts effect. A comman d that must be copie d befor e being place d on the histor y l i st acts as a Prototype (117). ptgINTERPRETER 243 I N T E R P R E T E R ciass Behavioral I n t e n t G i v e n a language , defin e a r e p r e s e n t i o n for its gramma r a l o ng with an interprete r that uses the representation to interpret sentences in the language. M o t i v a t i o n If a particula r k i nd of proble m o c c u r s often e n o u g h , then it migh t be worthwhil e to e x p r e s s i n s t a n c e s of t he p r o b l e m as s e n t e n c e s in a s i m p l e l a n g u a g e . T h en y ou can build an interprete r that s o l v e s the proble m by interpretin g t h e se s e n t e n c e s . For e x a m p l e , s e a r c h i n g for s t r i n g s that matc h a patter n is a c o m m o n p r o b l e m . R e g u l a r e x p r e s s i o n s a re a s t a n d a r d l a n g u a g e f or s p e c i f y i n g pattern s of s t r i n g s . Rathe r than buildin g c u s t o m algorithm s to matc h e a ch patter n agains t s t r i n g s , s e a r c h algorithm s c o u ld interpre t a regula r e x p r e s s i o n that s p e c i f i e s a s et of s t r i n g s to m a t c h . The Interprete r patter n d e s c r i b e s how to defin e a gramma r for s i m p l e l a n g u a g e s , r e p r e s e n t s e n t e n c e s in t he language , a nd interpre t t h e se s e n t e n c e s . In this e x a m p l e , the patter n d e s c r i b e s how to defin e a gramma r for regula r e x p r e s s i o n s , r e p r e s e n t a particular regular expression, and how to interpret that regular expression. S u p p o s e the following grammar defines the regular expressions: e x p r e s s i o n ::= literal | alternatio n | s e q u e n ce | repetitio n | ' (' e x p r e s s i o n ' )' a l t e r n a t i o n ::- e x p r e s s i o n ' |' e x p r e s s i o n s e q u e n ce ::- e x p r e s s i o n ' &' e x p r e s s i o n repetitio n : := e x p r e s s i o n ' *' literal ::- ' a ' \\ ' b ' | ' c ' | . . . { 'a' | 'b' | 'c' | . . . } * The s y m b o l e x p r e s s i o n is the start s y m b o l , and l i t e r a l is a termina l symbo l definin g s i m p l e words T he I n t e r p r e t e r patter n u s es a c l a ss to r e p r e s e n t e a ch gramma r r u l e. S y m b o l s on t he r i g h t - h a n d s i de of t he rule a re i n s t a n c e variable s of t h e se c l a s s e s . T he gramma r a b o ve is r e p r e s e n t e d by f i ve c l a s s e s : an abstrac t c l a ss RegularExpressio n a nd i ts f o ur s u b c l a s s e s L i t e r a l E x p r e s s i o n , A l t e r n a t i o n E x p r e s s i o n , S e q u e n c e E x p r e s s i o n , and RepetitionExpression. The l a s t t h r e e c l a s s e s define variables that hold subex - p r e s s i o n s . ptg2 4 4 BEHAVIORAL PATTERNS CHAPTER 5 Every regula r e x p r e s s i o n define d by t h is gramma r is r e p r e s e n t e d by an abstrac t synta x tree made up of i n s t a n c e s of t h e se c l a s s e s . For e x a m p l e , the abstrac t synta x tree represent s the regula r e x p r e s s i o n r a i n i ng & ( d o gs | cats) * We can creat e an interprete r for t h e se regula r e x p r e s s i o n s by definin g the Interpre t operatio n on e a ch s u b c l a s s of RegularExpression . Interpre t takes as an argumen t t he c o n t e x t in w h i c h to interpre t t he e x p r e s s i o n . T he contex t contain s t he input s t r i ng a nd informatio n on h ow much of it h as b e en matche d so far. E a ch s u b c l a s s of RegularExpressio n implement s Interpre t to matc h the next part of the input s t r i n g b a s e d on the current context. F o r example, ptgINTERPRETER 2 4 5 • LiteralExpressio n will c h e ck if the input matche s the litera l it d e f i n e s , •A l t e r n a t i o n E x p r e s s i o n w i ll c h e ck if t he input m a t c h e s a ny of i ts a l t e r n a t i v e s , •RepetitionExpressio n w i ll c h e ck if t he input h as multipl e c o p i e s of e x p r e s s i o n i t repeats, a n d s o o n . A p p l i c a b i l i t y Use the Interprete r patter n when there is a languag e to interpret , and you can r e p r e s e n t statement s in the languag e as abstrac t synta x tr ees. The Interprete r patter n work s b e st when • t he gramma r is s i m p l e . F or c o m p l e x g r a m m a r s , t he c l a ss h i e r a r c h y f or t he gramma r b e c o m e s l a r ge and unmanageable . T o o ls s u ch as parse r generator s are a bette r alternativ e in s u ch c a s e s . T h ey can interpre t e x p r e s s i o n s withou t buildin g abstrac t synta x t r e e s, whic h can save s p a ce and p o s s i b l y time. • efficienc y is not a critica l c o n c e r n . The m o st efficien t interpreter s are usuall y not implemente d by interpretin g parse t r e es d i r e c t l y but by first translatin g them into anothe r form . For example , regula r e x p r e s s i o n s are often trans- forme d i n to state m a c h i n e s . But e v en t h e n, the translator can be implemente d by the Interpreter pattern, so the pattern is still applicable. S t r u c t u r e Participants • A b s t r a c t E x p r e s s i o n ( R e g u l a r E x p r e s s i o n ) - d e c l a r e s an abstrac t Interpre t operatio n that is commo n to all n o d e s in the abstract syntax tree. ptg246 BEHAVIORAL PATTERNS CHAPTER 5 • T e r m i n a l E x p r e s s i o n ( L i t e r a l E x p r e s s i o n ) -implement s an Interpre t operatio n associate d with termina l s y m b o l s in the grammar. -an i n s t a n c e is r e q u i r e d f or every termina l s y m b o l in a s e n t e n c e . • N o n t e r m i n a l E x p r e s s i o n ( A l t e r n a t i o n E x p r e s s i o n , R e p e t i t i o n E x p r e s s i o n , S e - q u e n c e E x p r e s s i o n s ) - one s u ch c l a ss is require d for every rule R ::= R\\R^ • •. Rn in the grammar. - maintain s i n s t a n c e variable s of type AbstractExpressio n for e a ch of the s y m b o l s RI t h r o u g h Rn. -i m p l e m e n t s an Interpre t operatio n for nontermina l s y m b o l s in the gram- mar. Interpre t typicall y c a l ls i t s e lf r e c u r s i v e l y on t he v a r i a b l e s representin g RI throug h Jin. • C o n t e x t - c o n t a i n s i n f o r m a t i o n that's g l o b a l to t he i n t e r p r e t e r . • C l i e n t -build s (or is g i v e n ) an abstrac t synta x t r ee r e p r e s e n t i n g a particula r s e n - t e n ce in the languag e that the gramma r defines . The abstrac t synta x tree is a s s e m b l e d from instances of the NonterminalExpression and T e r m i n a l E x - p r e s s i o n c l a s s e s . -i n v o k e s the Interpret operation. C o l l a b o r a t i o n s • T he c l i e nt build s ( or is g i v e n ) t he s e n t e n c e as an abstrac t synta x tree of Nonter- m i n a l E x p r e s s i o n a nd T e r m i n a l E x p r e s s i o n i n s t a n c e s . T h en t he c l i e n t i n i t i a l i z e s the contex t and i n v o k e s the Interpre t operation. • E a ch NonterminalExpressio n n o de define s Interpre t in term s of Interpre t on e a ch s u b e x p r e s s i o n . T he Interpre t operatio n of e a ch T e r m i n a l E x p r e s s i o n d e - fines t he base c a se in t he r e c u r s i o n . • The Interpre t operation s at e a ch n o de use the contex t to s t o re and a c c e s s the state of the i n t e r p r e t e r . C o n s e q u e n c e s The Interprete r patter n has the followin g benefit s and l i a b i l i t i e s : 1. It's easy to change a nd extend t he grammar. B e c a u s e t he patter n u s es c l a s s e s to r e p r e s e n t gramma r r u l e s , you can use inheritanc e to c h a n g e or exten d t he grammar . E x i s t i n g e x p r e s s i o n s c an be modifie d i n c r e m e n t a l l y , a nd n ew e x p r e s s i o n s can be defined as variations on old ones. ptgINTERPRETER 247 2. Implementing the grammar is easy, too. C l a s s e s definin g n o d e s in the abstrac t synta x tree have simila r implementations . T h e s e c l a s s e s are easy to write , and often t h e ir generatio n can be automate d with a compile r or parse r generator. 3. Complex grammars are hard to maintain. The Interprete r patter n define s at least one c l a ss for every rule in the gramma r (gramma r rules define d using BNF may requir e multipl e c l a s s e s ) . H e n c e grammar s containin g many rules can be hard to manag e and maintain . Othe r d e s i g n pattern s can be applie d to mitigat e the proble m ( s ee Implementation) . But when the gramma r is very c o m p l e x , other technique s such as parse r or compile r generator s are more appropriate. 4. Adding new ways to interpret expressions. The Interprete r patter n make s it e a s i e r to evaluat e an e x p r e s s i o n in a new way. For e x a m p l e , you can suppor t p r e t t y printin g or type-checkin g an expressio n by definin g a new operatio n on t he e x p r e s s i o n c l a s s e s . If y ou k e ep c r e a t i n g n ew ways of i n t e r p r e t i n g an e x p r e s s i o n , then conside r using the Visito r ( 3 3 1) p a t t e r n to avoid changin g the grammar classes. Implementation The Interprete r and Composit e ( 1 6 3) pattern s share many implementatio n i s s u e s . The followin g i s s u e s are specifi c to Interpreter: 1.Creating the abstract syntax tree. The Interprete r patter n doesn' t explai n how to create an abstrac t synta x tree. In other words , it doesn' t addres s parsing . The abstrac t synta x tree can be create d by a table-drive n parser , by a hand-crafte d (usuall y recursiv e descent ) parser , or directl y by the client. 2.Defining the Interpret operation. You don't have to defin e the Interpre t o p e r - ation in the e x p r e s s i o n c l a s s e s . If it's commo n to creat e a new interpreter , then it's bette r to use the Visito r ( 3 3 1) patter n to put Interpre t in a separat e \"visitor \" object . For example , a gramma r for a programmin g languag e will have many operation s on abstrac t synta x t r e e s, such as as t y p e - c h e c k i n g , op- t i m i z a t i o n , c o de g e n e r a t i o n , a nd so o n. It will be m o re l i k e ly to u se a v i s i t o r to avoid definin g t h e se operation s on ever y gramma r c l a s s . 3.Sharing terminal symbols with the Flyweight pattern. Grammar s w h o s e s e n t e n c e s contai n many occurrence s of a termina l symbo l migh t benefi t from sharin g a s i n g le c o py of that s y m b o l . Grammar s for compute r program s are g o od examples—eac h progra m variabl e will appea r in many place s throughou t the c o d e. In the Motivatio n example , a s e n t e n c e can have the termina l symbo l d og ( m o d e l e d by t he L i t e r a l E x p r e s s i o n c l a s s) appearin g many t i m e s . Termina l n o d e s generall y don't store informatio n abou t their positio n in the a b s t r a c t synta x t r e e. P a r e n t n o d e s p a ss them w h a t e v e r c o n t e x t t h ey n e ed durin g interpretation . H e n c e there is a distinctio n betwee n share d (intrinsic ) state and passed-in ( e x t r i n s i c ) state, and the Flyweight (195) pattern applies. ptg248 BEHAVIORAL PATTERNS CHAPTERS For e x a m p l e , e a ch i n s t a n c e of LiteralExpressio n for dog r e c e i v e s a contex t c o n t a i n i n g t he substrin g matche d so far. A nd e v e ry s u ch LiteralExpressio n d o es t he s a me thing in i ts Interpre t operation—i t c h e c k s whethe r t he n e xt part of the input c o n t a i n s a dog—n o matte r wher e the i n s t a n c e appear s in t h e tree. S a m p l e C o d e Here a re t wo e x a m p l e s . T he f i r st is a c o m p l e t e exampl e in S m a l l t a l k f or c h e c k i n g whethe r a s e q u e n c e m a t c h e s a r e g u l a r e x p r e s s i o n . T he s e c o n d is a C ++ progra m for evaluatin g B o o l e a n e x p r e s s i o n s . T he regula r e x p r e s s i o n matche r tests whethe r a s t r i ng is in t he l a n g u a g e define d by t he regula r e x p r e s s i o n . T he regula r e x p r e s s i o n is define d by t he followin g grammar: e x p r e s s i o n : := literal | alternatio n | s e q u e n ce | repetitio n | ' (' e x p r e s s i o n ' )' a l t e r n a t i o n : := e x p r e s s i o n ' ]' e x p r e s s i o n s e q u e n ce ::= e x p r e s s i o n ' &' e x p r e s s i o n repetitio n ::- e x p r e s s i o n ' r e p e a t' literal : : = ' a ' | 'b' | ' c ' | ... { ' a ' | 'b' | ' c ' | ... }* T h is gramma r is a s l i g ht modificatio n of t he Motivatio n example . We c h a n g e d t he c o n c r e t e synta x of r e g u l a r e x p r e s s i o n s a l i t t l e, b e c a u s e s y m b o l \" *\" can't be a postfi x operatio n in Smalltalk . So we use r e p e a t i n s t e a d . For e x a m p l e , the regular expression ( ( ' d o g ' | ' c a t ') r e p e a t & 'weather') matche s the input s t r i ng \" d og dog cat w e a t h e r \" . To i m p l e m e n t t he matcher , we defin e t he f i ve c l a s s e s d e s c r i b e d on p a ge 2 4 3. T he c l a ss SequenceExpressio n h as i n s t a n c e v a r i a b l e s expres- sion ! and e x p r e s s i o n 2 for its c h i l d r e n in the abstrac t synta x t r e e. A l t e r n a t i o n E x p r e s s i o n s t o r e s its a l t e r n a t i v e s in the i n s t a n c e v a r i a b l e s a l t e r n a t i v e l and a l t e r n a t i v e 2 , w h i le R e p e t i t i o n E x p r e s s i o n h o l d s the e x p r e s s i o n it r e p e a t s in its r e p e t i t i o n i n s t a n c e v a r i a b l e . L i t e r a l E x p r e s s i o n has a c o m p o n e n t s i n s t a n c e variabl e that h o l ds a l i st of o b j e c t s (probabl y characters) . T h e se r e p r e s e n t the l i t e r a l s t r i ng that must matc h the input s e q u e n c e . T he m a t c h : o p e r a t i o n i m p l e m e n t s an i n t e r p r e t e r f or t he r e g u l a r e x p r e s s i o n . E a ch of t he c l a s s e s d e f i n i n g t he abstrac t synta x t r ee implement s t h is o p e r a t i o n . It takes i n p u t S t a te as an argumen t r e p r e s e n t i n g the curren t state of the matchin g p r o c e s s , havin g read part of t he input s t r i n g . T h is curren t state is characterize d by a s et of i n p ut stream s r e p r e s e n t i n g t he s et of input s that t he regula r e x p r e s s i o n c o u ld have a c c e p t e d so far. ( T h is is r o u g h l y e q u i v a l e n t to r e c o r d i n g all states that the e q u i v a l e n t finite state automat a woul d b e in, h a v i n g recognized t h e input stream to this point). ptgINTERPRETER 2 4 9 T he c u r r e n t state is m o st i m p o r t a n t to t he r e p e a t o p e r a t i o n . F or e x a m p l e , if t he r e g u l a r e x p r e s s i o n w e r e ' a' repeat t h en t he i n t e r p r e t e r c o u ld m a t c h \" a \", \" a a \" , \" a a a \" , a nd so o n. If it w e r e ' a' r e p e a t & ' b e ' t h en it c o u ld m a t c h \" a b c \" , \" a a b c \" , \" a a a b c \" , a nd so o n. B ut if t he r e g u l a r e x - p r e s s i o n w e r e ' a' r e p e a t & ' a b c ' t h en m a t c h i n g t he i n p u t \" a a b c \" a g a i n s t t he s u b e x p r e s s i o n \"' a' r e p e a t \" w o u l d y i e ld t wo i n p u t s t r e a m s , o ne h a v i n g m a t c h e d o ne c h a r a c t e r of t he i n p u t , a nd t he o t h er h a v i n g m a t c h e d t wo c h a r a c t e r s . O n ly t he s t r e a m that h as a c c e p t e d o ne c h a r a c t e r will m a t c h t he r e m a i n i n g \" a b c \" . N ow we c o n s i d e r t he d e f i n i t i o n s of m a t c h : f or e a ch c l a ss d e f i n i n g t he r e g u - l ar e x p r e s s i o n . T he d e f i n i t i o n f or SequenceExpressio n m a t c h e s e a ch of i ts s u b e x p r e s s i o n s in s e q u e n c e . U s u a l l y it will e l i m i n a t e i n p u t s t r e a m s f r om i ts i n p u t S t a t e . match: inputStat e \" e x p r e s s i o n 2 match: ( e x p r e s s i o n l match: i n p u t S t a t e ) . An A l t e r n a t i o n E x p r e s s i o n will r e t u r n a state that c o n s i s t s of the u n i on of state s f r om e i t h e r alternative . T he d e f i n i t i o n of m a t c h : f o r A l t e r n a t i o n E x p r e s s i o n is m a t c h : i n p u t S t a t e I f i n a l S t a t e I f i n a l S t a t e := a l t e r n a t i v e l m a t c h : i n p u t S t a t e . f i n a l S t a t e a d d A l l : ( a l t e r n a t i v e 2 m a t c h : i n p u t S t a t e ) . ~ f i n a l S t a t e The mat c h: o p e r a t i o n for R e p e t i t i onExpr e s s i on t r i es to find as m a ny state s t h at c o u ld m a t c h as p o s s i b l e : match: inputStat e I aState finalStat e I aState := inputState . finalStat e := inputStat e copy. [ a S t a te isEmpty] whileFalse : [ a S t a te := repetitio n match: aState. finalState addAll: a S t a t e ] . \" f i n a l S t a t e ptg250 BEHAVIORAL PATTERNS CHAPTER 5 Its outpu t state usuall y contain s more states than its input s t a t e, b e c a u s e a R e p e t i t i o n E x p r e s s i o n can matc h o n e, two, or many o c c u r r e n c e s of r e p e t i t i o n on the input state. The outpu t states represen t all t h e se p o s s i b i l - i t i e s, a l l o w i n g subsequen t e l e m e n t s of t he regula r e x p r e s s i o n to d e c i d e w h i c h state is t he correc t o n e . F i n a l l y , the definitio n of m a t c h : for L i t e r a l E x p r e s s i o n tries to matc h its component s a g a i n s t e a ch p o s s i b l e input stream . It keeps o n ly t h o se input stream s that have a match: match: inputStat e | finalStat e t S t r e am | finalStat e := S et n e w. inputState do: [ : s t r e am | tStream := s t r e am c o p y . ( t S t r e am n e x t A v a i l a b l e : c o m p o n e n t s s i z e ) = c o m p o n e n t s i f T r u e: [ f i n a l S t a t e a d d: tStream] ] . \" finalState T he n e x t A v a i l a b l e : m e s s a g e advance s t he input stream . T h is is t he o n ly m a t c h : operatio n that advance s the stream . N o t i c e how the state that's returne d c o n t a i n s a copy of the input stream , thereb y e n s u r i n g that matchin g a litera l never c h a n g e s t he input stream . T h is is importan t becaus e e a ch alternativ e of an A l t e r n a t i o n E x p r e s s i o n s h o u l d see identica l c o p i e s of the input stream. Now that we've define d the c l a s s e s that make up an abstrac t synta x t r e e, we can d e s c r i b e how to build it. Rathe r than write a parse r for regula r e x p r e s s i o n s , w e ' ll defin e s o me operation s on the R e g u l a r E x p r e s s i o n c l a s s e s so that evaluatin g a Smalltal k e x p r e s s i o n will produc e an abstrac t synta x tree for the c o r r e s p o n d i n g regula r e x p r e s s i o n . That l e ts us u se t he b u i l t - i n S m a l l t a l k c o m p i l e r as if it were a parse r for regula r e x p r e s s i o n s . To build t he abstrac t synta x t r e e, we'll n e ed to defin e \" | \", \"repeat\" , a nd \"&\" as operation s on R e g u l a r E x p r e s s i o n . T h e se operation s a re define d in c l a ss R e g u l a r E x p r e s s i o n like this: & aNode \" S e q u e n c e E x p r e s s i o n new e x p r e s s i o n l : s e l f expression2: aNode asRExp r e p e a t RepetitionExpression new repetition: self ptgINTERPRETER 251 | aNode A l t e r n a t i o n E x p r e s s i o n n ew alternativel : s e lf alternative2 : a N o de a s R E x p a s R E xp ~ self The a s R E x p operatio n w i ll conver t literal s i n to R e g u l a r E x p r e s s i o n s . T h e se operations are defined in class String: & aNode S e q u e n c e E x p r e s s i o n n ew e x p r e s s i o n l : s e l f a s R E x p expression2: aNode asRExp r e p e a t RepetitionExpressio n n ew repetition : s e l f | a N o d e A l t e r n a t i o n E x p r e s s i o n n ew alternativel: self asRExp alternative2: aNode asRExp a s R E x p L i t e r a l E x p r e s s i o n n e w components: self If we define d t h e se operation s h i g h e r up in the c l a ss h i e r a r c h y ( S e q u e n c e a b l e - C o l l e c t i o n in S m a l l t a l k - 8 0 , I n d e x e d C o l l e c t i o n in Smalltalk/V) , then they woul d a l so be define d f or c l a s s e s s u ch as A r r a y a nd O r d e r edCo 11 a ct ion. T h is woul d l et regula r e x p r e s s i o n s matc h s e q u e n c e s of a ny k i nd of o b j e c t . T he s e c o n d exampl e is a s y s t e m for manipulatin g a nd evaluatin g B o o l e a n e x p r e s - s i o ns i m p l e m e n t e d in C++. T he t e r m i n a l s y m b o l s in t h is l a n g u a g e a re B o o l e a n v a r i a b l e s , that is, the c o n s t a n t s t r ue and f a l s e . N o n t e r m i n a l s y m b o l s r e p r e s e n t e x p r e s s i o n s c o n t a i n i n g the operator s and, or, and n o t. The gramma r is d e f i n e d a s follows 1: B o o l e a n E x p : := VariableEx p | C o n s t a nt | O r E xp | A n d E xp | NotExp | ' (' B o o l e a n E x p ' ) ' A n d E xp ::- B o o l e a n E x p ' a n d' B o o l e a n E x p O r E xp : := B o o l e a n E x p ' o r' B o o l e a n E x p N o t E xp : := ' n o t' B o o l e a n E x p C o n s t a n t : : = ' t r u e ' | ' f a l s e ' VariableExp : : = ' A ' j ' B ' | . . . | ' X ' | 'Y' | 'Z' We defin e two operation s on B o o l e a n e x p r e s s i o n s . The first, E v a l u a t e , evaluate s a B o o l e a n e x p r e s s i o n in a c o n t e x t that a s s i g n s a true or false v a l ue to e a ch v a r i a b l e . T he s e c o n d operation , R e p l a c e , p r o d u c e s a n ew B o o l e a n e x p r e s s i o n by r e p l a c i n g a variabl e with an e x p r e s s i o n . R e p l a c e s h o w s how the Interprete r patter n can be u s ed for more than j u st e v a l u a t i n g e x p r e s s i o n s . In t h is c a s e, it manipulate s the e x p r e s s i o n itself. 1 F or s i m p l i c i t y , we i g n o r e operato r p r e c e d e n c e a nd a s s u m e it's t he r e s p o n s i b i l i t y of w h i c h e v e r o b j e c t constructs the syntax tree. ptg2 52 B E H A V I O R A L PATTERNS CHAPTER 5 We g i ve d e t a i l s of just the B o o l e a n E x p , V a r i a b l e E x p , and AndEx p c l a s s e s h e r e. C l a s s e s O r E x p and N o t E x p are simila r to AndExp . The C o n s t a n t c l a ss r e p r e s e n t s the Boolean c o n s t a n t s . B o o l e a n E x p defines the interface for all c l a s s e s t h a t d e f i n e a Boolean expression: c l a ss B o o l e a n E x p { public: B o o l e a n E x p ( ) ; virtual \" B o o l e a n E x p ( ) ; virtual bool Evaluate(Contexts ) = 0; virtual B o o l e a n E x p * Replace(cons t char*, BooleanExpS ) - 0; v i r t u a l B o o l e a n E x p * CopyO c o n s t = 0; } ; The c l a ss C o n t e x t d e f i n e s a mappin g from variable s to B o o l e a n values , whic h we r e p r e s e n t with the C++ constant s t r ue and f a l s e . C o n t e x t has the followin g i n t e r f a c e : class C o n t e xt { public: bool Lookup(cons t char*) const; v o i d Assign(VariableExp*, b o o l ) ; } ; A VariableExp represents a named v a r i a b l e : c l a ss VariableEx p : public B o o l e a n E x p { public: V a r i a b l e E x p ( c o n s t char*); virtual \" V a r i a b l e E x p ( ) ; virtual bool E v a l u a t e ( C o n t e x t s ) ; virtual BooleanExp * Replace(cons t c h a r *, B o o l e a n E x p S ) ; virtual BooleanExp * C o p y () const; private: c h a r * _ n a m e ; } ; The constructor takes t h e variable's name a s a n a r g u m e n t : V a r i a b l e E x p : : V a r i a b l e E x p ( c o n st c h a r* name) { _name = strdup(name) ; } Evaluating a variable returns i t s value i n t h e current c o n t e x t . bool VariableExp::Evaluat e ( C o n t e x ts aContext ) { r e t u r n aContext.Lookup(_name); } ptgINTERPRETER 2 53 C o p y i n g a v a r i a b l e r e t u r n s a new V a r i a b l e E x p : BooleanExp * VariableExp::Cop y () c o n st { r e t u r n new VariableExp(_name); } To r e p l a c e a variabl e with an e x p r e s s i o n , we c h e ck to s ee if t he variabl e h as t he same name as the one it is passed as an argument: BooleanExp * VariableExp::Replac e ( const char* name, B o o l e a n E x p & exp ) { if ( s t r c m p ( n a m e , _name) = =0) { return exp.Copy(); } else { r e t u rn n ew VariableExp(_name); } } An A n d E x p represent s an e x p r e s s i o n made by A N D i n g two B o o l e a n e x p r e s s i o n s together. class A n d E xp : public BooleanEx p { public: AndExp(BooleanExp* , BooleanExp*) ; virtual ~AndExp(); virtual bool Evaluate(Contexts) ; virtual BooleanExp * Replace(cons t char*, B o o l e a n E x p & ) ; virtual B o o l e a n E x p * CopyO const; private: BooleanExp * _operandl; BooleanExp * _operand2; } ; AndExp::AndEx p ( B o o l e a n E x p * opl, B o o l e a n E x p * op2) { _operand l = opl; _operand2 = op2; } Evaluatin g an A n d E x p evaluate s its operand s and return s the l o g i c a l \" a n d \" of the r e s u l t s . bool AndExp::Evaluat e ( C o n t e x ts aContext ) { r e t u r n _operandl->Evaluate(aContext ) && _operand2->Evaluate(aContext); } An AndEx p implement s Copy and R e p l a c e by makin g r e c u r s i v e c a l ls on its operands: ptg254 BEHAVIORAL P A T T E R N S CHAPTERS B o o l e a n E x p * A n d E x p : : C o p y () c o n st { r e t u r n n ew A n d E x p ( _ o p e r a n d l - > C o p y ( ) , _ o p e r a n d 2 - > C o p y ( ) ) ; } B o o l e a n E x p * AndExp::Replac e ( c o n st c h a r* n a m e, B o o l e a n E x p & e x p) { r e t u r n n ew A n d E x p( _operandl->Replace(name , e x p ), _operand2->Replace(name , e x p ) ) ; } N o w w e c a n define t h e Boolean expression ( t r u e a n d x ) o r ( y a n d ( n o t x )) and evaluat e it for a g i v en a s s i g n m e n t of t r ue or f a l se to the v a r i a b l e s x and y : B o o l e a n E x p * e x p r e s s i o n ; C o n t e xt context; VariableExp * x = new VariableExp(\"X\") ; VariableExp * y - new VariableExp(\"Y\"); e x p r e s s i o n = new O r E x p( n ew A n d E x p ( n e w Constant(true) , x), n ew A n d E x p ( y , n ew N o t E x p ( x ) ) ) ; context.Assign(x , false); c o n t e x t . A s s i g n ( y , t r u e ) ; bool r e s u lt = expression->Evaluate(context); The e x p r e s s i o n evaluate s to t r ue for t h is a s s i g n m e n t to x and y. We can evaluat e the e x p r e s s i o n with a differen t a s s i g n m e n t to the v a r i a b l e s s i m p l y by c h a n g i n g t he c o n t e x t . F i n a l l y , we can r e p l a c e the variabl e y with a new e x p r e s s i o n and then reevaluat e i t : V a r i a b l e E x p * z = new VariableExp(\"Z\") ; NotExp not_z(z); B o o l e a n E x p * replacemen t = expression->Replace(\"Y\" , not_z); context.Assign(z , true); r e s u lt = replacement->Evaluate(context); T h is e x a m p l e i l l u s t r a t e s an i m p o r t a n t p o i nt a b o u t t he I n t e r p r e t e r p a t t e r n : m a ny k i n d s o f operations c a n \"interpret\" a sentence. O f t h e t h r e e o p e r a t i o n s d e f i n e d ptgINTERPRETER 2 5 5 for BooleanExp , E v a l u a t e fits our i d ea of what an interprete r s h o u l d do m o st closely—tha t i s, it interpret s a progra m or e x p r e s s i o n and return s a simpl e result. However , R e p l a c e can be viewe d as an interprete r as well. It's an interprete r whos e contex t is the name of the variabl e being replace d along with the e x p r e s s i o n that r e p l a c e s it, and whos e resul t is a new e x p r e s s i o n . E v en Copy can be though t of as an interprete r with an empt y context . It may s e em a little strang e to conside r R e p l a c e and Copy to be interpreters , becaus e t h e se are j u st basic operation s on t r e e s. T he e x a m p l e s in V i s i t o r ( 3 3 1) illustrat e h ow a ll t h r ee o p e r a t i o n s c an be refactore d into a separat e \"interpreter \" visitor , thus showin g that the similarit y is deep. The Interprete r patter n is more than j u st an operatio n distribute d o v er a c l a ss hierarch y that u s es the Composit e ( 1 6 3) pattern . We c o n s i d e r E v a l u a t e an in- terprete r becaus e we think of the B o o l e a n E x p c l a ss hierarch y as representin g a language . G i v e n a simila r c l a ss hierarch y for representin g automotiv e p a rt assem- b l i e s, i t 's u n l i k e l y we'd c o n s i d e r o p e r a t i o n s l i ke W e i g h t a nd Copy as i n t e r p r e t e r s e v en thoug h they are distribute d o v er a c l a ss hierarch y that uses the C o m p o s - ite pattern—w e j u st don't think of automotiv e parts as a language . It's a matte r of perspective ; if we starte d publishin g grammar s of automotiv e parts , then we c o u l d c o n s i d e r o p e r a t i o n s on those parts to be ways of i n t e r p r e t i n g the language. K n o w n U s e s T he I n t e r p r e t e r patter n is w i d e l y u s ed in c o m p i l e r s i m p l e m e n t e d with o b j e c t - o r i e n t e d languages , as the Smalltal k c o m p i l e r s are. S P E C T a l k u s es the patter n to interpre t description s of input file f o r m a t s [ S z a 9 2 ] . The Q O C A constraint-solvin g toolki t u s es it to evaluat e constraint s [ H H M V 9 2 ] . C o n s i d e r e d in its most genera l f o rm ( i . e ., an operatio n distribute d over a c l a ss hierarch y based on the C o m p o s i t e pattern) , nearl y every use of the Composit e patter n w i ll also contai n the Interprete r pattern . But the Interprete r patter n s h o u l d be r e s e r v e d f or t h o se c a s es in w h i c h y ou want to think of t he c l a ss h i e r a r c h y as defining a language. Related Patterns C o m p o s i t e ( 1 6 3 ) : The abstrac t synta x tree is an instanc e of the Composit e pattern. Flyweigh t ( 1 9 5) s h o w s how to share termina l symbol s withi n the abstrac t synta x tree. Iterato r ( 2 5 7 ) : The interprete r can use an Iterato r to travers e the structure. Visito r ( 3 3 1) can be u s ed to maintai n the behavio r in e a ch node in the abstrac t syntax tree in one class. ptg This page intentionally left blank ptgITERATOR 257 I T E R A T O R O b j e c t Behavioral I n t e n t P r o v i d e a w ay to a c c e s s t he e l e m e n t s of an a g g r e g a t e o b j e c t s e q u e n t i a l l y w i t h o u t e x p o s i n g its underlying representation. A l s o Known As C u r s o r Motivation An a g g r e g a t e o b j e c t s u ch as a l i st s h o u l d g i ve y ou a w ay to a c c e s s i ts e l e m e n t s withou t e x p o s i n g its i n t e r n a l structure . M o r e o v e r , you m i g h t want to travers e the l i st in differen t w a y s , d e p e n d i n g on what you want to a c c o m p l i s h . But you p r o b - a b ly don't want to b l o at the L i st interfac e with operation s for differen t traversals , e v en if y ou c o u ld anticipat e t he o n es y ou w i ll n e e d. Y ou m i g h t a l so n e ed to have m o re than o ne t r a v e r s a l p e n d i n g on t he s a me l i s t . T he Iterato r patter n l e ts y ou do a ll t h i s. T he k ey i d ea in t h is patter n is to take t he r e s p o n s i b i l i t y f or a c c e s s a nd traversa l o ut of t he l i st o b j e c t a nd p ut it into an i t e r a t o r o b j e c t . T he Iterato r c l a ss define s an interfac e f or a c c e s s i n g t he l i s t 's e l e m e n t s . An i t e r a t o r o b j e c t is r e s p o n s i b l e f or k e e p i n g t r a ck of t he c u r r e n t e l e m e n t ; that i s, it knows which elements have been traversed already. For example, a List class would call for a Listlterator with the following relation - s h i p b e t w e e n t h e m : Befor e y ou c an i n s t a n t i a t e L i s t l t e r a t o r , y ou must suppl y t he L i st to traverse . O n ce y ou have t he Listlterato r i n s t a n c e , y ou c an a c c e s s t he l i s t 's e l e m e n t s s e q u e n t i a l l y . T he Currentlte m operatio n return s t he curren t e l e m e n t in t he l i s t, F i r st i n i t i a l i z e s the curren t e l e m e n t to the first e l e m e n t , Next advance s the curren t e l e m e n t to t he n e xt e l e m e n t , a nd I s D o n e t e s ts w h e t h e r w e ' ve a d v a n c e d b e y o n d t he l a st element—that is, we're finished with the traversal. ptg2 5 8 BEHAVIORAL PATTERNS CHAPTER 5 S e p a r a t i n g t he t r a v e r s a l m e c h a n i s m from t he L i st o b j e c t l e ts us d e f i n e i t e r a t o r s f or differen t traversa l p o l i c i e s withou t enumeratin g them in the L i st interface . For e x a m p l e , FilteringListlterato r migh t p r o v i d e a c c e s s only to those e l e m e n t s that s a t i s f y s p e c i f i c f i l t e r i n g c o n s t r a i n t s . Not ic e that the iterato r and the l i st are c o u p l e d , and the c l i e nt must know that it is a list that's t r a v e r s e d as o p p o s e d to s o me o t h er a g g r e g a t e s t r u c t u r e . H e n c e the c l i e nt commit s to a particula r aggregat e structure . It woul d be bette r if we c o u ld chang e t he aggregat e c l a ss withou t changin g c l i e nt c o d e. We c an do this by g e n e r a l i z i n g t he i t e r a t o r c o n c e p t to s u p p o r t p o l y m o r p h i c i t e r a t i o n . As an e x a m p l e , l e t 's assum e that we a l so have a S k i p L i s t implementatio n of a l i s t. A s k i p l i s t [ P u g 9 0 ] is a p r o b a b i l i s t i c data structur e with c h a r a c t e r i s t i c s s i m i l a r to balance d t r e e s. We want to be a b le to write c o d e that work s for both L i st and S k i p L i s t objects. We defin e an AbstractLis t c l a ss that p r o v i d e s a c o m m o n interfac e for manipulatin g l i s t s. S i m i l a r l y , we n e ed an abstrac t Iterato r c l a ss that define s a commo n iteratio n interface . T h en we can defin e c o n c r e t e Iterato r s u b c l a s s e s for the differen t l i st implementations . As a r e s u l t , the iteratio n mechanis m b e c o m e s independen t of c o n c r e t e aggregate classes. The remainin g p r o b l e m is how to creat e the iterator . S i n ce we want to write c o d e that's i n d e p e n d e n t of t he c o n c r e t e L i st s u b c l a s s e s , we c a n n o t s i m p l y instantiat e a s p e c i f i c c l a s s. Instead , we make the l i st o b j e c t s r e s p o n s i b l e for creatin g their correspondin g iterator . T h is r e q u i r e s an operatio n l i ke Createlterato r throug h w h i c h c l i e n t s r e q u e s t an iterato r o b j e c t . Createlterato r is an exampl e of a f a c t o r y metho d ( s ee Factor y Metho d ( 1 0 7 ) ) . We u se it h e re to l et a c l i e nt a sk a l i st o b j e c t f or t he a p p r o p r i a t e i t e r a t o r . T he F a c t o r y Metho d approac h g i ve rise to two c l a ss h i e r a r c h i e s , one f or l i s ts and anothe r f or iterators. The Createlterator factory method \"connects\" t h e t w o hierarchies. ptgITERATOR 259 Applicability Use the Iterato r pattern • to a c c e s s an agg re ga t e o b j e c t ' s con t ent s withou t e x p o s i n g its interna l r e p r e - s e n t a t i o n . •to suppor t multipl e traversal s of aggregat e o b j e c t s . •to provid e a unifor m interfac e for traversin g differen t aggregat e structure s (that is, to support polymorphic iteration). S t r u c t u r e P a r t i c i p a n t s • Iterator - d e f i n e s an interfac e for a c c e s s i n g and traversin g e l e m e n t s . • C o n c r e t e l t e r a t o r - i m p l e m e n t s the Iterato r interface. - k e e ps track of the curren t positio n in the traversa l of the aggregate. • A g g r e g a t e - d e f i n e s an interfac e for c r e a t i n g an Iterato r object. • C o n c r e t e A g g r e g a t e - i m p l e m e n t s the Iterato r c r e a t i o n interfac e to retur n an i n s t a n c e of the p r o p e r Concretelterator. ptg260 BEHAVIORAL P A T T E R N S CHAPTERS C o l l a b o r a t i o n s • A Concretelterato r keep s track of the curren t objec t in the aggregat e and can compute the succeeding object in the traversal. C o n s e q u e n c e s The Iterato r patter n has three importan t c o n s e q u e n c e s : 1. It supports variations in the traversal of an aggregate. Comple x aggregate s may be traverse d in many ways . For e x a m p l e , c o de generatio n and semanti c c h e c k i n g i n v o l v e traversin g parse trees. C o de generatio n may travers e the parse t r ee i n o r d e r or p r e o r d e r . I t e r a t o r s make it e a sy to c h a n g e t he t r a v e r s a l algorithm : Just r e p l a c e the iterato r i n s t a n c e with a differen t o n e. You can a l so defin e Iterato r s u b c l a s s e s to suppor t new traversals. 2. Iterators simplify the Aggregate interface. Iterator' s traversa l interfac e o b v i a t e s the n e ed for a s i m i l a r interfac e in Aggregate , thereb y simplifyin g the a g g r e - gate' s interface. 3. More than one traversal can be pending on an aggregate. An iterato r keep s track of its own traversa l state. Therefor e you can have more than one traversa l in p r o g r e s s at once. Implementation Iterato r has many implementatio n variant s and alternatives . S o me importan t o n es follow . The trade-off s often depen d on the contro l structures your languag e pro- v i d e s . S o me language s ( C LU [ L G 8 6 ] , for example ) e v en suppor t t h is patter n di- r e c t l y . 1. W ho controls t he iteration? A fundamenta l i s s ue is d e c i d i n g w h i c h party c o n - t r o ls the iteration , the iterato r or the c l i e n t that u s es the iterator . Whe n the c l i e n t control s the iteration , the iterato r is c a l l ed an externa l iterator , and when the iterato r control s it, the iterato r is an interna l iterator. 2 C l i e n t s that use an externa l iterato r must advanc e the traversa l and reques t the next el- emen t explicitl y f r om the iterator . In contrast , the c l i e n t hand s an interna l iterato r an operatio n to perform , and the iterato r applie s that operatio n to every e l e m e n t in the aggregate. Externa l iterator s are more flexibl e than interna l iterators . I t 's e a sy to compar e two c o l l e c t i o n s for equalit y with an externa l iterator , for e x a m p l e , but it's practicall y i m p o s s i b l e with interna l iterators . Interna l iterator s are e s p e c i a l l y weak in a languag e like C++ that d o es not provid e anonymou s functions , c l o s u r e s , or continuation s l i ke Smalltal k a nd C L O S . B ut on t he other hand, 2Booc h refer s to externa l and interna l iterator s as activ e and passiv e iterators , respectivel y [ B o o 9 4 ] . The terms \"active\" and \"passive\" describe the role of the client, not the level of activity in the iterator. ptgITERATOR 2 6 1 i n t e r n a l i t e r a t o r s a re e a s i er to u s e, b e c a u s e t h ey defin e t he i t e r a t i o n l o g ic f or you. 2. Who defines the traversal algorithm? The iterato r is not the o n ly place wher e the traversa l algorith m can be defined . The aggregat e migh t defin e the traversa l algorith m and use the iterato r to s t o re just the state of the iteration . We c a ll this k i nd of iterato r a c u r s o r , s i n ce it m e r e l y point s to the curren t positio n in the aggregate . A c l i e n t w i ll i n v o k e the Next operatio n on the aggregat e with t he c u r s o r as an a r g u m e n t , a nd t he N e xt o p e r a t i o n w i ll c h a n g e t he s t a te of the c u r s o r . 3 If the iterato r is r e s p o n s i b l e for the traversa l algorithm , then it's e a sy to use differen t iteratio n algorithm s on the same aggregate , and it can a l so be e a s i e r to r e u se the s a me algorith m on differen t a g g r e g a t e s . On the o t h er hand , the traversa l algorith m migh t n e ed to a c c e s s the privat e variable s of the a g g r e g a t e . If so, puttin g the traversa l algorith m in the iterato r v i o l a t e s the e n c a p s u l a t i o n of t he a g g r e g a t e . 3. How robust is the iterator? It can be dangerou s to modif y an aggregat e while you'r e traversin g it. If e l e m e n t s are adde d or delete d from the a g g r e g a t e , you migh t end up a c c e s s i n g an e l e m e n t t w i ce or m i s s i n g it c o m p l e t e l y . A s i m p l e solutio n is to c o py the aggregat e and travers e the c o p y, but that's too e x p e n s i v e to do in general. A robus t iterato r e n s u r e s that i n s e r t i o n s and r e m o v a l s won' t interfer e with t r a v e r s a l , a nd it d o es it w i t h o u t c o p y i n g t he a g g r e g a t e . T h e re a re many ways to implemen t robus t iterators . M o st r e ly on r e g i s t e r i n g the iterato r with the aggregate . On insertio n or r e m o v a l , the aggregat e eithe r adjust s the interna l state of iterator s it has p r o d u c e d , or it maintain s informatio n internall y to e n s u r e prope r traversal. Kofle r p r o v i d e s a g o od d i s c u s s i o n of how robus t iterator s are implemente d in ET++ [ K o f 9 3 ] . Murra y d i s c u s s e s the implementatio n of robus t iterator s f or t he U SL StandardComponents ' L i st c l a ss [ M u r 9 3 ] . 4. Additional Iterator operations. The minima l interfac e to Iterato r c o n s i s t s of the operation s F i r s t, Next , I s D o n e , and Currentltem. 4 S o me additiona l op- eration s migh t prove useful . For e x a m p l e , o r d e r e d aggregate s can have a P r e v i o u s operatio n that p o s i t i o n s the iterato r to the p r e v i o u s element . A S k i p T o operatio n is usefu l f or sorte d or i n d e x e d c o l l e c t i o n s . S k i p T o p o s i t i o n s the iterato r to an o b j e c t matchin g s p e c i f i c criteria. 5. Using polymorphic iterators in C++. P o l y m o r p h i c i t e r a t o r s have t h e ir c o s t. T h ey r e q u i r e the iterato r o b j e c t to be allocate d dynamicall y by a factor y method . H e n c e they s h o u l d be u s ed o n ly when there' s a n e ed for polymorphism . O t h e r w i s e use c o n c r e t e iterators , whic h can be allocate d on the stack. 3 Cursor s are a s i m p l e exampl e of the M e m e n t o ( 2 8 3) patter n and share many of its implementatio n i s s u e s . 4 We can make t h is interfac e e v en smaller by mergin g Next , I s D o n e , and Currentlte m into a s i n g l e operatio n that advance s to the next o b j e c t and return s it. If the traversa l is finished , then this operatio n return s a s p e c i a l value (0, for instance) that marks the end of the i t e r a t i o n . ptg262 BEHAVIORAL PATTERNS CHAPTERS Polymorphi c iterator s have anothe r drawback : the c l i e n t is r e s p o n s i b l e for d e l e t i n g t h e m . T h is is e r r o r - p r o n e , b e c a u s e i t 's e a sy to forge t to free a h e a p - allocate d iterato r o b j e c t when you'r e finishe d with it. Tha t' s e s p e c i a l l y l i k e ly w h en t h e re a re multipl e e x it p o i n t s in an o p e r a t i o n . A nd if an e x c e p t i o n is triggered , the iterato r objec t will never be freed. T he P r o xy ( 2 0 7) patter n p r o v i d e s a r e m e d y . We c an u se a s t a c k - a l l o c a t e d proxy as a stand-i n for the real iterator . The proxy d e l e t e s the iterato r in i ts d e s t r u c t o r . T h us w h en t he p r o xy g o es o ut of s c o p e , t he r e al i t e r a t o r w i ll get deallocate d along with it. The proxy e n s u r e s prope r cleanup , e v en in t he face of e x c e p t i o n s . T h is is an a p p l i c a t i o n of t he w e l l - k n o w n C ++ t e c h - nique \" r e s o u r c e allocatio n is initialization \" [ E S 9 0 ] . T he S a m p l e C o de g i v es an e x a m p l e . 6. Iterators may have privileged access. An iterato r can be v i e w e d as an e x t e n s i o n of the aggregat e that create d it. The iterato r and the aggregat e are tightl y cou- pled. We can e x p r e s s this c l o se r e l a t i o n s h i p in C+ + by makin g the iterato r a f r i e n d of its aggregate . T h en you don't n e ed to defin e aggregat e operation s whos e s o le purpos e is to let iterator s implemen t traversa l efficiently. However , s u ch privilege d a c c e s s can make definin g new traversal s difficult , s i n ce it'll requir e c han gi n g the a g g r e g a t e interfac e to add anothe r friend . To avoid this problem , the Iterato r c l a ss can i n c l u d e p r o t e c t e d operation s for accessin g importan t but publicl y unavailabl e member s of the a g g r e g a t e . Iterato r s u b c l a s s e s (and only Iterato r s u b c l a s s e s ) may use t h e se protecte d operation s to g a in p r i v i l e g e d a c c e s s to the a g g r e g a t e . 7. Iterators for composites. Externa l iterator s can be difficul t to implemen t o v er r e c u r s i v e a g g r e g a t e structure s l i ke t h o se in t he C o m p o s i t e ( 1 6 3) pattern , b e - cause a positio n in the structur e may span many l e v e ls of n e s t e d agg re ga te s . T h e r e f o r e an e x t e r n a l iterato r h as to s t o re a path t h r o u g h t he C o m p o s i t e to keep track of the curren t object . S o m e t i m e s it's e a s i e r j u st to use an interna l i t e r a t o r . It c an r e c o r d t he curren t p o s i t i o n s i m p l y by c a l l i n g i t s e lf r e c u r s i v e l y , thereb y storin g the p a th implicitl y in the c a ll stack. If t he n o d e s in a C o m p o s i t e h a ve an interfac e f or m o v i n g from a n o de to its s i b l i n g s , parents , and c h i l d r e n , then a cursor-base d iterato r may o f f er a bette r a l t e r n a t i v e . T he c u r s o r o n ly n e e ds to k e ep track of t he c u r r e n t n o d e ; it can rely on the node interfac e to travers e the Composite. C o m p o s i t e s often n e ed to be traverse d in m o re than one way. P r e o r d e r , postorder , i n o r d e r , and breadth-firs t traversal s are common . You can suppor t e a ch k i nd of traversa l with a differen t c l a ss of iterator. 8. Null iterators. A N u l l l t e r a t o r is a d e g e n e r a t e i t e r a t o r that's helpfu l for h a n - d l i ng boundar y conditions . By definition , a Nulllterator is always d o ne with t r a v e r s a l ; that i s, i ts I s D o n e o p e r a t i o n alway s evaluate s to true. Nulllterato r can make traversin g tree-structure d aggregate s (like C o m p o s - i t e s) e a s i e r . At e a ch p o i nt in t he t r a v e r s a l , we a sk t he c u r r e n t e l e m e n t f or an i t e r a t o r f o r i t s c h i l d r e n . A g g r e g a t e e l e m e n t s r e t u r n a c o n c r e t e i t e r a t o r ptgITERATOR 2 6 3 as usual . But l e af e l e m e n t s retur n an i n s t a n c e of Nulllterator . That lets us implement traversal over the entire structure in a uniform way. S a m p l e C o d e W e ' ll look at t he implementatio n of a s i m p l e L i st c l a s s, whic h is part of o ur foundatio n librar y (Appendi x C). W e ' ll s h ow two Iterato r implementations , one for traversin g the L i st in front-to-bac k o r d e r , and anothe r for traversin g back-to- front (the foundatio n librar y support s o n ly the first o n e ). T h en we s h ow how to use t h e se iterator s and how to a v o id committin g to a particula r implementation . After that, we c h a n g e the d e s i g n to make sure iterator s get d e l e t e d properly . The l a st exampl e illustrate s an interna l iterato r and compare s it to its externa l counterpart. 1. List a nd Iterator interfaces. F i r st let's l o ok at t he part of t he L i st interfac e that's relevan t to implementin g iterators . Refer to Appendi x C for the f u ll interface. template <class Item> c l a ss L i st { public: List(lon g s i ze = D E F A U L T _ L I S T _ C A P A C I T Y ) ; l o ng C o u n t () const; I t e m& Get(long i n d e x) const; // . . . } ; T he L i st c l a ss p r o v i d e s a r e a s o n a b l y efficien t w ay to s u p p o r t i t e r a t i o n throug h its publi c interface . I t 's sufficien t to implemen t both traversals . So there' s no n e ed to g i ve iterator s p r i v i l e g e d a c c e s s to the underlyin g data structure ; that is, the iterato r c l a s s e s are not friend s of L i s t . To e n a b l e trans- paren t use of the differen t traversal s we defin e an abstrac t I t e r a t o r c l a s s, w h i c h define s the iterato r interface. template <class Item> c l a ss I t e r a t or { public: virtual void First() = 0; virtual void Next() = 0; v i r t u al b o ol I s D o n eO c o n st = 0; virtual I t em Currentltem( ) c o n st = 0; protected: Iterator() ; } ; 2. I t e r a t o r s u b c l a s s i m p l e m e n t a t i o n s . Listlterator is a subclass of Iterator. ptg264 BEHAVIORAL P A T T E R N S CHAPTER 5 template <class Item> c l a ss Listlterato r : public Iterator<Item > { public: Listlterator(cons t List<Item> * aList); virtual void First(); virtual void Next(); virtual bool IsDoneO const; virtual I t em Currentltem( ) const; private: c o n st List<Item> * _list; l o ng _current; } ; T he i m p l e m e n t a t i o n of Li s t Iterator is straightforward . It s t o r es t he L i st along with an i n d ex . c u r r e n t into the l i s t : template <class Item> Listlterator<ltem>::Listlterato r ( c o n st List<Item> * a L i st ) : _list(aList) , _current(0 ) { } F i r s t position s the iterato r to the first e l e m e n t : template <class Item> void Listlterator<ltem>::Firs t () { _current = 0; } N e xt advance s the curren t e l e m e n t : template <class I t e m> void Listlterator<ltem>::Nex t () { _current++ ; } I s D o n e c h e c k s whethe r the i n d ex refers to an e l e m e n t withi n the L i s t : template <class Item> bool Listlterator<ltem>::IsDon e () c o n st { r e t u rn _current >= _list->Count() ; } F i n a l l y , C u r r e n t I t e rn return s the item at the curren t i n d e x . If the iteratio n has alread y terminated , then we throw an I t e r a t o r O u t O f Bound s e x c e p - t i o n : template <class Item> I t em Listlterator<ltem>::CurrentIte m () c o n st { if ( I s D o n e ( ) ) { t h r ow I t e r a t o r O u t O f B o u n d s ; } r e t u r n _list->Get(_current); } ptgITERATOR 2 6 5 T he i m p l e m e n t a t i o n of ReverseListlterato r is i d e n t i c a l , e x c e p t i ts F ir st o p - e r a t i o n p o s i t i o n s . c u r r e n t to the end of the l i s t, and N e xt d e c r e m e n t s . c u r r e n t t o w a r d the first item. 3. Using the iterators. L e t 's a s s u m e we h a ve a L i st of E m p l o y e e o b j e c t s , a nd we w o u l d l i ke to p r i nt a ll t he c o n t a i n e d e m p l o y e e s . T he E m p l o y e e c l a ss s u p p o r t s t h is with a P r i n t o p e r a t i o n . To p r i nt t he list, we defin e a P r i n t E m p l o y e e s o p e r a t i o n t h at takes an i t e r a t o r as an a r g u m e n t . It u s es t he i t e r a t o r to t r a v e r s e a nd p r i nt t he list. void PrintEmployee s (Iterator<Employee*> & i) { for ( i. First ( ); ! i . I s D o ne () ; i.NextO ) { i.Currentltem()->Print() ; } } S i n ce we h a ve i t e r a t o r s f or b o th back-to-fron t a nd f r o n t - t o - b a c k t r a v e r s a l s , we c an r e u se t h is o p e r a t i o n to p r i nt t he e m p l o y e e s in b o th o r d e r s . List<Employee*> * employees ; // . . . ListIterator<Employee* > forward(employees) ; ReverseListIterator<Employee*> backward(employees); PrintEmployees(forward); PrintEmployees(backward); 4. Avoiding commitment to a specific list implementation. L e t 's c o n s i d e r how a s k i p l i s t v a r i a t i o n of L i st w o u l d affec t our iteratio n c o d e . A S k i p L i s t s u b c l a s s of L i st m u st p r o v i d e a S k i p L i s t I t e r a t o r that i m p l e - m e n t s the I t e r a t o r interface . I n t e r n a l l y , the S k i p L i s t l t e r a t o r has to k e ep m o re t h an j u st an i n d ex to do t he iteratio n efficiently . B ut s i n ce S k i p L i s t l t e r a t o r c o n f o r m s to the I t e r a t o r i n t e r f a c e , the P r i n t Emp 1 oy e e s o p e r a t i o n c an a l so be u s ed w h en t he e m p l o y e e s a re s t o r e d in a S k i p L i s t o b j e c t . SkipList<Employee*> * employees ; // . . . SkipListIterator<Employee* > iterator(employees) ; PrintEmployees(iterator); A l t h o u g h t h is a p p r o a c h w o r k s , it woul d be b e t t e r if we d i d n ' t h a ve to c o m m i t to a s p e c i f i c L i st i m p l e m e n t a t i o n , n a m e l y S k i p L i s t . We can i n t r o d u c e an A b s t r a c t L i s t c l a ss to s t a n d a r d i z e the list interfac e for differen t l i st i m p l e - m e n t a t i o n s . L i st and S k i p L i s t b e c o m e s u b c l a s s e s of A b s t r a c t L i s t . To e n a b l e p o l y m o r p h i c i t e r a t i o n , A b s t r a c t L i s t d e f i n e s a f a c t o r y m e t h o d C r e a t e l t e r a t o r , w h i c h s u b c l a s s e s o v e r r i d e to r e t u r n t h e ir c o r r e s p o n d i n g i t e r a t o r : ptg266 BEHAVIORAL PATTERNS CHAPTER 5 template <class Item> class AbstractLis t { public: virtual Iterator<Item> * Createlterator( ) c o n st = 0; // . . . } ; An a l t e r n a t i v e w o u l d be to d e f i n e a g e n e r a l m i x in c l a ss T r a v e r s a b l e that define s t he i n t e r f a c e f or c r e a t i n g an i t e r a t o r . A g g r e g a t e c l a s s e s c an m ix in T r a v e r s a b l e to s u p p o r t p o l y m o r p h i c i t e r a t i o n . L i st o v e r r i d e s C r e a t e l t e r a t o r to retur n a L i s t l t e r a t o r o b j e c t : template <class Item> Iterator<Item> * List<Item>::CreateIterato r () const { return new Listlterator<ltem>(this) ; } N ow w e ' re in a p o s i t i o n to write t he c o de f or p r i n t i n g t he e m p l o y e e s i n d e - p e n d e n t of a c o n c r e t e r e p r e s e n t a t i o n . / / we k n ow o n ly that we have an AbstractLis t AbstractList<Employee*> * employees ; // . . . Iterator<Employee*> * iterator = employees->Create!terator() ; PrintEmployees(*iterator) ; delete iterator; 5. Making sure iterators get deleted. N o t i c e t h at C r e a t e l t e r a t o r r e t u r n s a n e w l y a l l o c a t e d i t e r a t o r o b j e c t . W e ' r e r e s p o n s i b l e f or d e l e t i n g i t. If we f o r g e t , t h en w e ' v e c r e a t e d a s t o r a g e leak. To m a ke life e a s i e r for c l i e n t s , w e ' ll p r o v i d e an 11 e r a t o r P t r t h at a c ts as a p r o x y f or an i t e r a t o r . It takes c a re of c l e a n i n g up t he I t e r a t o r o b j e c t w h en it g o es o ut of s c o p e . i t e r a t o r P t r is alway s a l l o c a t e d on the stack. 5 C++ a u t o m a t i c a l l y t a k es c a re of c a l l i n g i ts d e s t r u c t o r , w h i c h d e l e t e s t he r e al i t e r a t o r . I t e r a t o r P t r o v e r l o a d s b o th o p e r a t o r - > and o p e r a t o r * in s u ch a way t h at an I t e r a t o r P t r c an be t r e a t e d j u st l i ke a p o i n t e r to an i t e r a t o r . T he m e m - b e rs of I t e r a t o r P t r a re a ll i m p l e m e n t e d i n l i n e ; t h us t h ey c an i n c ur no o v e r h e a d . t e m p l a t e < c l a s s I t e m > c l a s s I t e r a t o r P t r { p u b l i c : I t e r a t o r P t r ( I t e r a t o r < I t e m > * i ): _ i (i) { } \" I t e r a t o r P t r ( ) { delete _ i ; } 5 You c a n ensure this at compile-time just by declaring private n e w and delete operators. An accompa - n y i n g implementation isn't needed. ptgITERATOR 267 Iterator<Item> * operator->( ) { return _i; } Iterator<Item> & operator*( ) { r e t u rn *_i; } private: // disallow c o py and a s s i g n m e n t to avoid // multiple deletion s of _i: IteratorPtr(cons t IteratorPtr&); IteratorPtr & operator=(cons t IteratorPtr&); private: Iterator<Item> * _i; } ; I t e r a t o r P t r lets us simplif y our p r i n t i n g c o d e : AbstractList<Employee*> * employees ; // . . . IteratorPtr<Employee* > iterator(employees->Create!terator()) ; PrintEmployees(*iterator); 6. An internal Listlterator. As a final example , let's l o ok at a p o s s i b l e implementa- tion of an interna l or p a s s i v e L i s t l t e r a t o r c l a s s. H e re the iterato r c o n t r o l s the iteration , and it applie s an operatio n to each e l e m e n t . The i s s ue in this c a se is how to parameteriz e the iterato r with the operatio n we want to p e r f o r m on e a ch element . C++ d o es not suppor t anonymou s function s or c l o s u r e s that other language s provid e for t h is task. T h e re are at least two o p t i o n s : (1) Pass in a pointe r to a functio n (globa l or static) , or (2) r e ly on s u b c l a s s i n g . In the first c a s e, the iterato r c a l ls the operatio n passe d to it at each point in the iteration . In the s e c o n d c a s e, the iterato r c a l ls an operatio n that a s u b c l a s s override s to e n a ct specifi c b e h a v i o r . Neithe r optio n is perfect . Often you want to accumulat e state durin g the iteration , and function s aren't well-suite d to that; we woul d have to use static variable s to remembe r the state. An I t e r a t o r s u b c l a s s provide s us with a c o n v e n i e n t place to store the accumulate d state, l i ke in an i n s t a n c e variable . But creatin g a s u b c l a s s for every d i f f e r e n t traversa l is more work. Here' s a s k e t c h of t he s e c o n d option , whic h uses subclassing . We c a ll t he internal iterator a ListTraverser. template <class Item> class ListTraverse r { public: ListTraverser(List<Item> * aList) ; bool Traverse(); protected : virtual bool Processltem(cons t Item&) = 0; private: Listlterator<ltem > _iterator ; } ; L i s t T r a v e r s e r takes a L i st instanc e as a parameter . Internall y it uses an external Listlterator t o d o t h e traversal. Traverse s t a r t s the traversal ptg268 BEHAVIORAL PATTERNS CHAPTER 5 and calls P r o c e s s I tern for e a ch item . The i n t e r n a l i t e r a t o r can c h o o s e to t e r m i n a t e a t r a v e r s a l by r e t u r n i n g f a l s e f r om P r o c e s s l t e m . T r a v e r s e r e t u r n s w h e t h e r t he t r a v e r s a l t e r m i n a t e d p r e m a t u r e l y . template <class Item> ListTraverser<Item>::ListTraverse r ( List<Item> * a L i st ) : _iterator(aList ) { } template <class Item> bool ListTraverser<Item>::Travers e () { bool result = false; for ( _iterator.First(); !_iterator.IsDone() ; _iterator.Next() ) { result = Processltem(_iterator.Currentltem()); if ( r e s u lt == false) { b r e a k ; } } r e t u r n r e s u l t ; L e t 's u se a L i s t T r a v e r s e r to p r i nt t he first 10 e m p l o y e e s f r om o ur e m - p l o y e e l i s t. To do it we h a ve to s u b c l a s s L i s t T r a v e r s e r a nd o v e r r i d e P r o c e s s l t e m . We c o u n t t he n u m b e r of p r i n t e d e m p l o y e e s in a _ c o u n t i n s t a n c e v a r i a b l e . class PrintNEmployee s : public ListTraverser<Employee* > { public: PrintNEmployees(List<Employee*> * aList, int n) : ListTraverser<Employee*>(aList) , _total(n) , _count(0 ) { } protected : bool Processltem(Employee * const&); private: int _total; int _count; } ; bool PrintNEmployees::Processlte m ( E m p l o y e e * c o n s t& e) { _count++ ; e->Print() ; return _count < _ t o t a l ; } H e r e ' s h o w P r i n t N E m p l o y e e s prints the first 1 0 employees on the list: ptgITERATOR 269 List<Employee*> * employees ; // . . . PrintNEmployee s pa(employees , 10) pa.Traverse(); Note how the c l i e nt doesn' t specif y the iteratio n l o o p. The entire iteratio n l o g ic c an be r e u s e d . T h is is t he primar y benefi t of an i n t e r n a l i t e r a t o r . I t 's a bit more work t h an an externa l iterator , though , becaus e we have to defin e a new c l a s s. Contras t this with using an externa l iterator: ListIterator<Employee* > i(employees) ; int count = 0; for ( i. First ( ); ! i . I s D o ne () ; i.NextO) { count++; i.Currentltem()->Print(); if ( c o u nt >= 10) { break; } } Interna l iterator s can encapsulat e differen t kinds of iteration . For e x a m p l e , F i l t e r i n g L i s t T r a v e r s e r e n c a p s u l a t e s an i t e r a t i o n that p r o c e s s e s o n ly items that satisf y a test: template <class Item> class FilteringListTraverse r { public: FilteringListTraverser(List<Item> * aList); bool Traverse(); protected : virtual bool Processltem(cons t Item&) - 0; virtual bool Testltem(cons t Item&) = 0; private: Listlterator<ltem > _iterator ; } ; T h is i n t e r f a c e is t he s a me as L i s t T r a v e r s e r ' s e x c e p t f or an a d d e d T e st I t e rn membe r functio n that define s the test. S u b c l a s s e s overrid e Te s 1 11 em to specif y t he test. T r a v e r s e d e c i d e s to c o n t i n u e t he t r a v e r s a l b a s ed on t he o u t c o m e of t he t e s t : template < c l a ss I t e m> void FilteringListTraverser<Item>::Travers e () { b o ol r e s u lt = false; for ( _iterator.First(); ! _ i t e r a t o r . I s D o n e ( ) ; _iterator.Next() ) { if (Testltem(_iterator.Currentltem()) ) { result = Processltem(_iterator.Currentltem()); ptg270 BEHAVIORAL P A T T E R N S CHAPTER 5 if ( r e s u lt == false) { break; } } } r e t u r n result; } A varian t of t h is c l a ss c o u ld defin e T r a v e r s e to retur n if at l e a st o ne i t em s a t i s f i e s the test. 6 K n o w n Uses Iterator s a re c o m m o n in o b j e c t - o r i e n t e d s y s t e m s . M o st c o l l e c t i o n c l a ss l i b r a r i e s offer i t e r a t o r s in o ne form or a n o t h e r . H e r e ' s an e x a m p l e from t he B o o c h c o m p o n e n t s [ B o o 9 4 ] , a p o p u l a r c o l l e c t i o n c l a ss l i b r a r y . It p r o v i d e s both a f i x ed s i ze (bounded ) a nd d y n a m i c a l l y g r o w i n g ( u n b o u n d e d ) i m p l e m e n t a t i o n of a q u e u e . T he q u e u e interfac e is d e f i n e d by an abstrac t Q u e u e c l a s s. To suppor t polymorphi c i t e r a t i o n o v er t he differen t q u e u e implementations , t he q u e u e iterato r is i m p l e m e n t e d in t he terms of t he abstrac t Q u e u e c l a ss i n t e r f a c e . T h is v a r i a t i o n h as t he a d v a n t a g e that y ou d o n 't n e ed a factor y metho d to ask the queu e i m p l e m e n t a t i o n s for their appropriat e iterator . H o w e v e r , it r e q u i r e s t he i n t e r f a c e of t he a b s t r a c t Q u e u e c l a ss to be powerfu l e n o u g h to i m p l e m e n t the iterato r e f f i c i e n t l y . Iterator s don't have to be define d as e x p l i c i t l y in S m a l l t a l k . T he standar d c o l l e c t i o n c l a s s e s ( B a g, S e t, D i c t i o n a r y , O r d e r e d C o l l e c t i o n , S t r i n g , e t c .) defin e an i n t e r n a l iterato r metho d d o :, w h i c h takes a b l o ck ( i . e ., c l o s u r e ) as an argument . E a ch e l e m e n t in t he c o l l e c t i o n is boun d to t he l o c al v a r i a b l e in t he b l o c k ; then t he b l o ck is e x e c u t e d . S m a l l t a l k a l so i n c l u d e s a s et of S t r e a m c l a s s e s t h at s u p p o r t an i t e r a t o r - l i ke interface . ReadStrea m is e s s e n t i a l l y an Iterator , a nd it c an a ct as an e x t e r n a l iterato r f or a ll t he s e q u e n t i a l c o l l e c t i o n s . T h e re a re no s t a n d a r d e x t e r n a l i t e r a t o r s f or n o n s e q u e n t i a l c o l l e c t i o n s such as S et a nd D i c t i o n a r y . P o l y m o r p h i c iterator s a nd t he c l e a n u p P r o xy d e s c r i b e d e a r l i e r a re p r o v i d e d by t he ET++ c o n t a i n e r c l a s s e s [ W G M 8 8 ] . T he U n i d r a w g r a p h i c a l e d i t i n g framewor k c l a s s e s u se c u r s o r - b a s e d i t e r a t o r s [ V L 9 0 ] . O b j e c t W i n d o w s 2 .0 [ B o r 9 4 ] p r o v i d e s a c l a ss h i e r a r c h y of i t e r a t o r s f or c o n t a i n e r s . Y ou c an i t e r a t e o v er differen t c o n t a i n e r t y p es in t he s a me w a y. T he O b j e c t W i n d o w iteratio n synta x r e l i es on o v e r l o a d i n g the p o s t i n c r e m e n t o p e r a t o r ++ to a d v a n c e the iteration. Related P a t t e r n s C o m p o s i t e ( 1 6 3 ) : Iterator s a re often a p p l i e d to r e c u r s i v e structure s s u ch as C o m - p o s i t e s . 6The T r a v e r s e o p e r a t i o n in t h e se e x a m p l e s is a T e m p l a t e M e t h o d ( 3 2 5) w i th p r i m i t i v e o p e r a t i o n s T e s t l t e m a n d Processltem. ptgITERATOR 2 7 1 Factor y Metho d ( 1 0 7 ) : Polymorphi c iterator s rely on f a c t o r y method s to instantiat e the appropriat e Iterato r s u b c l a s s . Mement o ( 2 8 3) is often used in conjunction with the Iterato r pattern . An iterato r can use a mement o to captur e the state of an iteration . The iterato r s t o r es the memento internally. ptg This page intentionally left blank ptgMEDIATOR 273 M E D I A T O R Object Behavioral I n t e n t Defin e an objec t that encapsulate s how a set of object s interact . Mediato r promote s l o o se c o u p l i n g by keepin g object s f r om referrin g to each other e x p l i c i t l y , and it lets you vary their interaction independently. Motivation O b j e c t - o r i e n t e d d e s i g n e n c o u r a g e s t he d i s t r i b u t i o n of b e h a v i o r a m o n g o b j e c t s . S u ch distributio n can resul t in an objec t structur e with many c o n n e c t i o n s betwee n o b j e c t s ; in t he wors t c a s e, e v e ry o b j e c t e n ds up k n o w i n g a b o u t e v e ry o t h e r . T h o u g h partitionin g a syste m into many object s g e n e r a l l y e n h a n c e s reusability , proliferatin g interconnection s tend to reduc e it again . Lots of i n t e r c o n n e c t i o n s make it l e ss l i k e ly that an o b j e c t c an work withou t t he s u p p o r t of o t h e r s — t h e syste m acts as thoug h it were monolithic . M o r e o v e r , it can be difficul t to c h a n g e t he s y s t e m ' s b e h a v i o r in a ny s i g n i f i c a n t way, s i n ce b e h a v i o r is d i s t r i b u t e d a m o n g many objects . As a result , you may be force d to defin e many subclasse s to c u s - tomiz e the system' s behavior. As an e x a m p l e , c o n s i d e r t he i m p l e m e n t a t i o n of d i a l o g b o x es in a g r a p h i c a l u s er interface . A d i a l o g box u s es a windo w to presen t a c o l l e c t i o n of widget s such as buttons, menus, and entry fields, as shown here: ptg2 7 4 BEHAVIORAL PATTERNS CHAPTER 5 Often there are d e p e n d e n c i e s betwee n the widget s in the d i a l o g . For e x a m p l e , a butto n g e ts d i s a b l e d when a certai n entry field is e m p t y . S e l e c t i n g an entry in a l i st of c h o i c e s called a list box migh t c h a n g e the content s of an entry field. C o n v e r s e l y typin g text into the entry field migh t automaticall y s e l e c t one or more correspondin g entrie s in the l i st box. O n ce text appear s in the entry field, other button s may b e c o m e e n a b l e d that let the user do somethin g with the text, s u ch as c h a n g i n g or d e l e t i n g t he t h i ng to w h i c h it refers. Differen t dialo g b o x e s will have differen t d e p e n d e n c i e s betwee n widgets . So e v en thoug h d i a l o g s d i s p l a y t he s a me k i n ds of w i d g e t s , t h ey c a n 't s i m p l y r e u se s t o ck widget c l a s s e s ; they have to be customize d to reflec t dialog-specifi c d e p e n d e n c i e s . Customizin g them individuall y by s u b c l a s s i n g will be tedious , s i n ce many c l a s s e s are involved. You can a v o id t h e se problem s by encapsulatin g c o l l e c t i v e behavio r in a separat e mediato r object . A mediato r is responsibl e for controllin g and coordinatin g the interaction s of a group of objects . The mediato r s e r v e s as an intermediar y that k e e ps o b j e c t s in t he g r o up from referrin g to e a ch o t h er e x p l i c i t l y . T he o b j e c t s o n ly know the mediator , thereb y reducin g the numbe r of i n t e r c o n n e c t i o n s . F or e x a m p l e , F o n t D i a l o g D i r e c t o r c an be t he m e d i a t o r b e t w e e n t he w i d g e t s in a dialo g box. A F o n t D i a l o g D i r e c t o r objec t know s the widget s in a dialo g and coordinates their interaction. It acts as a hub of communication for widgets: The followin g interactio n diagra m illustrate s how the object s cooperat e to handl e a change in a list box's selection: ptgMEDIATOR 275 H e r e ' s t he s u c c e s s i o n of e v e n t s by w h i c h a l i st box's s e l e c t i o n p a s s e s to an entry field: 1. T he l i st b ox t e l ls i ts d i r e c t o r that it's c h a n g e d . 2. T he d i r e c t o r g e ts t he s e l e c t i o n from t he l i st b o x . 3. T he d i r e c t o r p a s s e s t he s e l e c t i o n to t he e n t ry f i e l d . 4. Now that the entry field c o n t a i n s s o me text, the d i r e c t o r e n a b l e s button(s ) f or i n i t i a t i n g an a c t i o n ( e . g ., \" d e m i b o l d , \" \" o b l i q u e \" ) . Note h ow t he d i r e c t o r mediate s betwee n t he l i st b ox a nd t he entry f i e l d. W i d g e t s c o m m u n i c a t e w i th e a ch o t h er o n ly i n d i r e c t l y , t h r o u g h t he d i r e c t o r . T h ey d o n 't h a ve to know abou t e a ch o t h e r ; a ll they know is t he d i r e c t o r . Furthermore , b e c a u s e t he b e h a v i o r is l o c a l i z e d in o ne c l a s s, it c an be c h a n g e d or r e p l a c e d by e x t e n d i n g or r e p l a c i n g that c l a s s . H e r e ' s h ow t he F o n t D i a l o g D i r e c t o r abstractio n c an be integrate d i n to a c l a ss l i b r a r y : ptg2 7 6 B E H A V I O R A L P A T T E R N S CHAPTER 5 D i a l o g D i r e c t o r is an abstrac t c l a ss that define s the overal l behavio r of a d i a - l o g. C l i e n t s c a ll the S h o w D i a l o g operatio n to displa y the d i a l o g on the s c r e e n . CreateWidget s is an abstrac t operatio n for creatin g the widget s of a d i a l o g . W i d - getChange d is anothe r abstrac t operation ; widget s c a ll it to infor m t h e ir d i r e c t o r that they have c h a n g e d . D i a l o g D i r e c t o r s u b c l a s s e s o v e r r i d e C r e a t e W i d g e t s to cre- ate the proper widgets, and they override WidgetChanged to handle the changes. Applicability Use the Mediato r patter n when • a set of object s communicat e in well-define d but c o m p l e x ways . The r e s u l t i n g interdependencie s are unstructure d and difficul t to understand. • r e u s i n g an objec t is difficul t becaus e it refers to and communicate s with many other o b j e c t s . • a behavio r that's distribute d betwee n s e v e r a l c l a s s e s s h o u l d be customizabl e without a lot of subclassing. S t r u c t u r e A typical object structure might look like this: ptgMEDIATOR 277 P a r t i c i p a n t s • Mediato r ( D i a l o g D i r e c t o r ) - d e f i n e s an i n t e r f a c e for c o m m u n i c a t i n g with C o l l e a g u e o b j e c t s . • C o n c r e t e M e d i a t o r ( F o n t D i a l o g D i r e c t o r ) - i m p l e m e n t s c o o p e r a t i v e b e h a v i o r by c o o r d i n a t i n g C o l l e a g u e o b j e c t s . - know s and maintain s its c o l l e a g u e s . • Colleagu e c l a s s e s ( L i s t B o x , EntryField) - e a ch C o l l e a g u e c l a ss know s its Mediato r object. - e a ch c o l l e a g u e communicate s with its mediato r wheneve r it woul d have o t h e r w i s e communicated with another colleague. C o l l a b o r a t i o n s • C o l l e a g u e s s e nd and r e c e i v e request s f r om a Mediato r o b j e c t . The mediato r i m p l e m e n t s t h e cooperative behavior by routing requests between the appro - priate colleague(s). C o n s e q u e n c e s The Mediato r patter n has the followin g benefit s and drawbacks: 1. It limits subclassing. A mediato r l o c a l i z e s behavio r t h at otherwis e woul d be distribute d amon g severa l objects . Changin g this behavio r r e q u i r e s s u b c l a s s - i ng Mediato r o n l y; C o l l e a g u e c l a s s e s c an be r e u s e d as i s . 2. It decouples colleagues. A mediato r promote s l o o se couplin g betwee n c o l - l e a g u e s . You can vary and reuse C o l l e a g u e and Mediato r c l a s s e s indepen- d e n t l y . 3. It simplifies object protocols. A mediato r r e p l a c e s many-to-man y interaction s with one-to-man y interaction s betwee n the mediato r and its c o l l e a g u e s . O n e - to-man y r e l a t i o n s h i p s a re e a s i e r to understand , m a i n t a i n , a nd e x t e n d . 4. It abstracts how objects cooperate. M a k i n g m e d i a t i o n an i n d e p e n d e n t c o n c e p t and encapsulatin g it in an objec t l e ts you focus on how o b j e c t s interac t apart from their individua l b e h a v i o r . That can help clarif y how o b j e c t s interac t in a system. 5. It centralizes control. The Mediato r patter n trade s complexit y of interactio n for c o m p l e x i t y in the m e d i a t o r . B e c a u s e a mediato r encapsulate s p r o t o c o l s , it can b e c o m e m o re c o m p l e x than any individua l c o l l e a g u e . T h is can make the mediator itself a monolith that's hard to maintain. ptg278 BEHAVIORAL P A T T E R N S CHAPTER 5 I m p l e m e n t a t i o n The followin g implementatio n i s s u e s are r e l e v a n t to the Mediato r pattern: 1. Omitting t he abstract Mediator class. T h e r e ' s no n e ed to defin e an abstrac t M e d i a t o r c l a ss w h en c o l l e a g u e s w o rk w i th o n ly o ne m e d i a t o r . T he a b s t r a c t c o u p l i n g that the M e d i a t o r c l a ss p r o v i d e s l e ts c o l l e a g u e s work with differen t M e d i a t o r s u b c l a s s e s , a nd v i ce versa. 2.Colleague-Mediator communication. C o l l e a g u e s have to c o m m u n i c a t e with t h e ir mediato r when an e v e nt of i n t e r e s t o c c u r s . O ne a p p r o a c h is to i m - p l e m e n t t he Mediato r as an O b s e r v e r using t he O b s e r v e r ( 2 9 3) pattern . C o l - l e a g u e c l a s s e s a ct as S u b j e c t s , s e n d i n g notification s to t he mediato r wheneve r they c h a n g e state. T he med ia to r r e s p o n d s by propagatin g t he effect s of t he c h a n g e to o t h er c o l l e a g u e s . Anothe r approac h define s a s p e c i a l i z e d n o t i f i c a t i o n interfac e in M e d i a t o r that l e ts c o l l e a g u e s be m o re d i r e c t in their communication . Smalltalk/ V for W i n d o w s u s es a form of d e l e g a t i o n : W h en c o m m u n i c a t i n g w i th t he m e d i a - t o r, a c o l l e a g u e p a s s e s i t s e lf as an argument , a l l o w i n g the mediato r to identif y t h e sender. The Sample Code uses this approach, and the Smalltalk/V im- plementation is discussed f u r t h e r in the Known Uses. S a m p l e Code W e ' ll use a D i a l o g D i r e c t o r to i m p l e m e n t the font d i a l o g box show n in the M o t i - vation . The abstrac t c l a ss D i a l o g D i r e c t o r define s the interfac e for d i r e c t o r s . c l a ss D i a l o g D i r e c t o r { public: virtual \"DialogDirector(); virtual void ShowDialog() ; virtual void WidgetChanged(Widget* ) = 0; protected: DialogDirector() ; virtual void CreateWidgets( ) = 0 ; } ; W i d g e t is the abstrac t b a se c l a ss for w i d g e t s . A w i d g e t know s its d i r e c t o r . c l a ss W i d g et { public: Widget(DialogDirector*) ; virtual v o id C h a n g e d ( ) ; virtual void HandleMouse(MouseEvent & event); // . . . private: DialogDirector * _director ; } ; ptgMEDIATOR 2 7 9 C h a n g e d c a l ls the director' s W i d g e t C h a n g e d operation . W i d g e t s c a ll W i d g e t C h a n g e d on their director to inform it of a significant event. void Widget::Change d () { _director->WidgetChanged(this) ; } S u b c l a s s e s of D i a l o g D i r e c t o r o v e r r i d e W i d g e t C h a n g e d to affec t the ap- p r o p r i a t e w i d g e t s . T he w i d g e t p a s s e s a r e f e r e n c e to i t s e lf as an argumen t to W i d g e t C h a n g e d to let the d i r e c t o r identif y the w i d g e t that c h a n g e d . D i a l o g D i r e c t o r s u b c l a s s e s redefin e the C r e a t e W i d g e t s pure virtua l to c o n - struc t the w i d g e t s in the d i a l o g . The L i s t B o x , E n t r y F i e l d , and B u t t o n are s u b c l a s s e s of W i d g e t for s p e c i a l - i z ed u s er interfac e e l e m e n t s . L i s t B o x p r o v i d e s a G e t S e l e c t i o n o p e r a t i o n to get the c u r r e n t s e l e c t i o n , and E n t r y F ie Id's Set T e xt o p e r a t i o n puts new t e xt i n t o the field. c l a ss ListBox : public Widget { public: ListBox(DialogDirector*); virtual c o n st c h a r* GetSelection() ; virtual void SetList(List<char*> * listltems) ; virtual void HandleMouse(MouseEvent & event); // . . . } ; c l a ss EntryFiel d : public Widget { public: EntryField(DialogDirector*); virtual void S e t T e x t ( c o n s t c h a r* text); virtual const char* GetText() ; virtual void HandleMouse(MouseEvent& event); B u t t o n is a s i m p l e w i d g e t that c a l ls Change d w h e n e v e r i t 's p r e s s e d . T h is g e ts d o n e in its implementation of HandleMouse: c l a ss Button : public Widget { public: Button(DialogDirector* ) ; virtual void S e t T e x t ( c o n s t c h a r* text); virtual void HandleMouse(MouseEvent & event); // . . . } ; ptg2 80 B E H A V I O R A L PATTERNS CHAPTER 5 void Button::HandleMous e ( M o u s e E v e n t k event) { // . . . Changed(); } T he F o n t D i a l o g D i r e c t o r c l a ss m e d i a t e s b e t w e e n w i d g e t s in t he d i a l o g b o x. F o n t D i a l o g D i r e c t o r is a s u b c l a s s of D i a l o g D i r e c t o r : c l a ss F o n t D i a l o g D i r e c t o r : public D i a l o g D i r e c t o r { public: FontDialogDirector() ; virtual \"FontDialogDirector() ; virtual void WidgetChanged(Widget*); p r o t e c t e d : virtual void CreateWidgets(); p r i v a t e: Button* _ok; Button* _cancel; ListBox* _fontList ; EntryField * _fontName; } ; F o n t D i a l o g D i r e c t o r k e e p s t r a ck of t he w i d g e t s it d i s p l a y s . It r e d e f i n e s C r e a t e W i d g e t s to c r e a t e t he w i d g e t s a nd i n i t i a l i z e i ts r e f e r e n c e s to t h e m : void FontDialogDirector::CreateWidget s () { _ ok = n ew B u t t o n ( t h i s ) ; _cancel = new Button(this) ; _fontLis t = new ListBox(this) ; _fontNam e = new EntryField(this); // fill t he l i s t B ox with t he a v a i l a b le f o nt n a m e s // a s s e m b le t he w i d g e ts in t he d i a l og } WidgetChange d e n s u r e s t h at t he w i d g e t s w o rk t o g e t h e r p r o p e r l y : void FontDialogDirector::WidgetChange d ( Widget* t h e C h a n g e d W i d g e t ) { if ( t h e C h a n g e d W i d g e t == _fontList ) { _ f o n t N a m e - > S e t T e x t ( _ f o n t L i s t - > G e t S e l e c t i o n ( ) ) ; } else if ( t h e C h a n g e d W i d g e t == _ok) { // a p p ly f o nt c h a n ge a nd d i s m i ss d i a l og // . . . ptgMEDIATOR 281 } else if ( t h e C h a n g e d W i d g e t == _cancel) { // dismiss dialog T he c o m p l e x i t y of W i d g e t Change d i n c r e a s e s p r o p o r t i o n a l l y w i th t he c o m p l e x i t y of t he d i a l o g . L a r ge d i a l o g s a re u n d e s i r a b l e f or other r e a s o n s , of c o u r s e , b ut mediator complexity might mitigate the pattern's benefits in other applications. K n o w n Uses Both ET++ [ W G M 8 8 ] a nd t he T H I N K C c l a ss librar y [ S y m 9 3 b ] u se d i r e c t o r - l i k e o b j e c t s in d i a l o g s as m e d i a t o r s b e t w e e n w i d g e t s . T he a p p l i c a t i o n architectur e of Smalltalk/ V f or W i n d o w s is b a s ed on a m e d i a - t or s t r u c t u r e [ L a L 9 4 ] . In that e n v i r o n m e n t , an a p p l i c a t i o n c o n s i s t s of a W i n d o w c o n t a i n i n g a s et of p a n e s . T he librar y c o n t a i n s s e v e r a l predefine d Pane o b j e c t s ; e x a m p l e s i n c l u d e T e x t P a n e , L i s t B o x , Button , a nd so o n. T h e se p a n es c an be u s ed withou t s u b c l a s s i n g . An a p p l i c a t i o n d e v e l o p e r o n ly s u b c l a s s e s from V i e w M a n - a g e r, a c l a ss that's r e s p o n s i b l e f or doing inter-pan e c o o r d i n a t i o n . V i e w M a n a g e r is t he M e d i a t o r , a nd e a ch pane o n ly know s i ts v i ew manager , w h i c h is c o n s i d e r e d the \"owner\" o f t h e pane. Panes don't r e f e r to each other directly. The following o b j e c t diagram shows a snapshot of an application at run-time: Smalltalk/ V u s es an e v e nt m e c h a n i s m for P a n e - V i e w M a n a g e r communication . A pane g e n e r a t e s an e v e nt when it want s to get informatio n from the m edia to r or when it want s to infor m the mediato r that s o m e t h i n g s ig nif i can t happened . An e v e nt d e f i n e s a s y m b o l ( e . g ., # s e l e c t ) that i d e n t i f i e s t he e v e n t . To h a n d l e t he e v e n t , the v i ew manage r r e g i s t e r s a metho d s e l e c t o r with the pane . T h is s e l e c t o r i s t h e event's handler; it will be invoked whenever the event occurs. ptg2 82 B E H A V I O R A L PATTERNS CHAPTER 5 The followin g c o de excerp t show s how a ListPan e objec t g e ts create d i n s i d e a V i e w M a n a g e r s u b c l a s s a nd h ow V i e w M a n a g e r r e g i s t e r s an e v e nt h a n d l e r f or t he # s e l e c t event: self addSubpane : ( L i s t P a ne new paneName : 'myListPane' ; o w n e r: self; w h e n : # s e l e c t p e r f o r m : t t l i s t S e l e c t : ) . Anothe r applicatio n of the Mediato r patter n is in coordinatin g c o m p l e x updates . An exampl e is t he ChangeManage r c l a ss mentione d in O b s e r v e r ( 2 9 3 ) . C h a n g e - Manage r mediate s betwee n subject s and o b s e r v e r s to a v o id redundan t updates . When an o b j e c t c h a n g e s , it n o t i f i e s t he C h a n g e M a n a g e r , w h i c h in turn c o o r d i n a t e s the updat e by notifyin g the object' s dependents. A s i m i l a r applicatio n appear s in the Unidra w drawin g f r a m e w o r k [ V L 9 0 ] and u s es a c l a ss c a l l ed C S o l v e r to enforc e connectivit y constraint s betwee n \" c o n n e c t o r s . \" Object s in graphica l editor s can appea r to s t i ck to one anothe r in differen t w a y s . Connector s are usefu l in application s t h at maintai n c o n n e c t i v i t y automatically , l i ke diagra m editor s a nd c i r c u i t d e s i g n s y s t e m s . C S o l v e r is a mediato r b etw ee n c o n n e c t o r s . It s o l v e s the connectivit y constraint s and update s the c o n n e c t o r s ' p o s i t i o n s to reflect them. Related P a t t e r n s Facad e ( 1 8 5) d i f f e r s from Mediato r in t h at it abstract s a subsyste m of o b j e c t s to provid e a more c o n v e n i e n t interface . Its protoco l is u n i d i r e c t i o n a l ; that is, Facad e o b j e c t s make request s of the s u b s y s t e m c l a s s e s but not v i ce versa . In contrast , Mediato r e n a b l e s c o o p e r a t i v e behavio r that c o l l e a g u e object s don't or can't provide, and the protocol is multidirectional. C o l l e a g u e s can communicate with the mediator using the Observer (293) pattern. ptgMEMENTO 283 M E M E N T O O b j e c t Behavioral I n t e n t Withou t v i o l a t i n g encapsulation , captur e and e x t e r n a l i z e an o b j e c t ' s interna l state so that the object can be restored to this state later. Also Known As T o k e n Motivation S o m e t i m e s i t 's n e c e s s a r y to r e c o r d t he interna l state of an o b j e c t . T h is is r e q u i r e d when implementin g c h e c k p o i n t s and undo m e c h a n i s m s that let u s e rs b a ck out of tentativ e operation s or r e c o v e r from e r r o r s . Y ou must s a ve state informatio n s o m e - wher e so that y ou c an r e s t o r e o b j e c t s to their p r e v i o u s s t a t e s . B ut o b j e c t s n o r m a l l y encapsulat e s o me or a ll of their s t a t e, makin g it i n a c c e s s i b l e to other o b j e c t s a nd i m p o s s i b l e to s a ve e x t e r n a l l y . Exposin g this state woul d v i o l a t e e n c a p s u l a t i o n , whic h c an c o m p r o m i s e t he application' s r e l i a b i l i t y a nd e x t e n s i b i l i t y . C o n s i d e r for exampl e a graphica l e d i t o r t h at support s con ne ct ivi t y b e t w e e n ob- jects. A u s er can c o n n e c t two r e c t a n g l e s with a l i n e, and the r e c t a n g l e s stay c o n - n e c t e d when the user m o v e s eithe r of them . The edito r e n s u r e s that the l i ne stretches to maintain the connection. A w e l l - k n o w n way to maintai n c o n n e c t i v i t y r e l a t i o n s h i p s betwee n o b j e c t s is with a c o n s t r a i n t - s o l v i n g s y s t e m . We can encapsulat e this functionalit y in a Constraint- S o l v e r o b j e c t . C o n s t r a i n t S o l v e r r e c o r d s c o n n e c t i o n s as they a re made a nd g e n e r - ates mathematica l equation s that d e s c r i b e them . It s o l v e s t h e se equation s when- e v er the u s er make s a c o n n e c t i o n or oth e rw is e modifie s the diagram . C o n s t r a i n t - S o l v e r u s es t he r e s u l t s of i ts c a l c u l a t i o n s to rearrang e t he graphic s so that they maintai n the p r o p e r c o n n e c t i o n s . Supportin g undo in this applicatio n i s n 't as e a sy as it may s e e m . An o b v i o u s way to undo a move operation is to store the original distance moved and move the ptg2 8 4 BEHAVIORAL PATTERNS CHAPTER 5 objec t back an e q u i v a l e n t distance . However , t h is d o es not guarante e all o b j e c t s w i ll appea r wher e they d id before . S u p p o s e there is s o me s l a ck in t he c o n n e c - tion. In that c a s e, simpl y movin g the rectangl e back to its origina l l o c a t i o n won' t n e c e s s a r i l y a c h i e v e the desired e f f e c t . In general , the ConstraintSolver' s publi c interfac e migh t be insufficien t to a l l ow p r e c i s e reversa l of its effect s on other o b j e c t s . The undo mechanis m must work more c l o s e l y with ConstraintSolve r to r e e s t a b l i s h p r e v i o u s state, but we s h o u l d a l so a v o id e x p o s i n g the ConstraintSolver' s internal s to the undo mechanism. We can s o l ve this p r o b l e m with the Mement o pattern . A m e m e n t o is an o b j e c t that s t o r e s a snapsho t of the interna l state of anothe r object—th e memento' s o r i g i n a t o r . The undo mechanis m w i ll r e q u e s t a mement o f r om the originato r when it n e e ds to c h e c k p o i n t the originator' s state. The originato r i n i t i a l i z e s the mement o with informatio n that c h a r a c t e r i z e s its curren t state. O n ly the originato r can s t o re and r e t r i e v e informatio n from the memento—th e mement o is \" o p a q u e \" to other o b j e c t s . In the graphica l e d i t o r exampl e just d i s c u s s e d , the ConstraintSolve r can act as an originator . T he followin g s e q u e n c e of e v e n t s characterize s t he undo p r o c e s s : 1. T he edito r r e q u e s t s a mement o f r om t he ConstraintSolve r as a side-effec t of the m o ve operation. 2. The C o n s t r a i n t S o l v e r create s and return s a memento , an instanc e of a c l a ss S o l v e r S t a t e in t h is c a s e. A S o l v e r S t a t e mement o contain s data structure s that d e s c r i b e the curren t state of the ConstraintSolver' s interna l equation s and v a r i a b l e s . 3. Later when the u s er undoe s the move operation , the edito r g i v es the S o l v e r - State back to the ConstraintSolver. 4. B a s e d on the informatio n in the S o l v e r S t a t e , the ConstraintSolve r change s its interna l structure s to retur n its equation s and v a r i a b l e s to their e x a ct p r e v i o u s state. T h is arrangemen t l e ts the C o n s t r a i n t S o l v e r entrus t other object s with the infor- matio n it needs to rever t to a p r e v i o u s state withou t e x p o s i n g its interna l structur e and representations. ptgMEMENTO 285 Applicability Use the Mement o patter n when • a snapsho t of ( s o m e portio n of) an object' s state must be s a v ed so t h at it can be restore d to t h at state l a t e r, and • a d i r e c t interfac e to obtainin g the state woul d e x p o s e implementatio n detail s and break the object's encapsulation. S t r u c t u r e Participants • Mement o ( S o l v e r S t a t e ) - s t o r e s interna l state of the Originato r object . The mement o may s t o re as much or as l i t t le of the originator' s interna l state as necessar y at its o r i g i - nator' s discretion. - protect s agains t a c c e s s by object s other than the originator . Memento s have effectivel y two interfaces . Caretake r s e es a narrow interfac e to the Memento—i t can only p a ss the mement o to other objects . O r i g i n a t o r , in contrast , s e es a wide interface , one t h at l e ts it a c c e s s all the data n e c e s s a r y to restor e i t s e lf to its p r e v i o u s state. I d e a l l y , o n ly the originato r that produce d the memento would be permitted to access the memento's internal state. • Originator ( C o n s t r a i n t S o l v e r ) - creates a memento containing a snapshot of its current internal state. - uses the m e m e n t o to r e s t o r e its i n t e r n a l s t a t e . • Caretaker (undo mechanism) - is r e s p o n s i b l e for t h e m e m e n t o ' s s a f e k e e p i n g . - never operates on or examines the contents of a memento. ptg2 8 6 BEHAVIORAL PATTERNS CHAPTERS C o l l a b o r a t i o n s • A caretake r r e q u e s t s a mement o from an o r i g i n a t o r , h o l ds it for a t i m e, and p a s s e s i t b a c k to the originator, a s t h e following interaction diagram illustrates: S o m e t i m e s t he c a r e t a k e r w o n ' t p a ss t he m e m e n t o b a ck to t he o r i g i n a t o r , b e - c a u se t he o r i g i n a t o r migh t n e v er n e ed to r e v e r t to an e a r l i e r state. • Memento s are p a s s i v e . O n ly the o r i g i n a t o r that c r e a t e d a mement o w i ll a s s i g n o r retrieve its state. C o n s e q u e n c e s T he M e m e n t o patter n h as s e v e r a l c o n s e q u e n c e s : 1. Preserving encapsulation boundaries. Mement o a v o i d s e x p o s i n g informatio n that o n ly an o r i g i n a t o r s h o u l d manag e but that must be s t o r ed n e v e r t h e l e s s o u t s i d e t he o r i g i n a t o r . T he patter n s h i e l d s o t h er o b j e c t s from p o t e n t i a l l y c o m p l e x O r i g i n a t o r i n t e r n a l s , t h e r e b y p r e s e r v i n g e n c a p s u l a t i o n b o u n d a r i e s . 2. It simplifies Originator. In other e n c a p s u l a t i o n - p r e s e r v i n g d e s i g n s , O r i g i n a t o r k e e ps the v e r s i o n s of interna l state that c l i e n t s have r e q u e s t e d . T h at puts a ll t he s t o r a g e m a n a g e m e n t b u r d e n on O r i g i n a t o r . H a v i n g c l i e n t s m a n a g e the state they ask for s i m p l i f i e s O r i g i n a t o r and k e e ps c l i e n t s from h a v i n g to notify o r i g i n a t o r s when they'r e d o n e . 3. Using mementos might be expensive. Memento s m i g h t i n c ur c o n s i d e r a b l e o v e r - h e ad if O r i g i n a t o r must c o py l a r ge amount s of informatio n to s t o re in t he mement o or if c l i e n t s c r e a t e a nd retur n memento s to t he o r i g i n a t o r often e n o u g h . U n l e s s encapsulatin g a nd r e s t o r i n g O r i g i n a t o r state is c h e a p , t he patter n migh t n ot be appropriate . S ee t he d i s c u s s i o n of i n c r e m e n t a l i t y in t he Implementatio n s e c t i o n . 4. Defining narrow and wide interfaces. It may be difficul t in s o me l a n g u a g e s to e n s u r e that o n ly the originato r can a c c e s s the memento' s state. 5. Hidden costs in caring for mementos. A caretake r is r e s p o n s i b l e for d e l e t i n g the mementos it cares for. However, the caretaker h a s n o idea how much state is ptgMEMENTO 2 8 7 in the memento . H e n c e an otherwis e lightweigh t caretake r migh t incur l a r ge storage costs when it stores mementos. Implementation Here are two i s s u e s to conside r when implementin g the Mement o pattern: 1.Language support. Memento s have two interfaces : a wide one for originator s and a narro w one for other o b j e c t s . I d e a l l y the implementatio n languag e w i ll suppor t two l e v e ls of static protection . C++ lets you do this by makin g the Originato r a friend of Mement o and makin g Memento' s wide interfac e private. Only the narrow interface should be declared public. For example: class State; class Originato r { public: Memento* CreateMemento() ; void SetMemento(cons t Memento*) ; // . . . private: State* _state; // internal data structure s // . . . } ; class Memento { public: // narrow public interfac e virtual ~Memento(); private: // private members accessibl e o n ly to Originato r friend class Originator; Memento(); void SetState(State*); State* GetState O ; // . . . private: State* _state; // . - . } ; 2. Storing incremental changes. Whe n memento s get create d and p a s s e d back to their originato r in a predictabl e s e q u e n c e , then Mement o can save just the incremental change to the originator' s interna l state. For e x a m p l e , undoabl e command s in a histor y l i st can use memento s to en- sure t h at command s are restore d to their exact state when they'r e undon e ( s ee Comman d ( 2 3 3 ) ) . T he histor y l i st define s a s p e c i f i c o rd er in whic h c o m - mand s can be undon e and r e d o n e . That mean s memento s can store just the incrementa l chang e that a comman d make s rathe r than the f u ll state of every o b j e c t they a f f e c t . In the Motivatio n exampl e g i v en e a r l i e r , the constrain t s o l v e r c a n store only those internal structures that change to keep t h e l i n e ptg288 BEHAVIORAL PATTERNS CHAPTER 5 c o n n e c t i n g t he r e c t a n g l e s , as o p p o s e d to s t o r i n g t he a b s o l u t e p o s i t i o n s of t h e s e objects. Sample Code T he C ++ c o de g i v en h e re i l l u s t r a t e s t he C o n s t r a i n t S o l v e r e x a m p l e d i s c u s s e d e a r - l i e r. We u se M o v e C o m m a n d o b j e c t s ( s ee C o m m a n d (233) ) to ( u n ) d o t he t r a n s l a t i o n of a g r a p h i c a l o b j e c t f r om o ne positio n to a n o t h e r . T he g r a p h i c a l edito r c a l ls t he c o m m a n d ' s E x e c u t e o p e r a t i o n to m o ve a g r a p h i c a l o b j e c t and U n e x e c u t e to u n do t he move . T he c o m m a n d s t o r e s i ts t a r g e t , t he d i s t a n c e m o v e d , a nd an i n - s t a n c e of C o n s t r a i n t S o l v e r M e m e n t o , a m e m e n t o c o n t a i n i n g state f r om the c o n s t r a i n t s o l v e r . class Graphic; // base class for graphica l objects in the graphica l editor class MoveComman d { public: MoveCommand(Graphic * target, const Point& delta); void Execute() ; void Unexecute(); private: ConstraintSolverMemento * _state; P o i nt _delta; Graphic* _target; } ; T he c o n n e c t i o n c o n s t r a i n t s a re e s t a b l i s h e d by t he c l a ss C o n s t r a i n t S o l v e r . I ts k ey m e m b e r functio n is Solve , w h i c h s o l v e s t he c o n s t r a i n t s r e g i s t e r e d with the A d d C o n s t r a i n t operation . To s u p p o r t u n d o , C o n s t r a i n t S o l v e r ' s s t a te can be externalize d with C r e a t e M e m e n t o into a C o n s t r a i n t S o l v e r M e m e n t o i n s t a n c e . T he c o n s t r a i n t s o l v e r c an be r e t u r n e d to a p r e v i o u s state by c a l l i n g S e t M e m e n t o . C o n s t r a i n t S o l v e r is a S i n g l e t o n (127). class ConstraintSolve r { public: static ConstraintSolver * Instance(); void Solve(); void AddConstraint( Graphic* startConnection , Graphic* endConnectio n ) ; void RemoveConstraint( Graphic* startConnection , Graphic* endConnectio n ) ; ptgMEMENTO 289 ConstraintSolverMemento * CreateMemento() ; void SetMemento(ConstraintSolverMemento*); private: // nontrivia l state and operation s for enforcin g // connectivit y semantics } ; class ConstraintSolverMement o { public: virtual \"ConstraintSolverMemento() ; private: friend class ConstraintSolver; ConstraintSolverMemento(); // private constrain t solver state } ; G i v en t h e se interfaces , we can i m p l e m e n t M o v e C o n u n a n d m e m b e r s E x e c u t e and U n e x e c u t e as follows: void MoveCommand::Execut e () { ConstraintSolver * solver = ConstraintSolver::Instance() ; _state = solver->CreateMemento() ; // create a memento _target->Move(_delta) ; solver->Solve(); } void MoveCommand::Unexecut e () { ConstraintSolver * solver = ConstraintSolver::Instance() ; _target->Move(-_delta) ; solver->SetMemento(_state) ; // restore s o l v er state solver->Solve(); } E x e c u t e a c q u i r e s a C o n s t r a i n t S o l v e r M e m e n t o mement o befor e it m o v e s the g r a p h i c . U n e x e c u t e m o v e s the g r a p h i c b a c k, s e ts the c o n s t r a i n t s o l v e r ' s state to t h e previous state, and finally tells the constraint solver to solve the constraints. K n o w n Uses T he p r e c e d i n g sampl e c o de is b a s ed on Unidraw' s suppor t f or c o n n e c t i v i t y throug h i ts C S o l v e r c l a ss [ V L 9 0 1 . C o l l e c t i o n s in D y l a n [ A p p 9 2 ] p r o v i d e an iteratio n interfac e that reflect s t he M e - ment o pattern . Dylan' s c o l l e c t i o n s have t he n o t i o n of a \" s t a t e \" o b j e c t , w h i c h is a mement o that r e p r e s e n t s t he state of t he iteration . E a ch c o l l e c t i o n c an r e p r e s e n t t he curren t state of t he iteratio n in a ny w ay it c h o o s e s ; t he representatio n is c o m - p l e t e l y hidde n from c l i e n t s . The D y l a n iteratio n approac h migh t be translate d to C++ as follows: ptg290 BEHAVIORAL PATTERNS CHAPTER 5 template <class Item> class Collectio n { public: Collection(); IterationState * CreatelnitialState() ; void Next(IterationState*) ; bool I s D o n e ( c o n s t IterationState* ) const; Item Currentltem(cons t IterationState* ) const; I t e r a t i o n S t a t e * C o p y ( c o n s t I t e r a t i o n S t a t e * ) c o n s t ; void Append(cons t Item&); void Remove(cons t Item&); // . . . } ; C r e a t e l n i t i a l S t a t e r e t u r n s an initialize d I t e r a t i o n S t a t e o b j e c t for the collection . Next a d v a n c e s t he state o b j e c t to t he n e xt p o s i t i o n in t he i t e r a t i o n ; it effectivel y i n c r e m e n t s the i t e r a t i o n i n d e x . Is Done r e t u r n s t r ue if N e xt has a d v a n c e d b e y o n d t he last e l e m e n t in t he c o l l e c t i o n . C u r r e n t l t e m d e r e f e r e n c e s t he s t a te o b j e c t a nd r e t u r n s t he e l e m e n t in t he c o l l e c t i o n to w h i c h it refers . C o py r e t u r n s a c o py of t he g i v en state o b j e c t . T h is is u s e f u l f or m a r k i n g a p o i nt in an iteration. Give n a c l a ss I t e m T y p e , we can iterat e o v er a c o l l e c t i o n of its i n s t a n c e s as follows 7: class ItemType { public: void Process() ; // . . . } ; Collection<ItemType* > aCollection ; IterationState * state; state - aCollection.CreatelnitialState(); while (laCollection.IsDone(state) ) { aCollection.CurrentItern(state)->Process() ; aCollection.Next(state); } delete state; T he m e m e n t o - b a s e d i t e r a t i o n interfac e h as t wo i n t e r e s t i n g b e n e f i t s : 1. M o re t h an o ne state c an w o rk on t he s a me c o l l e c t i o n . ( T he s a me is t r ue of t he I t e r a t o r (257) pattern.) 7Note that o ur e x a m p l e d e l e t e s t he state o b j e c t at t he e nd of t he i t e r a t i o n . B ut d e l e t e w o n ' t g et c a l l e d if P r o c e s s l t e m t h r o w s an e x c e p t i o n , t h us c r e a t i n g g a r b a g e . T h is is a p r o b l e m in C++ but not in D y l a n , whic h h a s garbage collection. We d i s c u s s a solution to this problem on page 266. ptgMEMENTO 2 9 1 2. It d o e s n ' t r e q u i r e b r e a k i n g a c o l l e c t i o n ' s e n c a p s u l a t i o n to suppor t i t e r a t i o n . T he mement o is o n ly i n t e r p r e t e d by t he c o l l e c t i o n i t s e l f ; no o ne e l se h as a c c e s s to i t. O t h e r a p p r o a c h e s to i t e r a t i o n r e q u i r e b r e a k i n g e n c a p s u l a t i o n by makin g iterato r c l a s s e s M e n d s of t h e ir c o l l e c t i o n c l a s s e s ( s ee Iterato r ( 2 5 7 ) ) . T he s i t u a t i o n is r e v e r s e d in the m e m e n t o - b a s e d i m p l e m e n t a t i o n : C o l l e c t i o n is a friend of the i t e r a t o r S t a t e . T he Q O C A c o n s t r a i n t - s o l v i n g t o o l k i t s t o r es i n c r e m e n t a l informatio n in m e m e n - t os [ H H M V 9 2 ] . C l i e n t s c an o b t a i n a m e m e n t o that c h a r a c t e r i z e s t he c u r r e n t s o - l u t i on to a s y s t e m of c o n s t r a i n t s . T he mement o c o n t a i n s o n ly t h o se constrain t v a r i a b l e s that h a ve c h a n g e d s i n ce t he l a st s o l u t i o n . U s u a l l y o n ly a s m a ll s u b s e t of t he s o l v e r ' s v a r i a b l e s c h a n g e s f or e a ch n ew s o l u t i o n . T h is s u b s e t is e n o u g h to r e t u rn t he s o l v e r to t he p r e c e d i n g s o l u t i o n ; r e v e r t i n g to e a r l i e r s o l u t i o n s r e - q u i r e s r e s t o r i n g m e m e n t o s from t he i n t e r v e n i n g s o l u t i o n s . H e n c e y ou can't s et m e m e n t o s in a ny o r d e r ; Q O C A r e l i es on a h i s t o r y m e c h a n i s m to r e v e r t to e a r l i e r s o l u t i o n s . R e l a t e d Patterns C o m m a n d ( 2 3 3 ) : C o m m a n d s c an u se m e m e n t o s to maintai n state f or u n d o a b l e o p e r a t i o n s . Iterator (257): M e m e n t o s can be used for iteration as described earlier. ptg This page intentionally left blank ptgOBSERVER 293 O B S E R V E R O b j e c t Behavioral Intent Defin e a one-to-man y dependenc y betwee n o b j e c t s so that when one o b j e c t changes state, all its dependents are notified a n d updated automatically. Also Known A s Dependents, Publish-Subscribe Motivation A commo n side-effec t of partitionin g a syste m into a c o l l e c t i o n of cooperatin g c l a s s e s is the n e ed to maintai n c o n s i s t e n c y betwee n relate d o b j e c t s . You don't want to a c h i e v e c o n s i s t e n c y by makin g the c l a s s e s tightl y c o u p l e d , b e c a u s e that r e d u c e s their reusability. For example , many graphica l user interfac e toolkit s separat e the presentationa l a s p e c t s of t he u s er interfac e from t he u n d e r l y i n g a p p l i c a t i o n data [ K P 8 8 , L V C 8 9 , P+ 8 8, W G M 8 8 ] . C l a s s e s definin g applicatio n data a nd presentation s can be r e u s e d i n d e p e n d e n t l y . T h ey c an work t o g e t h e r , t o o. B o th a s p r e a d s h e e t o b j e c t a nd b ar chart objec t can depic t informatio n in the same applicatio n data objec t using differen t p r e s e n t a t i o n s . T he s p r e a d s h e e t a nd t he b ar c h a rt d o n 't know a b o u t e a ch other , thereb y lettin g you r e u se only the one you need. But they behave as thoug h they do. Whe n the u s er c h a n g e s the informatio n in the s p r e a d s h e e t , the bar c h a rt reflects the changes immediately, a n d vice versa. ptg2 9 4 B E H A V I O R A L P A T T E R N S CHAPTER 5 T h is behavio r i m p l i e s that t he s p r e a d s h e e t a nd b ar chart a re d e p e n d e n t on t he data o b j e c t a nd therefor e s h o u l d be notifie d of a ny c h a n g e in i ts state. A nd t h e r e ' s no reaso n to l i m it the numbe r of d e p e n d e n t object s to two; there may be any numbe r of differen t user interface s to the s a me data. T he O b s e r v e r patter n d e s c r i b e s h ow to e s t a b l i s h t h e se r e l a t i o n s h i p s . T he k ey o b j e c t s in t h is patter n are subjec t and observer . A s u b j e c t may have any numbe r of dependen t observers . All o b s e r v e r s are notifie d w h e n e v e r the subjec t u n d e r g o e s a c h a n g e in state. In r e s p o n s e , e a ch o b s e r v e r w i ll query t he subjec t to s y n c h r o n i z e its state with the subject' s state. T h is k i nd of interactio n is a l so know n as publish-subscribe . T he subjec t is t he publishe r of notifications . It s e n ds out t h e se notification s withou t havin g to know who its observers are. Any number of observers can subscribe to receive notifica - t i o n s . Applicability Use the O b s e r v e r patter n in any of the followin g situations: • Whe n an abstractio n has two aspects , one dependen t on the o t h e r . Encapsu- lating t h e se aspect s in separat e o b j e c t s l e ts you vary and r e u se them i n d e - p e n d e n t l y . • Whe n a chang e to one objec t require s c h a n g i n g o t h e r s , and you don't k n ow how many object s n e ed to be changed. • Whe n an o b j e c t s h o u l d be a b le to notif y other object s withou t makin g as- sumption s abou t who t h e se object s a r e. In o t h er w o r d s , you d o n 't want t h e se o b j e c t s tightly coupled. S t r u c t u r e ptgOBSERVER 295 P a r t i c i p a n t s • Subject - know s its o b s e r v e r s . Any numbe r of O b s e r v e r o b j e c t s may o b s e r v e a s u b - ject. - p r o v i d e s an interfac e for attachin g and detachin g O b s e r v e r objects. • O b s e r v e r - define s an updatin g interfac e f or o b j e c t s that s h o u l d be notifie d of c h a n g e s in a s u b j e c t . • C o n c r e t e S u b j e c t - s t o r es s t a te of i n t e r e s t to C o n c r e t e O b s e r v e r o b j e c t s . - s e n ds a notificatio n to its o b s e r v e r s when its state c h a n g e s . • C o n c r e t e O b s e r v e r - maintain s a referenc e to a C o n c r e t e S u b j e c t o b j e c t . - s t o r es state that s h o u l d stay c o n s i s t e n t with the s u b j e c t ' s . - implement s the O b s e r v e r updatin g interfac e to k e ep its state c o n s i s t e n t with the subject's. C o l l a b o r a t i o n s • C o n c r e t e S u b j e c t notifie s its o b s e r v e r s wheneve r a chang e o c c u r s that c o u ld make its o b s e r v e r s ' state i n c o n s i s t e n t with its o w n . • After b e i ng informe d of a c h a n g e in t he c o n c r e t e s u b j e c t , a C o n c r e t e O b s e r v e r o b j e c t may query the s u b j e c t for information . C o n c r e t e O b s e r v e r u s es this in- formatio n to r e c o n c i l e its state with that of the subject. T he f o l l o w i n g i n t e r a c t i o n d i a g r a m i l l u s t r a t e s t he c o l l a b o r a t i o n s b e t w e e n a subject and two observers: ptg296 BEHAVIORAL PATTERNS CHAPTERS Note how the Observe r o b j e c t that initiate s the c h a n g e reques t p o s t p o n e s its updat e until it g e ts a notificatio n f r om the subject . Notif y is not alway s c a l l ed by t he subject . It c an be c a l l ed by an o b s e r v e r or by anothe r k i nd of o b j e c t e n t i r e l y . The Implementation section discusses some common variations. C o n s e q u e n c e s The Observe r patter n lets you vary subject s and o b s e r v e r s i n d e p e n d e n t l y . You can reuse subject s withou t r e u s i n g their o b s e r v e r s , and v i ce versa . It l e ts you add observer s withou t modifyin g the subjec t or o t h er o b s e r v e r s . Furthe r benefit s and l i a b i l i t i e s of the O b s e r v e r patter n includ e the f o l l o w i n g : 1. Abstract coupling between Subject a nd Observer. A ll a subjec t know s is that it h as a l i st of o b s e r v e r s , e a ch c o n f o r m i n g to t he s i m p l e i n t e r f a c e of t he a b s t r a c t O b s e r v e r c l a s s . T he subjec t d o e s n ' t know t he c o n c r e t e c l a ss of a ny o b s e r v e r . T h us the c o u p l i n g betwee n subject s and o b s e r v e r s is abstrac t and m i n i m a l . Becaus e Subjec t and O b s e r v e r aren' t tightl y c o u p l e d , they can b e l o n g to differen t layer s of abstractio n in a s y s t e m . A l o w e r - l e v e l s u b j e c t can c o m - municat e and infor m a h i g h e r - l e v e l o b s e r v e r , thereb y k e e p i n g the s y s t e m ' s layerin g intact . If S u b j e c t and O b s e r v e r are lumpe d t o g e t h e r , then the result- ing objec t must eithe r span two l a y e r s (and violat e the l a y e r i n g ) , or it must be force d to l i ve in one layer or the other ( w h i c h migh t compromis e the layerin g abstraction). 2. Support for broadcast communication. Unlik e an ordinar y r e q u e s t , the notifi- c a t i o n that a subjec t s e n ds n e e d n ' t specif y i ts r e c e i v e r . T he notificatio n is broadcas t automaticall y to all i n t e r e s t e d o b j e c t s that s u b s c r i b e d to it. The subjec t doesn' t c a re how many intereste d object s e x i s t; its o n ly r e s p o n s i b i l - ity is to notif y its o b s e r v e r s . T h is g i v es you the freedo m to add and r e m o v e o b s e r v e r s at any time. It's up to the o b s e r v e r to handl e or i g n o r e a notification. 3. Unexpected updates. B e c a u s e o b s e r v e r s have no k n o w l e d g e of e a ch other' s p r e s e n c e , they can be blind to the ultimat e c o st of c h a n g i n g the s u b j e c t . A s e e m i n g l y innocuou s operatio n on the subjec t may c a u se a c a s c a d e of update s to o b s e r v e r s and t h e ir dependen t objects . M o r e o v e r , d e p e n d e n c y c r i t e r i a that aren' t well-define d or maintaine d usuall y l e ad to spuriou s updates , w h i c h can be hard to track down. T h is proble m is aggravate d by the f a ct that the s i m p l e updat e protoco l pro- vides no d e t a i l s on what c h a n g e d in the subject . Withou t additiona l protoco l to h e lp o b s e r v e r s d i s c o v e r what changed , they may be force d to work hard t o deduce the changes. I m p l e m e n t a t i o n S e v e r a l i s s u e s r e l a t e d to t he i m p l e m e n t a t i o n of t he d e p e n d e n c y m e c h a n i s m a re d i s c u s s e d in this section. ptgOBSERVER 297 1. Mapping subjects to their observers. The s i m p l e s t way for a subjec t to keep track of the observer s it s h o u l d notif y is to store reference s to them explicitl y in t he s u b j e c t . H o w e v e r , s u ch s t o r a g e m ay be t oo e x p e n s i v e w h en t h e re a re many subject s and few observers . One solutio n is to trade space for time by using an a s s o c i a t i v e look-u p ( e . g ., a hash table ) to maintai n the subject-to- o b s e r v e r mapping . T h us a subjec t with no o b s e r v e r s d o es not incur storag e overhead . On the other hand , t h is approac h increase s the c o st of a c c e s s i n g the observers. 2.Observing more than one subject. It migh t make s e n se in some situation s for an o b s e r v e r to depen d on more than one subject . For example , a spreadshee t may d e p e n d on more than one data s o u r c e . I t 's necessar y to e x t e n d the Updat e interfac e in s u ch c a s es to let the o b s e r v e r know which subjec t is s e n d i n g the notification . The subjec t can simpl y p a ss i t s e lf as a paramete r in the Updat e operation , thereb y lettin g the o b s e r v e r know whic h subjec t to examine. 3. Who triggers the update? The subjec t and its o b s e r v e r s r e ly on the notificatio n mechanis m to stay c o n s i s t e n t . But what o b j e c t actuall y c a l ls N o t i f y to trigge r the update ? H e re are two o p t i o n s : (a)Have state-settin g operation s on S u b j e c t c a ll N o t i f y a f t er they c h a n g e the subject' s state. The advantag e of this approac h is that c l i e n t s don't have to remembe r to c a ll Notif y on the subject . The disadvantag e is that s e v e r a l consecutiv e operation s will c a u se severa l consecutiv e updates , whic h may be inefficient. (b)Make c l i e n t s r e s p o n s i b l e for c a l l i n g Notif y at the right time. The advan- tage h e re is that the c l i e n t can wait to trigge r the u p d a t e until a f t er a s e r i es of state c h a n g e s has b e en made , thereb y avoidin g n e e d l e s s intermediat e updates . The disadvantag e is that c l i e n t s have an adde d r e s p o n s i b i l i t y to t r i g g e r t he u p d a t e . T h at m a k e s e r r o r s m o re l i k e l y , s i n ce c l i e n t s m i g h t forge t to c a ll Notify. 4. Dangling references to deleted subjects. D e l e t i n g a subjec t s h o u l d not produc e danglin g r e f e r e n c e s in its o b s e r v e r s . One way to a v o id danglin g reference s is to make the subjec t notif y its observer s as it is delete d so that they can r e s et t h e ir r e f e r e n c e to i t. In g e n e r a l , s i m p l y d e l e t i n g t he o b s e r v e r s is n ot an o p t i o n , becaus e other o b j e c t s may referenc e them , or they may be observin g other subject s as well. 5. Making sure Subject state is self-consistent before notification. It's importan t to make sure S u b j e c t state is s e l f - c o n s i s t e n t befor e c a l l i n g Notify , becaus e ob- s e r v e r s q u e ry t he s u b j e c t f or i ts c u r r e n t s t a te in t he c o u r s e of updatin g t h e ir own state. T h is s e l f - c o n s i s t e n c y rule is easy to violat e unintentionall y when S u b j e c t s u b c l a s s o p e r a t i o n s call inherited operations. For e x a m p l e , the notification in ptg2 98 B E H A V I O R A L PATTERNS CHAPTER 5 t he followin g c o de s e q u e n c e is t r i g g e d when t he subjec t is in an i n c o n s i s t e n t state: void M y S u b j e c t : : O p e r a t i o n ( i nt n e w V a l u e ) { B a s e C l a s s S u b j e c t : : O p e r a t i o n ( n e w V a l u e ) ; // t r i g g er notification _ m y ! n s t V a r += n e w V a l u e ; // u p d a te s u b c l a ss state ( t oo late!) } You can a v o id t h is pitfal l by s e n d i n g notification s from templat e method s ( T e m p l a t e M e t h o d ( 3 2 5 ) ) in abstrac t S u b j e c t c l a s s e s . D e f i n e a primitiv e o p - eratio n f or s u b c l a s s e s to o v e r r i d e , a nd make Notif y t he l a st o p e r a t i o n in t he templat e method , whic h w i ll e n s u r e that t he o b j e c t is s e l f - c o n s i s t e n t when s u b c l a s s e s overrid e S u b j e c t o p e r a t i o n s . void T e x t : : C ut ( T e x t R a n g e r) { ReplaceRange(r) ; // r e d e f i n ed in s u b c l a s s e s Notify(); } By the way, it's alway s a g o od i d ea to documen t w h i c h S u b j e c t operation s t r i g g e r notifications. 6. Avoiding observer-specific update protocols: the push and pull models. I m p l e m e n - tation s of the O b s e r v e r patter n often have the subjec t broadcas t a d d i t i o n a l informatio n abou t t he c h a n g e . T he s u b j e c t p a s s e s t h is informatio n as an argumen t to Update . The amoun t of informatio n may vary w i d e l y . At o ne e x t r e m e , w h i c h we c a ll t he p u sh m o d e l , t he subjec t s e n ds o b s e r v e r s detaile d informatio n abou t the c h a n g e , whethe r they want it or not. At the o t h er extrem e is t he pull m o d e l ; t he s u b j e c t s e n ds n o t h i n g b ut t he most m i n i m a l notification , and o b s e r v e r s ask for d e t a i l s e x p l i c i t l y thereafter. T he pull mode l e m p h a s i z e s t he subject' s i g n o r a n c e of i ts o b s e r v e r s , w h e r e a s the push mode l a s s u m e s s u b j e c t s k n ow s o m e t h i n g abou t t h e ir o b s e r v e r s ' n e e d s . T he push m o d e l migh t make o b s e r v e r s l e ss r e u s a b l e , b e c a u s e S u b j e c t c l a s s e s make assumption s abou t O b s e r v e r c l a s s e s that m i g h t n ot alway s be true. On the o t h er h a n d , the pull m o d e l may be inefficient , b e c a u s e O b s e r v e r c l a s s e s must a s c e r t a i n what c h a n g e d withou t h e lp from the S u b j e c t . 7. Specifying modifications of interest explicitly. You can improv e updat e efficienc y by e x t e n d i n g the s u b j e c t ' s registratio n interfac e to a l l ow r e g i s t e r i n g o b s e r v e r s o n ly f or s p e c i f i c e v e n t s of i n t e r e s t . W h e n s u ch an e v e nt o c c u r s , t he s u b j e c t inform s o n ly t h o se o b s e r v e r s that have r e g i s t e r e d i n t e r e s t in that e v e n t . O ne w ay to suppor t t h is u s es t he notio n of a s p e c t s f or S u b j e c t o b j e c t s . To r e g i s t e r i n t e r e s t in particular events, observers are attached to their subjects using void Subject::Attach(Observer*, Aspects interest); ptgOBSERVER 2 9 9 wher e i n t e r e s t specifie s the even t of i n t e r e s t . At notificatio n t i m e, the subjec t supplie s the c h a n g e d a s p e c t to its observer s as a paramete r to the Update operation. For e x a m p l e : void Observer::Update(Subject*, Aspect& interest); Encapsulating complex update semantics. Whe n the dependenc y r e l a t i o n s h i p betwee n subject s and o b s e r v e r s is particularl y complex , an o b j e c t that main- tains t h e se r e l a t i o n s h i p s migh t be r e q u i r e d . We c a ll s u ch an objec t a C h a n g e - M a n a g e r . Its purpos e is to m i n i m i z e the work r e q u i r e d to make o b s e r v e r s reflec t a c h a n g e in t h e ir subject . F or e x a m p l e , if an operatio n i n v o l v e s c h a n g e s to s e v e r a l interdependen t subjects , you migh t have to ensur e that their ob- s e r v e r s are notifie d o n ly a f t er all the subject s have been modifie d to a v o id notifying o b s e r v e r s more than o n c e . ChangeManage r has three r e s p o n s i b i l i t i e s : (a)It maps a subjec t to its o b s e r v e r s and provide s an interfac e to maintai n this mapping . T h is eliminate s the n e ed for subject s to maintai n reference s to their o b s e r v e r s and v i ce versa. (b)It define s a particula r updat e strategy. (c)It update s all dependen t observer s at the reques t of a subject. The followin g diagra m depict s a s i m p l e ChangeManager-base d implemen- tation of the O b s e r v e r pattern . T h e re are two s p e c i a l i z e d ChangeManagers . S i m p l e C h a n g e M a n a g e r is naive in that it alway s update s a ll o b s e r v e r s of e a ch subject . In contrast , DAGChangeManage r handle s d i r e c t e d - a c y c l i c graph s of dependencie s betwee n subject s and their o b s e r v e r s . A DAGChangeManage r is preferabl e to a SimpleChangeManage r when an o b s e r v e r o b s e r v e s more than one subject . In that c a s e, a c h a n g e in two or more subject s migh t c a u se redundan t updates . T he DAGChangeManage r e n s u r e s t he o b s e r v e r r e c e i v e s j u st one update . S i m p l e C h a n g e M a n a g e r is fine when multipl e update s aren' t an issue. ptg3 0 0 BEHAVIORAL PATTERNS CHAPTER 5 C h a n g e M a n a g e r is an i n s t a n c e of t he Mediato r ( 2 7 3) pattern . In g e n e r a l t h e re is o n ly o ne C h a n g e M a n a g e r , a nd it is know n g l o b a l l y . T he S i n g l e t o n ( 1 2 7) patter n woul d be usefu l h e r e . 9.Combining t he Subject a nd Observer classes. C l a ss l i b r a r i e s writte n in l a n g u a g e s that lack multipl e i n h e r i t a n c e (like Smalltalk ) generall y don't defin e separat e S u b j e c t a nd O b s e r v e r c l a s s e s b ut c o m b i n e their interface s in o ne c l a s s . That l e ts you defin e an o b j e c t that acts as both a subjec t and an o b s e r v e r withou t m u l t i p l e i n h e r i t a n c e . In S m a l l t a l k , f or e x a m p l e , t he S u b j e c t a nd O b s e r v e r interface s are define d in the root c l a ss O b j e c t , makin g them a v a i l a b l e to all c l a s s e s . S a m p l e C o d e An abstrac t c l a ss define s the O b s e r v e r interface: c l a ss S u b j e c t ; c l a ss O b s e r v er { public: virtual \" O b s e r v e r ( ) ; v i r t u a l void U p d a t e ( S u b j e c t * theChangedSubject) = 0; protected: O b s e r v e r ( ) ; T h is i m p l e m e n t a t i o n s u p p o r t s m u l t i p l e s u b j e c t s f or e a ch o b s e r v e r . T he s u b - ject passe d to the U p d a t e operatio n l e ts the o b s e r v e r determin e w h i c h subjec t c h a n g e d w h e n it observes more than one. S i m i l a r l y , an abstract class defines the Subject i n t e r f a c e : ptgOBSERVER 301 c l a ss S u b j e ct { public: virtual ~Subject(); virtual void Attach(Observer*) ; virtual void Detach(Observer*) ; virtual void Notify(); protected: Subject() ; private: L i s t < O b s e r v e r * > * _ o b s e r v e r s ; } ; void Subject:-.Attac h ( O b s e r v e r * o) { _observers->Append(o) ; } void Subject::Detac h ( O b s e r v e r * o) { _observers->Remove(o) ; } void Subject::Notif y () { ListIterator<Observer* > i ( _ o b s e r v e r s ) ; for ( i. First ( ); ! i . I s D o ne () ; i.NextO) { i.Currentltem()->Update(this) ; } } C l o c k T i m e r is a c o n c r e t e s u b j e c t f or s t o r i n g a nd m a i n t a i n i n g t he t i me of d a y. It n o t i f i e s i ts o b s e r v e r s e v e ry s e c o n d . C l o c k T i m e r p r o v i d e s t he i n t e r f a c e f or r e t r i e v i n g i n d i v i d u a l t i me u n i ts s u ch as t he h o u r , m i n u t e , a nd s e c o n d . class C l o c k T i m e r : public S u b j e ct { public: ClockTimer(); virtual int GetHour() ; virtual int GetMinute() ; virtual int GetSecond(); void Tick(); } ; T he T i ck o p e r a t i o n g e ts c a l l ed by an i n t e r n a l t i m er at r e g u l a r i n t e r v a l s to p r o v i d e an a c c u r a t e t i me b a s e. T i ck u p d a t e s t he C l o c k T i m e r ' s i n t e r n a l state a nd c a l ls Not i fy to i n f o r m o b s e r v e r s of the c h a n g e : void ClockTimer::Tic k () { // update i n t e r n al time-keepin g state // . . . Notify(); } ptg302 BEHAVIORAL PATTERNS CHAPTERS N ow we c an d e f i n e a c l a ss D i g i t a l C l o c k t h at d i s p l a y s t he t i m e. It i n h e r i t s i ts g r a p h i c a l f u n c t i o n a l i t y f r om a W i d g e t c l a ss p r o v i d e d by a u s er i n t e r f a c e t o o l k i t . T he O b s e r v e r i n t e r f a c e is m i x e d i n to t he D i g i t a l C l o c k i n t e r f a c e by i n h e r i t i n g f r om O b s e r v e r . class DigitalClock : public Widget, public O b s e r v er { public: DigitalClock(ClockTimer*) ; virtual \"DigitalClock(); virtual v o id U p d a t e ( S u b j e c t * ) ; // o v e r r i d es O b s e r v er o p e r a t i o n virtual void D r a w ( ); // o v e r r i d es Widget operation ; // defines h ow to d r aw t he digital c l o c k private: C l o c k T i m e r * _subject ; } ; DigitalClock::DigitalCloc k ( C l o c k T i m e r * s) { _subject = s; _subject->Attach(this); } DigitalClock::~DigitalCloc k () { _subject->Detach(this) ; } B e f o r e t he Updat e o p e r a t i o n d r a w s t he c l o ck f a c e, it c h e c k s to m a ke s u re t he n o t i f y i n g s u b j e c t is t he c l o c k ' s s u b j e c t : void DigitalClock::Updat e ( S u b j e c t* t h e C h a n g e d S u b j e c t ) { if ( t h e C h a n g e d S u b j e c t == _subject) { D r a w ( ); } } void DigitalClock::Dra w () { // g et t he n ew values f r om t he s u b j e c t int h o ur = _subject->GetHour() ; int minute = _subject->GetMinute() ; // etc. // d r aw the digital c l o ck } A n AnalogClock class can be defined in the same way. ptgOBSERVER 303 class AnalogCloc k : public Widget, public Observer { public: AnalogClock(ClockTimer*) ; virtual void Update(Subject*) ; virtual void Draw(); // . . . The followin g c o de c r e a t e s an A n a l o g C l o c k and a D i g i t a l C l o c k t h at alway s s h o w the same time: ClockTimer * timer = new ClockTimer; AnalogClock * analogCloc k = new AnalogClock(timer) ; DigitalClock* digitalClock = n e w DigitalClock(timer); Wheneve r the t i m e r t i c k s, the two c l o c k s w i ll be update d and w i ll redispla y themselves appropriately. K n o w n Uses The f i r st and perhap s best-know n exampl e of the O b s e r v e r patter n appear s in S m a l l t a l k Model/View/Controlle r ( M V C ) , the u s er interface framewor k in the S m a l l t a l k environmen t [ K P 8 8 ] . MVC s M o d e l c l a ss plays t he r o le of S u b j e c t , w h i le V i ew is t he b a se c l a ss f or o b s e r v e r s . S m a l l t a l k , ET++ [ W G M 8 8 1 , a nd t he T H I N K c l a ss librar y [ S y m 9 3 b ] provid e a genera l dependenc y mechanis m by puttin g S u b - ject and O b s e r v e r interface s in the paren t c l a ss for all other c l a s s e s in the s y s t e m . Othe r user interfac e toolkit s that e m p l o y this patter n are I n t e r v i e w s [ L V C 8 9 ] , the Andre w T o o l k i t [ P+8 8 ], and Unidra w [ V L 9 0 ] . I n t e r v i e w s define s O b s e r v e r a nd O b s e r v a b l e (for s u b j e c t s ) c l a s s e s e x p l i c i t l y . Andre w c a l ls them \" v i e w \" a nd \"data o b j e c t , \" r e s p e c t i v e l y . Unidra w s p l i ts graphica l edito r object s into V i ew ( f or o b s e r v e r s ) and Subject p a r t s . Related Patterns Mediato r ( 2 7 3 ) : By encapsulatin g c o m p l e x updat e semantics , the ChangeManage r acts as mediato r betwee n subject s and o b s e r v e r s . S i n g l e t o n ( 1 2 7 ) : The ChangeManage r may use the S i n g l e t o n patter n to make it unique and globally accessible. ptg This page intentionally left blank ptgS T A T E 305 S T A T E O b j e c t B e h a v i o r a l I n t e n t A l l ow an o b j e c t to a l t er i ts b e h a v i o r w h en i ts i n t e r n a l state c h a n g e s . T he o b j e c t will appear to change its class. Also Known As Objects for States M o t i v a t i o n C o n s i d e r a c l a ss T C P C o n n e c t i o n that represent s a networ k connection . A T C P - Connectio n o b j e c t can be in one of severa l differen t states : Established , L i s t e n i n g , C l o s e d . W h en a T C P C o n n e c t i o n o b j e c t r e c e i v e s r e q u e s t s from o t h er o b j e c t s , it respond s differentl y dependin g on its curren t state. For example , the effec t of an O p en reques t depend s on whethe r t he connectio n is in i ts C l o s e d state or i ts E s t a b - l i s h ed state. The State patter n d e s c r i b e s how T C P C o n n e c t i o n can exhibi t differen t behavio r in each state. T he k ey idea in t h is patter n is to introduc e an abstrac t c l a ss c a l l ed T C P S t a t e to r e p r e s e n t the states of the networ k c o n n e c t i o n . The T C P S t a t e c l a ss d e c l a r e s an interfac e commo n to all c l a s s e s that represen t differen t operationa l states . S u b c l a s s e s of TCPStat e implemen t state-specifi c b e h a v i o r . For example , the c l a s s e s TCPEstablishe d and T C P C l o s e d implemen t behavio r particula r to the Establishe d a n d Closed states of T C P C o n n e c t i o n . The c l a ss T C P C o n n e c t i o n maintain s a state objec t (an instanc e of a s u b c l a s s of T C P S t a t e ) t h a t represents the current s t a t e of the TCP c o n n e c t i o n . T h e class ptg3 0 6 BEHAVIORAL PATTERNS CHAPTER 5 Connectio n delegate s all state-specifi c request s to t h is state object . T C P C o n n e c t i o n u s es its T C P S t a t e s u b c l a s s instanc e to p e r f o r m operation s particula r to the state of t he c o n n e c t i o n . Wheneve r the connectio n change s state, the T C P C o n n e c t i o n objec t c h a n g e s the s t a te o b j e c t it u s e s. When t he c o n n e c t i o n g o es from e s t a b l i s h e d to c l o s e d , f or e x a m - p l e, T C P C o n n e c t i o n will replac e its T C P E s t a b l i s h e d instanc e with a T C P C l o s e d instance. Applicability U se t he S t a te patter n in e i t h er of t he followin g c a s e s : • An object' s behavio r d e p e n d s on its state, and it must chang e its behavio r at run-tim e d ep endi n g on that state. • Operation s have l a r g e , multipar t conditiona l statement s that depen d on the o b j e c t ' s state. T h is state is usuall y represente d by o ne or m o re enumerate d constants . Often , severa l operation s w i ll contai n this same conditiona l s t r u c - ture. The State patter n puts e a ch branc h of the conditiona l in a separat e c l a s s. T h is l e ts you treat the object' s state as an o b j e c t in its own right that can vary independently f r o m o t h e r objects. S t r u c t u r e Participants • Contex t ( T C P C o n n e c t i o n ) -define s the interfac e of interes t to c l i e n t s . -maintain s an instanc e of a ConcreteStat e s u b c l a s s that define s the curren t state. • State ( T C P S t a t e ) - defines an interface for encapsulating the behavior associated with a par- ticular state of the Context. ptgS T A T E 307 • ConcreteState subclasses ( T C P E s t a b l i s h e d , T C P L i s t e n , T C P C l o s e d ) - each subclass implements a b e h a v i o r a s s o c i a t e d w i t h a state o f t h e C o n t e x t . C o l l a b o r a t i o n s • Contex t delegate s state-specifi c request s to the curren t C o n c r e t e S t a t e o b j e c t . • A c o n t e x t m ay p a ss i t s e lf as an argumen t to t he S t a te o b j e c t h a n d l i n g t he request . T h is l e ts t he State objec t a c c e s s t he contex t if n e c e s s a r y . • C o n t e x t is t he primar y i n t e r f a c e f or c l i e n t s . C l i e n t s c an c o n f i g u r e a c o n t e x t w i th State objects . O n ce a contex t is configured , its c l i e n t s don't have to deal with the State object s d i r e c t l y . • Eithe r Contex t or the C o n c r e t e S t a t e s u b c l a s s e s can d e c i d e whic h state s u c c e e d s another and under what circumstances. C o n s e q u e n c e s The State patter n has the followin g c o n s e q u e n c e s : 1. It localizes state-specific behavior and partitions behavior for different states. The State patter n puts all behavio r a s s o c i a t e d with a particula r state into one o b j e c t . B e c a u s e a ll s t a t e - s p e c i f i c c o de l i v es in a S t a te s u b c l a s s , n ew s t a t es a nd transition s can be adde d e a s i ly by definin g new s u b c l a s s e s . An alternativ e is to u se data v a l u e s to d e f i n e i n t e r n a l s t a t es a nd h a ve C o n - text operation s c h e ck the data e x p l i c i t l y . But then we'd have l o o k - a l i k e c o n - ditiona l or c a se statement s scattere d throughou t Context' s implementation . Addin g a new state could requir e changin g s e v e r a l operations , whic h c o m - plicate s maintenance. The State patter n a v o i d s t h is p r o b l e m but migh t introduc e another , b e c a u s e the patter n distribute s behavio r for differen t states a c r o s s s e v e r a l State s u b - c l a s s e s . T h is i n c r e a s e s t he numbe r of c l a s s e s a nd is l e ss c o m p a c t than a s i n g le c l a s s. But s u ch distributio n is actuall y g o od if there are many s t a t e s , whic h woul d otherwis e necessitat e l a r ge conditiona l statements. Like long p r o c e d u r e s , l a r ge conditiona l statement s are u n d e s i r a b l e . T h e y ' r e monolithi c and tend to make the c o de l e ss e x p l i c i t , whic h in turn make s them difficul t to modif y and extend . The State patter n offer s a bette r way to structur e state-specifi c c o d e. The l o g ic that determine s the state transition s doesn' t r e s i d e in m o n o l i t h i c if or s w i t c h statement s but instea d is parti- tione d betwee n the State s u b c l a s s e s . Encapsulatin g e a ch state transitio n and a c t i o n in a c l a ss e l e v a t e s t he i d ea of an e x e c u t i o n s t a te to full o b j e c t s t a t u s . That i m p o s e s structur e on the c o de and make s its inten t c l e a r e r . 2. It makes state transitions explicit. Whe n an o b j e c t d e f i n e s i ts c u r r e n t state s o l e ly in terms of internal data values, its state transitions have no explicit repre - s e n t a t i o n ; they only show u p a s assignments t o some variables. Introduc - ing separate objects for different s t a t e s m a k e s the t r a n s i t i o n s m o r e e x p l i c i t . ptg308 BEHAVIORAL PATTERNS CHAPTER 5 A l s o , State object s can protec t the Contex t from inconsisten t interna l states , becaus e state transition s are atomi c f r om the Context' s perspective—the y happe n by rebindin g one variabl e (the Context' s State objec t variable) , not severa l [ d C L F 9 3 ] . 3.State objects c an be shared. If S t a te object s have no instanc e variables—tha t i s, the state they represen t is encode d entirel y in their type—the n context s can share a State object . Whe n state s are share d in this way, they are essentiall y flyweights (see Flyweight (195)) with no intrinsic state, only behavior. Implementation The State patter n raise s a variet y of implementatio n i s s u e s : 1. Who defines the state transitions? The State patter n d o es not specif y whic h participan t define s the criteri a for state transitions . If the criteri a are fixed , then they can be implemente d entirel y in the Context . It is g e n e r a l l y more flexibl e and appropriate , however , to let the State s u b c l a s s e s themselve s specif y t h e ir s u c c e s s o r state and when to make the transition . T h is r e q u i r e s addin g an interfac e to the Contex t that l e ts State object s set the Context' s curren t state e x p l i c i t l y . Decentralizin g the transitio n l o g ic in this way make s it easy to m o d i f y or exten d the l o g ic by definin g new State s u b c l a s s e s . A disadvantag e of de- centralizatio n is that one State s u b c l a s s will have knowledg e of at least one other , whic h introduce s implementatio n dependencie s betwee n s u b c l a s s e s . 2. A table-based alternative. In C++ Programming Style [ C a r 9 2 1 , C a r g i l l d e s c r i b e s anothe r way to impos e structur e on state-drive n c o d e: He uses table s to map input s to state transitions . For each state, a table maps every p o s s i b l e input to a succeedin g state . In effect , this approac h convert s conditiona l c o de (and virtua l f u n c t i o n s , in t he c a se of t he S t a te pattern ) into a t a b le l o o k - u p . The main advantag e of table s is their regularity : You can chang e the transitio n criteri a by modifyin g data instea d of changin g progra m c o d e . T h e r e are s o me disadvantages , however: • A table look-u p is o f t en l e ss efficien t t h an a (virtual ) functio n c a l l . • Puttin g transitio n l o g ic into a uniform , tabula r f o r m a t make s the transi- tion criteri a l e ss e x p l i c i t and therefor e harde r to understand. • It's usuall y difficul t to add action s to accompan y the state transitions . The table-drive n approac h capture s the state s and their transitions , but it must be augmente d to p e r f o r m arbitrar y computatio n on e a ch transition. The key differenc e betwee n table-drive n state machine s and the State patter n can be summe d up like this: The State p a t t e r n model s state-specifi c behavior , whereas the table-driven approach focuses on defining state transitions. ptgS T A T E 3 0 9 3.Creating and destroying State objects. A commo n implementatio n trade-of f wort h c o n s i d e r i n g is whethe r ( 1) to c r e a t e S t a te o b j e c t s o n ly when they a re neede d and destro y them thereafte r versu s (2) creatin g them ahea d of time and neve r destroyin g them. The first c h o i c e is preferabl e when the states t h at w i ll be entere d aren' t know n at run-time , and context s chang e state infrequently . T h is approac h avoid s creatin g object s t h at won' t be u s e d , whic h is importan t if the State object s store a lot of information . The s e c o n d approac h is bette r when state change s o c c u r rapidly , in whic h c a se you want to avoid destroyin g states , becaus e they may be n e e d e d again shortly . Instantiatio n c o s ts are paid once up-front , and there are no destructio n c o s ts at a l l. T h is approac h migh t be inconvenient , though , becaus e the Contex t must keep reference s to all states that migh t be entered. 4. Using dynamic inheritance. Changin g the behavio r for a particula r reques t c o u ld be accomplishe d by changin g the object' s c l a ss at run-time , but this is not p o s s i b l e in most object-oriente d programmin g languages . Exception s includ e S e lf [ U S 8 7 ] and other delegation-base d language s that provid e such a mechanis m and henc e suppor t the State p a t t e r n d i r e c t l y . O b j e c t s in S e lf can delegat e operation s to other o b j e c t s to a c h i e v e a f o rm of dynami c inher- itance . Changin g the delegatio n targe t at run-tim e effectivel y change s the inheritanc e structure . T h is mechanis m l e ts o b j e c t s chang e their behavio r and amounts to changing their class. Sample Code The followin g exampl e g i v es the C++ c o de for the TCP connectio n exampl e de- s c r i b e d in the Motivatio n s e c t i o n . T h is exampl e is a simplifie d versio n of the TCP p r o t o c o l ; it doesn' t describ e the complet e protoco l or all the state s of TCP connections. 8 F i r s t, we defin e the c l a ss T C P C o n n e c t i o n, whic h provide s an interfac e for trans- mittin g d a ta and handle s request s to chang e state. class TCPOctetStream ; class TCPState; class TCPConnectio n { public: TCPConnection O ; void ActiveOpen() ; void PassiveOpen() ; void Close(); 8 T h i s example is based on the TCP c o n n e c t i o n protocol described by Lynch and Rose [LR93]. ptg310 BEHAVIORAL PATTERNS CHAPTER 5 void S e n d ( ); void Acknowledge() ; void S y n c h r o n i z e ( ) ; void ProcessOctet(TCPOctetStream*) ; private: f r i e nd c l a ss T C P S t a t e ; void ChangeState(TCPState*); private: TCPState * _state; } ; T C P C o n n e c t i o n k e e p s an i n s t a n c e of the T C P S t a t e c l a ss in the _ s t a t e m e m - b er v a r i a b l e . T he c l a ss T C P S t a t e d u p l i c a t e s t he s t a t e - c h a n g i n g i n t e r f a c e of T C P C o n n e c t i o n . E a ch T C P S t a t e o p e r a t i o n t a k es a T C P C o n n e c t i o n i n s t a n c e as a p a r a m e t e r , l e t t i n g T C P S t a t e a c c e s s d a ta f r om T C P C o n n e c t i o n a nd c h a n g e t h e connection's state. class T C P S t a te { public: virtual void Transmit(TCPConnection* , TCPOctetStream*) ; virtual void ActiveOpen(TCPConnection*) ; virtual void PassiveOpen(TCPConnection*) ; virtual void Close(TCPConnection*) ; virtual void Synchronize(TCPConnection*) ; virtual void A c k n o w l e d g e ( T C P C o n n e c t i o n * ) ; virtual void Send(TCPConnection*); protected : void ChangeState(TCPConnection*, TCPState*); } ; T C P C o n n e c t i o n d e l e g a t e s a ll s t a t e - s p e c i f i c r e q u e s t s to i ts T C P S t a t e i n s t a n c e _ s t a t e . T C P C o n n e c t i o n a l so p r o v i d e s an o p e r a t i o n for c h a n g i n g t h is v a r i a b l e to a new T C P S t a t e . The c o n s t r u c t o r for T C P C o n n e c t ion i n i t i a l i z e s the o b j e c t to t h e TCPClosed state (defined later). TCPConnection::TCPConnectio n () { _state = T C P C l o s e d : : I n s t a n c e ( ) ; } void T C P C o n n e c t i o n : : C h a n g e S t a t e ( T C P S t a t e * s) { _state = s; } void TCPConnection::ActiveOpe n () { _state->ActiveOpen(this) ; } void TCPConnection::PassiveOpe n () { _ s t a t e - > P a s s i v e O p e n ( t h i s ) ; } ptgS T A T E 311 v o id T C P C o n n e c t i o n : : C l o s e () { _state->Close(this) ; • } void TCPConnection::Acknowledg e () { _s tate->Acknowledge(this) ; } void TCPConnection::Synchroniz e () { _state->Synchronize(this) ; } T O P S t ate i m p l e m e n t s defaul t b e h a v i o r for all r e q u e s t s d e l e g a t e d to it. It can a l so c h a n g e the s t a te of a T C P C o n n e c t i o n with the C h a n g e S t a t e o p e r a t i o n . T C P S t a t e is d e c l a r e d a f r i e n d of T C P C o n n e c t i o n to g i ve it p r i v i l e g e d a c c e s s to t h is o p e r a t i o n . void TCPState::Transmi t ( T C P C o n n e c t i o n * , TCPOctetStream* ) { } v o id T C P S t a t e : : A c t i v e O p e n ( T C P C o n n e c t i o n * ) { } void TCPState::PassiveOpe n ( T C P C o n n e c t i o n * ) { } void TCPState::Clos e ( T C P C o n n e c t i o n * ) { } void TCPState::Synchroniz e ( T C P C o n n e c t i o n * ) { } void TCPState::ChangeStat e ( T C P C o n n e c t i o n * t, TCPState * s) { t - > C h a n g e S t a t e ( s ) ; } S u b c l a s s e s of T C P S t a t e i m p l e m e n t s t a t e - s p e c i f i c b e h a v i o r . A T CP c o n n e c - t i on c an be in m a ny s t a t e s : E s t a b l i s h e d , L i s t e n i n g , C l o s e d , e t c ., a nd t h e r e ' s a s u b c l a s s of T C P S t a t e f or e a ch state . W e ' l l d i s c u s s t h r ee s u b c l a s s e s in d e t a i l : T C P E s t a b l i s h e d , T C P L i s t e n , a nd T C P C l o s e d . class TCPEstablishe d : public TCPState { public: static TCPState * Instance(); virtual void Transmit(TCPConnection* , TCPOctetStream*) ; virtual void Close(TCPConnection*); } ; class TCPListen : public TCPState { public: static TCPState * Instance(); virtual void Send(TCPConnection*) ; // . . . } ; ptg312 BEHAVIORAL PATTERNS CHAPTERS class TCPClose d : public TCPState { public: static TCPState * Instance(); virtual void ActiveOpen(TCPConnection*) ; virtual void PassiveOpen(TCPConnection*) ; // . . . } ; T C P S t a t e s u b c l a s s e s m a i n t a i n no l o c al state , so t h ey c an be s h a r e d , a nd o n ly o ne i n s t a n c e of e a ch is r e q u i r e d . T he u n i q u e i n s t a n c e of e a ch T C P S t a t e s u b c l a s s is o b t a i n e d by the static I n s t a n c e o p e r a t i o n . 9 E a ch T C P S t a t e s u b c l a s s i m p l e m e n t s state-specifi c b e h a v i o r f or v a l id r e q u e s t s in t he state: void TCPClosed::ActiveOpe n ( T C P C o n n e c t i o n * t) { // s e nd S Y N, r e c e i ve S Y N, ACK, etc. ChangeState(t , TCPEstablished::Instance( ) ) ; } v o id T C P C l o s e d : : P a s s i v e O p e n ( T C P C o n n e c t i o n * t) { ChangeState(t , TCPListen::Instance()) ; } void TCPEstablished::Clos e ( T C P C o n n e c t i o n * t) { // s e nd P I N, r e c e i ve A CK of F I N ChangeState(t , TCPListen::Instance()) ; } void T C P E s t a b l i s h e d : : T r a n s m i t ( T C P C o n n e c t i o n * t, TCPOctetStream * o ) { t->ProcessOctet(o) ; } void TCPListen::Sen d ( T C P C o n n e c t i o n * t) { // s e nd S Y N, receive SYN, ACK, etc. ChangeState(t , TCPEstablished::Instance()) ; } After p e r f o r m i n g s t a t e - s p e c i f i c w o r k , t h e se o p e r a t i o n s c a ll t he C h a n g e S t a t e o p e r a t i o n to c h a n g e the state of the T C P C o n n e c t i o n . T C P C o n n e c t i o n i t s e lf d o e s n ' t k n ow a t h i ng a b o u t t he T CP c o n n e c t i o n p r o t o c o l ; i t 's t he T C P S t a t e s u b c l a s s e s that define each state transition and action in T C P . 9This makes each TCPState subclass a Singleton (see Singleton ( 1 2 7 ) ) . ptgS T A T E 313 K n o w n Uses J o h n s o n a nd Z w e i g [ J Z 9 1 ] characteriz e t he S t a te patter n a nd i ts applicatio n to T CP c o n n e c t i o n p r o t o c o l s . M o st popula r i n t e r a c t i v e drawin g program s provid e \" t o o l s \" for performin g op- e r a t i o n s by d i r e c t manipulation . For e x a m p l e , a l i n e - d r a w i n g tool l e ts a u ser c l i ck a nd drag to creat e a n ew l i n e. A s e l e c t i o n t o ol l e ts t he us er s e l e c t s h a p e s . T h e r e ' s u s u a l l y a p a l e t t e of s u ch t o o ls to c h o o s e from . T he u s er t h i n k s of t h is a c t i v i t y as p i c k i n g up a t o ol and w i e l d i n g i t, but in realit y the editor' s behavio r c h a n g e s with t he curren t t o o l: W h e n a drawin g tool is a c t i v e we creat e s h a p e s ; when t he s e l e c t i o n t o ol is a c t i v e we s e l e ct s h a p e s ; a nd so forth . We c an u se t he State patter n to c h a n g e t he editor' s b e h a v i o r d e p e n d i n g on t he curren t t o o l . We c an defin e an abstrac t T o ol c l a ss from whic h to defin e s u b c l a s s e s that i m p l e - ment t o o l - s p e c i f i c b e h a v i o r . T he drawin g e d i t o r m a i n t a i n s a curren t T o ol o b j e c t a nd d e l e g a t e s r e q u e s t s to i t. It r e p l a c e s t h is o b j e c t when t he u s er c h o o s e s a n ew t o o l, c a u s i n g t he behavio r of t he drawin g e d i t o r to c h a n g e a c c o r d i n g l y . T h is t e c h n i q u e is u s ed in both t he HotDra w [ J o h 9 2 ] a nd Unidra w [ V L 9 0 ] drawin g e d i t o r frameworks . It a l l o w s c l i e n t s to defin e n ew k i n ds of t o o ls e a s i l y . In HotDraw , t he D r a w i n g C o n t r o l l e r c l a ss forward s t he r e q u e s t s to t he curren t T o ol object . In Unidraw , t he c o r r e s p o n d i n g c l a s s e s a re V i e w e r a nd T o o l. T he followin g c l a ss diagram sketches the Tool and DrawingController interfaces: C o p l i e n ' s E n v e l o p e - L e t t e r i d i om [ C o p 9 2 ] is r e l a t e d to S t a t e . E n v e l o p e - L e t t e r is a t e c h n i q u e for c h a n g i n g an object' s c l a ss at run-time . The S t a te patter n is more s p e c i f i c , focusin g on h ow to d e al with an objec t whos e behavio r d e p e n d s on i ts state. Related Patterns T h e Flyweight (195) pattern explains when and how State objects can be shared. State objects a r e often Singletons ( 1 2 7 ) . ptg This page intentionally left blank ptgSTRATEGY 315 S T R A T E G Y O b j e c t Behavioral I n t e n t Define a family of a l g o r i t h m s , encapsulate each one, and make them interchange - a b l e . Strategy lets the algorithm vary independently f r o m clients that use it. Also Known As P o l i c y M o t i v a t i o n Many algorithm s e x i st f or breakin g a strea m of text into l i n e s. Hard-wirin g all s u ch algorithm s into the c l a s s e s that r e q u i r e them i s n 't d e s i r a b l e for s e v e r a l r e a s o n s : • C l i e n t s that n e ed l i n e b r e a k i n g g et m o re c o m p l e x if t h ey i n c l u d e t he l i n e - breakin g c o d e. T h at make s c l i e n t s b i g g e r a nd harde r to maintain , e s p e c i a l l y if they suppor t multipl e l i n e b r e a k i n g a l g o r i t h m s . • Differen t algorithm s w i ll be appropriat e at differen t t i m e s . We don't want to s u p p o r t m u l t i p l e l i n e b r e a k i n g a l g o r i t h m s if we d o n 't u se them a l l . • It's difficul t to add new a l g o r i t h m s and vary e x i s t i n g o n es when l i n e b r e a k i n g is an integra l part of a c l i e n t . We c an a v o id t h e se p r o b l e m s by d e f i n i n g c l a s s e s that e n c a p s u l a t e differen t l i n e - breakin g a l g o r i t h m s . An algorith m that's en cap su la te d in this way is c a l l ed a strategy. S u p p o s e a C o m p o s i t i o n c l a ss is r e s p o n s i b l e for maintainin g and updatin g the l i n e b r e a k s of text d i s p l a y e d in a text v i e w e r . L i n e b r e a k i n g s t r a t e g i e s aren' t i m - p l e m e n t e d by the c l a ss C o m p o s i t i o n . Instead , they are implemente d separatel y by s u b c l a s s e s of t he abstrac t C o m p o s i t o r c l a s s. C o m p o s i t o r s u b c l a s s e s i m p l e m e n t different s t r a t e g i e s : ptg3 1 6 BEHAVIORAL PATTERNS CHAPTER 5 • SimpleComposito r implement s a s i m p l e strateg y t h at determine s l i n e b r e a k s one at a time. • TeXComposito r implement s the T gX algorithm for findin g linebreaks . T h is strateg y tries to optimiz e linebreak s g l o b a l l y , that i s, one paragrap h at a time. • ArrayComposito r implement s a strateg y t h at s e l e c t s break s so that each row has a fixed numbe r of items . It's u s e f u l for breakin g a c o l l e c t i o n of i c o ns into r o w s , for example. A C o m p o s i t i o n m a i n t a i n s a r e f e r e n c e to a C o m p o s i t o r o b j e c t . W h e n e v e r a C o m p o - sition reformat s its text, it forward s this r e s p o n s i b i l i t y to its Co mp osi to r object . The c l i e nt of Compositio n s p e c i f i e s whic h Composito r s h o u l d be u s ed by installin g the Compositor it desires into the C o m p o s i t i o n . Applicability Use the Strateg y patter n when • many relate d c l a s s e s d i f f er only in their b e h a v i o r . Strategie s provid e a way to configur e a c l a ss with one of many behaviors. • you n e ed differen t variant s of an algorithm . For e x a m p l e , you migh t de- fine algorithm s reflectin g differen t space/tim e trade-offs . S t r a t e g i e s can be u s ed when t h e se variant s a re implemente d as a c l a ss hierarch y of a l g o - rithm s [ H O 8 7 ] . • an a l g o r i t h m u s es data that c l i e n t s shouldn' t know about . Use the Strateg y patter n to a v o id e x p o s i n g c o m p l e x , algorithm-specifi c data structures. • a c l a ss d e f i n e s many b e h a v i o r s , a nd t h e se appea r as m u l t i p l e c o n d i t i o n a l statement s in its operations . Instea d of many conditionals , move relate d conditional branches into their own Strategy class. S t r u c t u r e ptgS T R A T E G Y 317 Participants • Strateg y (Compositor) - d e c l a r e s an i n t e r f a c e commo n to all supporte d algorithms . Contex t uses this interface to call the algorithm defined by a C o n c r e t e S t r a t e g y . • ConcreteStrategy (SimpleCompositor, TeXCompositor, A r r a y C o m p o s i t o r ) - implements the a l g o r i t h m u s i n g the S t r a t e g y interface. • Context (Composition) -is c o n f i g u r e d w i t h a ConcreteStrategy object. -maintains a reference to a Strategy object. -may define an interface that lets Strategy access its data. C o l l a b o r a t i o n s • Strateg y and Contex t interac t to implemen t the c h o s e n algorithm . A contex t may p a ss all data r e q u i r e d by the algorith m to the strateg y w h en the a l g o r i t h m is c a l l e d . Alternatively , the contex t can pass i t s e lf as an argumen t to Strateg y operations . That lets the strateg y c a ll back on the contex t as required. • A c o n t e x t forward s r e q u e s t s from i ts c l i e n t s to i ts s t r a t e g y . C l i e n t s usuall y creat e and pass a ConcreteStrateg y objec t to the context ; thereafter , client s interac t with the contex t e x c l u s i v e l y . T h e re is o f t en a f a m i l y of ConcreteStrateg y c l a s s e s for a client to choose from. C o n s e q u e n c e s The S t r a t e g y patter n has the followin g benefit s and d r a w b a c k s : 1. Families of related algorithms. Hierarchie s of Strateg y c l a s s e s defin e a f a m i l y of algorithm s or behavior s for context s to reuse . Inheritanc e can help f a c t o r out c o m m o n functionalit y of t he a l g o r i t h m s . 2. An alternative to subclassing. Inheritanc e o f f e r s anothe r way to suppor t a variet y of algorithm s or behaviors . You can subclas s a Contex t c l a ss d i r e c t l y to g i ve it differen t behaviors . But this hard-wire s the behavio r into Context . It m i x e s the algorith m implementatio n with Context's , makin g Contex t harde r to understand , maintain , and extend . And you can't vary the algorith m d y n a m i c a l l y . Y ou w i nd up with many r e l a t e d c l a s s e s w h o s e o n ly differenc e is the algorith m or behavio r they e m p l o y . Encapsulatin g the algorith m in separat e Strateg y c l a s s e s lets you vary the algorith m independentl y of its context, making it easier to switch, understand, a n d extend. 3.Strategies eliminate conditional statements. The Strategy pattern offers a n alter - native to conditional statements for selecting desired behavior. When d i f f e r - e n t behaviors are lumped into one class, it's hard to avoid using conditional ptg3 18 BEHAVIORAL PATTERNS CHAPTER 5 statement s to s e l e c t the right b e h a v i o r . Encapsulatin g the behavio r in s e p a - rate Strateg y c l a s s e s eliminate s these conditiona l statements. For e x a m p l e , withou t strategies , the c o de for breakin g text into l i n es c o u ld l o o k l i k e void Composition::Repai r () { s w i t ch ( _ b r e a k i n g S t r a t e g y ) { case SimpleStrategy: ComposeWithSimpleCompositor() ; b r e a k ; case TeXStrategy : ComposeWithTeXCompositor() ; break; // . . . } // merge results with existing composition , if necessar y } The Strategy pattern eliminates this case statement by d e l e g a t i n g t h e l i n e - breaking task to a Strategy object: void Composition::Repai r () { _compositor->Compose() ; // merge results with existing composition, if n e c e s s a r y } C o de containin g many conditiona l statement s o f t en indicate s the need to a p p ly t he S t r a t e g y pattern. 4. A choice of implementations. S t r a t e g i e s can provid e differen t implementation s of t he same b e h a v i o r . T he c l i e nt c an c h o o s e a m o n g s t r a t e g i e s with differen t time and s p a ce trade-offs. 5. Clients must be aware of different Strategies. The patter n has a potentia l draw- back in that a c l i e nt must understan d how S t r a t e g i e s d i f f e r befor e it can s e l e ct t he appropriat e o n e. C l i e n t s m i g h t be e x p o s e d to i m p l e m e n t a t i o n i s - s u e s. T h e r e f o r e you shoul d use the Strateg y patter n o n ly when the variatio n in b e h a v i o r is r e l e v a n t to c l i e n t s . 6. Communication overhead between Strategy and Context. The Strateg y interfac e is s h a r e d by a ll C o n c r e t e S t r a t e g y c l a s s e s whethe r t he algorithm s they i m p l e - ment a re trivia l or c o m p l e x . H e n c e i t 's l i k e ly that s o me ConcreteStrategie s won' t u se a ll t he informatio n p a s s e d to them throug h t h is interface ; s i m p l e C o n c r e t e S t r a t e g i e s may use none of it! That mean s there w i ll be t i m es when t he c o n t e x t c r e a t e s a nd i n i t i a l i z e s p a r a m e t e r s that n e v er g et u s e d. If t h is is an i s s u e , then you'l l need tighte r c o u p l i n g betwee n Strateg y and Context. 7. Increased number of objects. S t r a t e g i e s i n c r e a s e the numbe r of object s in an application . S o m e t i m e s you can r e d u c e t h is o v e r h e a d by implementin g s t r a t e g i e s as s t a t e l e s s o b j e c t s that context s can s h a r e . Any r e s i d u a l state is maintained b y t h e context, which passes i t i n each request t o t h e Strategy ptgS T R A T E G Y 3 1 9 object . S h a r e d strategie s s h o u l d not maintai n state a c r o s s invocations . The F l y w e i g h t ( 1 9 5 ) p a t t e r n d e s c r i b e s t h i s a p p r o a c h in more detail. Implementation C o n s i d e r the followin g implementatio n i s s u e s : 1.Defining t he Strategy a nd Context interfaces. T he S t r a t e g y a nd C o n t e x t i n t e r f a c e s must g i ve a ConcreteStrateg y efficien t a c c e s s to any data it n e e ds from a context , a nd v i ce v e r s a . O ne a p p r o a c h is to h a ve C o n t e x t p a ss data in p a r a m e t e r s to S t r a t e g y operations—i n other w o r d s , take the data to the strategy . T h is k e e ps Strateg y and Contex t decoupled . On the other hand , Contex t migh t pass data the S t r a t e g y d o e s n ' t n e e d . Anothe r techniqu e has a contex t p a ss itself as an argument , and the strateg y r e q u e s t s data from the contex t e x p l i c i t l y . Alternatively , the strateg y can s t o re a referenc e to i ts context , e l i m i n a t i n g t he n e ed to p a ss anythin g at a l l. Eithe r way, the strateg y can reques t e x a c t l y what it n e e d s . But now Contex t must defin e a m o re elaborat e interfac e to its data, whic h c o u p l e s Strateg y and Contex t more c l o s e l y . The needs of the particula r algorith m and its data requirement s w i ll deter- mine the best technique. 2.Strategies as template parameters. In C++ template s can be u s ed to configur e a c l a ss with a strategy . T h is techniqu e is o n ly applicabl e if ( 1) t he Strateg y c an be s e l e c t e d at c o m p i l e - t i m e , a nd ( 2) it d o es n ot h a ve to be c h a n g e d at run-time . In this c a s e, the c l a ss to be configure d ( e . g ., C o n t e x t ) is define d as a templat e c l a ss that has a S t r a t e g y c l a ss as a parameter: template <class AStrategy > class Context { void Operation( ) { theStrategy.DoAlgorithm() ; } // . . . private: A S t r a t e g y t h e S t r a t e g y ; } ; The c l a ss is then configure d with a S t r a t e g y c l a ss when it's instantiated: class MyStrateg y { public: void DoAlgorithm() ; } ; Context<MyStrategy> aContext; With templates , there' s no n e ed to defin e an abstrac t c l a ss that define s the interfac e to the S t r a t e g y . Usin g S t r a t e g y as a templat e paramete r a l so lets you b i nd a S t r a t e g y to its C o n t e x t s t a t i c a l l y , whic h can i n c r e a s e efficiency. ptg320 BEHAVIORAL PATTERNS CHAPTERS 3. Making Strategy objects optional. The Contex t c l a ss may be simplifie d if it's meaningfu l not to have a Strateg y object . Contex t c h e c k s to see if it has a Strateg y objec t befor e a c c e s s i n g it. If there is o n e, then Contex t u s es it normally . If there isn't a strategy , then Contex t carrie s out d e f a u l t behavior . The benefi t of this approac h is t h at c l i e n t s don't have to deal with Strateg y objects at all unless they don't like the default behavior. S a m p l e C o d e W e ' ll g i ve the h i g h - l e v e l c o de for the Motivatio n e x a m p l e , whic h is b a s ed on the implementatio n of Compositio n and Composito r c l a s s e s in Interview s [LCI+92]. The C o m p o s i t i o n c l a ss maintain s a c o l l e c t i o n of C o m p o n e n t instances , whic h r e p r e s e n t t e xt a nd g r a p h i c a l e l e m e n t s in a document . A c o m p o s i t i o n a r r a n g e s componen t object s into l i n es using an instanc e of a C o m p o s i t o r s u b c l a s s , whic h e n c a p s u l a t e s a l i n e b r e a k i n g s t r a t e g y . E a ch c o m p o n e n t h as an a s s o c i a t e d natura l s i z e, stretchability , and shrinkability . The stretchabilit y define s how much the componen t can g r ow beyon d its n a t u r a l s i z e; shrinkabilit y is how much it can shrink . The compositio n passe s these value s to a compositor , whic h uses them to determine the best location for linebreaks. c l a s s C o m p o s i t i o n { p u b l i c : Composition(Compositor*) ; void Repair(); private: Compositor * _compositor; Component * _components ;// t he l i st of c o m p o n e n t s int _componentCount ; // the number of component s int _lineWidth ; // the Composition' s line width i n t* _lineBreaks ; // the position of l i n e b r e a k s // in component s int _lineCount; // the number o f lines W h en a n ew layou t is r e q u i r e d , t he c o m p o s i t i o n a s ks i ts c o m p o s i t o r to d e t e r m i n e wher e to p l a ce l i n e b r e a k s . The compositio n p a s s e s the composito r three array s that defin e natura l s i z e s, s t r e t c h a b i l i t i e s , a nd s h r i n k a b i l i t i e s of t he c o m p o n e n t s . It also p a s s e s the numbe r of components , how wide the line is, and an array that the c o m p o s i t o r fills with the positio n of e a ch linebreak . The c o m p o s i t o r return s the number of calculated breaks. T h e Compositor interface lets the composition p a s s the compositor a l l t h e infor - mation it needs. This is an example of \"taking the data to the strategy\": ptgS T R A T E G Y 321 class Composito r { public: virtual int Compose( Coord natural[] , Coord stretch[] , Coord shrinkf] , int componentCount , int lineWidth , int breaks[] ) = 0; protected: Compositor() ; } ; Note that C o m p o s i t o r is an abstrac t c l a s s. Concret e s u b c l a s s e s defin e s p e c i f i c linebreakin g s t r a t e g i e s . The c o m p o s i t i o n c a l ls its c o m p o s i t o r in its R e p a i r operation . R e p a i r first i n i t i a l - i z es array s with the natura l s i z e, stretchability , and shrinkabilit y of e a ch c o m p o - nent (the detail s of whic h we omit for brevity) . T h en it c a l ls on the composito r to obtai n the l i n e b r e a k s and finall y lays out the component s accordin g to the break s (also omitted): void Composition::Repai r () { Coord* natural; Coord* stretchability ; Coord* shrinkability ; int componentCount ; int* breaks; // prepare the arrays with the desired componen t sizes // . . . // determin e where the breaks are: int breakCount ; breakCoun t - _compositor->Compose( natural, stretchability , shrinkability , componentCount , _lineWidth , breaks ) ; // lay out component s accordin g to breaks // . . . Now let's l o ok at the C o m p o s i t o r s u b c l a s s e s . S i m p l e C o m p o s i t o r e x a m i n e s components a line at a time to determine where breaks should go: class SimpleComposito r : public Composito r { public: SimpleComposito r () , - virtual int Compose( C o o rd n a t u r a l [ ] , C o o rd stretch[] , C o o rd s h r i n k [ ] , int componentCount, int lineWidth, int breaks[] ptg322 BEHAVIORAL PATTERNS CHAPTER 5 T e X C o m p o s i t o r u s es a more g l o b a l strategy . It e x a m i n e s a paragraph at a t i m e, takin g into accoun t the components ' s i ze and s t r e t c h a b i l i t y . It a l so t r i es to g i ve an even \" c o l o r \" to the paragrap h by minimizin g the whitespac e betwee n c o m p o - nents. class TeXComposito r : public Composito r { public: TeXCompositor(); virtual int Compose( C o o rd natural[] , C o o rd stretch[] , C o o rd shrinkf] , int componentCount, int lineWidth, int breaks[] A r r a y C o m p o s i t o r break s the component s into l i n es at regula r intervals. class ArrayComposito r : public Composito r { public: ArrayCompositor(in t interval); virtual int Compose( C o o rd natural[] , Coord stretchf] , C o o rd shrink[], int componentCount , int lineWidth , int breaks[] ) ; // . . . T h e se c l a s s e s don't use all the informatio n p a s s e d in C o m p o s e . S i m p l e C o m - p o s i t o r i g n o r e s the stretchabilit y of the components , takin g o n ly their nat- ural width s into account . T e X C o m p o s i t o r u s es all the informatio n p a s s e d to it, w h e r e a s A r r a y C o m p o s i t o r i g n o r e s e v e r y t h i n g . To instantiate C o m p o s it ion, you pass it the c o m p o s i t o r you w a nt to u s e : Composition * quick = new Composition(ne w SimpleCompositor) ; Composition * slick - new Composition(ne w TeXCompositor) ; Composition* iconic = new Composition(new ArrayCompositor(100)); C o m p o s i t o r ' s interfac e is carefull y d e s i g n e d to suppor t all layou t a l g o r i t h m s t h at s u b c l a s s e s migh t implement . You don't want to have to chang e this interfac e with every new s u b c l a s s , b e c a u s e that w i ll r e q u i r e changin g existin g s u b c l a s s e s . In g e n e r a l , t he S t r a t e g y a nd C o n t e x t i n t e r f a c e s d e t e r m i n e h ow w e ll t he patter n a c h i e v e s its intent. K n o w n Uses Both ET++ [ W G M 8 8 ] and I n t e r v i e w s u s e strategies to encapsulate different l i n e - breaking algorithms as we've described. ptgS T R A T E G Y 3 2 3 In the RTL S y s t e m for compile r code optimizatio n [ J M L 9 2 ] , strategie s defin e d i f f e r - e nt registe r a l l o c a t i o n s c h e m e s (RegisterAllocator ) a nd instructio n s et s c h e d u l i n g p o l i c i e s ( R I S C s c h e d u l e r , C I S C s c h e d u l e r ) . T h is provide s flexibilit y in targetin g the optimize r for differen t machin e architectures. The ET++SwapsManage r calculatio n e n g i n e f r a m e w o r k compute s price s for dif- feren t financia l instrument s [EG92] . Its key abstraction s are Instrumen t and Y i e l d - Curve . Differen t instrument s are implemente d as s u b c l a s s e s of Instrument . Y i e l d - Curv e calculate s discoun t factors , whic h determin e the presen t value of f u t u r e c a sh flows . B o th of these c l a s s e s delegat e s o me behavio r to Strateg y objects . The f r a m e w o r k provide s a famil y of ConcreteStrateg y c l a s s e s for generatin g c a sh flows , valuin g swaps , and calculatin g discoun t factors . You can creat e new c a l - culatio n e n g i n e s by configurin g Instrumen t and YieldCurv e with the d i f f e r e n t ConcreteStrateg y objects . T h is approac h support s mixin g and matchin g existin g Strateg y implementation s as well as definin g new o n e s . T he B o o c h component s [ B V 9 0 ] u se strategie s as templat e arguments . T he B o o c h c o l l e c t i o n c l a s s e s suppor t three differen t kinds of memor y allocatio n strategies : manage d (allocatio n out of a pool) , controlle d (allocations/deallocation s are pro- tecte d by l o c k s ) , and unmanage d (the norma l memor y allocator) . T h e s e strategie s are p a s s e d as templat e arguments to a collectio n c l a ss when it's instantiated . For e x a m p l e , an UnboundedCollectio n that u s es the unmanage d strateg y is instanti- ated as U n b o u n d e d C o l l e c t i o n < M y I t e m T y p e * , U n m a n a g e d > . RAp p is a s y s t e m for integrate d circui t layou t [ G A 8 9 , AG90] . RAp p must lay out and route wires that c o n n e c t subsystem s on the circuit . Routin g algorithm s in RAp p are define d as s u b c l a s s e s of an abstrac t Route r c l a s s . Route r is a Strateg y c l a s s . Borland' s Objec t Window s [ B o r 9 4 ] u s es strategie s in d i a l o g s boxe s to ensur e that the user enter s v a l id data. For example , number s migh t have to be in a certai n range , and a numeri c entry field s h o u l d accep t o n ly digits . Validatin g that a string is correc t can requir e a table look-up. O b j e c t W i n d o w s u s es Validato r o b j e c t s to encapsulat e validatio n strategies . V a l - idator s are example s of Strateg y objects . Data entry fields delegat e the validatio n strateg y to an optiona l Validato r object . The c l i e n t attache s a validato r to a field if validatio n is r e q u i r e d (an exampl e of an optiona l strategy) . Whe n the dialo g is c l o s e d , the entry fields ask their validator s to validat e the data. The c l a ss librar y provide s validator s for commo n c a s e s , s u ch as a Rang e Validato r for numbers . New c l i e n t - s p e c i f i c validatio n strategie s can be define d e a s i ly by subclassin g the Validator class. Related Patterns Flyweight (195): Strategy objects o f t e n make good f l y w e i g h t s . ptg This page intentionally left blank ptgTEMPLATE M E T H O D 325 T E M P L A T E M E T H O D C l a s s B e h a v i o r a l Intent Defin e the skeleto n of an algorith m in an operation , deferrin g s o me s t e ps to s u b c l a s s e s . T e m p l a t e M e t h o d l e ts s u b c l a s s e s r e d e f i n e c e r t a i n s t e ps of an a l g o r i t h m without changing the algorithm's structure. Motivation Conside r an applicatio n f r a m e w o r k t h at provide s Applicatio n and Documen t c l a s s e s . The Applicatio n c l a ss is r e s p o n s i b l e for o p e n i n g existin g document s store d in an externa l f o r m a t , such as a file. A Documen t objec t represent s the informatio n in a documen t o n ce i t 's r e ad from t he file. Application s built with the f r a m e w o r k can s u b c l a s s Applicatio n and Documen t to suit specifi c needs . For example , a drawin g applicatio n define s Draw Applicatio n and DrawDocument subclasses; a spreadsheet application defines Spreadsheet- Application and SpreadsheetDocument subclasses. The abstrac t Applicatio n c l a ss define s the algorith m for openin g and readin g a document in its OpenDocument operation: void Application::OpenDocumen t ( c o n st char^ if (!CanOpenDocument(name) ) { // cannot handle this document return; }name) { ptg3 2 6 BEHAVIORAL PATTERNS CHAPTER 5 Document * doc = DoCreateDocument(); if ( d o c) { _docs->AddDocument(doc); AboutToOpenDocument(doc) ; doc->Open() ; d o c - > D o R e a d ( ) ; } } OpenDocumen t define s each step for openin g a document . It c h e c k s if the d o c u - ment can be o p e n e d , create s the application-specifi c Documen t o b j e c t , adds it to its set of documents , and reads the Documen t from a file. We c a ll OpenDocumen t a templat e method . A templat e metho d define s an a l g o - rithm in term s of abstrac t operation s that s u b c l a s s e s overrid e to p r o v i d e c o n c r e t e b e h a v i o r . Applicatio n s u b c l a s s e s defin e the s t e ps of the algorith m that c h e ck if the documen t can be o p e n e d (CanOpenDocument ) and that creat e the Documen t (DoCreateDocument) . Documen t c l a s s e s defin e the step t h at reads the documen t (DoRead) . The templat e metho d a l so define s an operatio n that l e ts Applicatio n s u b c l a s s e s know when the documen t is abou t to be o p e n e d (AboutToOpenDocu- ment) , in c a se t h ey c a r e . By definin g s o me of the s t e ps of an algorith m using abstrac t o p e r a t i o n s , the tem- plate metho d fixes their ordering , but it lets Applicatio n and Documen t s u b c l a s s e s vary those steps to suit their needs. A p p l i c a b i l i t y The Templat e Metho d patter n shoul d be u s e d • to implemen t the invarian t parts of an algorith m o n ce and l e a ve it up to subclasse s to implemen t the behavio r that can v a r y . • when commo n behavio r amon g s u b c l a s s e s s h o u l d be factore d and l o c a l i z e d in a commo n c l a ss to a v o id c o de duplication . T h is is a g o od exampl e of \"refactorin g to g e n e r a l i z e \" as d e s c r i b e d by Opdyk e and Johnso n [ O J 9 3 ] . You first identif y the difference s in the e x i s t i n g c o de and then separat e the difference s into n ew o p e r a t i o n s . F i n a l l y , y ou r e p l a c e t he differin g c o de w i th a templat e metho d t h at c a l ls one of t h e se new operations. • to contro l s u b c l a s s e s extensions . You can defin e a templat e metho d that c a l ls \" h o o k \" operation s ( s ee C o n s e q u e n c e s ) at s p e c i f i c p o i n t s , thereb y permittin g extensions only at those points. ptgS t r u r t u r eTEMPLATE M E T H O D 327 P a r t i c i p a n t s • A b s t r a c t C l a s s ( A p p l i c a t i o n ) - d e f i n e s abstrac t primitiv e operation s that c o n c r e t e s u b c l a s s e s defin e to i m p l e m e n t s t e ps of an a l g o r i t h m . - i m p l e m e n t s a templat e m e t h o d d e f i n i n g t he s k e l e t o n of an a l g o r i t h m . T he templat e m e t h o d c a l ls p r i m i t i v e o p e r a t i o n s as w e ll as o p e r a t i o n s d e f i n e d in A b s t r a c t C l a s s or t h o se of o t h er o b j e c t s . • C o n c r e t e C l a s s ( M y A p p l i c a t i o n ) - i m p l e m e n t s t he p r i m i t i v e o p e r a t i o n s to carry o ut s u b c l a s s - s p e c i f i c s t e ps of the algorithm. C o l l a b o r a t i o n s • C o n c r e t e C l a s s r e l i es on A b s t r a c t C l a s s to i m p l e m e n t t he i n v a r i a n t s t e ps of t he a l g o r i t h m . C o n s e q u e n c e s T e m p l a t e m e t h o d s a re a fundamenta l t e c h n i q u e f or c o de r e u s e . T h ey a re p a r t i c - ularly importan t in c l a ss l i b r a r i e s , b e c a u s e they are the m e a n s for factorin g out c o m m o n b e h a v i o r in librar y c l a s s e s . T e m p l a t e m e t h o d s l e ad to an i n v e r t e d c o n t r o l structur e t h a t 's s o m e t i m e s referre d to as \" t he H o l l y w o o d p r i n c i p l e , \" that i s, \" D o n ' t c a ll u s, w e ' ll c a ll you\" [ S w e 8 5 ] . T h is refers to h ow a paren t c l a ss c a l ls t he o p e r a t i o n s of a s u b c l a s s a nd n ot t he o t h e r way around. Template methods call the following kinds of operations: • c o n c r e t e o p e r a t i o n s ( e i t h e r on the ConcreteClass or on client classes); ptg3 28 B E H A V I O R A L PATTERNS CHAPTER 5 • concret e AbstractClas s operation s ( i . e ., operation s that are generall y usefu l to s u b c l a s s e s ) ; • primitiv e operation s ( i . e ., abstrac t operations); • factor y method s ( s ee Factor y Metho d ( 1 0 7 ) ) ; and • h o ok o p e r a t i o n s , w h i c h provid e defaul t behavio r that s u b c l a s s e s can e x t e n d if n e c e s s a r y . A hook operatio n often d o es nothin g by default. It's importan t for templat e method s to specif y w h i c h operation s are h o o k s (may be overridden ) and whic h are abstrac t operation s (must be overridden) . To r e u se an abstrac t c l a ss effectively , s u b c l a s s writer s must understan d w h i c h operation s are d e s i g n e d for overriding. A subclas s can extend a paren t c l a ss operation' s behavio r by overridin g the o p e r - ation and c a l l i n g the paren t operatio n e x p l i c i t l y : void DerivedClass::Operatio n () { ParentClass::Operation() ; // DerivedClas s e x t e n d ed b e h a v i o r } Unfortunately, i t 's easy to forge t to c a ll the i n h e r i t e d operation . We can transfor m s u ch an operatio n i n to a templat e metho d to g i ve the paren t c o n t r o l o v er how s u b c l a s s e s e x t e n d it. The i d ea is to c a ll a hook operatio n from a templat e metho d in the paren t c l a s s . T h en s u b c l a s s e s can then overrid e t h is hook operation: void ParentClass::Operatio n () { // P a r e n t C l a s s b e h a v i or HookOperation(); } HookOperatio n does n o t h i ng in P a r e n t C l a s s : void P a r e n t C l a s s : : H o o k O p e r a t i o n () { } S u b c l a s s e s overrid e H o o k O p e r a t i o n to exten d its behavior: void D e r i v e d C l a s s : : H o o k O p e r a t i o n () { // derived c l a ss e x t e n s i on } Implementation T h r ee implementatio n i s s u e s are wort h n o t i n g : 1. Using C++ access control. In C++, the primitiv e operation s that a templat e metho d c a l ls can be d e c l a r e d protecte d members . T h is ensure s that they are o n l y c a l l e d by the template method. Primitive operations that m u s t be ptgTEMPLATE METHOD 3 2 9 overridde n are d e c l a r e d pure virtual . The templat e metho d i t s e lf s h o u l d not be o v e r r i d d e n ; therefor e y ou c an make t he templat e metho d a nonvirtua l membe r function. 2. Minimizing primitive operations. An importan t g o al in d e s i g n i n g templat e method s is to minimiz e the numbe r of primitiv e operation s that a s u b c l a s s must overrid e to flesh out the algorithm . The more operation s that n e ed overriding , the more tediou s thing s get for c l i e n t s . 3. Naming conventions. You can identif y the operation s that shoul d be overrid- den by addin g a prefix to their names . For e x a m p l e , the MacAp p f r a m e w o r k for Macintos h application s [ A p p 8 9 ] prefixe s templat e metho d name s with \" D o - \" : \"DoCreateDocument\", \"DoRead\", and so forth. S a m p l e C o d e The followin g C++ exampl e show s how a paren t c l a ss can enforc e an invarian t for its s u b c l a s s e s . The exampl e c o m e s from N e X T ' s AppKi t [ A d d 9 4 ] . C o n s i d e r a c l a ss V i ew that support s drawin g on the s c r e e n . V i ew enforce s the invarian t t h at its s u b c l a s s e s can draw into a v i ew o n l y after it b e c o m e s the \" f o c u s , \" whic h r e q u i r e s certai n drawin g state (for e x a m p l e , c o l o r s and f o n t s ) to be set up p r o p e r l y . We can use a D i s p l a y templat e metho d to set up this state. V i ew define s two c o n c r e t e o p e r a t i o n s , S e t F o c u s and R e s e t F o c u s , that set up and c l e an up the drawin g state, r e s p e c t i v e l y . V i e w ' s D o D i s p l a y hook operatio n perform s the ac- tual drawing . D i s p l a y c a l ls S e t F o c u s befor e D o D i s p l a y to s e t up t he drawin g state; Display calls ResetFocus afterwards t o release the drawing state. void View::Displa y () { SetFocus(); DoDisplay() ; ResetFocus(); } To maintai n the invariant , the view' s c l i e n t s alway s c a ll D i s p l a y , and V i ew s u b c l a s s e s a l w a y s o v e r r i d e D o D i s p l a y . D o D i s p l a y does nothing in View: void View::DoDisplay ( ) { } S u b c l a s s e s o v e r r i d e it to add their specific drawing behavior: void MyView::DoDispla y () { // render the view's contents } Known Uses Template methods are so fundamental that they can be f o u n d i n a l m o s t e v e r y ptg3 30 BEHAVIORAL PATTERNS CHAPTERS abstrac t c l a s s. W i r f s - B r o c k et a l. [ W B W W 9 0 , W B J 9 0 ] p r o v i d e a g o od o v e r v i e w a n d discussion of template methods. R e l a t e d P a t t e r n s Factor y M e t h o d s ( 1 0 7) a re often c a l l ed by templat e m e t h o d s . In t he M o t i v a t i o n e x a m p l e , t he factor y m e t h o d D o C r e a t e D o c u m e n t is c a l l ed by t he templat e m e t h o d O p e n D o c u m e n t . S t r a t e g y ( 3 1 5 ) : T e m p l a t e m e t h o d s u se i n h e r i t a n c e to vary part of an a l g o r i t h m . S t r a t e g i e s use delegation to vary the entire algorithm. ptgVISITOR 331 V I S I T O R O b j e c t Behavioral Intent Represen t an operatio n to be performe d on the element s of an objec t structure . V i s - itor lets you defin e a new operatio n withou t changin g the c l a s s e s of the element s on which it operates. Motivation C o n s i d e r a c o m p i l e r that represent s program s as abstrac t synta x trees. It w i ll n e ed to p e r f o r m operation s on abstrac t synta x trees for \" s t a t i c semantic \" analyse s l i ke checkin g that all variable s are defined . It w i ll also need to generat e c o d e. So it migh t defin e operation s for type-checking , c o de optimization , flow analysis , c h e c k i n g for variable s being assigne d value s befor e they'r e u s e d, and so on. M o r e o v e r , we c o u ld use the abstrac t synta x t rees for pretty-printing , progra m restructuring , c o de instrumentation , and computin g variou s metric s of a program. M o st of these operation s w i ll need to treat node s t h at represen t assignment state- ment s differentl y f r om node s t h at represen t variable s or arithmeti c e x p r e s s i o n s . Henc e there w i ll be one c l a ss for assignmen t statements , anothe r for variabl e a c c e s s e s , anothe r f or arithmeti c e x p r e s s i o n s , a nd so o n. T he s et of node c l a s s e s depend s on the languag e b e i ng compiled , of course , but it doesn' t chang e much for a given language. T h is diagra m show s part of the Node c l a ss hierarchy . The proble m here is t h at distributin g all t h e se operation s a c r o s s the variou s node c l a s s e s leads to a syste m that's hard to understand , maintain , and change . It will be confusin g to have type- che ck in g c o de m i x e d with pretty-printin g c o de or flow analysi s c o d e. M o r e o v e r , adding a new operation usually requires recompiling all of these classes. It w o u l d ptg3 3 2 BEHAVIORAL PATTERNS CHAPTER 5 be bette r if e a ch new operatio n c o u ld be adde d separately , and the node c l a s s e s were independen t of the operation s that apply to them. We can have both by packagin g relate d operation s from each c l a ss in a separat e object , c a l l ed a visitor , and passin g it to element s of the abstrac t synta x tree as i t 's traversed. Whe n an e l e m e n t \" a c c e p t s \" the v i s i t o r , it s e n ds a reques t to the visito r that e n c o d e s the element' s c l a s s . It a l so i n c l u d e s the elemen t as an argument . The visito r w i ll then execut e the operatio n for t h at element—th e operatio n t h at used to be in the c l a ss of the element. For example , a compile r t h at didn' t use visitor s migh t type-chec k a procedur e by c a l l i n g the T y p e C h e c k operatio n on its abstrac t synta x t r e e. Each of the node s w o u l d i m p l e m e n t T y p e C h e c k by c a l l i n g T y p e C h e c k on i ts c o m p o n e n t s ( s ee t he p r e c e d i n g c l a ss diagram) . If the compile r t y p e - c h e c k e d a procedur e using v i s i t o r s , then it woul d creat e a T y p e C h e c k i n g V i s i t o r objec t and c a ll the A c c e p t operatio n on the abstrac t synta x tree with that objec t as an argument . Each of the node s woul d implemen t A c c e p t by c a l l i n g back on the visitor : an assignmen t node c a l ls VisitAssignmen t operatio n on the visitor , while a variabl e referenc e c a l ls V i s i t V a r i a b l e R e f e r e n c e . Wha t u s ed to be t he T y p e C h e c k o p e r a t i o n in c l a ss A s s i g n - mentNod e is now the VisitAssignmen t operatio n on T y p e C h e c k i n g V i s i t o r . To make visitor s work f or more than just t y p e - c h e c k i n g , we n e ed an abstrac t paren t c l a ss NodeVisito r for all v i s i t o r s of an abstrac t synta x tree. N o d e V i s i t o r must declar e an operatio n for e a ch node c l a s s. An applicatio n that needs to comput e progra m metric s w i ll defin e new s u b c l a s s e s of NodeVisito r and will no l o n g e r n e ed to add application-specifi c c o de to the node c l a s s e s . The V i s i t o r patter n encapsulate s the operation s for each compilatio n phase in a V i s i t o r a s s o c i a t e d with that phase. ptgVISITOR 333 With the Visito r pattern , you defin e two c l a ss h i e r a r c h i e s : one for the element s b e i ng operate d on (the Node hierarchy ) and one for the v i s i t o r s that defin e op- eration s on the e l e m e n t s (the Node V i s i t o r hierarchy) . You creat e a new operatio n by addin g a new s u b c l a s s to the v i s i t o r c l a ss h i e r a r c h y . As long as the gramma r that the c o m p i l e r accept s doesn' t chang e (that i s, we don't have to add new Node s u b c l a s s e s ) , we can add new functionalit y s i m p l y by definin g new Node V i s i t o r s u b c l a s s e s . Applicability Use the V i s i t o r patter n when • an o b j e c t structur e contain s many c l a s s e s of o b j e c t s with differin g interfaces , and you want to perfor m operation s on these o b j e c t s t h at depen d on their c o n c r e t e c l a s s e s . • many distinc t and unrelate d operation s n e ed to be performe d on object s in an o b j e c t structure , and you want to a v o id \" p o l l u t i n g \" their c l a s s e s with t h e se operations . V i s i t o r l e ts you keep r e l a t e d operation s togethe r by definin g them in o ne c l a s s. Whe n t he o b j e c t structur e is s h a r e d by many a pp li ca ti on s , u se V i s i t o r to put operation s in just those application s that n e ed them. • the c l a s s e s definin g the o b j e c t structur e rarely c h a n g e , but you often want to defin e new operation s o v er the structure . Changin g the o b j e c t structur e c l a s s e s r e q u i r e s redefinin g t he interfac e to a ll v i s i t o r s , whic h is potentiall y c o s t l y . If the o b j e c t structur e c l a s s e s c h a n g e often , then it's probabl y bette r to define the operations in those classes. ptg3 3 4 BEHAVIORAL PATTERNS S t r u c t u r eCHAPTER 5 P a r t i c i p a n t s • Visito r (NodeVisitor) - declare s a V i s it operatio n for each c l a ss of ConcreteElemen t in the o b j e c t structure . The operation' s name and signatur e identifie s the c l a ss t h at s e n ds the V i s it reques t to the v i s i t o r . That lets the visito r determin e the c o n c r e t e c l a ss of the elemen t being visited . Then the visito r can a c c e s s the e l e m e n t directl y throug h its particula r interface. • Concret e Visito r (TypeCheckingVisitor) - implement s each operatio n declare d by V i s i t o r . Each operatio n implement s a f r a g m e n t of the algorith m define d for the correspondin g c l a ss of o b j e c t in the structure . ConcreteVisito r provide s the contex t for the algorith m and store s its l o c al state. T h is state o f t en accumulate s result s durin g the traversal of the structure. • Element (Node) - defines an Accept operation that takes a visitor as an argument. ptgVISITOR 335 • C o n c r e t e E l e m e n t (AssignmentNode,VariableRefNode) - implement s an Accep t operatio n that takes a v i s i t o r as an argument. • O b j e c t S t r u c t u r e (Program) - can enumerat e its e l e m e n t s . - may provid e a h i g h - l e v e l interfac e to a l l ow the v i s i t o r to v i s it its e l e m e n t s . - may eithe r be a composit e ( s ee Composit e ( 1 6 3 ) ) or a c o l l e c t i o n such as a l i s t or a set. C o l l a b o r a t i o n s • A c l i e n t that u s es the Visito r patter n must creat e a C o n c r e t e V i s i t o r objec t and then travers e the o b j e c t structure , visitin g each e l e m e n t with the v i s i t o r . • Whe n an elemen t is v i s i t e d , it c a l ls the Visito r operatio n that c o r r e s p o n d s to its c l a s s. The e l e m e n t s u p p l i e s i t s e lf as an argumen t to this operatio n to let the v i s i t o r a c c e s s i ts s t a t e, if n e c e s s a r y . The followin g interactio n diagra m illustrate s the collaboration s betwee n an o b j e c t structure, a visitor, and two elements: C o n s e q u e n c e s S o me of the benefit s and l i a b i l i t i e s of the Visito r patter n are as follows: 1. Visitor makes adding new operations easy. Visitor s make it e a sy to add operation s that depen d on the component s of comple x objects . You can defin e a new operatio n over an objec t structur e simpl y by addin g a new v i s i t o r . In contrast , if you s p r e a d functionalit y o v er many c l a s s e s , then you must chang e each c l a ss to defin e a new operation. 2. A visitor gathers related operations and separates unrelated ones. Relate d behav- i or i s n 't s p r e a d o v er t he c l a s s e s definin g t he o b j e c t s t r u c t u r e ; i t 's l o c a l i z e d in a visitor. Unrelated sets o f behavior a r e partitioned i n their o w n v i s i t o r ptg3 36 BEHAVIORAL PATTERNS CHAPTER 5 s u b c l a s s e s . That s i m p l i f i e s both the c l a s s e s definin g the e l e m e n t s and the al- gorithm s define d in the v i s i t o r s . Any algorithm-specifi c data structure s can be hidde n in the v i s i t o r . 3. Adding n ew ConcreteElement classes is hard. T he V i s i t o r patter n m a k e s it hard to add new s u b c l a s s e s of Element . E a ch new ConcreteElemen t g i v es r i se to a new abstrac t operatio n on V i s i t o r and a correspondin g implementatio n in e v e ry C o n c r e t e V i s i t o r c l a s s. S o m e t i m e s a defaul t implementatio n can be provide d in V i s i t o r that can be inherite d by most of the C o n c r e t e V i s i t o r s , but this is the e x c e p t i o n rathe r than the r u l e . So t he k ey consideratio n in applyin g t he V i s i t o r patter n is whethe r y ou a re mostl y l i k e ly to chang e the algorith m a p p l i e d o v er an o b j e c t structur e or the c l a s s e s of o b j e c t s that make up the structure . The V i s i t o r c l a ss hierarch y can be difficul t to maintai n when new C o n c r e t e E l e m e n t c l a s s e s are adde d frequently . In such c a s e s , it's probabl y e a s i e r just to defin e operation s on the c l a s s e s that make up the structure . If the Elemen t c l a ss hierarch y is s t a b l e , but you are continuall y addin g operation s or changin g a l g o r i t h m s , then the V i s i t o r patter n w i ll help you manag e the c h a n g e s . 4.Visiting across class hierarchies. An iterato r ( s ee Iterato r ( 2 5 7 ) ) can v i s it the object s in a structur e as it traverse s them by c a l l i n g their operations . But an iterato r can't work a c r o s s o b j e c t structure s with differen t t y p es of e l e m e n t s . For e x a m p l e , the Iterato r interfac e define d on page 263 can a c c e s s o n ly o b j e c t s of type I t e m : template <class Item> class Iterator { // . . . I t em C u r r e n t l t e m ( ) c o n s t ; } ; T h is i m p l i e s that all element s the iterato r can v i s it have a commo n paren t c l a ss I t e m . Visito r d o es not have this r e s t r i c t i o n . It can v i s it o b j e c t s t h at don't have a commo n paren t c l a s s. You can add any type of o b j e c t to a Visito r interface . F or e x a m p l e , i n class Visitor { public: // . . . void VisitMyType(MyType*) ; void VisitYourType(YourType*); } ; M y T y p e and Y o u r T y p e do not have to be r e l a t e d throug h inheritanc e at a l l . 5. Accumulating state. V i s i t o r s c an accumulat e state as they v i s it e a ch e l e m e n t in the o b j e c t structure . Withou t a v i s i t o r , t h is state woul d be p a s s e d as extra argument s to the operation s that perfor m the traversal , or they migh t appea r a s global variables. ptgVISITOR 3 3 7 6.Breaking encapsulation. Visitor' s approac h assume s t h at the ConcreteElemen t interfac e is p o w e r f u l enoug h to let visitor s do their job. As a result , the p a t t e r n o f t en force s you to provid e publi c operation s that a c c e s s an element' s interna l state, which may compromise i t s encapsulation. Implementation Each objec t structur e will have an associate d Visito r c l a s s. T h is abstrac t visito r c l a ss declare s a VisitConcreteElemen t operatio n for each c l a ss of ConcreteEle- ment definin g the objec t structure . Each V i s it operatio n on the Visito r declare s its argumen t to be a particula r ConcreteElement , allowin g the Visito r to a c c e s s the i n t e r f a c e of the ConcreteElemen t d i r e c t l y . Concret e Visito r c l a s s e s overrid e each V i s it operatio n to implemen t visitor-specifi c behavio r for the correspondin g ConcreteElement class. The Visitor class would be declared like this in C + + : class Visitor { public: virtual void VisitElementA(ElementA*) ; virtual void VisitElementB(ElementB*); // and so on for other concrete elements protected: Visitor() ; } ; Each c l a ss of ConcreteElemen t implement s an A c c e p t operatio n t h at c a l ls the matchin g V i s i t . . . operatio n on the visito r for t h at ConcreteElement . Thus the operatio n t h at ends up gettin g c a l l ed depend s on both the c l a ss of the elemen t and the class of the visitor. 1 0 The concrete elements are declared a s class Element { public: virtual ~Element() ; virtual void Accept(Visitors ) = 0; protected: Element() ; } ; 10 We could use f u n c t i o n overloadin g to give these operation s the same simpl e name , like V i s i t , s i n ce the operation s are alread y differentiate d by the paramete r they'r e passed . There are p r os and cons to such overloading . On the one hand , it reinforce s the f a ct t h at each operatio n involve s the same analysis , albei t on a d i f f e r e n t argument . On the other h a n d , that migh t make what' s going on at the call s i te l e ss obviou s to someone r e a d i n g the code. It really boils down to whether you believe function overloading is good or not. ptg3 3 8 BEHAVIORAL PATTERNS CHAPTER 5 class ElementA : public Element { public: ElementA() ; virtual void Accept(Visitor & v) { v.VisitElementA(this) ; } } ; class Elements : public Element { public: Elements() ; virtual void Accept(Visitors v) { v . V i s i t E l e m e n t B ( t h i s ) ; } } ; A CompositeElement class might implement A c c e p t l i k e this: class CompositeElemen t : public Element { public: virtual void Accept(Visitor^) ; private: List<Element.*> * __children ; } ; void CompositeElement::Accep t (Visitor k v) { ListIterator<Element* > i(_children); for ( i. First (); 1 i . I s D o ne () ; i.NextO ) { i.Currentltem()->Accept(v) ; } v.VisitCompositeElement(this) ; } H e re are two other implementatio n i s s u e s t h at arise when you apply the V i s i t o r pattern: 1. Double dispatch. Effectively , the Visito r patter n l e ts you add operation s to c l a s s e s withou t changin g them . Visito r a c h i e v e s this by using a techniqu e c a l l ed double-dispatch . It's a well-know n technique . In fact, some program- ming language s suppor t it directl y ( C L O S , for example) . Language s l i ke C++ and Smalltal k suppor t single-dispatch. In s i n g l e - d i s p a t c h l a n g u a g e s , two criteri a determin e whic h operatio n w i ll f u l f i l l a request : the name of the reques t and the type of r e c e i v e r . For ex- a m p l e , the operatio n t h at a GenerateCod e r e q u e s t w i ll c a ll depend s on the type of node objec t you ask. In C++, c a l l i n g G e n e r a t e C o d e on an instanc e of V a r i a b l e R e f N o de w i ll c a ll V a r i a b l e R e f N o d e : : G e n e r a t e C o d e ( w h i c h generate s c o de for a variabl e reference) . C a l l i n g G e n e r a t e C o d e on an A s s i g n m e n t N o d e w i ll c a ll A s s i g n m e n t N o d e : : G e n e r a t e C o d e (whic h w i ll generat e c o de for an assignment) . The operatio n that g e ts e x e c u t e d d e p e n d s both on t he k i nd of r e q u e s t a nd t he type of t he r e c e i v e r . \" D o u b l e - d i s p a t c h \" simpl y mean s the operatio n that g e ts execute d depend s on the kind o f request a n d t h e types o f two receivers. Accept i s a d o u b l e - dispatch operation. Its meaning depends o n t w o types: the Visitor's and the ptgVISITOR 3 3 9 Element's . D o u b l e - d i s p a t c h i n g l e ts visitor s r e q u e s t differen t operation s on e a ch c l a ss of e l e m e n t . 1 1 T h is is t he k ey to t he V i s i t o r pattern : T he operatio n that g e ts e x e c u t e d d e - pend s on both the type of V i s i t o r and the type of Elemen t it v i s i t s . Instea d of bindin g operation s staticall y into the Elemen t interface , you can c o n s o l i d a t e the operation s in a V i s i t o r and use A c c e p t to do the bindin g at run-time . Ex- tendin g the Elemen t interfac e amount s to definin g one new V i s i t o r s u b c l a s s rathe r than many new Elemen t s u b c l a s s e s . 2. Who is responsible for traversing the object structure? A visito r must v i s it e a ch e l e m e n t of t he o b j e c t structure . T he questio n i s, h ow d o es it g et there ? We c an p ut r e s p o n s i b i l i t y f or t r a v e r s a l in a ny of three p l a c e s : in t he o b j e c t s t r u c t u r e , in the v i s i t o r , or in a separat e iterato r o b j e c t ( s ee Iterato r ( 2 5 7 ) ) . Often the o b j e c t structur e is r e s p o n s i b l e for iteration . A c o l l e c t i o n w i ll s i m p l y iterat e o v er i ts e l e m e n t s , c a l l i n g t he A c c e p t operatio n on e a c h. A c o m p o s i t e w i ll c o m m o n l y travers e i t s e lf by havin g e a ch A c c e p t operatio n travers e t he e l e m e n t ' s c h i l d r e n a nd c a ll A c c e p t on e a ch of them r e c u r s i v e l y . Anothe r solutio n is to use an iterato r to v i s it the e l e m e n t s . In C++, you c o u ld use e i t h e r an interna l or externa l iterator , dependin g on what is a v a i l a b l e and what is m o st efficient . In S m a l l t a l k , you usuall y use an interna l iterato r using d o: and a b l o c k . S i n ce interna l iterator s are implemente d by the o b j e c t structure , using an interna l iterato r is a lot l i ke makin g the o b j e c t structur e r e s p o n s i b l e for iteration . The main differenc e is that an interna l iterato r w i ll not c a u se double-dispatching—i t w i ll c a ll an operatio n on the visitor with an element as an argumen t as o p p o s e d to c a l l i n g an o p e r a t i o n on the element with the visitor as an argument . But it's e a sy to use the V i s i t o r patter n with an interna l iterato r if the operatio n on the visito r s i m p l y c a l ls the operatio n on the e l e m e n t withou t r e c u r s i n g . You c o u ld e v en put the traversa l algorith m in the v i s i t o r , althoug h y o u ' l l end up duplicatin g the traversa l c o de in e a ch C o n c r e t e V i s i t o r for e a ch aggregat e C o n c r e t e E l e m e n t . The main reaso n to put the traversa l strateg y in the v i s i t o r is to implemen t a particularl y c o m p l e x traversal , one that d e p e n d s on the r e s u l t s of t he operation s on t he o b j e c t structure . W e ' ll g i ve an exampl e of such a case in the Sample Code. S a m p l e Code B e c a u s e v i s i t o r s are usuall y a s s o c i a t e d with c o m p o s i t e s , w e ' ll use the E q u i p m e n t c l a s s e s define d in t he S a m p l e C o de of C o m p o s i t e ( 1 6 3) to illustrat e t he V i s i t o r pattern . We w i ll use V i s i t o r to defin e operation s for computin g the inventor y of material s and the total c o st for a p i e ce of equipment . The E q u i p m e n t c l a s s e s are 11 If we can have double-dispatch, then why not triple or quadruple, or any o t h er number ? Actually , d o u b l e - dispatc h is just a s p e c i a l c a se of multipl e dispatch , in whic h the operatio n is c h o s e n b a s ed on any numbe r of t y p e s . ( C L O S actuall y support s multipl e dispatch. ) Language s that suppor t d o u b l e - or multipl e dispatc h l e s s e n the need for the Visitor pattern. ptg340 BEHAVIORAL PATTERNS CHAPTER 5 so s i m p l e t h at u s i ng Visito r i s n 't reall y n e c e s s a r y , b ut they m a ke it e a sy to s ee what' s involve d in i m p l e m e n t i n g the pattern. H e re a g a in is the E q u i p m e n t class from C o m p o s i t e (163) . W e ' v e a u g m e n t e d it with an A c c e p t o p e r a t i o n to let it work with a v i s i t o r . class Equipmen t { public: virtual ~Equipment(); const char* Name() { return _name; } virtual Watt Power(); virtual Currency NetPrice() ; virtual Currency DiscountPrice(); virtual void Accept(EquipmentVisitork) ; protected: Equipment(cons t char*); private: const char* _name; } ; T he E q u i p m e n t o p e r a t i o n s r e t u r n t he a t t r i b u t e s of a p i e ce of e q u i p m e n t , s u ch as i ts p o w e r c o n s u m p t i o n a nd cost. S u b c l a s s e s r e d e f i n e t h e se o p e r a t i o n s a p p r o p r i - ately for specifi c types of e q u i p m e n t (e.g., a c h a s s i s , d r i v e s , and p l a n a r b o a r d s ) . T he a b s t r a c t class f or a ll visitor s of e q u i p m e n t h as a virtua l functio n f or e a ch s u b c l a s s of e q u i p m e n t , as s h o w n next. A ll of t he virtua l f u n c t i o n s do n o t h i n g by default. class EquipmentVisito r { public: virtual ~EquipmentVisitor(); virtual void VisitFloppyDisk(FloppyDisk*) ; virtual void VisitCard(Card*) ; virtual void VisitChassis(Chassis*) ; virtual void VisitBus(Bus*); // and so on for other concrete subclasse s of Equipmen t protected: tquipmentvisitor() ; } ; E q u i p m e n t s u b c l a s s e s defin e A c c e p t in basicall y the s a me way: It calls the E q u i p m e n t V i s i t o r o p e r a t i o n that c o r r e s p o n d s to the class that r e c e i v e d the A c c e p t r e q u e s t , like t h i s : void FloppyDisk::Accep t (EquipmentVisitor k visitor) { visitor.VisitFloppyDisk(this); } ptgVISITOR 3 4 1 Equipmen t that c o n t a i n s other equipmen t (in particular , s u b c l a s s e s of Com- p o s i t e E q u i p m e n t in the Composit e pattern ) implement s A c c e p t by iteratin g over its c h i l d r e n and c a l l i n g A c c e p t on e a ch of them . T h en it c a l ls the V i s i t operatio n as usual . For e x a m p l e , C h a s s i s : : A c c e p t c o u ld travers e all the parts i n t h e chassis as follows: void Chassis::Accep t ( E q u i p m e n t V i s i t o r & visitor) { for ( ListIterator<Equipment* > i(_parts) ; ! i . I s D o n e ( ) ; i.Next() ) { i.Currentltem()->Accept(visitor) ; } v i s i t o r . V i s i t C h a s s i s ( t h i s ) ; } S u b c l a s s e s of E q u i p m e n t V i s i t o r defin e particula r algorithm s o v er the equip- m e nt s t r u c t u r e . T he Pr i c ingV i s i t or c o m p u t e s t he c o st of t he e q u i p m e n t s t r u c - ture. It compute s t he n et price of a ll simpl e equipmen t ( e . g ., f l o p p i e s ) a nd t he d i s c o u n t p r i c e of all composite equipment (e.g., chassis and b u s e s ) . c l a ss P r i c i n g V i s i t o r : p u b l ic E q u i p m e n t V i s i t o r { public: PricingVisitor(); C u r r e n c y & GetTotalPrice(); virtual void VisitFloppyDisk(FloppyDisk*) ; v i r t u al v o id V i s i t C a r d ( C a r d * ) ; virtual void VisitChassis(Chassis*) ; virtual void VisitBus(Bus*) ; // . . . private: Currency _total; } ; void PricingVisitor::VisitFloppyDis k ( F l o p p y D i s k * e) { _total += e->NetPrice() ; } void PricingVisitor::VisitChassi s ( C h a s s i s * e) { _total +- e->DiscountPrice() ; } P r i c i n g V i s i t o r w i ll comput e the total c o st of all n o d e s in the equipmen t structure . Note that P r i c i n g V i s i t o r c h o o s e s the appropriat e p r i c i n g polic y for a c l a ss of equipmen t by d i s p a t c h i n g to the c o r r e s p o n d i n g membe r function . What' s m o r e , we can c h a n g e the p r i c i n g p o l i c y of an equipmen t structur e just by c h a n g i n g the PricingVisitor class. ptg342 BEHAVIORAL PATTERNS CHAPTERS We c an d e f i n e a v i s i t o r f or c o m p u t i n g i n v e n t o r y l i ke t h i s : class I n v e n t o r y - V i s i t o r : public EquipmentVisito r { public: InventoryVisitor(); I n v e n t o r y ^ Getlnventory(); virtual void VisitFloppyDisk(FloppyDisk*) ; virtual void VisitCard(Card*) ; virtual void VisitChassis(Chassis*) ; virtual void VisitBus(Bus*) ; // . . . private: I n v e n t o ry _inventory ; } ; T he I n v e n t o r y V i s i t o r a c c u m u l a t e s t he total s f or e a ch t y pe of e q u i p m e n t in t he o b j e c t s t r u c t u r e . I n v e n t o r y V i s i t o r u s es an Inventor y c l a ss t h at d e f i n e s an i n t e r f a c e f or a d d i n g e q u i p m e n t ( w h i c h we w o n ' t b o t h e r d e f i n i n g h e r e ) . void InventoryVisitor::VisitFloppyDis k ( F l o p p y D i s k * e) { _inventory.Accumulate(e) ; } void InventoryVisitor::VisitChassi s ( C h a s s i s* e) { _inventory.Accumulate(e) ; } H e r e ' s h ow we c an u se an I n v e n t o r y V i s i t o r on an e q u i p m e n t s t r u c t u r e : E q u i p m e n t * c o m p o n e n t ; I n v e n t o r y V i s i t o r visitor; component->Accept(visitor) ; cout « \" I n v e n t o r y \" « component->Name( ) « visitor.Getlnventory(); N ow w e ' ll s h ow h ow to i m p l e m e n t t he S m a l l t a l k e x a m p l e f r om t he I n t e r p r e t e r p a t t e r n ( s ee p a ge 2 4 8) with t he V i s i t o r p a t t e r n . L i ke t he p r e v i o u s e x a m p l e , t h is o ne is so s m a l l t h at V i s i t o r p r o b a b l y w o n ' t b uy us m u c h , b ut it p r o v i d e s a g o od i l l u s t r a t i o n of h ow to u se t he p a t t e r n . F u r t h e r , it i l l u s t r a t e s a s i t u a t i o n in w h i c h i t e r a t i o n is t he v i s i t o r ' s r e s p o n s i b i l i t y . T he o b j e c t s t r u c t u r e ( r e g u l a r e x p r e s s i o n s ) is m a de of f o ur c l a s s e s , a nd a ll of t h em h a ve an a c c e p t : m e t h o d t h at t a k es t he v i s i t o r as an a r g u m e n t . In c l a ss S e q u e n c e E x p r e s s i o n , the a c c e p t : method is ptgVISITOR 343 accept: aVisitor aVisitor visitSequence: self In c l a ss R e p e a t E x p r e s s i o n , t he a c c e p t : metho d sends t he v i s i t R e p e a t : m e s s a g e . In c l a ss A l t e r n a t i o n E x p r e s s i o n , it sends the v i s i t A l t e r n a - t i o n : m e s s a g e . In c l a ss L i t e r a l - E x p r e s s i o n , it s e n ds the v i s i t L i t e r a l : m e s s a g e . T he f o ur c l a s s e s a l so must have a c c e s s i n g function s that t he v i s i t o r c an u s e. F or S e q u e n c e E x p r e s s i o n these a re e x p r e s s i o n l a nd e x p r e s s i o n 2 ; f or A l t e r n a t i o n E x p r e s s i o n these a re a l t e r n a t i v e l a nd a l t e r n a t i v e 2 ; f or R e p e a t E x p r e s s i on it is r e p e t it ion; and f or L it e r a l E x p r e s s i on these a re c o m p o n e n t s . T he C o n c r e t e V i s i t o r c l a ss is R E M a t c h i n g V i s i t o r . It is r e s p o n s i b l e f or t he tra- versa l becaus e its traversa l algorith m is irregular . The b i g g e s t irregularit y is t h at a R e p e a t E x p r e s s i o n w i ll repeatedl y travers e its component . The c l a ss R E M a t c h i n g V i s i t o r has an instanc e variabl e i n p u t S t a t e . Its method s are essentiall y the same as the m a t c h : method s of the e x p r e s s i o n c l a s s e s in the In- terprete r patter n e x c e p t they r e p l a c e the argumen t name d i n p u t S t a t e with the e x p r e s s i o n node being matched . However , they s t i ll retur n the set of stream s that the expression would match to identify the current state. visitSequence : sequenceEx p inputStat e := s e q u e n c e E x p e x p r e s s i o n l accept: self. sequenceEx p expression 2 accept: self. visitRepeat : repeatEx p ! finalStat e I finalStat e := inputStat e copy. [ i n p u t S t a t e i s E m p t y ] whileFalse: [inputStat e := repeatEx p repetitio n accept: self. finalStat e addAll: inputState]. \" finalState visitAlternation : alternateExp I finalStat e originalStat e I originalStat e := inputState . finalStat e := alternateEx p alternative l accept: self. inputStat e := originalState . finalStat e addAll: (alternateEx p alternative 2 accept: self). ~ f i n a l S t a t e ptg344 BEHAVIORAL P A T T E R N S CHAPTER 5 visitLiteral : literalEx p I finalStat e tStream I finalStat e := Set n e w. inputState do: [:stream I tStream := stream copy. (tStream nextAvailable : literalEx p component s size ) = literalEx p component s ifTrue: [finalState add: tStream] ] . \" finalState Known Uses The Smalltalk-8 0 compile r has a Visito r c l a ss c a l l ed ProgramNodeEnumerator . It's used primaril y for algorithm s that analyz e s o u r c e c o d e. It isn't u s ed for c o de generatio n or pretty-printing , althoug h it c o u ld be. IRIS Invento r [ S t r 9 3 1 is a toolki t f or d e v e l o p i n g 3 -D graphic s applications . Invento r represent s a three-dimensiona l s c e ne as a hierarch y of n o d e s , e a ch representin g eithe r a geometri c objec t or an attribut e of o n e. Operation s l i ke renderin g a s c e ne or mappin g an input event r e q u i r e traversin g this hierarch y in differen t ways . Invento r d o es this using visitor s c a l l ed \" a c t i o n s . \" T h e re are differen t visitor s for rendering , event handling , searching , filing , and determinin g boundin g b o x e s . To m a ke addin g new node s e a s i e r , Invento r implement s a double-dispatc h s c h e m e for C + +. The schem e r e l i es on run-tim e type informatio n and a two-dimensiona l table in whic h r o ws r e p r e s e n t visitor s and column s represen t node c l a s s e s . The c e l ls store a pointe r to the functio n boun d to the visito r and node c l a s s . Mark Linto n c o i n e d the term \" V i s i t o r \" in the X Consortium' s F r e s c o Applicatio n T o o l k i t specification [LP93]. Related Patterns Composit e ( 1 6 3 ) : Visitor s can be used to apply an operatio n o v er an o b j e c t structur e defined by the Composite pattern. Interpreter (243): Visitor m a y b e applied to do the i n t e r p r e t a t i o n . ptgDISCUSSION O F BEHAVIORAL P A T T E R N S 345 Discussion o f Behavioral Patterns Encapsulatin g Variation Encapsulatin g variatio n is a them e of many behaviora l patterns . When an aspec t of a progra m change s frequently , t h e se pattern s defin e an objec t that encapsulate s that aspect . T h en other parts of the progra m can collaborat e with the objec t wheneve r they depen d on that aspect . The pattern s usuall y defin e an abstrac t c l a ss that d e s c r i b e s the encapsulatin g object , and the patter n derive s its name f r om that object. 12 For example, • a Strateg y objec t encapsulate s an algorith m (Strateg y ( 3 1 5 ) ) , • a State objec t encapsulate s a state-dependen t behavio r (State ( 3 0 5 ) ) , • a Mediato r o b j e c t encapsulate s the protoco l betwee n object s (Mediato r ( 2 7 3 ) ) , and • an Iterato r objec t encapsulate s the way you a c c e s s and travers e the component s of an aggregat e objec t (Iterato r ( 2 5 7 ) ) . T h e se pattern s d e s c r i b e a s p e c t s of a progra m that are l i k e ly to change . M o st pattern s have two k i n ds of o b j e c t s : the new object(s ) that encapsulat e the aspect , and the existin g object(s ) that use the new o n e s. Usuall y the functionalit y of new object s woul d be an integra l p a rt of the e x i s t i n g object s were it not for the pattern . For example , c o de for a Strateg y woul d probabl y be wired into the strategy' s Context , and c o de for a State woul d be implemente d d i r e c t l y in the state' s Context. But not all objec t behaviora l pattern s partitio n functionalit y l i ke this. For example , C h a in of R e s p o n s i b i l i t y ( 2 2 3) deals with an arbitrar y numbe r of object s ( i . e ., a c h a i n ) , all of whic h may alread y exist in the system. C h a in of R e s p o n s i b i l i t y illustrate s anothe r differenc e in behaviora l patterns : Not all defin e static communicatio n relationship s betwee n c l a s s e s . Chain of Responsibilit y prescribe s communicatio n betwee n an open-ende d numbe r of objects . Othe r pattern s i n v o l v e object s that are passe d aroun d as arguments. Object s as A r g u m e n t s S e v e r a l pattern s introduc e an objec t that's always used as an argument . One of t h e se is Visito r ( 3 3 1 ) . A Visito r objec t is the argumen t to a polymorphi c Accep t operatio n on the object s it v i s i t s . The visito r is never c o n s i d e r e d a p a rt of those objects , e v en thoug h the conventiona l alternativ e to the patter n is to distribut e Visito r c o de a c r o s s the objec t structur e c l a s s e s . 12 T h is them e runs throug h other kinds of patterns , too. Abstrac t Factor y ( 8 7 ), Builde r ( 9 7 ), and Proto- type ( 1 1 7) all encapsulat e knowledg e abou t how object s are created . Decorato r ( 1 7 5) encapsulate s responsi- bility that can be adde d to an object . Bridg e ( 1 5 1) separate s an abstractio n from its implementation , lettin g them vary independently. ptg346 BEHAVIORAL PATTERNS CHAPTER 5 Othe r pattern s defin e object s t h at act as magi c token s to be p a s s e d aroun d and i n v o k e d at a later time. Both Comman d ( 2 3 3) and Mement o ( 2 8 3) f a ll into this c a t e g o r y . In Command , the token represent s a request ; in Memento , it represent s the interna l state of an objec t at a particula r time. In both c a s e s , the token can have a comple x interna l representation , but the c l i e n t is neve r awar e of it. But even here there are differences . P o l y m o r p h i s m is importan t in t he C o m m a n d pattern , b e c a u s e e x e c u t i n g t he C o m m a n d objec t is a polymorphi c operation . In contrast , the Mement o interfac e is so narro w that a mement o can only be passe d as a value . So it's l i k e ly to presen t no polymorphi c operation s at all to its c l i e n t s . S h o u l d C o m m u n i c a t i o n be E n c a p s u l a t e d or D i s t r i b u t e d ? Mediato r ( 2 7 3) and Observe r ( 2 9 3) are competin g patterns . The differenc e betwee n them is t h at O b s e r v e r distribute s communicatio n by introducin g O b s e r v e r and S u b j e c t o b j e c t s , wherea s a Mediato r objec t encapsulate s the communicatio n betwee n other objects. In the O b s e r v e r pattern , there is no s i n g le objec t that encapsulate s a constraint. Instead , the O b s e r v e r and the S u b j e c t must cooperat e to maintai n the constraint . Communica- tion pattern s are determine d by the way o b s e r v e r s and subject s are interconnected : a s i n g le subjec t usuall y has many o b s e r v e r s , and sometime s the o b s e r v e r of one subjec t is a subjec t of anothe r o b s e r v e r . The Mediato r patter n centralize s rathe r than distributes . It p l a c e s the responsibilit y for maintainin g a constrain t squarel y in the mediator. W e ' v e f o u nd it e a s i e r to make reusabl e O b s e r v e r s and Subject s than to make reusabl e Mediators . The O b s e r v e r patter n promote s partitionin g and l o o se c o u p l i n g betwee n O b s e r v e r and Subject , and that leads to finer-graine d c l a s s e s that are more apt to be reused. On the other hand , it's e a s i e r to understan d the flow of communicatio n in Mediato r than in O b s e r v e r . O b s e r v e r s a nd s u b j e c t s a re u s u a l l y c o n n e c t e d s h o r t l y after they'r e created , and it's hard to see how they are connecte d later in the program . If you know the O b s e r v e r pattern , then you understan d t h at the way observer s and subject s are connecte d is important , and you a l so know w h at connection s to l o ok for. However , the indirectio n that O b s e r v e r introduce s w i ll s t i ll make a syste m harde r to understand. Observer s in Smalltal k can be parameterize d with m e s s a g e s to a c c e s s the S u b j e c t state, and so they are e v en more reusabl e than they are in C++. T h is make s O b s e r v e r more attractiv e than Mediato r in Smalltalk . Thus a Smalltal k programme r w i ll often use O b s e r v e r wher e a C++ programme r woul d use Mediator. Decouplin g S e n d e r s a nd Receivers Whe n collaboratin g object s r e f er to each other directly , they becom e dependen t on e a c h other, and t h a t can have an a d v e r s e i m p a c t on the layering a n d r e u s a b i l i t y o f a ptgDISCUSSION OF BEHAVIORAL PATTERNS 347 system . Command , O b s e r v e r , Med iat o r , a nd C h a in of R e s p o n s i b i l i t y a d d r e s s h ow y ou can d e c o u p l e s e n d e r s and r e c e i v e r s , but with differen t trade-offs. T he C o m m a n d patter n s u p p o r t s d e c o u p l i n g by u s i ng a C o m m a n d o b j e c t to d e f i n e t he binding between a sender and receiver: The Comman d o b j e c t p r o v i d e s a s i m p l e interfac e for i s s u i n g the r e q u e s t (that is, the Execut e operation) . Definin g t he s e n d e r - r e c e i v e r c o n n e c t i o n in a separat e o b j e c t l e ts the s e n d e r work with differen t r e c e i v e r s . It k e e ps the s e n d e r d e c o u p l e d from the re- c e i v e r s , makin g s e n d e r s e a sy to r e u s e . M o r e o v e r , y ou c an r e u se t he Comman d o b j e c t to parameteriz e a r e c e i v e r with differen t s e n d e r s . The Comman d patter n n o m i n a l l y r e q u i r e s a s u b c l a s s f or e a ch s e n d e r - r e c e i v e r c o n n e c t i o n , althoug h t he patter n d e s c r i b e s implementatio n t e c h n i q u e s that a v o id s u b c l a s s i n g . T he O b s e r v e r patter n d e c o u p l e s s e n d e r s (subjects ) from r e c e i v e r s ( o b s e r v e r s ) by defin- i ng an interfac e f or s i g n a l i n g c h a n g e s in s u b j e c t s . O b s e r v e r d e f i n e s a l o o s e r s e n d e r - r e c e i v e r bindin g than Command , s i n ce a s u b j e c t may have m u l t i p l e o b s e r v e r s , and their number can vary at run-time. The S u b j e c t and O b s e r v e r interface s in the O b s e r v e r patter n are d e s i g n e d for c o m m u - nicatin g c h a n g e s . Therefor e the O b s e r v e r patter n is b e st f or d e c o u p l i n g o b j e c t s w h en there are data d e p e n d e n c i e s betwee n them. T he M e d i a t o r patter n d e c o u p l e s o b j e c t s by h a v i n g t h em refer to e a ch o t h er i n d i r e c t l y through a Mediator object. ptg3 4 8 B E H A V I O R A L P A T T E R N S CHAPTER 5 A Mediato r o b j e c t route s request s betwee n C o l l e a g u e o b j e c t s and centralize s their c o m - munication . C o n s e q u e n t l y , c o l l e a g u e s can o n ly talk to e a ch other throug h the Mediato r i n t e r f a c e . B e c a u s e t h is interfac e is f i x e d , t he M e d i a t o r m i g h t h a ve to i m p l e m e n t i ts own dispatchin g s c h e m e f or adde d flexibility . Request s can be e n c o d e d and argument s p a c k e d in s u ch a way that c o l l e a g u e s can r e q u e s t an o p e n - e n d e d set of operations. The Mediato r patter n can r e d u c e s u b c l a s s i n g in a s y s t e m , b e c a u s e it centralize s c o m - municatio n behavio r in o ne c l a ss instea d of distributin g it amon g s u b c l a s s e s . H o w e v e r , ad hoc dispatchin g s c h e m e s often d e c r e a s e type safety. F i n a l l y , the Chai n of R e s p o n s i b i l i t y patter n d e c o u p l e s the s e n d e r f r om the r e c e i v e r by p a s s i n g the request along a chain of potential receivers: S i n ce t he interfac e betwee n sender s a nd r e c e i v e r s is f i x e d , C h a in of R e s p o n s i b i l i t y may a l so r e q u i r e a c u s t o m dispatchin g s c h e m e . H e n c e it has the same type-safet y drawback s as Mediator . C h a in of Responsibilit y is a g o od way to d e c o u p l e the s e n d e r and the r e c e i v e r if the chain is alread y part of the system' s structure , and one of s e v e r a l o b j e c t s may be in a p o s i t i o n to handl e the request . M o r e o v e r , the patter n offer s a d d e d flexibility in that the chain can be changed or extended easily. ptgDISCUSSION O F BEHAVIORAL P A T T E R N S 349 S u m m a r y With few e x c e p t i o n s , behaviora l d e s i g n pattern s complemen t and reinforc e e a ch o t h e r . A c l a ss in a c h a in of r e s p o n s i b i l i t y , for example , will probabl y includ e at l e a st one ap- plicatio n of Templat e Metho d ( 3 2 5 ) . T he templat e metho d c an u se primitiv e operation s to determin e whethe r the objec t s h o u l d handl e the reques t and to c h o o s e the o b j e c t to forwar d to. The c h a in can use the Comman d patter n to represen t request s as objects . Interprete r ( 2 4 3) can use the State patter n to defin e parsin g contexts . An iterato r can travers e an aggregate , and a v i s i t o r can apply an operatio n to e a ch e l e m e n t in the aggregate. Behaviora l pattern s work well with other patterns , too. For e x a m p l e , a syste m that u s es the Composit e ( 1 6 3) patter n m i g h t use a visito r to perfor m operation s on component s of the c o m p o s i t i o n . It c o u ld use C h a in of Responsibilit y to let component s a c c e s s g l o b a l propertie s throug h their parent . It c o u ld a l so use Decorato r ( 1 7 5) to overrid e t h e se p r o p e r t i e s on parts of t he c o m p o s i t i o n . It c o u ld u se t he O b s e r v e r patter n to t ie o ne objec t structur e to anothe r and the State patter n to let a componen t c h a n g e its behavio r as i ts state c h a n g e s . T he compositio n i t s e lf migh t be cr e at e d using t he approac h in B u i l d e r ( 9 7 ), a nd it m i g h t be treate d as a Prototyp e ( 1 1 7) by s o me other part of t he s y s t e m . W e l l - d e s i g n e d object-oriente d system s are j u st l i ke this—the y have multipl e pattern s e m b e d d e d in them—bu t n ot b e c a u s e t h e ir d e s i g n e r s n e c e s s a r i l y t h o u g h t in t h e se t e r m s . C o m p o s i t i o n at the pattern l e v el rathe r than the c l a ss or objec t l e v e ls l e ts us a c h i e v e the s a m e s y n e r g y w i t h g r e a t e r e a s e . ptg This page intentionally left blank ptgC h a p t e r 6 C o n c l u s i o n It's p o s s i b l e to argue that this book hasn' t accomplishe d much . A f t er a l l, it doesn' t presen t any algorithm s or programmin g technique s that haven' t been used before . It d o e s n ' t g i ve a r i g o r o u s metho d f or d e s i g n i n g s y s t e m s , n or d o es it d e v e l o p a n ew theor y of design—i t just document s existin g d e s i g n s . You c o u ld c o n c l u d e that it make s a reasonabl e tutorial , perhaps , but it certainl y can't o f f er much to an e x p e r i e n c e d object- oriente d d e s i g n e r . We hope you think differently . Catalogin g d e s i g n pattern s is important . It g i v es us standar d n a m e s and definition s for the t e c h n i q u e s we u s e. If we don't study d e s i g n pattern s in software , we won' t be a b le to improv e them , and it'll be harde r to come up with new o n e s . T h is book is o n ly a start. It contain s s o me of the most commo n d e s i g n pattern s t h at exper t object-oriente d designer s u s e, and yet p e o p l e hear and learn abou t them s o l e ly by w o rd of mout h or by s t u d y i n g e x i s t i n g s y s t e m s . E a r ly draft s of t he b o ok p r o m p t e d other p e o p l e to write down the d e s i g n pattern s they u s e, and it shoul d promp t e v en more in its curren t f o r m . We hope this will m a rk the start of a movemen t to documen t t he e x p e r t i s e of softwar e p r a c t i t i o n e r s . T h is chapte r d i s c u s s e s the impac t we think d e s i g n pattern s will ha ve, how they are relate d to other work in d e s i g n , and how you can get i n v o l v e d in findin g and catalogin g patterns. 6 . 1 What to Expect from Design Patterns Here are severa l ways in whic h the d e s i g n pattern s in this book can a f f e c t the way you design object-oriented software, based on our day-to-day experience with them. 3 5 1 ptg3 52 CONCLUSION CHAPTER 6 A C o m m o n Desig n Vocabulary Studie s of exper t programmer s for conventiona l language s have show n that knowledg e a nd e x p e r i e n c e i s n 't o r g a n i z e d s i m p l y aroun d synta x b ut in l a r g e r c o n c e p t u a l s t r u c t u r e s such as algorithms , data structure s a nd idiom s [ A S 8 5 , C o p 9 2 , C u r 8 9 , S S 8 6 ] , a nd plans f or fulfillin g a particula r g o al [ S E 8 4 ] . D e s i g n e r s p r o b a b l y don't t h i nk a b o u t t he n o t a t i o n they'r e using for recordin g the desig n as much as they try to matc h the curren t d e s i g n s i t u a t i o n a g a i n s t p l a n s , a l g o r i t h m s , data s t r u c t u r e s , a nd i d i o m s they have l e a r n e d in the past. Compute r scientist s name and catalo g algorithm s and data structures , but we don't often name other kinds of patterns . D e s i g n pattern s provid e a commo n vocabular y for d e s i g n e r s to use to communicate , document , and explor e d e s i g n alternatives . D e s i g n pattern s make a s y s t e m s e em l e ss comple x by lettin g you talk abou t it at a h i g h e r l e v el of abstractio n than that of a d e s i g n notatio n or programmin g language . D e s i g n pattern s raise the l e v el at whic h you d e s i g n and d i s c u s s d e s i g n with your colleagues. O n ce you'v e absorbe d the d e s i g n pattern s in this book , your d e s i g n vocabular y will a l m o s t c e r t a i n l y c h a n g e . Y ou w i ll s p e ak d i r e c t l y in terms of t he n a m e s of t he d e s i g n patterns . You'l l find yoursel f sayin g thing s l i k e, \" L e t 's use an Observe r h e r e , \" or, \" L e t 's make a S t r a t e g y o ut of t h e se c l a s s e s . \" A Documentatio n and L e a r n i n g Aid Knowin g the d e s i g n pattern s in this book make s it easie r to understan d existin g s y s - t e m s. M o st l a r ge o b j e c t - o r i e n t e d s y s t e m s u se t h e se d e s i g n patterns . P e o p l e l e a r n i n g object-oriente d programmin g often complai n that the system s they'r e workin g with use inheritanc e in convolute d ways and that it's d i f f i c u l t to follow the flow of c o n t r o l . In large p a rt this is becaus e they do not understan d the d e s i g n pattern s in the s y s - t e m. Learnin g these d e s i g n pattern s will help you understan d e x i s t i n g object-oriente d s y s t e m s . T h e se d e s i g n pattern s c an a l so make y ou a bette r d e s i g n e r . T h ey p r o v i d e s o l u t i o n s to commo n problems . If you work with object-oriente d s y s t e m s l o ng e n o u g h , you'l l p r o b a b l y l e a rn t h e se d e s i g n pattern s on your o w n. B ut r e a d i n g t he b o ok w i ll h e lp y ou learn them much faster . Learnin g these pattern s will help a n o v i c e act more l i ke an e x p e r t . M o r e o v e r , describin g a syste m in terms of the d e s i g n pattern s that it uses will make it a lot easie r to understand . Otherwise , peopl e will have to r e v e r s e - e n g i n e e r the d e s i g n to uneart h the pattern s it u s e s. Havin g a commo n vocabular y mean s you don't have to d e s c r i b e the whol e d e s i g n pattern ; you can j u st name it and expec t your reade r to know it. A reade r who doesn' t know the pattern s will have to look them up at first, but that's s t i ll easie r than reverse-engineering. We u se t h e se pattern s in o ur o wn d e s i g n s , a nd we've found them i n v a l u a b l e . Y et we use the p a t t e r n s i n a r g u a b l y n a i v e w a y s . We use t h e m t o pick names f o r classes, t o ptgSECTION 6.1 WHAT TO EXPECT FROM DESIGN PATTERNS 353 think abou t and teach g o od d e s i g n , and to d e s c r i b e d e s i g n s in terms of the s e q u e n c e of d e s i g n pattern s we applie d [ B J 9 4 ] . It's easy to imagin e more s o p h i s t i c a t e d ways of using patterns , such as pattern-base d C A SE tools or hypertex t documents . But pattern s are a big help e v en withou t sophisticate d tools. An Adjunc t to Existin g M e t h o d s Object-oriente d d e s i g n method s are s u p p o s e d to promot e g o od d e s i g n , to teach new d e s i g n e r s how to d e s i g n w e l l, and to standardize the way d e s i g n s are d e v e l o p e d . A d e s i g n metho d typicall y define s a set of notation s (usuall y graphical ) for m o d e l i n g variou s aspect s of a d e s i g n , along with a set of rules that gover n how and when to use e a ch notation . D e s i g n method s usuall y d e s c r i b e p r o b l e m s t h at o c c ur in a d e s i g n , how to r e s o l v e them , and how to evaluat e d e s i g n . But they haven' t been a b le to captur e the experienc e of exper t d e s i g n e r s . We b e l i e v e our d e s i g n pattern s are an importan t p i e ce that's b e en missin g f r om object- oriente d d e s i g n methods . The d e s i g n pattern s show how to use primitiv e technique s such as objects , inheritance , and polymorphism . T h ey s h ow how to parameteriz e a syste m with an algorithm , a behavior , a state, or the kind of o b j e c t s it's s u p p o s e d to c r e a t e . D e s i g n pattern s provid e a way to d e s c r i b e more of the \" w h y \" of a d e s i g n and not just r e c o r d the result s of your d e c i s i o n s . The A p p l i c a b i l i t y , C o n s e q u e n c e s , and Implementatio n s e c t i o n s of the d e s i g n pattern s help g u i de you in the d e c i s i o n s you have to make. D e s i g n pattern s are e s p e c i a l l y usefu l in turnin g an analysi s m o d e l into an implementa- tion model . D e s p i t e many c l a i m s t h at promis e a smoot h transitio n f r om object-oriente d analysi s to d e s i g n , in practic e the transitio n is anythin g but smooth . A flexibl e and reusabl e d e s i g n w i ll contai n o b j e c t s that aren' t in the analysi s model . The program- ming languag e and c l a ss librarie s you use a f f e c t the d e s i g n . Analysi s model s often must be redesigne d to make them r e u s a b l e . Many of the d e s i g n pattern s in the catalo g addres s these i s s u e s , whic h is why we c a ll them design patterns. A full-fledge d desig n metho d r e q u i r e s more kinds of pattern s than j u st d e s i g n patterns . T h e re can also be analysi s patterns , user i n t e r f a c e d e s i g n patterns , or performance- tunin g patterns . But the d e s i g n pattern s are an essentia l part, one that's been m i s s i n g until n o w . A T a r g e t for Refactoring One of the p r o b l e m s in d e v e l o p i n g reusabl e softwar e is that it o f t en has to be reorga- nized or refactore d [ O J 9 0 ] . D e s i g n pattern s help you determin e how to r e o r g a n i z e a d e s i g n , and they can reduc e the amoun t of refactorin g you need to do later. The lifecycl e of object-oriente d softwar e has s e v e r a l p h a s e s . B r i an F o o te identifie s t h e se phases as the prototyping, expansionary, a n d consolidating phases [ F o o 9 2 ] . ptg3 54 CONCLUSION CHAPTER 6 T he p r o t o t y p i n g p h a se is a flurry of a c t i v i t y as t he softwar e is b r o u g h t to l i fe throug h rapid prototypin g and incrementa l c h a n g e s , until it meet s an initia l set of requirement s and r e a c h e s a d o l e s c e n c e . At this point , the softwar e usuall y c o n s i s t s of c l a ss h i e r a r c h i e s that c l o s e l y r e f l e c t e n t i t i e s in t he i n i t i a l p r o b l e m domain . T he main k i nd of r e u se is white-bo x r e u se by inheritance. O n ce t he softwar e h as r e a c h e d a d o l e s c e n c e a nd is p ut i n to s e r v i c e , i ts e v o l u t i o n is governe d by two conflictin g n e e d s : (1) the softwar e must satisf y more r e q u i r e m e n t s , and (2) the softwar e mus t be m o re r e u s a b l e . New requirement s usuall y add new c l a s s e s a nd o p e r a t i o n s a nd perhap s w h o l e c l a ss h i e r a r c h i e s . T he softwar e g o es throug h an expansionar y phase to meet new requirements . T h is can't continu e for l o n g, h o w e v e r . Eventuall y the softwar e w i ll b e c o m e too inflexibl e and arthriti c for f u r t h e r change . The c l a ss h i e r a r c h i e s w i ll no l o n g e r matc h any p r o b l e m domain . Instea d they'l l reflec t many proble m domains , and c l a s s e s w i ll defin e many unrelate d operation s and instanc e v a r i a b l e s . To continu e to e v o l v e , the softwar e must be r e o r g a n i z e d in a p r o c e s s know n as refactor- ing. T h is is the phase in whic h framework s o f t en e m e r g e . Refactorin g i n v o l v e s tearin g apart c l a s s e s into s p e c i a l - and general-purpos e c o m p o n e n t s , movin g operation s up or down the c l a ss h i e r a r c h y , and rationalizin g the interface s of c l a s s e s . T h is c o n s o l i d a t i o n p h a se p r o d u c e s many n ew k i n ds of o b j e c t s , often by d e c o m p o s i n g e x i s t i n g o b j e c t s a nd u s i ng objec t compositio n instea d of inheritance . H e n c e b l a c k - b o x r e u se r e p l a c e s w h i t e - b o x r e u s e . The continua l n e ed to satisf y m o re requirement s along with the n e ed f or m o re r e u se p r o p e l s o b j e c t - o r i e n t e d softwar e throug h r e p e a t e d p h a s e s of e x p a n s i o n and consolidation—expansio n as new requirement s are satisfied , and consolidatio n as the software becomes more general. T h is c y c le is unavoidable . B ut g o od d e s i g n e r s a re awar e of t he c h a n g e s that c an promp t r e f a c t o r i n g s . G o od d e s i g n e r s a l so know c l a ss a nd o b j e c t s t r u c t u r e s that c an h e lp a v o id refactorings—thei r d e s i g n s are robus t in the face of requiremen t c h a n g e s . A thoroug h requirement s analysi s w i ll highligh t those requirement s that are l i k e ly to c h a n g e durin g t he l i fe of t he software , a nd a g o od d e s i g n w i ll be r o b u s t to them. Our d e s i g n pattern s captur e many of the structure s that resul t from refactoring . U s i ng these patterns early in the l i f e o f a design prevents later refactorings. But even if you ptgSECTION 62 A BRIEF HISTORY 355 d o n 't s ee h ow to a p p ly a patter n u n t il after y o u ' v e b u i lt y o ur s y s t e m , t he patter n c an s t i ll s h o w you how to change it. Design patterns thus provide targets for your refactorings. 6 . 2 A Brief History T he catalo g b e g a n as a part of Erich' s P h . D . t h e s is [ G a m 9 1 , G a m 9 2 ] . Roughl y h a lf of t he c u r r e n t p a t t e r n s w e re in h is t h e s i s . By O O P S L A ' 91 it w as officiall y an i n d e p e n d e n t c a t a l o g , and R i c h a r d had j o i n e d E r i ch to work on it. John starte d workin g on it s o on thereafter . By O O P S L A ' 9 2, Ralp h had joine d the g r o u p . We worke d hard to make the c a t a l o g fit for publicatio n at E C O O P ' 9 3, but s o on we r e a l i z e d that a 9 0 - p a g e pape r was not g o i ng to be a c c e p t e d . So we summarize d the catalo g and submitte d the summary , whic h was accepted . We d e c i d e d to t u rn the catalo g into a book shortl y thereafter. Our n a m e s for the pattern s have c h a n g e d a little a l o ng the way. \" W r a p p e r \" b e c a m e \" D e c o r a t o r , \" \" G l u e \" b e c a m e \" F a c a d e , \" \" S o l i t a i r e \" b e c a m e \" S i n g l e t o n , \" a nd \" W a l k e r \" b e c a m e \" V i s i t o r . \" A c o u p l e of pattern s g ot d r o p p e d b e c a u s e they didn' t s e em importan t e n o u g h . B ut o t h e r w i s e t he s et of pattern s in t he c a t a l o g h as change d l i t t le s i n ce t he e nd of 1 9 9 2. T he pattern s t h e m s e l v e s , h o w e v e r , have e v o l v e d tremendously. In fact, n o t i c i n g that somethin g is a patter n is the e a sy part. All f o ur of us are a c t i v e l y workin g on buildin g o b j e c t - o r i e n t e d s y s t e m s , and we'v e found that it's e a sy to s p ot pattern s when you l o ok at e n o u g h s y s t e m s . But finding pattern s is much e a s i e r than describing t h e m . If you build s y s t e m s and then reflec t on what you b u i l d , you w i ll see pattern s in what you do. But it's hard to d e s c r i b e pattern s so that p e o p l e who don't know them w i ll understan d them and r e a l i z e why they are important . Expert s immediatel y r e c o g n i z e d the value of the c a t a l o g in its e a r ly s t a g e s . But the o n ly o n es who c o u ld understan d the pattern s w e re those who had alread y u s ed them. S i n ce o ne of t he main p u r p o s e s of t he book w as to teach object-oriente d d e s i g n to n ew d e s i g n e r s , we k n ew we h ad to i m p r o v e t he c a t a l o g . We expande d t he averag e s i ze of a pattern from l e ss than 2 to m o re than 10 page s by i n c l u d i n g a d e t a i l e d motivating e x a m p l e and s a m p l e c o d e. We a l so starte d examinin g the trade-off s and the variou s ways of implementin g the pattern . T h is made the pattern s e a s i e r to l e a r n . Anothe r importan t chang e o v er the past year has been a greate r emphasi s on the p r o b l e m that a pattern s o l v e s . It's e a s i e s t to see a patter n as a s o l u t i o n , as a techniqu e that can be adapte d and r e u s e d . It's harde r to see when it is appropriate—to characteriz e t he p r o b l e m s it s o l v e s a nd t he c o n t e x t in w h i c h i t 's t he b e st s o l u t i o n . In g e n e r a l , i t 's e a s i e r to see what s o m e o n e is d o i ng than to know why, and the \" w h y \" for a patter n is the proble m it s o l v e s . Knowin g t he purpos e of a patter n is importan t t o o, becaus e it h e l ps us c h o o s e pattern s to a p p l y . It a l so h e l ps us understan d the d e s i g n of existin g s y s t e m s . A patter n autho r must determin e and characteriz e the p r o b l e m that the patter n s o l v e s , e v e n if you have to do it after you've discovered i t s s o l u t i o n . ptg3 5 6 CONCLUSION CHAPTER 6 6 . 3 The Pattern Community We aren' t the o n ly o n es intereste d in writin g book s that catalo g the pattern s expert s use. We are a part of a l a r g e r communit y intereste d in pattern s in g e n e r a l and software- relate d pattern s in particular . Christophe r Alexande r is the a r c h i t e c t who first studie d pattern s in b u i l d i n g s and communitie s and d e v e l o p e d a \"patter n language \" for g e n e r - ating them . His work has i n s p i r e d us time and again . So it's f i t t i n g and worthwhil e to compar e our work to h i s. T h en w e ' ll l o ok at o t h e r s ' work in software-relate d patterns. A l e x a n d e r ' s P a t t e r n L a n g u a g e s T h e re are many ways in whic h our work is like Alexander's . Both are b a s ed on ob- s e r v i n g e x i s t i n g s y s t e m s a nd l o o k i n g f or p a t t e r n s in them . B o th h a ve t e m p l a t e s f or d e s c r i b i n g pattern s (althoug h our template s are quite different) . Both r e ly on natura l l a n g u a g e a nd l o ts of e x a m p l e s to d e s c r i b e pattern s rathe r than forma l l a n g u a g e s , a nd both g i ve rationale s for e a ch pattern. But there are just as many ways in whic h our work s are different: 1. P e o p l e have been makin g building s f or thousand s of years , and there are many c l a s s i c e x a m p l e s to draw upon . We have b e en makin g softwar e system s for a relativel y short t i m e, and few are c o n s i d e r e d c l a s s i c s . 2. A l e x a n d e r g i v es an o r d er in w h i ch h is pattern s s h o u l d be u s e d; we h a ve not. 3. Alexander' s pattern s emphasiz e the problem s they a d d r e s s , wherea s d e s i g n pat- terns d e s c r i b e the s o l u t i o n s in more detail. 4. Alexande r c l a i m s h is pattern s w i ll generat e c o m p l e t e b u i l d i n g s . We do n ot c l a im that our pattern s w i ll generat e complet e programs. Whe n Alexande r c l a i m s you can d e s i g n a house s i m p l y by applyin g his pattern s one after another , he h as g o a ls s i m i l a r to t h o se of o b j e c t - o r i e n t e d d e s i g n m e t h o d o l o g i s t s w ho g i ve step-by-ste p rules for d e s i g n . Alexande r doesn' t deny the n e ed for creativity ; s o me of h is pattern s requir e understandin g t he l i v i ng h a b i t s of t he p e o p l e w ho w i ll u se t he b u i l d i n g , a nd h is b e l i ef in t he \" p o e t r y \" of d e s i g n i m p l i e s a l e v el of e x p e r t i s e beyon d t he patter n languag e i t s e l f . 1 B ut h is d e s c r i p t i o n of h ow pattern s generat e d e s i g n s i m p l i e s that a patter n languag e can make the d e s i g n p r o c e s s deterministi c and repeatable. The Alexandria n point of v i ew has h e l p e d us focus on d e s i g n trade-offs—th e differen t \" f o r c e s \" that help shape a d e s i g n . His influenc e made us work harde r to understan d the a p p l i c a b i l i t y and c o n s e q u e n c e s of our patterns . It a l so kept us from worryin g abou t definin g a forma l representatio n of patterns . Althoug h s u ch a representatio n migh t make automatin g pattern s p o s s i b l e , at this stage it's more importan t to e x p l o r e the s p a c e of design patterns than to formalize it. 1 S e e \"The poetry of the language\" [AIS+ 77]. ptgSECTION 6.3 THE PATTERN COMMUNITY 357 F r om Alexander' s point of v i e w , the pattern s in this book do not f o rm a patter n lan- guage . G i v e n the variet y of softwar e s y s t e m s that p e o p l e build , it's hard to see how we c o u ld provid e a \" c o m p l e t e \" set of patterns , one t h at o f f e r s step-by-ste p instruction s for d e s i g n i n g an application . We can do that for certai n c l a s s e s of applications , such as report-writin g or makin g a forms-entr y system . But our catalo g is just a collectio n of relate d patterns ; we can't preten d it's a patter n language. In fact, we think it's unlikel y that there w i ll ever be a complet e patter n languag e for software . But it's certainl y p o s s i b l e to make one that is more complete . Addition s woul d have to includ e framework s and how to use them [ J o h 9 2 ] , pattern s for user interfac e de- s i gn [ B J 9 4 ] , analysi s pattern s [ C o a 9 2 1 , and all the other aspect s of developin g software . D e s i g n pattern s are just a part of a large r patter n languag e for software. P a t t e r n s in Software Our first c o l l e c t i v e e x p e r i e n c e in the study of softwar e architectur e was at an O O P S L A ' 91 worksho p led by Bruc e Anderson . The worksho p was dedicate d to de- velopin g a handboo k for softwar e architects . (Judgin g from this b o o k , we suspec t \"architectur e e n c y c l o p e d i a \" w i ll be a more appropriat e name than \"architectur e hand- b o o k . \" ) That first worksho p has led to a s e r i es of m e e t i n g s , the most recen t of whic h being the first conferenc e on Patter n Language s of Program s h e ld in Augus t 1 9 9 4 . T h is has create d a communit y of p e o p l e intereste d in documentin g softwar e expertise. Of course , other s have had this goal as w e l l. Donal d Knuth' s The Art of Computer Pro- gramming [ K n u 7 3 ] was one of the first attempt s to catalo g softwar e knowledge , thoug h he focuse d on describin g algorithms . Even so, the task prove d too great to finish . The Graphics Gems s e r i es [ G l a 9 0 , A r v 9 1 , K i r 9 2 ] is anothe r catalo g of desig n knowledge , thoug h it too tends to focus on algorithms . The Domai n S p e c i f i c Softwar e Architectur e progra m sponsore d by the U . S. Departmen t of Defens e [ G M 9 2 ] concentrate s on gather- ing architectura l information . The knowledge-base d softwar e engineerin g communit y tries to represen t software-relate d knowledg e in general . T h e r e are many other group s with goals at l e a st a little l i ke ours. Jame s C o p l i e n ' s Advanced C++: Programming Styles and Idioms [ C o p 9 2 ] has influence d us, too. The pattern s in his book tend to be more C++-specifi c than our d e s i g n patterns, and his book contain s lots of l o w e r - l e v e l pattern s as w e l l. But there is s o me overlap , as we point out in our patterns . Jim has b e en activ e in the patter n community . H e 's currentl y workin g on pattern s that d e s c r i b e p e o p l e ' s r o l es in softwar e developmen t organizations. T h e re are a lot of other p l a c e s in whic h to find description s of patterns . Kent B e ck was one of the first peopl e in the s o f t w a r e communit y to advocat e Christophe r Alexander' s work . In 1 9 93 he starte d writin g a colum n in The Smalltalk Report on Smalltal k patterns . Peter Coad has a l so been c o l l e c t i n g pattern s for some time. His pape r on pattern s s e e m s to us to contai n mostl y analysi s pattern s [ C o a 9 2 ] ; we haven' t s e en his lates t patterns , though we know he is still working on them. We've heard of several books on patterns ptg3 58 CONCLUSION CHAPTER 6 that are in the works , but we haven' t s e en any of them , e i t h e r . All we can do is let you know they'r e c o m i n g . One of these b o o k s w i ll be from the Patter n Language s of Programs c o n f e r e n c e . 6 . 4 An Invitation Wha t can you do if you are intereste d in patterns ? F i r s t, use them and l o ok for other pattern s that fit the way you d e s i g n . A lot of b o o k s and a r t i c l e s abou t pattern s w i ll be c o m i n g o ut in t he n e xt f ew y e a r s , so t h e re w i ll be p l e n t y of s o u r c e s f or n ew p a t t e r n s . D e v e l o p your vocabular y of patterns, and use it. Use it when you talk with other p e o p l e abou t your d e s i g n s . Use it when you think and write abou t them. S e c o n d , be a critica l c o n s u m e r . T he d e s i g n patter n catalo g is t he r e s u l t of hard work , n ot just ours but t h at of dozen s of r e v i e w e r s who gave us feedback . If you s p ot a p r o b l e m or b e l i e v e more explanatio n is n e e d e d , contac t u s. T he s a me g o es f or a ny other catalo g of patterns: Give the author s feedback ! One of the great thing s abou t pattern s is that they move desig n d e c i s i o n s out of the r e a lm of vagu e intuition . T h ey let author s be e x p l i c i t abou t the trade-off s they make . T h is make s it e a s i e r to see what is wron g with their pattern s and to argue with them . Take advantag e of that. T h i r d , l o ok for pattern s you u s e, and write them down . Make them a part of your d o c u m e n t a t i o n . S h ow them to o t h er p e o p l e . Y ou don't h a ve to be in a r e s e a r c h l ab to find patterns . In fact, findin g relevan t pattern s is nearl y i m p o s s i b l e if you don't have practica l e x p e r i e n c e . F e el free to write your own catalo g of patterns...bu t make s u re s o m e o n e else helps you beat them into shape! 6 . 5 A Parting Thought The best d e s i g n s w i ll use many d e s i g n pattern s that dovetai l and intertwin e to produc e a greate r w h o l e . As Christophe r Alexande r s a y s : It is p o s s i b l e to make building s by stringin g togethe r patterns , in a rathe r l o o se w a y. A buildin g made l i ke t h i s, is an a s s e m b l y of patterns . It is n ot d e n s e . It is not profound . But it is a l so p o s s i b l e to put pattern s togethe r in such a way that many pattern s overla p in the same p h y s i c a l s p a c e : the buildin g is very d e n s e ; it has many meaning s capture d in a smal l s p a c e ; and through this density, it becomes profound. A Pattern Language [AIS+77, page x l i ] ptgAppendix A G l o s s a r y a b s t r a c t c l a ss A c l a ss w h o s e primar y purpos e is to defin e an interface . An abstrac t c l a ss defer s s o me or a ll of i ts implementatio n to s u b c l a s s e s . An abstrac t c l a ss canno t be instantiated. a b s t r a c t c o u p l i n g G i v e n a c l a ss A that maintain s a referenc e to an abstrac t c l a ss B, c l a ss A is s a id to be abstractly coupled to B. We c a ll t h is abstrac t couplin g becaus e A refer s to a type of object , not a c o n c r e t e object. a b s t r a c t operatio n An operatio n that d e c l a r e s a signatur e but doesn' t implemen t it. In C++, an abstrac t operatio n c o r r e s p o n d s to a p u re virtua l membe r function. a c q u a i n t a n c e relationshi p A c l a ss that refer s to anothe r c l a ss has an acquaintance with that c l a s s . a g g r e g a t e objec t An objec t that's c o m p o s e d of subobjects . T he subobject s a re c a l l ed the aggregate' s p a r t s , and the aggregat e is r e s p o n s i b l e for them. aggregatio n relationshi p The relationshi p of an aggregat e o b j e c t to its parts . A c l a ss define s this r e l a t i o n s h i p for its i n s t a n c e s ( e . g ., aggregat e objects). black-bo x r e u se A style of r e u se based on objec t c o m p o s i t i o n . C o m p o s e d object s revea l no interna l detail s to e a ch other and are thus analogou s to \" b l a c k b o x e s . \" c l a ss A c l a ss define s an object' s interfac e and implementation . It s p e c i f i e s the object' s interna l representatio n and define s the operation s the objec t can perform. c l a ss d i a g r a m A diagra m that d e p i c t s c l a s s e s , t h e ir interna l structur e and o p e r a t i o n s , and the static relationship s betwee n them. class operatio n An operatio n targete d to a c l a ss and not to an individua l o b j e c t . In C++, c l a s s o p e r a t i o n s are are called static member f u n c t i o n s . c o n c r e t e class A class having no abstract operations. It can be instantiated. 3 5 9 ptg3 60 G L O S S A R Y APPENDIX A constructo r In C++, an operatio n that is automaticall y i n v o k e d to i n i t i a l i z e new in- s t a n c e s . couplin g T he d e g r e e to w h i c h softwar e c o m p o n e n t s d e p e n d on e a ch o t h e r . delegatio n An implementatio n m e c h a n i s m in whic h an o b j e c t forward s or delegates a reques t to anothe r object . The delegat e carrie s out the r e q u e s t on behal f of the o r i g i n a l o b j e c t . desig n patter n A d e s i g n patter n systematicall y names , motivates , and e x p l a i n s a g e n - eral d e s i g n that a d d r e s s e s a recurrin g d e s i g n proble m in o b j e c t - o r i e n t e d s y s t e m s . It d e s c r i b e s the problem , the s o l u t i o n , when to apply the solution , and its c o n - s e q u e n c e s . It also g i v es implementatio n hints a nd examples . T he s o l u t i o n is a g e n e r a l a r r a n g e m e n t of o b j e c t s a nd c l a s s e s that s o l ve t he p r o b l e m . T he s o l u t i o n is customize d and implemente d to s o l ve the proble m in a particula r context. destructo r In C++, an operatio n that is automaticall y invoke d to finaliz e an objec t that is abou t to be d e l e t e d . dynami c bindin g The run-tim e associatio n of a r e q u e s t to an o b j e c t and one of its operations . In C++, o n ly virtua l function s are dynamicall y bound. encapsulatio n T he resul t of h i d i n g a representatio n a nd implementatio n in an object . The representatio n is not v i s i b l e and canno t be a c c e s s e d directl y f r om outsid e the object . Operation s are the o n ly way to a c c e s s and modif y an object' s representa- tion. f r a m e w o r k A set of cooperatin g c l a s s e s that make s up a r e u s a b l e d e s i g n for a s p e c i f i c c l a ss of software . A framewor k p r o v i d e s architectura l guidanc e by partitionin g the d e s i g n into abstrac t c l a s s e s and definin g their r e s p o n s i b i l i t i e s and c o l l a b o - rations . A d e v e l o p e r customize s the framewor k to a particula r applicatio n by s u b c l a s s i n g a nd c o m p o s i n g i n s t a n c e s of f r a m e w o r k c l a s s e s . f r i e n d c l a ss In C++, a c l a ss that has the s a me a c c e s s right s to the operation s and data of a c l a ss as that c l a ss i t s e l f . inheritanc e A r e l a t i o n s h i p that d e f i n e s o ne entity in t e r ms of a n o t h e r . C l a ss i n h e r i t a n c e define s a n ew c l a ss in terms of o ne or more paren t c l a s s e s . T he n ew c l a ss i n h e r i t s i ts interfac e a nd implementatio n f r om i ts parents . T he n ew c l a ss is c a l l ed a s u b c l a s s or (in C + + ) a derive d c l a s s . C l a ss i n h e r i t a n c e c o m b i n e s i n t e r f a c e inheritanc e and implementatio n inheritance . Interfac e inheritanc e define s a new interfac e in terms of one or more e x i s t i n g interfaces . Implementatio n i n h e r i t a n c e define s a n ew implementatio n in term s of o ne or more e x i s t i n g implementations. instanc e variabl e A p i e ce of data that define s part of an object' s representation . C++ u s e s the term data member. interaction diagram A diagram that shows the flow of r e q u e s t s b e t w e e n o b j e c t s . ptg3 6 1 i n t e r f a c e T he s et of a ll s i g n a t u r e s d e f i n e d by an o b j e c t ' s o p e r a t i o n s . T he interfac e d e s c r i b e s the set of request s to whic h an objec t can respond. metaclas s C l a s s e s are object s in Smalltalk . A metaclas s is the c l a ss of a c l a ss object. mixi n c l a ss A c l a ss designe d to be c o m b i n e d with other c l a s s e s throug h inheritance . Mixi n c l a s s e s are usuall y abstract. objec t A run-tim e entity that package s both data and the procedure s that operat e on that data. objec t c o m p o s i t i o n Assemblin g or composing object s to get m o re comple x behavior. objec t d i a g r a m A diagra m that depict s a particula r objec t structur e at run-time. objec t referenc e A value t h at identifie s anothe r object. operatio n An object' s d a ta can be manipulate d o n ly by its operations . An objec t p e r - form s an operatio n when it r e c e i v e s a request . In C++, operation s are c a l l ed m e m b e r functions . Smalltal k u s es the term method. o v e r r i d i n g Redefinin g an operatio n ( i n h e r i t e d f r om a paren t c l a s s ) in a s u b c l a s s . parameterize d type A type that l e a v e s s o me constituen t types unspecified . The un- s p e c i f i e d t y p es a re s u p p l i e d as parameter s at t he p o i nt of u s e. In C++, parame- terize d types are c a l l ed templates. p a r e n t c l a ss The c l a ss f r om whic h anothe r c l a ss inherits . Synonym s are s u p e r c l a s s (Smalltalk) , b a se class (C++) , and a n c e s t o r class. p o l y m o r p h i s m The abilit y to substitut e object s of matchin g interfac e for one anothe r at r u n - t i m e . privat e i n h e r i t a n c e In C++ , a c l a ss inherite d s o l e ly for its implementation. protoco l Extend s the concep t of an interfac e to includ e the allowabl e s e q u e n c e s of requests. r e c e i v e r T he targe t o b j e c t of a r e q u e s t . r e q u e s t An objec t perform s an operatio n when it r e c e i v e s a correspondin g reques t f r om anothe r object . A commo n synony m for reques t is message. s i g n a t u r e An operation' s signatur e define s its name , parameters , and retur n value. s u b c l a s s A c l a ss that i n h e r i t s from anothe r c l a s s. In C++, a s u b c l a s s is c a l l ed a d e r i v e d class. s u b s y s t e m A n independent group of classes that collaborate to fulfill a s e t o f respon - s i b i l i t i e s . ptg3 62 G L O S S A R Y APPENDIX A s u b t y p e A type is a subtyp e of anothe r if its interfac e contain s the interfac e of the other t y p e . s u p e r t y p e The paren t type from whic h a type i n h e r i t s . toolki t A c o l l e c t i o n of c l a s s e s that provide s usefu l functionalit y but d o es not defin e t he d e s i g n of an a p p l i c a t i o n . t y pe The name of a particula r interface. white-bo x r e u se A s t y le of r e u se based on c l a ss inheritance . A s u b c l a s s r e u s e s t he i n - terfac e a nd i m p l e m e n t a t i o n of i ts p a r e n t c l a s s, b ut it m ay h a ve a c c e s s to o t h e r w i s e private aspects of its parent. ptgA p p e n d i x B G u i d e to N o t a t i o n We u se d i a g r a m s throughou t t he b o ok to i l l u s t r a t e importan t i d e a s . S o me d i a g r a m s a re informal , like a s c r e e n shot of a d i a l o g box or a schemati c showin g a tree of objects . But the desig n pattern s in particula r use more f o r m a l notation s to denot e relationship s and interaction s betwee n c l a s s e s and objects . T h is appendi x d e s c r i b e s t h e se notation s in detail. We u se t h r ee differen t diagrammati c n o t a t i o n s : 1.A class diagra m depict s c l a s s e s , their structure , and the static relationship s be- twee n them. 2.An objec t d i a g r a m depict s a particula r objec t structur e at run-time. 3.An interactio n d i a g r a m show s the flow of request s betwee n objects. E a ch d e s i g n patter n i n c l u d e s at l e a st one c l a ss diagram . The other notation s are u s ed as n e e d e d to supplemen t the discussion . The c l a ss and objec t diagram s are based on O MT ( O b j e c t M o d e l i n g T e c h n i q u e ) [ R B P + 9 1 , R u m 9 4 1 . 1 T he interactio n diagram s a re taken f r om Objector y [ J C J O 9 2 ] and the Booc h metho d [ B o o 9 4 ] . T h e s e notation s are summarized on the inside back cover of the book. B.I Class Diagram F i g u r e B.I a s h o w s the OMT notatio n for abstrac t and concret e c l a s s e s . A c l a ss is denote d by a b ox with t he c l a ss name in b o ld type at t he t o p. T he k ey o p e r a t i o n s of t he c l a ss appea r b e l ow the c l a ss name . Any instanc e variable s appea r below the operations. 1 O MT u s es t he term \" o b j e c t diagram \" to refer to c l a ss diagrams . We u se \" o b j e c t diagram \" exclusivel y to refer to diagrams of object structures. 3 6 3 ptg364 GUIDE TO NOTATION APPENDIX B T y pe informatio n is o p t i o n a l ; we u se t he C ++ c o n v e n t i o n , w h i c h puts t he t y pe n a me befor e the name of the operatio n (to signif y the retur n type) , i n s t a n c e variable , or actua l parameter . S l a n t e d type i n d i c a t e s that t he c l a ss or operatio n is abstract. In s o me d e s i g n pattern s i t 's helpfu l to s ee w h e r e c l i e nt c l a s s e s r e f e r e n c e P a r t i c i p a n t c l a s s e s . Whe n a patter n i n c l u d e s a C l i e n t c l a ss as o ne of i ts participant s ( m e a n i n g the c l i e nt has a r e s p o n s i b i l i t y in the pattern) , the C l i e n t appear s as an ordinar y c l a s s. T h is is true in F l y w e i g h t ( 1 9 5 ) , f or example . Whe n t he patter n d o es n ot i n c l u d e a C l i e n t participan t ( i . e ., c l i e n t s have no r e s p o n s i b i l i t i e s in t he pattern) , b ut i n c l u d i n g it n e v e r t h e l e s s c l a r i f i e s w h i ch patter n p a r t i c i p a n t s i n t e r a c t with c l i e n t s , t h en t he C l i e n t c l a ss is show n in g r a y, as show n in Figur e B.lb. An exampl e is P r o xy ( 2 0 7 ) . A gray C l i e n t also make s it c l e ar that we haven' t a c c i d e n t a l l y omitte d the C l i e n t from the Participant s d i s c u s s i o n . F i g u r e B.lc s h o w s variou s relationship s betwee n c l a s s e s . The OMT notatio n for c l a ss inheritanc e is a triangl e c o n n e c t i n g a s u b c l a s s ( L i n e S h a p e in the figure ) to its paren t c l a ss ( S h a p e ) . An o b j e c t r e f e r e n c e r e p r e s e n t i n g a p a r t - o f or a g g r e g a t i o n r e l a t i o n s h i p is indicate d by an arrowheade d l i ne with a diamon d at the base. The arrow point s to t he c l a ss that is a g g r e g a t e d ( e . g ., S h a p e ) . An a r r o w h e a d e d l i ne withou t t he d i a m o n d d e n o t e s acquaintanc e ( e . g ., a L i n e S h a p e k e e ps a referenc e to a C o l o r o b j e c t , w h i c h other s h a p e s may share) . A name for the referenc e may appea r near the base to d i s t i n g u i s h it from o t h er r e f e r e n c e s . 2 Anothe r usefu l t h i ng to s h ow is whic h c l a s s e s instantiat e w h i c h o t h e r s . We use a dashe d arrowheade d l i ne to indicat e t h i s, s i n ce O MT doesn' t suppor t i t. We c a ll t h is t he \" c r e a t e s \" r e l a t i o n s h i p . T he a r r ow p o i n t s to t he c l a ss that's i n s t a n t i a t e d . In F i g u r e B . l c, C r e a t i o n T o o l create s L i n e S h a p e o b j e c t s . OMT a l so define s a filled c i r c le to mean \" m o r e than o n e .\" Whe n the c i r c le appear s at t he h e ad of a r e f e r e n c e , it m e a n s m u l t i p l e o b j e c t s a re b e i ng r e f e r e n c e d or a g g r e g a t e d . Figur e B.lc s h o w s that Drawin g aggregate s multipl e object s of type S h a p e . F i n a l l y , we've augmente d OMT with pseudocod e annotation s to let us s k e t c h the im- p l e m e n t a t i o n s of o p e r a t i o n s . F i g u r e B . ld s h o w s t he p s e u d o c o d e a n n o t a t i o n f or t he Draw operation on the Drawing class. B.2 Object Diagram An o b j e c t d i a g r a m s h o w s i n s t a n c e s e x c l u s i v e l y . It p r o v i d e s a s n a p s h o t of t he o b j e c t s in a d e s i g n pattern . T he o b j e c t s a re name d \"aSomething\", wher e Something is t he c l a ss of t he o b j e c t . Our s y m b o l for an o b j e c t (modifie d s l i g h t l y from standar d O M T ) is a r o u n d e d 2 O MT a l so d e f i n e s a s s o c i a t i o n s betwee n c l a s s e s , w h i c h appea r as plain l i n es betwee n c l a ss b o x e s . A s s o c i - ation s are bidirectional . Althoug h a s s o c i a t i o n s are appropriat e durin g analysis , we feel they'r e too h i g h - l e v e l for e x p r e s s i n g the r e l a t i o n s h i p s in d e s i g n patterns , s i m p l y b e c a u s e a s s o c i a t i o n s must be m a p p e d down to o b j e c t reference s or pointer s durin g d e s i g n . Objec t reference s are intrinsicall y d i r e c t e d and are therefor e b e t t er s u i t ed to t he r e l a t i o n s h i p s that c o n c e r n u s. F or e x a m p l e , D r a w i n g k n o w s a b o u t S h a p e s , b ut t he S h a p e s don't know about the Drawing they're in. You can't express this relationship with associations alone. ptgSECTION B . 2 OBJECT D I A G R A M 365 F i g u r e B . 1 : C l a s s d i a g r a m n o t a t i o n ptg3 6 6 GUIDE T O N O T A T I O N APPENDIX B b ox with a l i ne s e p a r a t i n g t he o b j e c t n a me from a ny o b j e c t r e f e r e n c e s . A r r o w s i n d i c a t e t h e object referenced. Figure B.2 s h o w s an example. B . 3 Interaction Diagram An i n t e r a c t i o n d i a g r a m s h o w s t he o r d er in w h i c h r e q u e s t s b e t w e e n o b j e c t s g et e x e c u t e d . F i g u r e B.3 is an interactio n diagra m that s h o w s how a s h a pe g e ts adde d to a drawing. T i me flows from t op to botto m in an i n t e r a c t i o n d i a g r a m . A s o l id v e r t i c a l l i ne i n d i c a t e s the lifetim e of a particula r object . The namin g conventio n for o b j e c t s is the s a me as for o b j e c t d i a g r a m s — t h e c l a ss n a me p r e f i x e d by t he l e t t er \" a\" ( e . g ., a S h a p e ) . If t he o b j e c t doesn' t get instantiate d until a f t er the b e g i n n i n g of time as r e c o r d e d in the diagram , then i ts v e r t i c a l l i ne a p p e a r s d a s h e d until t he p o i nt of c r e a t i o n . A vertica l r e c t a n g l e s h o w s that an o b j e c t is a c t i v e ; that i s, it is handlin g a r e q u e s t . T he o p e r a t i o n c an s e nd r e q u e s t s to o t h er o b j e c t s ; t h e se a re i n d i c a t e d w i th a h o r i z o n t a l a r r ow pointin g to t he r e c e i v i n g o b j e c t . T he name of t he r e q u e s t is show n a b o v e t he a r r o w . A r e q u e s t to c r e a te an o b j e c t is s h o w n with a d a s h e d a r r o w h e a d e d l i n e. A r e q u e s t to t he s e n d i n g object itself points back to the sender.F i g u r e B.3: Interaction diagram notation ptgSECTION B.3 INTERACTION DIAGRAM 367 F i g u r e B.3 show s that the first r e q u e s t is f r om a C r e a t i o n T o o l to creat e a L i n e S h a p e . Later , aLineShap e is Adde d to aDrawing , whic h prompt s aDrawin g to s e nd a Refres h reques t to itself . Note that aDrawin g s e n ds a Draw r e q u e s t to a L i n e S h a p e as part of the Refres h operation. ptg This page intentionally left blank ptgA p p e n d i x C F o u n d a t i o n C l a s s e s T h is appendi x d o c u m e n t s t he foundatio n c l a s s e s we u se in t he C ++ s a m p l e c o de of s e v e r a l d e s i g n patterns . W e ' v e i n t e n t i o n a l l y kept t he c l a s s e s s i m p l e a nd m i n i m a l . We d e s c r i b e t he followin g c l a s s e s : • List, an o r d e r e d l i st of o b j e c t s . •I t e r a t o r , the interfac e for a c c e s s i n g an aggregate' s o b j e c t s in a s e q u e n c e . •L i st I t e r a t o r , an iterato r f or traversin g a L i s t . •P o i n t , a t w o - d i m e n s i o n a l point. •R e c t , an a x i s - a l i g n e d r e c t a n g l e . S o me newe r C ++ standar d t y p es m ay n ot be a v a i l a b l e on a ll c o m p i l e r s . In p a r t i c u l a r , if your c o m p i l e r d o e s n ' t defin e b o o l , then defin e it manuall y as t y p e d e f i nt b o o l ; c o n s t int t r ue = 1; c o n s t i n t false = 0 ; C . 1 List T he L i st c l a ss templat e p r o v i d e s a b a s ic c o n t a i n e r for s t o r i n g an o r d e r e d l i st of o b j e c t s . L i st s t o r es e l e m e n t s by v a l u e , w h i c h m e a n s it work s f or b u i l t - i n t y p es as w e ll as c l a ss i n s t a n c e s . For e x a m p l e , Li s t < i n t > d e c l a r e s a l i st of ints. But m o st of the pattern s use L i s t to s t o re p o i n t e r s to o b j e c t s , as in L i s t < G lyph * >. That way L i st can be u s ed for h e t e r o g e n e o u s l i s t s . 3 6 9 ptg370 FOUNDATION CLASSES APPENDIX C For c o n v e n i e n c e , L i st a l so p r o v i d e s synonym s for s t a ck o p e r a t i o n s , whic h make c o de that u s es L i st for stack s m o re e x p l i c i t withou t definin g anothe r c l a s s . t e m p l a t e < c l a s s I t e m > c l a s s L i st { p u b l i c : L i s t ( l o n g s i ze = D E F A U L T _ L I S T _ C A P A C I T Y ) ; L i s t ( L i s t & ) ; ~ L i s t ( ) ; List& operator=(cons t List&); l o ng C o u n t () const; I t e m& Get(long i n d e x) c o n s t; I t e m& First() const; I t e m& Last() const; b o ol I n c l u d e s ( c o n s t I t e m &) const; void Append(cons t I t e m & ); void P r e p e n d ( c o n s t I t e m & ) ; void Remove(cons t I t e m & ); v o id RemoveLast( ) ; void RemoveFirst( ) ; void RemoveAll(); I t e m& T o p () c o n s t; void P u s h ( c o n s t I t e m & ); I t e m& Pop(); } ; T he followin g s e c t i o n s d e s c r i b e t h e se operation s in g r e a t e r d e t a i l . C o n s t r u c t i o n , D e s t r u c t i o n , Initialization , a nd A s s i g n m e n t List(long size) initialize s the l i s t. The s i ze paramete r is a hint f or the i n i t i a l numbe r of e l e m e n t s . L i s t ( L i s t & ) o v e r r i d e s the defaul t c o py constructo r so that membe r data are i n i t i a l i z e d p r o p - e r l y . ~ L i s t ( ) frees the l i s t 's interna l data structure s but not the e l e m e n t s in the l i s t. The c l a ss is not d e s i g n e d for s u b c l a s s i n g ; therefor e the destructo r i s n 't virtual. L i s t& o p e r a t o r ^ ( c o n s t L i s t &) implements the assignment operation to assign member data properly. ptgSECTION C.I LIST 3 7 1 A c c e s s i n g T h e se operation s p r o v i d e b a s ic a c c e s s to t he l i s t 's e l e m e n t s . l o ng Count() c o n s t return s the numbe r of o b j e c t s in the l i s t . I t e m Sc G et ( l o ng i n d e x) c o n s t return s the o b j e c t at the g i v en i n d e x . I t e m& First() c o n st return s the first o b j e c t in the l i s t . I t e m& Last() c o n st return s t he l a st o b j e c t in t he l i s t . Adding void Append(cons t I t e m &) adds the argumen t to the l i s t, makin g it the l a st element. void P r e p e n d ( c o n s t I t e m &) adds the argumen t to the l i s t, makin g it the first e l e m e n t . R e m o v i n g v o id Remove(cons t I t e m &) r e m o v e s the g i v en e l e m e n t from the l i s t. T h is operatio n r e q u i r e s t h at the type of e l e m e n t s in the l i st support s the == operato r for c o m p a r i s o n . void RemoveFirst( ) r e m o v e s the first e l e m e n t from the l i s t . void RemoveLast( ) r e m o v e s the last element from t h e list. v o i d RemoveAll() r e m o v e s all elements from t h e list. ptg372 FOUNDATION CLASSES APPENDIX C S t a ck Interface I t e m& T o p () c o n st return s the top e l e m e n t (whe n the L i st is v i e w e d as a stack). void P u s h ( c o n s t I t e m &) pushe s the e l e m e n t onto the stack. I t e m & P o p ( ) p o p s the top element from the stack. C . 2 Iterator I t e r a t o r is an a b s t r a c t c l a ss that d e f i n e s a t r a v e r s a l interfac e for a g g r e g a t e s . t e m p l a t e < c l a s s I t e m > c l a s s I t e r a t o r { p u b l i c : v i r t u a l v o idF i r s t () - 0; v i r t u a l v o idN e x t ( ) = 0; v i r t u a l boolI s D o n e O c o n s t = 0; v i r t u a l I t emC u r r e n t l t e m ( ) c o n s t = 0 ; p r o t e c t e d : I t e r a t o r ( ) ; } ; The operation s do the following: virtual v o id First() p o s i t i o n s the iterato r to the first o b j e c t in the aggregate. virtual void Next() p o s i t i o n s the iterato r to the next o b j e c t in the s e q u e n c e . v i r t u a l b o ol I s D o n e ( ) c o n s t return s t r ue when there are no more object s in the s e q u e n c e . virtual I t em Currentltem( ) c o n st returns the object at the current position in the s e q u e n c e . C . 3 Listlterator L i s t l t e r a t o r implements t h e Iterator i n t e r f a c e to traverse List objects. Its con- structor takes a list to traverse as an argument. ptgSECTION C A POINT 3 7 3 t e m p l a te < c l a ss I t e m> c l a ss L i s t l t e r a t o r : p u b l ic I t e r a t o rs I t e m> { p u b l i c : L i s t l t e r a t o r ( c o n s t List<Item> * a L i s t ) ; v i r t u al v o id F i r s t ( ); v i r t u al v o id N e x t ( ); v i r t u al b o ol I s D o n e () c o n s t; virtual I t e m Currentltem() const; C . 4 Point P o i nt r e p r e s e n ts a p o i nt in a t w o - d i m e n s i o n a l C a r t e s i an c o o r d i n a te s p a c e. P o i nt s u p p o r ts s o me m i n i m al v e c t or a r i t h m e t i c. T he c o o r d i n a t e s of a P o i nt a re d e f i n ed a s t y p e d ef f l o at C o o r d ; P o i n t 's o p e r a t i o n s a re s e l f - e x p l a n a t o r y . c l a ss P o i nt { p u b l i c : s t a t ic c o n st P o i nt Z e r o ; P o i n t ( C o o r d x = 0.0, C o o rd y = 0 . 0 ) ; C o o rd X () c o n s t; v o id X ( C o o rd x) ; C o o rd Y () c o n s t; void Y ( C o o rd y) ; f r i e nd P o i nt o p e r a t o r + ( c o n s t P o i n t &, c o n st P o i n t & ); f r i e nd P o i nt o p e r a t o r - ( c o n s t P o i n t &, c o n st P o i n t & ); f r i e nd P o i nt o p e r a t o r * ( c o n s t P o i n t &, c o n st P o i n t & ); f r i e nd P o i nt o p e r a t o r / ( c o n s t P o i n t &, c o n st P o i n t & ) ; P o i n t& o p e r a t o r + = ( c o n s t P o i n t & ) ; P o i n t& operator-=(cons t P o i n t & ); P o i n t& o p e r a t o r * = ( c o n s t P o i n t & ); P o i n t& o p e r a t o r / ^ ( c o n s t P o i n t & ) ; P o i nt operator-(); f r i e nd b o ol operator==(cons t P o i n t &, c o n st P o i n t & ); f r i e nd b o ol o p e r a t o r ! = ( c o n s t P o i n t &, c o n st P o i n t & ) ; f r i e nd o s t r e a m& o p e r a t o r « ( o s t r e a m & , c o n st P o i n t & ); f r i e n d istream& operator» ( i s t r e a m & , Point&) ; T h e s t a t i c m e m b e r Z e r o r e p r e s e n t s P o i n t ( 0 , 0 ) . ptg374 FOUNDATION CLASSES APPENDIX C C 5 Rect Rect r e p r e s e n ts an a x i s - a l i g n e d r e c t a n g l e. A Rect is d e f i n ed by an o r i g in p o i nt a nd an e x t e nt ( t h at i s, w i d th a nd h e i g h t ). T he Rect o p e r a t i o ns a re s e l f - e x p l a n a t o r y . c l a ss Rect { p u b l i c : s t a t ic c o n st Rect Z e r o ; R e c t ( C o o r d x, C o o rd y, C o o rd w, C o o rd h ) ; R e c t ( c o n s t P o i n t& o r i g i n, c o n st P o i n t& e x t e n t ) ; C o o rd W i d t h () c o n s t;v o id W i d t h ( C o o r d ) ; C o o rd H e i g h t () c o n s t;v o id H e i g h t ( C o o r d ) ; C o o rd Left() c o n s t;v o id L e f t ( C o o r d ) ; C o o rd B o t t o m () c o n s t;v o id B o t t o m ( C o o r d ) ; P o i n t& O r i g i n () c o n s t;v o id O r i g i n ( c o n s t P o i n t & ) ; P o i n t& E x t e n t () c o n s t;v o id E x t e n t ( c o n s t P o i n t & ) ; v o id M o v e T o ( c o n s t P o i n t & ); v o id M o v e B y ( c o n s t P o i n t & ) ; b o ol I s E m p t yO c o n s t; b o o l Contains(const P o i n t & ) const; } ; T h e static m e m b e r Z e r o i s e q u i v a l e n t t o t h e r e c t a n g l e Rect(Point(0, 0 ) , Point(0, 0 ) ) ; ptgB i b l i o g r a p h y [ A d d 9 4 ] A d d i s o n - W e s l e y , Reading , MA. NEXTSTEP General Reference: Release 3, Volumes 1 and 2,1994. [ A G 9 0 ] D . B. Anderso n a nd S. Gossain . Hierarch y evolutio n a nd t he softwar e l i f e c y c l e . In TOOLS '90 Conference Proceedings, p a g e s 4 1 - 5 0 , P a r i s , June 1 9 9 0. Prentic e H a l l . [ A I S + 7 71 Christophe r Alexander , S a ra Ishikawa , Murra y S i l v e r s t e i n , M ax J a c o b s o n , Ingri d F i k s d a h l - K i n g , and S h l o m o Angel . A Pattern Language. Oxfor d Universit y P r e s s , N ew York , 1 9 7 7 . [ A p p 8 9 1 Appl e Computer , I n c ., Cupertino , C A. Macintosh Programmers Workshop Pascal 3 .0 Reference, 1 9 8 9 . [ A p p 9 2 1 Appl e Computer , I n c ., Cupertino , CA. Dylan. An object-oriented dynamic language, 1 9 9 2 . [ A r v 9 1 1 Jame s Arvo . Graphics Gems I I. Academi c P r e s s , B o s t o n , M A, 1 9 9 1 . [ A S 8 5 1 B. A d e l s o n a nd E. S o l o w a y . T he r o le of domai n e x p e r i e n c e in softwar e d e s i g n . IEEE Transactions on Software Engineering, 1 1 ( 1 1 ) : 1 3 5 1 - 1 3 6 0 , 1 9 8 5 . [ B E 9 3 1 Andrea s B i r r e r a nd Thoma s E g g e n s c h w i l e r . Framework s in t he financia l e n g i n e e r i n g d o m a i n : An e x p e r i e n c e r e p o r t . In European Conference on Object-Oriented Programming, page s 2 1 - 3 5 , Kaiserslautern , Germany , July 1 9 9 3. S p r i n g e r - V e r l a g . [ B J 9 4 ]Kent B e ck and Ralp h Johnson . Pattern s generat e architectures . In European Conference on Object-Oriented Programming, page s 1 3 9 - 1 4 9 , B o l o g n a , Italy, July 1 9 9 4. S p r i n g e r - V e r l a g . [ B o o 9 4 ]Grad y B o o c h . Object-Oriented Analysis and Design with Applications. B e n - jamin/Cummings , Redwoo d C i t y, C A, 1 9 9 4. S e c o n d E d i t i o n . [BorSl ]A. Borning . The programmin g languag e aspect s of ThingLab— a c o n s t r a i n t - o r i e n t e d simulation laboratory. A C M T r a n s a c t i o n s o n Program- ming Languages and Systems, 3(4):343-387, O c t o b e r 1981. 3 7 5 ptg3 76 BIBLIOGRAPHY [ B o r 9 4 ] B o r l a n d International , I n c ., S c o t t s V a l l e y , C A. A Technical Comparison of Borland ObjectWindows 2.0 and Microsoft MFC 2.5,1994. [ B V 9 0 ] Grad y B o o c h a nd M i c h a e l V i l o t . T he d e s i g n of t he C ++ B o o c h c o m p o - nents . In Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings, p a g es 1 - 1 1, Ottawa , Canada , O c t o b e r 1 9 9 0. A CM P r e s s . [ C a l 9 3 ] Paul R. C a l d e r . Building User Interfaces with Lightweight Objects. PhD t h e s i s , Stanfor d U n i v e r s i t y , 1 9 9 3 . [ C a r 8 9 ] J. C a r o l a n . Constructin g b u l l e t - p r o o f c l a s s e s . In Proceedings C++ at Work '89. S I GS P u b l i c a t i o n s , 1 9 8 9 . [ C a r 9 2 ]T om C a r g i l l . C ++ Programming Style. A d d i s o n - W e s l e y , R e a d i n g , M A, 1 9 9 2 . [ C I R M 9 3 ]R oy H. C a m p b e l l , N a y e e m I s l a m , D a v i d R a i l a , a nd P e t er M a d e a n y . D e - s i g n i n g a nd implementin g C h o i c e s : An o b j e c t - o r i e n t e d s y s t e m in C++. Communications of t he ACM, 3 6 ( 9 ) : 1 1 7 - 1 2 6 , S e p t e m b e r 1 9 9 3 . [ C L 9 0 1Paul R. C a l d e r a nd Mark A. Linton . G l y p h s : F l y w e i g h t o b j e c t s f or u s er interfaces . In ACM User Interface Software Technologies Conference, p a g es 9 2 - 1 0 1 , S n o w b i r d , U T, O c t o b e r 1 9 9 0 . [ C L 9 2 ]Paul R. C a l d e r a nd Mark A. L i n t o n . T he o b j e c t - o r i e n t e d i m p l e m e n t a t i o n of a documen t e d i t o r . In Object-Oriented Programming Systems, Languages, a nd Applications Conference Proceedings, p a g es 1 5 4 - 1 6 5 , V a n c o u v e r , B r i t i s h C o l u m b i a , Canada , O c t o b e r 1 9 9 2. A CM P r e s s . [ C o a 9 2 1 P e t er C o a d . O b j e c t - o r i e n t e d patterns . Communications of the ACM, 3 5 ( 9 ) : 1 5 2 - 1 5 9 , S e p t e m b e r 1 9 9 2 . [ C o o 9 2 ] W i l l i a m R. C o o k . Interface s a nd s p e c i f i c a t i o n s f or t he S m a l l t a l k - 8 0 c o l - l e c t i o n c l a s s e s . In Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings, p a g es 1 - 1 5, V a n c o u v e r , B r i t i s h C o l u m - b i a, C a n a d a , O c t o b e r 1 9 9 2. A CM P r e s s . [ C o p 9 2 ] J a m e s O. C o p l i e n . Advanced C++ Programming Styles and Idioms. A d d i s o n - W e s l e y , R e a d i n g , M A, 1 9 9 2 . [ C u r 8 9 ]B i ll C u r t i s . C o g n i t i v e i s s u e s in r e u s i n g softwar e artifacts . In T ed J. B i g g e r - staff a nd A l an J. P e r l i s , e d i t o r s , Software Reusability, Volume I I: Applications a nd Experience, p a g es 2 6 9 - 2 8 7 . A d d i s o n - W e s l e y , R e a d i n g , M A, 1 9 8 9 . [ d C L F 9 3 ]D e n n i s de C h a m p e a u x , D o ug L e a, a nd P e n e l o p e F a u r e . Object-Oriented System Development. A d d i s o n - W e s l e y , R e a d i n g , M A, 1 9 9 3 . [ D e u 8 9 ]L. P e t er D e u t s c h . D e s i g n r e u se a nd framework s in t he S m a l l t a l k - 8 0 s y s - tem. In T ed J. B i g g e r s t a f f a nd Alan J. P e r l i s , e d i t o r s , Software Reusability, Volume II: A p p l i c a t i o n s and Experience, p a g e s 5 7 - 7 1 . A d d i s o n - W e s l e y , R e a d - i n g , MA, 1989. ptgBIBLIOGRAPHY 3 7 7 [ E d e 9 2 ] D. R. E d e l s o n . S m a r t p o i n t e r s : T h e y ' r e smart , b ut they'r e n ot p o i n t e r s . In Proceedings of t he 1992 USENIX C ++ Conference, p a g e s 1 - 1 9, Portland , O R, A u g u s t 1 9 9 2. U S E N I X A s s o c i a t i o n . [ E G 9 2 ] T h o m a s E g g e n s c h w i l e r a nd E r i ch Gamma. T he E T + + S w a p s M a n a g e r : U s i ng o b j e c t t e c h n o l o g y in t he financia l e n g i n e e r i n g d o m a i n . In Object- Oriented Programming Systems, Languages, and Applications Conference Pro- ceedings, p a g e s 1 6 6 - 1 7 8 , V a n c o u v e r , B r i t i s h C o l u m b i a , C a n a d a , O c t o b e r 1 9 9 2. A CM P r e s s . [ E S 9 0 ] Margare t A. E l l is and Bjarn e Stroustrup . The Annotated C++ Reference Manual. A d d i s o n - W e s l e y , R e a d i n g , M A, 1 9 9 0 . [ F o o 9 2 lB r i an F o o t e . A fracta l m o d e l of t he l i f e c y c l e s of r e u s a b l e o b j e c t s . O O P - S LA '92 Workshop on Reuse, O c t o b e r 1 9 9 2. V a n c o u v e r , B r i t i s h C o l u m b i a , Canada. [ G A 8 9 ]S. G o s s a i n a nd D . B. A n d e r s o n . D e s i g n i n g a c l a ss h i e r a r c h y f or d o m a i n r e p r e s e n t a t i o n and r e u s a b i l i t y . In TOOLS '89 Conference Proceedings, p a g e s 2 0 1 - 2 1 0 , C N IT Paris—L a D e f e n s e , F r a n c e , Novembe r 1 9 8 9. P r e n t i c e H a l l . [ G a m 9 1 1E r i ch Gamma . Object-Oriented Software Development based on ET++: Design Patterns, Class Library, Tools (in German) . PhD t h e s i s , U n i v e r s i t y of Zuric h Institutfiir Informatik, 1 9 9 1 . [ G a m 9 2 ]E r i ch Gamma . Object-Oriented Software Development based on ET++: Design Patterns, Class Library, Tools ( in G e r m a n ) . S p r i n g e r - V e r l a g , B e r l i n , 1 9 9 2 . [ G l a 9 0 ]Andre w G l a s s n e r . Graphics Gems. A c a d e m i c P r e s s , B o s t o n , M A, 1 9 9 0 . [ G M 9 2 ]M. Graha m a nd E. Mettala . T he D o m a i n - S p e c i f i c Softwar e Architectur e Program . In Proceedings of DARPA Software Technology Conference, 1992, p a g e s 2 0 4 - 2 1 0 , A p r il 1 9 9 2. A l so p u b l i s h e d in CrossTalk, T he Journal of Defense Software Engineering, p a g e s 1 9 - 2 1 , 3 2 , O c t o b e r 1 9 9 2 . [ G R 8 3 ]A d e l e J. G o l d b e r g and D a v i d R o b s o n . Smalltalk-80: The Language and Its Implementation. A d d i s o n - W e s l e y , R e a d i n g , M A, 1 9 8 3 . [ H H M V 9 2 ]Richar d H e l m , T i en Huynh , K im Marriott , a nd John V l i s s i d e s . An o b j e c t - o r i e n t e d architectur e f or c o n s t r a i n t - b a s e d g r a p h i c a l e d i t i n g . In Proceedings of the Third Eurographics Workshop on Object-Oriented Graphics, p a g e s 1 - 2 2, C h a m p e r y , S w i t z e r l a n d , O c t o b e r 1 9 9 2. A l so a v a i l a b l e as I BM R e s e a r c h D i v i s i o n T e c h n i c a l Repor t RC 1 8 5 24 ( 7 9 3 9 2 ) . [ H O 8 7 ]D a n i e l C. H a l b e r t a nd P a t r i c k D. O ' B r i e n . O b j e c t - o r i e n t e d d e v e l o p m e n t . IEEE Software, 4 ( 5 ) : 7 1 - 7 9 , S e p t e m b e r 1 9 8 7 . [ I O N 9 4 ] I O NA T e c h n o l o g i e s , L t d ., D u b l i n , I r e l a n d . Programmer's Guide f or Orbix, Version 1 . 2 , 1994. ptg3 78 BIBLIOGRAPHY [ J C J O 9 2 ]Ivar J a c o b s o n , Magnu s C h r i s t e r s o n , Patri k Jonsson , and Gunna r O v e r - gaard . Object-Oriented Software Engineering—A Use Case Driven Approach. A d d i s o n - W e s l e y , Wokingham , England , 1 9 9 2 . [ J F 8 8 ]R a l ph E. J o h n s o n a nd B r i an F o o t e . D e s i g n i n g r e u s a b l e c l a s s e s . Journal of Object-Oriented Programming, l ( 2 ) : 2 2 - 3 5 J u n e / J u l y 1 9 8 8 . [ J M L 9 2 ]Ralp h E. J o h n s o n , Carl M c C o n n e l l , a nd J. M i c h a e l L a k e . T he R TL s y s t e m : A framewor k for c o de optimization . In Rober t G i e g e r i c h and S u s an L. Graham , e d i t o r s , Code Generation—Concepts, Tools, Techniques. Proceedings of the International Workshop on Code Generation, pages 2 5 5 - 2 7 4 , D a g s t u h l , G e r m a n y , 1 9 9 2. S p r i n g e r - V e r l a g . [ J o h 9 2 ]Ralp h Johnson . Documentin g framework s u s i ng patterns . In Object- Oriented Programming Systems, Languages, and Applications Conference Pro- ceedings, p a g es 6 3 - 7 6 , Vancouver , B r i t i s h Columbia , Canada , O c t o b e r 1 9 9 2. A CM P r e s s . [ J Z 9 1 ]Ralph E. J o h n s o n a nd Jonatha n Z w e i g . D e l e g a t i o n in C++. Journal of Object-Oriented Programming, 4 ( 1 1 ) : 2 2 - 3 5 , Novembe r 1 9 9 1 . [ K i r 9 2 ]D a v i d Kirk. Graphics Gems III. Harcourt , B r a c e , J o v a n o v i c h , B o s t o n , MA, 1 9 9 2 . [ K n u 7 3 ]Donal d E. Knuth . The Art of Computer Programming, Volumes 1, 2, and 3. A d d i s o n - W e s l e y , R e a d i n g , M A, 1 9 7 3 . [ K n u 8 4 ]D o n a l d E. Knuth . T he TEXbook. A d d i s o n - W e s l e y , R e a d i n g , M A, 1 9 8 4 . [ K o f 9 3 ]Thoma s Kofler . Robus t iterator s in ET++ . Structured Programming, 1 4 : 6 2 - 8 5, M a r c h 1 9 9 3 . [ K P 8 8 ]Glen n E. Krasne r a nd S t e p h e n T. P o p e . A c o o k b o o k f or using t he m o d e l - v i ew c o n t r o l l e r user interfac e paradig m in S m a l l t a l k - 8 0 . Journal of Object- Oriented Programming, l ( 3 ) : 2 6 - 4 9 , August/Septembe r 1 9 8 8 . [ L a L 9 4 ]W i lf LaLonde . Discovering Smalltalk. Benjamin/Cummings , Redwoo d C i t y, C A, 1 9 9 4 . [LCI+92 ]Mark Linton , Paul C a l d e r , John Interrante , S t e v e n T a n g , and John V l i s - s i d e s . Interviews Reference Manual. C S L, Stanfor d U n i v e r s i t y , 3 .1 e d i t i o n , 1 9 9 2 . [ L e a 8 8 ]Doug Lea. libg++ , the GNU C++ l i b r a r y . In Proceedings of the 1988 USENIX C ++ Conference, p a g es 2 4 3 - 2 5 6 , D e n v e r , C O, O c t o b e r 1 9 8 8. U S E N I X A s s o - c i a t i o n . [ L G 8 6 ]B a r b a r a L i s k o v and J o hn Guttag . Abstraction and Specification in Program Development. M c G r a w - H i l l , New Y o r k , 1986. ptgBIBLIOGRAPHY 3 7 9 [ L i e 8 5 ] Henr y Lieberman . T h e r e ' s more to menu s y s t e m s than meet s the s c r e e n . In SIGGRAPH Computer Graphics, p a g es 1 8 1 - 1 8 9 , S an F r a n c i s c o , C A, J u ly 1 9 8 5 . [ L i e 8 6 ] Henr y L i e b e r m a n . U s i ng p r o t o t y p i c a l o b j e c t s to i m p l e m e n t s h a r e d b e - havio r in object-oriente d s y s t e m s . In Object-Oriented Programming Sys- tems, Languages, and Applications Conference Proceedings, p a g es 2 1 4 - 2 2 3 , Portland , O R, Novembe r 1 9 8 6 . [ L i n 9 2 ] Mark A. L i n t o n . Encapsulatin g a C++ l i b r a r y . In Proceedings of the 1992 USENIX C ++ Conference, pages 5 7 - 6 6 , Portland , O R, Augus t 1 9 9 2. A CM P r e s s . [ L P 9 3 ] Mark Linto n and Chuc k P r i c e . B u i l d i n g distribute d user interface s with F r e s c o . In Proceedings of the 7th X Technical Conference, pages 7 7 - 8 7 , B o s t o n , M A, Januar y 1 9 9 3 . [ L R 9 3 ] Danie l C. Lync h a nd Marshal l T. R o s e . Internet System Handbook. A d d i s o n - W e s l e y , Reading , M A, 1 9 9 3 . [ L V C 8 9 ] Mark A. Linton , John M. V l i s s i d e s , and Paul R. C a l d e r . C o m p o s i n g u s er interface s with Interviews . Computer, 2 2 ( 2 ) : 8 - 2 2 , Februar y 1 9 8 9 . [ M a r 9 1 ]Bruce Martin . The separatio n of interfac e and implementatio n in C++. In Proceedings of t he 1991 USLNIX C ++ Conference, p a g es 5 1 - 6 3 , W a s h i n g t o n , D . C ., April 1 9 9 1. USENI X Association. [ M c C 8 7 ]Paul M c C u l l o u g h . Transparen t forwarding : F i r st s t e p s . In Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings, p a g es 3 3 1 - 3 4 1 , O r l a n d o , F L, O c t o b e r 1 9 8 7. A CM P r e s s . [ M e y 8 8 ]Bertran d M e y e r . Object-Oriented Software Construction. S e r i e s in Compute r S c i e n c e . Prentic e H a l l, Englewoo d Cliffs , N J, 1 9 8 8 . [ M u r 9 3 1Rober t B. Murray . C++ Strategies and Tactics. A d d i s o n - W e s l e y , R e a d i n g , M A, 1 9 9 3 . [ O J 9 0 ]W i l l i a m F. O p d y k e a nd R a l ph E. J o h n s o n . R e f a c t o r i n g : An a id in d e - s i g n i n g applicatio n framework s and e v o l v i n g o b j e c t - o r i e n t e d s y s t e m s . In SOOPPA Conference Proceedings, p a ges 1 4 5 - 1 6 1 , Maris t C o l l e g e , P o u g h - k e e p s i e , N Y, S e p t e m b e r 1 9 9 0. A CM P r e s s . [ O J 9 3 ]W i l l i a m F. O p d y k e a nd R a l ph E. J o h n s o n . C r e a t i n g a b s t r a c t s u p e r c l a s s e s by refactoring . In Proceedings of the 21st Annual Computer Science Conference (ACM C SC '93), p a g es 6 6 - 7 3 , I n d i a n a p o l i s , I N, F e b r u a r y 1 9 9 3 . [ P + 8 8 ]Andre w J. Palay et a l. The Andre w T o o l k i t : An o v e r v i e w . In Proceedings of t he 1988 Winter USENIX Technical Conference, p a g es 9 - 2 1, D a l l a s , T X, February 1988. USENIX Association. ptg3 80 BIBLIOGRAPHY [ P a r 9 0 ] P a r c P l a c e S y s t e m s , Mountai n V i e w , C A. ObjectWorks\\Smalltalk Release 4 Users Guide, 1 9 9 0 . [ P a s 8 6 ] Geoffre y A. P a s c o e . Encapsulators : A new softwar e paradig m in S m a l l t a l k - 8 0 . In Object-Oriented Programming Systems, Languages, and Ap-' plications Conference Proceedings, p a g es 3 4 1 - 3 4 6 , P o r t l a n d , O R, O c t o b e r 1 9 8 6. A CM P r e s s . [ P u g 9 0 ] W i l l i a m P u g h . S k i p l i s t s : A probabilisti c alternativ e to b a l a n c e d t r e e s. Communications of t he ACM, 3 3 ( 6 ) : 6 6 8 - 6 7 6 , June 1 9 9 0 . [ R B P +9 1] Jame s Rumbaugh , M i c h a e l B l a h a , W i l l i a m P r e m e r l a n i , F r e d e r i c k E d d y , and W i l l i a m L o r e n s o n . Object-Oriented Modeling and Design. P r e n t i c e H a l l, E n g l e w o o d C l i f f s , N J, 1 9 9 1 . [ R u m 9 4 ] J a m e s Rumbaugh . T he l i fe of an o b j e c t m o d e l : H ow t he o b j e c t m o d e l c h a n g e s durin g d e v e l o p m e n t . Journal of Object-Oriented Programming, 7 ( l ) : 2 4 - 3 2 , March/Apri l 1 9 9 4 . [ S E 8 4 ] E l l i ot S o l o w a y a nd Kate E h r l i c h . Empirica l s t u d i e s of programmin g k n o w l e d g e . IEEE Transactions on Software Engineering, 1 0 ( 5 ) 5 9 5 - 6 0 9 , S e p - t e m b e r 1 9 8 4 . [ S h a 9 0 ] Y e n - P i n g S h a n . M o D E : A U I MS f or S m a l l t a l k . In A CM OOPSLA/ECOOP '90 Conference Proceedings, p a g es 2 5 8 - 2 6 8 , O t t a w a , O n t a r i o , C a n a d a , O c t o - b er 1 9 9 0. A CM P r e s s . [ S n y 8 6 ] Alan S n y d e r . Encapsulatio n a nd i n h e r i t a n c e in o b j e c t - o r i e n t e d l a n g u a g e s . In Object-Oriented Programming Systems, Languages, and Applications Confer- ence Proceedings, p a g es 3 8 - 4 5 , P o r t l a n d , O R, N o v e m b e r 1 9 8 6. A CM P r e s s . [ S S 8 6 ] Jame s C. S p o h r e r a nd E l l i ot S o l o w a y . N o v i c e m i s t a k e s : A re t he folk w i s - d o ms c o r r e c t ? Communications of t he ACM, 2 9 ( 7 ) : 6 2 4 - 6 3 2 , J u ly 1 9 8 6 . [ S S 9 4 ] D o u g l a s C. S c h m i d t a nd T a t s u y a S u d a . T he S e r v i c e C o n f i g u r a t o r F r a m e - work : An e x t e n s i b l e architectur e for dynamicall y c o n f i g u r i n g c o n c u r r e n t , m u l t i - s e r v i c e networ k d a e m o n s . In Proceeding of the Second International Workshop on Configurable Distributed Systems, page s 1 9 0 - 2 0 1 , P i t t s b u r g h , P A, M a r c h 1 9 9 4. I E EE C o m p u t e r S o c i e t y . [ S t r 9 1 ] B j a r n e S t r o u s t r u p . T he C ++ Programming Language. A d d i s o n - W e s l e y , R e a d i n g , M A, 1 9 9 1. S e c o n d E d i t i o n . [ S t r 9 3 ] P a ul S. S t r a u s s . I R IS I n v e n t o r , a 3D g r a p h i c s t o o l k i t . In Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings, p ag es 1 9 2 - 2 0 0 , W a s h i n g t o n , D . C ., S e p t e m b e r 1 9 9 3. A CM P r e s s . [ S t r 9 4 ] Bjarn e Stroustrup . The Design and Evolution of C++. A d d i s o n - W e s l e y , R e a d i n g , MA, 1994. ptgBIBLIOGRAPHY 3 8 1 [ S u t 6 3 ] I . E. Sutherland . Sketchpad: A Man-Machine Graphical Communication Sys- tem. P hD t h e s i s , M I T, 1 9 6 3 . [ S w e 8 5 ] Richar d E. S w e e t . The M e sa programmin g environment . SIGPLAN No- tices, 2 0 ( 7 ) : 2 1 6 - 2 2 9 , J u ly 1 9 8 5 . [ S y m 9 3 a ] Symante c Corporation , Cupertino , C A. Bedrock Developer's Architecture Kit, 1 9 9 3 . [ S y m 9 3 b ] S y m a n t e c C o r p o r a t i o n , C u p e r t i n o , C A. THINK Class Library Guide, 1 9 9 3 . [ S z a 9 2 ] Duan e Szafron . S P E C T a l k : An object-oriente d data specificatio n language . In Technology of Object-Oriented Languages and Systems (TOOLS 8), page s 1 2 3 - 1 3 8 , Santa Barbara , C A, Augus t 1 9 9 2. P r e n t i c e Hall. [ U S 8 7 ] D a v i d Unga r a nd Randal l B. S m i t h . S e l f: T he powe r of s i m p l i c i t y . In Object-Oriented Programming Systems, Languages, and Applications Confer- ence Proceedings, page s 2 2 7 - 2 4 2 , O r l a n d o , F L, O c t o b e r 1 9 8 7. A CM P r e s s . [ V L 8 8 ] John M. V l i s s i d e s and Mark A. Linton . Applyin g object-oriente d d e s i g n to structure d g r a p h i c s . In Proceedings of the 1988 USENIX C++ Conference, page s 8 1 - 9 4 , D e n v e r , C O, O c t o b e r 1 9 8 8. U S E N I X Association. [ V L 9 0 ] John M. V l i s s i d e s a nd Mark A. L i n t o n . U n i d r a w : A framewor k f or b u i l d - ing domain-specifi c graphica l editors . ACM Transactions on Information Systems, 8 ( 3 ) : 2 3 7 - 2 6 8 , July 1 9 9 0 . [ W B J 9 0 ]R e b e c c a W i r f s - B r o c k and Ralp h E. Johnson . A surve y of curren t r e s e a r c h in o b j e c t - o r i e n t e d d e s i g n . Communications of t he ACM, 3 3 ( 9 ) : 1 0 4 - 1 2 4 , 1 9 9 0 . [ W B W W 9 0 ]R e b e c c a W i r f s - B r o c k , B r i an W i l k e r s o n , a nd L a u r e n W i e n e r . Designing Object-Oriented Software. Prentic e H a l l, E n g l e w o o d Cliffs , N J, 1 9 9 0 . [ W G M 8 8 ]Andr e W e i n a n d , E r i ch Gamma , and R u d o l f M a r t y . ET++—A n o b j e c t - oriente d applicatio n f r a m e w o r k in C++. In Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings, p a g e s 4 6 - 5 7 , S a n Diego, CA, September 1988. ACM Press. ptg This page intentionally left blank ptgI n d e x N a m e s of d e s i g n pattern s appea r in s m a ll c a p i t a l s : e . g ., A D A P T E R . P a ge number s in b o ld i n d i c a t e t he d e f i n i t i o n of a term. Number s in italics i n d i c a t e a diagra m f or t he term. L e t t e r s after a d i a g r a m ' s p a ge n u m b e r i n d i c a t e t he k i nd of d i a g r a m : a \"c\" d e n o t e s a c l a ss d i a g r a m , an \"i\" d e n o t e s an i n t e r a c t i o n d i a g r a m , a nd an \"o\" d e n o t e s an o b j e c t d i a g r a m . For example, 88co means that a class and object diagram appears on page 8 8 . abstrac t c l a ss 1 5 ,1 6 c, 3 5 9 , 3 6 4 , 365c a b s t r a c t c o u p l i n g , s ee c o u p l i n g , a b s t r a c t in O B S E R V E R 2 96 A B S T R A C T F A C T O R Y 8 7 e x t e n s i b i l i t y of 91 in catalo g summar y 8 L e x i ' s u se of 51 u s ed to c o n f i g u r e a s u b s y s t e m 1 9 3 Abstrac t Factor y participan t of A B S T R A C T F A C T O R Y 88c, 8 9 abstrac t o p e r a t i o n , see o p e r a t i o n , abstrac t u se to i m p l e m e n t A D A P T E R 1 4 4 a b s t r a c t s y n t a x t r ee 2 4 4 , 2 5 1 , 3 3 1 c l a ss structur e for 2 4 4 c, 331c c o n s t r u c t i n g in S m a l l t a l k 2 50 o b j e c t structur e for 2 4 4 0 A b s t r a c t E x p r e s s i o n p a r t i c i p a n t of I N T E R P R E T E R 2 4 5 c, 2 4 5 Abstractio n participan t of B R I D G E 153c, 1 5 4 AbstractProduc t p a r t i c i p a n t of A B S T R A C T F A C T O R Y 88c, 8 9 a c c u m u l a t i n g s t a te 3 36 a c q u a i n t a n c e 2 2 , 3 5 9 C++, define d in 23 compare d with a g g r e g a t i o n 23 S m a l l t a l k , d e f i n e d in 23 A c t i o n , s e e C O M M A N Da c t i ve i t e r a t o r , s ee i t e r a t o r , a c t i ve A da 4, 21 Adaptee participan t of ADAPTE R 1 4 1 ,1 4 1c A D A P T E R 1 3 9 c o m p a r e d with B R I D G E 1 6 1 , 2 1 9 c o m p a r e d with D E C O R A T O R 1 84 compare d with PROX Y 2 16 in c a t a l o g summary 8 Adapte r participan t of A D A P T E R 1 4 1 ,1 4 1 c a d a p t e r 1 40 c l a ss adapte r 1 4 1 ,1 4 1c o b j e c t adapte r 1 4 1 ,1 4 1c parameterize d 1 45 p l u g g a b l e , see p l u g g a b l e adapte r t w o - w a y 1 4 3 ,1 4 3 c adorne r 1 79 Aggregate participan t of ITERATO R 259,259c aggregat e o b j e c t 2 57 a g g r e g a t i o n 2 2, 3 5 9 C++, d e f i n e d in 23 compare d with acquaintanc e 23 notatio n for 23 S m a l l t a l k , d e f i n e d in 23 A l e x a n d e r , Christopher x i i i , 2 , 3 5 6 , 3 5 8 3 8 3 A ptg3 84 INDEX a l g o r i t h m a v o i d i n g d e p e n d e n c e on 24 d e f i n i n g s t e ps of 3 26 famil y of 3 17 s k e l e t o n 3 2 7 A l t e r n a t i o n E x p r e s s i o n 244co, 3 43 i m p l e m e n t e d in S m a l l t a l k 2 4 9 aluminu m a l l oy 76 Ambassador , see also P R O X Y C++idio m 2 08 A n a l o g C l o c k 3 03 a n a l y s i s o b j e c t model transformin g to d e s i g n objec t m o d e l 3 53 a n c e s t o r c l a ss 3 6 1, s ee also c l a s s, paren t A n d e r s o n , B r u ce x i, 3 57 AndEx p 2 53 Andre w T o o l k i t u se of O B S E R V E R 3 03 A p p l i c a t i o n 1 0 7 ,1 0 7 c, 223o, 224ci, 2 3 1 , 3 2 5 , 3 2 5c a p p l i c a t i o n p r o g r a m s 25 A p p l i c a t i o n W i n d o w 5 3 ,5 4 c, 55c, 1 5 7 ,2 3 3 c, 234c ArrayComposito r 42c, 3 1 5 , 3 1 5 c, 3 22 A S C I I 7 S t r e a m 1 8 3 ,1 8 3c a s p e c t of an o b j e c t 2 98 A s s i g n m e n t N o d e 333c a s s o c i a t i o n s , s e e a l s o acquaintance, aggregation inOMT 364B o o l e a n e x p r e s s i o n 2 51 variabl e 2 5 4 B o o l e a n E x p 2 52 B o r d e r 44,45c, 46o B o r d e r D e c o r a t o r 176o, 176c, 1 80 B R I D G E 1 5 1 c o m p a r e d with A D A P T E R 2 19 c o n f i g u r e d by A B S T R A C T F A C T O R Y 1 55 in c a t a l o g summar y 8 L e x i 's u se of 58 u se of d e l e g a t i o n in 2 1 bridg e 1 52 b r o a d c a s t c o m m u n i c a t i o n 2 96 B U I L D E R 9 7 c o m p a r e d w i th A B S T R A C T F A C T O R Y 1 0 5 , 1 35 compare d with P R O T O T Y P E 1 35 in c a t a l o g summar y 8 u se in c o m p i l e r e x a m p l e 1 8 9 Builde r p a r t i c i p a n t of B U I L D E R 9 8, 9 8 c Bureaucra t 2 3 2, s ee also C H A I N OF R E S P O N S I B I L - I TY B u t t o n 5 0 c , 223o f 2 2 4 c i , 2 2 9 , 2 7 9 6 B T r ee 2 02 b a se c l a s s, s ee c l a s s, paren t B e c k, Kent x i, 3 57 B e d r o c k u se of D E C O R A T O R 1 7 9 , 1 8 0 b e h a v i o r a l patter n 1 0 , 2 2 1 c o m p a r i s o n b e t w e e n c l a ss a nd o b j e c t s c o pe 2 2 1 d i s c u s s i o n 3 45 b l a c k - b o x r e u s e , s ee r e u s e , b l a c k - b o x b l o c k , S m a l l t a l k 2 70 B N F f o r m 247 e x a m p l e s of 2 4 3 , 2 4 8 , 2 5 1 B o m b e d M a z e F a c t o r y 93 B o m b e d M a z e G a m e 1 15 B o m b e d W a l l 9 3 , 9 4 , 1 2 4 B o o c h C o m p o n e n t s u se of I T E R A T O R 2 70 u se of S T R A T E G Y 3 2 3 B o o c h , Grad y xiii, 2 60 B o o c h method 3 6 3C 4 C a l d e r , P a ul 3 3 , 38 c a l l b a c k functio n 2 35 Caretaker participan t of M E M E N T O 2 8 5 ,2 8 5 c, 2 8 6i C a r g i l l , T om 3 08 C H A I N OF R E S P O N S I B I L I T Y 2 2 3 c o m b i n e d with C O M P O S I T E 1 6 6 , 2 3 2 c o m p a r e d with M E D I A T O R 3 48 compare d w i th O B S E R V E R 3 48 d e f i n e d by p a r e n t r e f e r e n c e s 1 6 6 , 2 3 2 in c a t a l o g summar y 8 u se of d e l e g a t i o n in 2 1 C h a n g e M a n a g e r 282,299, 300c C h a r a c t e r 38,38c c h a r a c t e r r e p r e s e n t e d as o b j e c t 3 8 , 1 9 5 - 1 9 6 C h e s h i r e C at 1 55 C h o i c e s o p e r a t i n g s y s t e m u se of F A C A D E 1 92 u se of P R O X Y 2 0 9 c l a ss 14,35 9 a b s t r a c t , s ee abstrac t c l a ss a d a p t e r , s e e a d a p t e r , class C ptgI N D E X 385 compare d with type 16 c o n c r e t e , see concret e c l a ss derive d 3 60 friend , see friend c l a ss i n a b i l i t y to a l t er 24 inheritance , see inheritanc e instanc e 15 l i b r a r y , s ee t o o l k i t mixin , see mixin c l a ss notatio n f or 1 5 , 3 6 3 paren t 1 5 , 3 6 1 s u b c l a s s 15 t e m p l a t e , see t e m p l a t e c l a ss diagra m 3 6 3 , 3 6 5 c , 3 59 c l a ss hierarchy addin g o p e r a t i o n s to 3 56 connectin g p a r a l l e l 1 0 9 , 2 5 8 e x p l o s i o n 2 5 , 4 3 , 1 5 1 , 1 7 7 minimizin g s i ze of 1 1 3 , 1 2 0 , 1 7 7 , 2 7 7 , 3 1 7 , 3 48 v i s i t i n g m u l t i p l e 3 3 6 c l a ss operatio n 3 59 a l t e r n a t i v e s p r o v i d e d by S I N G L E T O N 1 2 8 C l i e n t participan t of A B S T R A C T F A C T O R Y 88c, 89 p a r t i c i p a n t of A D A P T E R 1 4 1 ,1 4 1c participan t of BUILDE R 98,98c, 99i participan t of C H A I N O F R E S P O N S I B I L I T Y 225d, 226,348i participan t of COMMAN D 2 3 6 , 2 3 6 c , 237z p a r t i c i p a n t of C O M P O S I T E 164c, 1 65 participan t of FLYWEIGH T 198c, 1 99 participan t of INTERPRETE R 245c, 2 46 participan t of P R O T O T Y P E 1 1 9 ,1 1 9 c c l i e nt 11 i s o l a t i n g c o n c r e t e c l a s s e s from 8 9 C l o c k T i m e r 3 02 c l o ne operatio n 1 1 7 u s ed in P R O T O T Y P E 1 17 implementin g 1 2 1 c l o n e d o b j e c t 1 17 initializin g 1 2 1 C L OS 4,260 , 3 38 c l o s u r e 2 6 0 , 2 6 7 C o a d , Peter 3 57 c o de structure run-tim e versu s c o m p i l e - t i m e 23 CodeGenerationVisito r 3 3 2c C o l l e a g u e communicatin g with Mediato r 2 7 8 , 2 8 2 participan t of M E D I A T O R 2 7 6 c o , 2 7 7, 348i COMMAN D 2 33 c o m b i n e d with MEMENT O 239,28 7 c o m b i n e d w i t h PROTOTYPE 2 3 8in catalo g summar y 8 u se in Lexi 6 4 Comman d 6 0, 61 c, 2 3 3 , 2 3 3 c , 2 39 configure d in Menulte m 61 h i s t o r y of 62 participan t of COMMAN D 236,236c , 237z, 3 4 7i c o m m a n d C++ i d i o m , see functo r copyin g befor e e x e c u t i o n 2 38 h i s t o r y , see histor y l i st implemente d throug h C++ template s 2 3 9 , 2 40 intelligenc e of 2 3 8 commo n vocabular y 3 52 communication encapsulate d or distribute d 3 46 b e t w e e n S t r a t e g y a nd C o n t e x t 3 18 betwee n Visito r a nd Elemen t 3 3 7 compilatio n dependencie s r e d u c i n g u s i ng F A C A D E 1 8 8 Compile r 185,186c , 1 91 c o m p i l e r exampl e in FACAD E 185,186c , 1 88 implemente d using V I S I T O R 3 31 S m a l l t a l k , s ee R TL S m a l l t a l k c o m p i l e r Componen t participan t of C O M P O S I T E 164c, 1 6 5 , 1 6 8 participan t of D E C O R A T O R 1 7 7 ,1 77 c C O M P O S I T E 1 63 c a c h i n g c h i l d r e n of 1 69 c h i ld managemen t 1 67 c o m b i n e d with INTERPRETE R 2 55 c o m b i n e d with I T E R A T O R 2 62 c o m b i n e d with V I S I T O R 3 39 c o m p a r e d w i th D E C O R A T O R 2 1 9 - 2 2 0 compare d with INTERPRETE R 247 data structur e for 1 6 9 , 1 7 0 in c a t a l o g summar y 8 interfac e of 1 67 L e x i ' s u se of 40 paren t reference s 1 66 sharin g component s 1 66 u se in M o d e l / V i e w / C o n t r o l l e r 5 Composit e participan t of C O M P O S I T E 164c, 1 6 5 ,1 6 5 o , 1 68 CompositeEquipmen t 1 71 C o m p o s i t i o n 41,42c, 3 1 5 ,3 1 5 c, 3 20 composition , see objec t compositio n C o m p o s i t o r 4 1 , 4 2 , 3 1 5 , 3 1 5 c , 3 2 1 interfac e 41 CompressingStream 1 8 3 c , 184 ptg3 86 INDEX concret e c l a s s, 1 5 , 3 5 9 avoidin g specificatio n of 24 i s o l a t i n g c l i e n t s from 8 9 ConcreteAggregat e participan t of I T E R A T O R 259,259c ConcreteBuilde r participan t of BUILDE R 98c, 99, 99i ConcreteComman d participan t of COMMAN D 236,236c , 238 ConcreteComponen t participan t of D E C O R A T O R 1 7 7 ,1 7 7 c ConcreteDecorato r participan t of D E C O R A T O R 2 7 7 c, 1 7 8 ConcreteElemen t participan t of V I S I T O R 334,334c , 335i ConcreteFactor y participan t of A B S T R A C T F A C T O R Y 8 9 ConcreteFlyweigh t participan t of FLYWEIGH T 198co, 1 9 9 ConcreteHandle r participan t of CHAI N O F RESPONSIBILIT Y 2 2 5 c, 2 26 Concretelmplementor participan t of BRIDG E 153c, 1 54 Concretelterator participan t of I T E R A T O R 259,259c C o n c r e t e O b s e r v e r participan t of O B S E R V E R 294c, 295,295i ConcreteProduct participan t of A B S T R A C T F A C T O R Y 8 8, 89 participan t of FACTOR Y METHO D 1 0 8 ,1 0 8 c ConcretePrototyp e participan t of P R O T O T Y P E 1 1 9 ,1 1 9 c C o n c r e t e S t a t e participan t of S T A T E 3 0 7 ,3 0 7 c ConcreteStrateg y participan t of STRATEG Y 316c, 3 1 6 ConcreteSubjec t participan t of OBSERVE R 294c, 2 9 5 , 2 9 5 ? Concret e Visito r participan t 3 3 4, 334c, 3 3 5 * conditiona l statement s avoidin g using S T A T E 3 07 avoidin g using S T R A T E G Y 3 1 7 c o n s o l i d a t i o n p h a se of lifecycl e 3 53 constrain t s o l v i n g 282,283 see also ThingLab , Q O C A ConstraintSolve r 2 8 3 - 2 8 4 , 2 88 constructo r 3 60 Contex t 2 5 2 participan t of INTERPRETE R 2 4 5 c, 2 46 participan t of S T A T E 3 0 6, 306c participant of STRATEGY 3 1 6 c , 316contro l flow e n c a p s u l a t i n g , see M E D I A T O R i n v e r s i o n of 2 7 C o p l i e n , Jame s 1 2 5 , 1 5 3 , 1 6 0 , 2 4 2 , 3 1 3 , 3 5 7 c o p y deep 1 21 on write 2 10 shallo w 1 2 1 CountingMazeBuilde r 1 04 couplin g 3 6 0 a b s t r a c t 1 8 8 , 2 7 8 , 2 9 6 , 3 59 l o o se 24,26 , 2 7 7 , 3 4 7 , see also d e c o u p l i n g r e d u c i n g 2 4 , 1 8 7 , 1 8 8 , 2 2 3 , 2 2 6 tight 2 4 CreateMaz e o p e r a t i o n 84 A B S T R A C T F A C T O R Y varian t ( C + + ) 92 A B S T R A C T F A C T O R Y varian t ( S m a l l t a l k ) 94 BUILDE R varian t 1 02 F A C T O R Y M E T H O D varian t 1 14 P R O T O T Y P E varian t (Smalltalk ) 1 2 3 , 1 2 5 c r e a t i o n a l patter n 1 0 ,8 1 d i s c u s s i o n of 1 3 5 C r e a t o r participan t of F A C T O R Y METHO D 1 0 8 ,1 0 8c i m p l e m e n t a t i o n of 1 1 1, 1 1 3 Cursor , see I T E R A T O R c u r s o r , s e e i t e r a t o r , c u r s o r D data membe r 360 DebuggingGlyp h 1 82 D E C O R A T O R 1 7 5 compare d with ADAPTE R 1 7 5 , 1 8 4 compare d with C O M P O S I T E 4 4 , 1 7 3 , 2 1 9 - 2 20 compare d with P R O X Y 2 1 6 , 2 1 9 - 2 2 0 compare d with S T R A T E G Y 1 79 in catalo g summar y 8 L e x i ' s use of 45c, 46o, 47 lightweigh t versu s heavyweigh t 1 7 9 Decorato r 276,18 0 participan t of D E C O R A T O R 1 7 7 , 1 7 7 c , 180o decorato r 1 75 d e c o u p l i n g , see also c o u p l i n g , l o o s e interfac e a nd implementatio n 1 54 s e n d e r s a nd r e c e i v e r s 3 4 6 deep c o p y , s ee c o p y, d e ep delegat e 2 0 , 1 4 4 d e l e g a t i o n 2 0 , 278,360 compared with inheritance 2 0 - 2 1 ptgI N D E X 387 i m p l e m e n t i n g pluggabl e adapter s with 1 4 4 pattern s that rely on 21 d e p e n d e n c y 2 9 3 m a n a g i n g c o m p l e x 2 99 D e p e n d e n t s , s ee O B S E R V E R d e r i v e d c l a s s, s ee c l a s s, d e r i v e d d e s i g n deja-vu 2 d e n s i t y 3 58 d o c u m e n t i n g with pattern s 2 7 , 3 5 2 for c h a n g e 23 p o e t r y of 3 56 f or r e u se 2 3 d e s i g n o b j e c t mode l 3 53 d e s i g n patter n 3 6 0 adjunc t to d e s i g n m e t h o d o l o g y 3 53 a s p e c t s of d e s i g n v a r i e d by 30 benefit s 3 51 c a t a l o g summar y 8 c a t a l o g templat e 6 c l a s s i f i c a t i o n 10 c o m p a r e d with framework s 28 diagra m of r e l a t i o n s h i p s 12 d o c u m e n t i n g d e s i g n s with 2 7 , 3 5 2 e s s e n t i a l e l e m e n t s 3 findin g 3 55 h i s t o r y of 3 55 h ow to u se 29 p u r p o s e 10 refactorin g with 3 53 s c o pe 10 s e l e c t i o n of 28 t a b le of 1 0 destructo r 3 6 0 e n s u r i n g iterator' s is c a l l ed 2 6 6 D i a l o g 2 2 3 , 2 3 1 D i a l o g D i r e c t o r 2 7 4 o, 2 7 5 c z , 2 78 D i a l o g W i n d o w 53,54c, 55c D i g i t a l C l o c k 3 02 D i r e c t o r participan t of BUILDE R 98c, 9 9, 9 9i D i r e c t o r y B r o w s e r 144,144c , 145c discretionar y glyph 75 d i s p a t c h d o u b l e 3 38 multipl e 3 39 s i n g le 3 3 8 D oc 2 0 5, s ee also L e xi D o c u m e n t 1 0 7 ,1 0 7 c , 233c, 234,234c , 325,325c document c o l or 4 2, 3 22 formatting 4 0l o g i c a l structur e 40 p h y s i c a l structur e 3 5 documentin g d e s i g n with pattern s 2 7, 3 52 doesNotUnderstan d m e s s a g e u s ed to implemen t CHAI N OF R E S P O N S I B I L I T Y 2 29 u s ed to implemen t P R O X Y 2 1 2 , 2 1 5 D o m a i n 192,192c D o or 82c,83 e x t e n s i o n s f or P R O T O T Y P E 1 23 d o u b l e - d i s p a t c h , see d i s p a t c h , doubl e downcas t 91 Dyla n 4 u se of M E M E N T O 2 89 dynami c bindin g 14,36 0 d y n a m i c i n h e r i t a n c e 3 09 dynamic_cast in C++ 9 1 , 1 6 8 e - m a i l addres s r e a c h i n g the author s xii E i f f e l 1 7, 21 E l e m e n t p a r t i c i p a n t of V I S I T O R 3 3 4 ,3 3 4c e n c a p s u l a t i o n 1 1 , 3 6 0 breakin g with i n h e r i t a n c e 19 breakin g with V I S I T O R 3 37 preservin g b o u n d a r i e s of 2 86 of a l g o r i t h m s , s ee S T R A T E G Y of comple x updat e s e m a n t i c s , 2 9 9, s ee also C h a n g e M a n a g e r of c o n c e p t that varie s 29,54 of documen t analysi s a nd traversa l 71 of protoco l b e t w e e n o b j e c t s , s ee M E D I A T O R of h ow o b j e c t s a re c r e a t e d , s ee A B S T R A C T F A C T O R Y , B U I L D E R , P R O T O T Y P E of traversal , s ee I T E R A T O R of r e q u e s t s 5 9, s ee also COMMAN D of s t a t e - s p e c i f i c b e h a v i o r , s ee S T A T E EnchantedMazeFactor y 93 e n v e l o p e - l e t t e r idiom 3 13 Equipmen t 1 7 0 , 3 4 0 EquipmentVisito r 3 41 error accumulation avoidin g durin g undo/red o 239 ET++ u seof A B S T R A C T F A C T O R Y 95 u seof A D A P T E R 1 2 6 , 1 4 8 u seof B R I D G E 1 60 u seof B U I L D E R 1 05 u s eo f C H A I N OF R E S P O N S I B I L I T Y 2 3 2 E ptg3 88 INDEX u seof C O M P O S I T E 1 72 u seof C O M M A N D 2 42 u seof D E C O R A T O R 1 8 2 , 1 8 3 useof FACAD E 1 92 u seof F A C T O R Y M E T H O D 1 15 u seof F L Y W E I G H T 2 06 u seof I T E R A T O R 2 61 u seof M E D I A T O R 2 81 u seof O B S E R V E R 3 03 u seof P R O T O T Y P E 1 2 0 , 1 2 5 u seof P R O X Y 2 16 u seof S T R A T E G Y 3 2 2 - 3 2 3 ET++SwapsManage r u se of S T R A T E G Y 3 2 3 ETgd b 1 25 e x p a n s i o n p h a se of l i f e c y c l e 3 5 3 , 3 5 4 e x p l o s i o n , s ee c l a ss hierarchy , e x p l o s i o n E x t e n d e d H a n d l e r 2 28 externa l iterator , see iterator , externa l e x t r i n s i c state, s e e s t a t e , extrinsicframewor k 26,36 0 c o m p a r e d with d e s i g n p a t t e r n s 28 documentin g with pattern s 27 graphica l edito r 1 17 see Bedroc k s ee C h o i c e s see ET++ see HotDra w see M a c A p p see N E X T S T E P see N e XT A p p K i t see RAp p see RTL Smalltal k c o m p i l e r see Unidra w trade-offs a s s o c i a t e d with 27 F r e s c o 3 44 friend c l a ss 3 6 0 u s ed to grant I t e r a t o r p r i v i l e g e d a c c e s s to c o l l e c t i o n 2 6 2 u s ed to s u p p o r t M e m e n t o 2 87 functo r 242 f u t u r e cash flow 323F F A C A D E 1 85 c o m p a r e d with M E D I A T O R 1 9 3 , 2 8 2 in catalo g summar y 8 u se in C h o i c e s 1 9 2 F a c a d e participan t of FACAD E 185c, 1 8 7 ,1 8 7 c facad e 1 85 F A C T O R Y METHO D 1 0 7 in c a t a l o g s u m m a r y 8 language-specifi c variant s 1 12 parameterize d with produc t identifie r 1 10 u s ed to implemen t A B S T R A C T F A C T O R Y 9 0 , 9 1 , 1 1 0 u s ed to creat e an iterato r 258 F i l e S t r e a m 1 8 3 ,1 8 3c F L Y W E I G H T 1 9 5 combine d with C O M P O S I T E 1 6 7 , 2 0 0 c o m b i n e d with I N T E R P R E T E R 2 47 combine d with S T A T E 3 08 in catalo g summar y 9 L e x i ' s u se of 39 participan t of F L Y W E I G H T 198,198co flyweigh t 196,196o managin g s h a r e d 2 0 0 F l y w e i g h t F a c t o r y 2 04 participan t of F L Y W E I G H T 198co, 1 9 9 F o n t D i a l o g D i r e c t o r 2 7 4 , 2 7 4 o , 2 7 5 cf F o o t e , Brian 3 53 forwarding requests 2 2 9G g db 1 26 g e n e r i c s 21 Glyp h 38,38c, 42c, 430,45c, 46o, 50c, 54c, 67c implemente d as a f l y w e i g h t 2 0 1 - 2 0 4 interfac e 39 interfac e for traversa l 66 G l u e , s ee F A C A D E GlyphArraylterato r 67,67 c GNU g db 1 26 gramma r 243 maintainin g c o m p l e x 2 47 Graphi c 163c, 208c, 213 GraphicToo l Il7,118c guarantee d r e c e i p t of r e q u e s t 2 26 GUIFactory 4 9 ,50c, 5 1 H Hamle t 1 Handle/Body , see also B R I D G E C++idio m 1 5 5 , 1 6 0 Handler participan t of CHAI N OF R E S P O N S I B I L I T Y 2 2 5 , 2 2 5 c z , 348i ptgINDEX 389 hardwar e platform i s o l a t i n g applicatio n from 2 4 h e l p context-sensitiv e 2 23 o n - l i n e 2 2 3 HelpHandle r 224,224c , 227,229 histor y l i st 6 2 - 6 4 , 2 3 8 c o p y i n g command s o n to 2 38 H o l l y w o o d principl e 3 27 h o ok operatio n 3 2 6 , 3 2 8 inA B S T R A C T F A C T O R Y 1 09 inF A C T O R Y M E T H O D 1 09 inP R O X Y 2 12 inT E M P L A T E M E T H O D 3 2 6 , 3 2 8 HotDra w u se of S T A T E 3 1 3 h ub of communicatio n 2 74 hyphenation 6 4 I I c o n W i n d o w 5 3 , 5 4 c , 1 5 1 - 1 5 2 , 1 5 1 c, 1 57 Imag e 2 0 7 o, 208c, 2 13 ImageProx y 207o,208c Implementor participan t of BRIDG E 153c, 1 54 i m p l i c i t r e c e i v e r , s ee r e c e i v e r , implici t incrementa l c h a n g e s 2 87 inheritanc e 1 5 , 3 6 0 C++, define d in 17 c l a ss versu s interfac e 16 c o m b i n e d with polymorphis m 18 compare d with o b j e c t c o m p o s i t i o n 1 8 , 1 7 8 compare d with parameterize d types 21 dynami c 3 09 Eiffel , define d in 17 implementatio n 1 7, 3 60 interfac e 1 7 , 3 6 0 m i x i n , see mixin c l a ss n o t a t i o n for 1 5 , 3 6 4 , 365c prope r u se of 18 r e u se throug h 18 S m a l l t a l k , define d in 1 7 i n o r d e r traversal , see traversal , inorde r i n s t a n c e , see also c l a s s, i n s t a n c e ensurin g u n i q u e n e s s , s ee S I N G L E T O N variabl e 1 5 , 3 6 0 instantiatio n 15 abstractin g p r o c e s s of 48 notation for 15, 364, 365c integrated circuit 323interactio n diagra m 7, 3 66 in B U I L D E R 9 9? in CHAI N OF R E S P O N S I B I L I T Y 224z, 348i in COMMAN D 2 3 7 z, 347i in M E D I A T O R 274i, 348i in M E M E N T O 286i in O B S E R V E R 295i, 347i in V I S I T O R 3 3 5z L e x i ' s V i s i t o r 74i interfac e 13 benefit s of programmin g to 18 b l o at 2 57 c o n v e r s i o n , see ADAPTE R for iteratio n 262 i n h e r i t a n c e 1 3 , 17 narro w versu s wide in MEMENT O 2 85 specifyin g in C ++ 17 simplifyin g s u b s y s t e m s , see FACADE interna l iterator , see iterator , interna l INTERPRETE R 2 4 3 c o m b i n e d with C O M P O S I T E 2 55 c o m b i n e d with V I S I T O R 247,25 5 in c a t a l o g summary 9 Interview s u se of A B S T R A C T F A C T O R Y 95 u se of ADAPTE R 1 48 u se of C O M M A N D 2 42 u se of C O M P O S I T E 1 72 u se of D E C O R A T O R 1 82 u se of F L Y W E I G H T 2 05 u se of O B S E R V E R 3 03 u se of S I N G L E T O N 1 33 u se of S T R A T E G Y 3 2 0 , 3 2 2 - 3 2 3 i n t r i n s i c s t a t e, see s t a t e, intrinsi c i n v e r s i o n of contro l flow 27 invitatio n 3 58 Invoker participan t of COMMAN D 2 3 6 , 2 3 6 c , 237z, 347i IRIS I n v e n t o r u se of V I S I T O R 3 44 I T E R A T O R 2 5 7 c o m b i n e d with C O M P O S I T E 3 62 c o m b i n e d with V I S I T O R 3 39 compare d with V I S I T O R 3 36 in catalo g summar y 9 u se in L e xi 6 9 Iterato r 6 7, 67c, 258c, 2 6 3 , 3 7 2 participan t of I T E R A T O R 259,259c iterato r 6 6, 2 5 7 , 3 3 9 a c c e s s to a g g r e g a t e 2 62 a c t i ve 2 60 alternativ e to in S m a l l t a l k 2 70 controlling 2 6 0 ptg3 9 0 INDEX curso r 2 61 ensurin g deletio n of 2 66 externa l 260,339,26 9 interfac e to 2 6 1 , 2 6 3 interna l 260,267,339 , see also ListTraverse r null 2 6 2, see also Nulllterato r over recursiv e structure s 262 parameterize d with an operatio n 267 p a s s i v e 2 60 polymorphi c 2 5 8 , 2 6 1 , 2 6 5 privilege d a c c e s s to Aggregat e 2 62 robust 2 6 1M K Kit, see also A B S T R A C T FACTOR Y i n Inter V i e w s 9 5 Knuth, Donald 3 5 7 L lazy initializatio n 1 12 Leaf participan t of C O M P O S I T E 164c, 1 6 5 , 1 6 5 0 , 1 68 L e m p e l - Z i v compressio n 1 83 Lexi 3 3 documen t structur e 35 documen t traversa l and analysi s 64 look-and-fee l standard s 47 multipl e windo w system s 51 user interfac e 3 3, 34 user operation s 5 8 libg+ + use of BRIDG E 1 6 0 lifecycl e of softwar e 3 5 3, 3 54 Linton , M a rk 3 44 L i st 2 5 7 , 2 5 7 c , 258c, 2 6 3 , 3 6 9 l i st b ox 2 74 l i st traversa l 2 57 ListBo x 274o, 275ci, 279 Listlterato r 6 7, 2 5 7 , 2 5 7 c , 258c, 264,37 2 ListTraverse r 2 67 LiteralExpressio n 244co, 3 4 4 implemente d in Smalltal k 2 50 look-and-feel standards 8 7 support in Lexi 3 5 , 4 7MacAp p u se of CHAI N OF R E S P O N S I B I L I T Y 2 32 use of COMMAN D 2 42 u se of D E C O R A T O R 1 7 9 , 1 8 0 u se of FACTOR Y M E T H O D 1 1 3 , 1 1 5 Macbet h 1 MacFactor y 50c Macintos h 4 8, 52 MacroComman d 2 3 5 , 2 3 5 c , 2 41 magi c token 3 46 Manipulato r 1 0 9, llOc M a p S i t e 8 2, 8 2c Marriag e of C o n v e n i e n c e 1 49 Maze S2c,8 4 MazeBuide r 1 01 MazeFactor y 9 2 as singleto n 1 33 MazeGam e 8 4 , 1 1 4 MazePrototypeFactor y 1 22 MEDIATO R 2 7 3 c o m b i n e d with OBSERVE R 299 compare d with CHAI N OF R E S P O N S I B I L I T Y 3 48 compare d with FACAD E 2 82 compare d with O B S E R V E R 3 4 6 , 3 4 8 in catalo g summar y 9 u se of delegatio n in 2 1 Mediato r communicatin g with Colleagu e 2 7 8, 2 82 participan t of MEDIATO R 2 7 6 c o , 277,348i omittin g abstrac t c l a ss of 2 7 8 mediato r 2 74 membe r functio n 3 6 1, s ee also operatio n M E M E N T O 2 8 3 in catalo g summar y 9 Memento c o m b i n e d with COMMAN D 2 3 9 , 2 8 7 participan t of MEMENT O 285,285c , 286i mement o 2 84 c o s ts a s s o c i a t e d with 2 86 languag e suppor t for 287 MemoryStrea m 1 83 Menu 50c,233c menu 2 3 3 configurin g 6 0, 2 34 pull-dow n 5 8 Menulte m 5 9, 6 1 c, 2 3 3 , 2 3 3 c metaclas s 1 3 3 , 3 6 1 metho d 3 6 1, s ee also operatio n Microsof t Window s 52 mixin class 1 6 , 1 6 c , 361 ptgI N D E X 391 Model/View/Controlle r 4 ,5 u se of C O M P O S I T E 5 , 1 72 u se of F A C T O R Y M E T H O D 1 15 u se of O B S E R V E R 5 , 3 03 u se of S T R A T E G Y 6 M o n o G l y p h 44,45c M o t if 35,47,48,49,51 , 87 MotifFactor y 4 9, 5 0c multipl e d i s p a t c h , see d i s p a t c h , multipl e m u l t i p l e i n h e r i t a n c e , see also m i x in c l a s s u s ed to i m p l e m e n t c l a ss adapte r 1 41 u s ed to i m p l e m e n t B R I D G E 1 5 6 M V C , see Model/View/Controlle r M e y e r , Bertrand 149 N namin g c o n v e n t i o n s 2 9 , 31 F A C T O R Y M E T H O D 3 1 , 1 13 T E M P L A T E M E T H O D 3 29 V I S I T O R 3 3 7 N e XT AppKi t u se of A D A P T E R 1 49 u se of B R I D G E 1 60 u se of C H A I N OF R E S P O N S I B I L I T Y 2 32 u se of T E M P L A T E M E T H O D 3 2 9 N E X T S T E P u se of A D A P T E R 1 45 u se of P R O X Y 2 0 8 , 2 1 2 , 2 1 6 Node 3 3 3c N o d e V i s i t o r 3 3 2c nontermina l s y m b o l 2 46 N o n T e r m i n a l E x p r e s s i o n participan t of I N T E R P R E T E R 245c, 2 46 notificatio n 2 94 null i t e r a t o r , see iterator , null N u l l l t e r a t o r 6 7 c, 6 7 - 6 8 , 2 6 2 NXProxy 2 0 8 , 2 1 2 o objec t 1 1 , 3 6 1 a d a p t e r , s ee a d a p t e r , o b j e c t acquaintanc e 22 aggregatio n 22 as argumen t to r e q u e s t 3 45 a s p e c t of 2 98 avoidin g d e p e n d e n c e on implementation of 24 c o m p o s i t i o n , s e e o b j e c t c o m p o s i t i o nfindin g 11 granularit y of 1 3, s ee also F L Y W E I G H T g u ts 1 79 referenc e 3 61 s h a r e d , s ee F L Y W E I G H T s k in 1 79 specifyin g implementatio n of 14 specifyin g interfac e to 1 3 o b j e c t c o m p o s i t i o n 1 8, 3 61 c o m p a r e d with inheritanc e 1 8 - 20 compare d with parameterize d types 22 r e u se throug h 1 9 o b j e c t diagra m 3 6 4 , 3 6 1 O b j e c t s for S t a t e s , see S T A T E O b j e c t M o d e l i n g T e c h n i q u e 7,14,363,36 4 O b j e c t i v e C 9 0 , 1 2 0 , 1 2 1 , 1 3 5 , 1 4 4 Objector y 3 63 O b j e c t W i n d o w s u se of I T E R A T O R 2 70 u se of S T R A T E G Y 3 2 3 ObjectWorksXSmalltalk , see also S m a l l t a l k u se of A D A P T E R 1 4 8 - 1 4 9 u se of D E C O R A T O R 1 82 u se of FACAD E 1 9 1 O B S E R V E R 2 93 c o m b i n e d with M E D I A T O R 2 7 8 , 2 8 2 compare d with CHAI N OF R E S P O N S I B I L I T Y 3 4 6 , 3 4 8 compare d with M E D I A T O R 3 4 6 , 3 4 8 in Model/View/Controlle r 5 in catalo g summar y 8 l i m i t i n g unexpecte d update s in 2 9 6 O b s e r v e r 3 00 c o m b i n i n g with Subjec t 3 00 participan t of O B S E R V E R 294c, 295,295i, 300c, 347i O M T, s ee O b j e c t M o d e l i n g T e c h n i q u e operatio n 1 1 , 3 6 1 abstrac t 1 5 , 3 5 9 addin g to c l a s s e s 3 35 avoidin g d e p e n d e n c e on specifi c 24 c l a s s, s ee c l a ss operatio n c o n c r e t e 3 27 d i s p a t c h , see dispatc h h o o k , see h o ok operatio n overridin g 16 primitiv e 3 2 7 , 3 2 9 Orbix u se of F A C T O R Y M E T H O D 1 1 6 O r i g i n a t o r participant of MEMENTO 2 8 5 , 285c, 286i originator 2 8 4 ptg3 9 2 INDEX overloadin g u s ed to implemen t PROX Y 2 11 u s e d to implement V I S I T O R 7 2 , 3 3 7 parameterize d types 2 1, 3 6 1, s ee also templat e compare d with inheritanc e 22 compare d with c o m p o s i t i o n 2 2 paren t c l a s s , see c l a s s, paren t paren t references define d in C O M P O S I T E 1 66 parse r 247 p a r t - w h o l e , s ee r e c u r s i v e c o m p o s i t i o n see also aggregatio n P a s c a l 4 p a s s i v e iterator , see iterator , passiv e PassivityWrappe r 1 82 path specifyin g m u l t i - s e g m e n t s h a p e s 57 patter n languag e 3 56 Patter n Language s of Program s 3 57 patter n matchin g 243 p e r s i s t e n c e 2 09 Pictur e 163c, 164o P L o P , see Patter n Language s of Program s pluggabl e adapte r 1 4 2 implementatio n of 1 4 4 - 1 4 5 , 1 4 4 c , 145c, 148,149c PMFactor y 50c PMIconWindo w 1 5 1 ,1 5 1c P M W i n d o w 1 5 1 ,1 5 1c PMWindowIm p 152,152c , 1 5 8 - 1 5 9 Point 3 73 P o l i c y , s ee STRATEG Y polymorphi c iteratio n 2 5 8 i m p l e m e n t i n g in C ++ 2 61 polymorphis m 1 4, 3 6 1 u s ed with inheritanc e 18 postorde r traversal , see traversal , postorde r preorde r traversal , see traversal , preorde r Preorderlterato r 6 7 membe r function s 6 8 - 69 Presentatio n Manage r 35,48,52,56,57 , 8 7 , 1 5 1 , 1 58 P r i c i n g V i s i t o r 3 41 PrintDialo g 223o,224i privat e inheritanc e 3 6 1, s ee also inheritance, implementatio n P r o d u c t participan t of BUILDE R 98c, 99 participant o f F A C T O R Y METHOD 1 0 8 , 1 0 8 cproduc t object s 49 c h a n g i n g at run-tim e 1 19 creatin g in A B S T R A C T F A C T O R Y 90 exchangin g 89 famil y of 87 varyin g representatio n of 1 0 0 protectio n proxy , see proxy , protectio n p r o t o c o l 3 61 P R O T O T Y P E 1 1 7 compare d with A B S T R A C T F A C T O R Y 1 2 6 , 1 35 c o m b i n e d with COMMAN D 2 38 c o m p a r e d with F A C T O R Y M E T H O D 1 1 6 , 1 2 0 in catalo g summar y 9 participan t of P R O T O T Y P E 1 1 9 ,1 1 9c u s ed to implemen t A B S T R A C T FACTOR Y 9 0 prototyp e 1 17 prototyp e m a n a g e r 1 21 prototypin g p h a se of lifecycl e 3 53 P R O X Y 2 0 7 c o m b i n e d with ITERATO R 2 62 compare d with D E C O R A T O R 220 in catalo g summar y 9 Prox y participan t of PROX Y 209co, 209 proxy 2 07 protectio n 2 0 8 , 2 1 0 r e m o t e 2 0 8 , 2 1 0 virtua l 2 0 8 , 2 1 0 p s e u d o c o d e 16,16c, 365c P u b l i s h - S u b s c r i b e , s ee O B S E R V E R pull mode l 2 98 pull-dow n menu , see menu , pull-dow n purpos e of d e s i g n pattern , see d e s i g n pattern, purpos e p u s h model 298 Q Q O C A use of ADAPTE R 1 43 u se of I N T E R P R E T E R 2 55 use of MEMENTO 2 9 1 R RAp p u se of S T R A T E G Y 3 2 3 RealSubjec t participant of P R O X Y 2 0 9 c o , 210 ptgINDEX 393 R e c e i v e r participan t of COMMAND 236,236c , 237i, 2 38 receive r 3 6 1 decouplin g from sende r 3 46 implici t 224 R e ct 3 74 Rectangl e 20,20 c recursiv e c o m p o s i t i o n 3 6, s ee also C O M P O S I T E iteratio n o v er 2 62 of documen t structur e 36 of graphi c e l e m e n t s 1 63 of part-whol e structure s 1 6 4 r e d e s i g n , c a u s e s of 24 r e d o, see u n d o / r e d o refactorin g 3 2 6 , 3 5 3 referenc e countin g 2 10 RefinedAbstraction p a r t i c i p a n t of B R I D G E 153c, 1 54 regula r e x p r e s s i o n 2 4 3 representin g in Smalltal k 2 48 RegularExpressio n 244c remot e proxy , see proxy , remot e RepetitionExpressio n 244co, 3 4 3 implemente d in Smalltal k 2 49 r e q u e s t 1 1 , 3 6 1 automati c forwardin g of 229 encapsulatio n of 59, see also COMMAN D guarantee d receip t of 2 26 representin g 227 s e q u e n c i n g 2 3 4 Responde r 2 32 reuse black-bo x 1 9 , 3 5 4 , 3 5 9 by compositio n 19 by parameterize d types 21 by s u b c l a s s i n g 19 code 26 designin g for 2 4 - 25 framework s 26 interna l 25 maximizin g 23 of i m p l e m e n t a t i o n 18 toolkit s 26 white-bo x 1 9 , 3 5 4 , 3 6 2 R i ch T e xt Forma t 97 robus t iterator , see iterator , robus t R o om 82c,83 R T F, see Rich T e xt Forma t R T F R e a d e r 9 7, 9 7c R TL Smalltal k compiler u se of C O M P O S I T E 1 72 u s e o f S T R A T E G Y 3 2 3S s c o pe of desig n pattern , see desig n pattern , s c o p e Scrollba r 50c S c r o l l D e c o r a t o r 17 60,17 6c S c r o l l e r 4 5 ,4 6o S e lf 4,121,30 9 sender decouplin g from receive r 346 S e q u e n c e E x p r e s s i o n 244co, 3 4 3 implemente d in Smalltal k 2 49 s e q u e n c i n g r e q u e s t s 2 34 s h a l l o w c o p y , see c o p y , shallo w S h a p e 139,140c , 1 46 shrinkabilit y 3 20 signatur e 1 3 , 3 6 1 S i m p l e C o m p o s i t o r 42,42c, 3 1 5, 315c, 3 21 s i n g l e static a s s i g n m e n t form , S SA 1 72 s i n g l e - d i s p a t c h , see dispatch , s i n g le SINGLETO N 1 2 7 C++ implementatio n 1 2 9 , 1 3 1 in c a t a l o g summar y 9 registr y of 1 30 subclassin g 1 30 u s ed to implemen t ABSTRAC T FACTOR Y 90 S i n g l e t o n participan t of SINGLETO N 1 2 7 c, 1 2 8 Sketchpa d 1 25 S k i p L i s t 258c,265 skiplis t 2 58 Smalltalk-80 , see also Objec t Work s \\Smalltalk, Smalltalk/ V use of BUILDE R 1 05 u se of C O M P O S I T E 1 72 u se of FACTOR Y METHO D 1 15 u se of INTERPRETE R 2 51 u se of ITERATO R 2 70 u se of OBSERVE R 3 03 u se of S I N G L E T O N 1 33 use of V I S I T O R 3 4 4 Smalltalk/ V u se of INTERPRETE R 2 51 u se of MEDIATO R 2 7 8 , 2 8 1 smar t pointer s 209 smar t reference s 209 softwar e platform isolatin g applicatio n from 24 S o l i t a i r e , see SINGLETO N S o l v e r S t a t e 2 8 3 - 2 8 4 S P E C T a l k u se of INTERPRETE R 2 55 s p e l l i n g c h e c k i n g 64 ptg3 94 I N D E X S p e l l i n g C h e c k e r 7 1 - 73 S p e l l i n g C h e c k e r V i s i t o r 75 StandardMazeBuilde r 1 03 S T A T E 3 0 5 C++ idiom for, see envelope-lette r idiom in catalo g summary 9 u se of d e l e g a t i o n in 2 1 S t a t e participan t of S T A T E 306,306c s t a t e accumulatin g durin g traversa l 336 avoidin g inconsisten t 3 08 e x t r i n s i c 1 96 incrementa l change s to 287 intrinsi c 1 96 s h a r i n g 3 0 8, s ee also F L Y W E I G H T state transition s atomi c 3 08 definin g 3 08 table-drive n 3 0 8 S T R A T E G Y 3 15 c o m p a r e d with D E C O R A T O R 1 79 in catalo g summar y 8 L e x i ' s u se of 42 u se in C h o i c e s 1 93 use in Model/View/Controlle r 6 u se of delegatio n in 2 1 S t r a t e g y 180o makin g optiona l 3 20 participan t of S T R A T E G Y 316c, 3 1 6 s t r a t e g y 3 15 Strea m 1 8 3 ,1 8 3c StreamDecorato r 1 8 3 ,1 8 3c s t r e t c h a b i l i t y 3 20 Stroustrup , Bjarn e 1 60 structura l patter n 1 0 , 1 3 7 c o m p a r i s o n b e t w e e n c l a ss a nd o b j e c t s c o pe 1 3 7 d i s c u s s i o n of 2 19 s u b c l a s s , s ee c l a s s, s u b c l a s s subclassing extendin g functionalit y by 24 S u b j e c t 3 0 1 avoidin g danglin g reference s to 297 combinin g with O b s e r v e r 3 00 p a r t i c i p a n t of O B S E R V E R 294c, 2 9 5 ,2 9 5 i , 300c, 347i participan t of PROX Y 209co, 2 1 0 s u b j e c t 2 94 mappin g to observer s 297 o b s e r v i n g more than one 297 s u b s y s t e m 3 61 simplifying interface to, s e e F A C A D E s u b t y p e , s e e t y p e , s u b t y p es u c c e s s o r 2 24 connectin g in chain 2 27 implementin g chain of 2 2 5 s u p e r c l a s s 3 6 1, s ee also c l a s s, p a r e n t supertype , see t y p e, supertyp e S u r r o g a t e , s ee P R O X Y S u t h e r l a n d , I v an 1 25 swaps 3 2 3 T Targe t participan t of ADAPTE R 141,141c T CP p r o t o c o l 3 09 T C P C o n n e c t i o n 3 0 5 , 3 0 5 c , 3 09 T C P S t a t e 3 0 5 , 3 0 5 c , 3 1 0 t e m p l a t e 2 1, s ee also p a r a m e t e r i z e d t y p e s u s ed to i m p l e m e n t COMMAN D 2 39 used to implemen t F A C T O R Y M E T H O D 1 13 u s ed to i m p l e m e n t S T R A T E G Y 3 1 9 , 3 2 3 TEMPLAT E METHO D 3 25 c a l l i n g F a c t o r y Method s 1 16 in c a t a l o g summar y 9 namin g convention s for 329 u s ed to implemen t I T E R A T O R 2 7 0 t e m p l a t e m e t h o d 3 26 termina l s y m b o l 2 4 6 s h a r e d using F L Y W E I G H T 2 47 T e r m i n a l E x p r e s s i o n participan t of INTERPRETE R 2 4 5 c, 2 46 T gX 42,97,316 T e X C o m p o s i t o r 42c, 3 1 5 ,3 1 5 c, 3 22 T e x t S h a p e 1 3 9 ,1 4 0 c , 1 4 6 , 1 4 7 T e x t V i e w u se in A D A P T E R 1 3 9 ,1 4 0 c, 1 46 use in D E C O R A T O R 176c, 1760 ThingLa b 1 25 T H I N K use of COMMAN D 2 42 u se of O B S E R V E R 3 0 3 T o k e n , s ee M E M E N T O T o ol 1 1 7 ,1 1 8 c, 3 1 3 ,3 1 3c t o o l k i t 26,233,362 see Andre w see B o o c h Component s s ee F r e s c o see I n t e r v i e w s see I R IS Invento r see O b j e c t Window s s ee Q O C A see T H I N K T r a n s a c t i o n , s e e COMMAND ptgtransactio n 2 36 t r a n s p a r e n t e n c l o s u r e 4 3, s ee also D E C O R A T O R traversa l of aggregat e o b j e c t s , see also I T E R A T O R a c r o s s c l a ss hierarchie s 3 36 a s s i g n i n g r e s p o n s i b i l i t y f or in V I S I T O R 3 39 inorder , preorder , postorde r 262 T r e e A c c e s s o r D e l e g a t e 1 4 5 ,1 4 5c T r e e D i s p l a y 142,144, 144c , 145c two-wa y adapter , see adapter , two-wa y type 1 3 compare d with c l a ss 16 C++, definitio n in 17 Eiffel , definitio n in 17 S m a l l t a l k , d e f i n i t i o n in 17 subtyp e 13 supertyp e 1 3 t y p e - c h e c k i n g 3 32 to identif y request s at run-tim e 228 see also dynamic_cast T y p e C h e c k i n g V i s i t o r 3 3 2 c U undo/red o 5 9 - 6 0 , 62-64,235,238,283,28 7 avoidin g error accumulatio n durin g 239 Unidra w u se of ADAPTE R 1 43 u se of CHAI N OF R E S P O N S I B I L I T Y 2 32 u se of C O M M A N D 2 3 2 , 2 4 2 u se of F A C T O R Y M E T H O D 1 11 u seof I T E R A T O R 2 70 u seof M E D I A T O R 2 82 u seof MEMENT O 2 89 u seof O B S E R V E R 3 03 u seof P R O T O T Y P E 1 26 useof S T A T E 3 1 3 UnsharedConcreteFlyweigh t participan t of FLYWEIGH T 1 9 9 update s encapsulatin g comple x 2 99 l i m i t i n g u n e x p e c t e d 2 96 protoco l f or in O B S E R V E R 2 96 triggering 2 9 7INDEX 395 Virtua l Constructor , see F A C T O R Y M E T H O D virtua l m e m o r y framewor k 1 92 virtua l proxy , see proxy , virtua l V I S I T O R 3 3 1 c o m b i n e d with INTERPRETE R 247,25 5 in catalo g summar y 9 i n t e r a c t i o n d i a g r a m f or L e xi 74 u se in Lexi 76 u se in c o m p i l e r exampl e 1 9 0 , 3 3 1 u se of delegatio n in 2 1 Visito r 7 5 , 3 3 7 participan t of V I S I T O R 3 3 4 ,3 3 4 c v i s i t o r 7 4 , 3 3 2 V i s u a l C o m p o n e n t 1 7 6 ,17 6 c, 1 80 vocabulary, defining common 352 W Wall 82c, 83 w h i t e - b o x r e u s e , see reuse , white-bo x Widge t 2 2 4 c, 2 3 0 , 2 7 5 c , 2 78 w i d g e t 4 8, 8 7 Glyp h hierarch y 50 WidgetFactor y 87 Windo w 20c, 39, 54c, 55c, 152,156 configurin g with Windowlm p 5 7 - 58 interfac e 5 3 windo w s y s t e m s 35 s u p p o r t in L e xi 5 1 Windowlm p 55,55c, 152,152c , 1 57 s u b c l a s s e s 5 5 W i n d o w s , see Microsof t Window s WindowSystemFactor y 57 W r a p p e r , s ee A D A P T E R , D E C O R A T O R WYSIWYG 3 3 X X W i n d o w S y s t e m 5 2, 5 6 , 5 7 , 1 5 1 , 1 5 8 X l c o n W i n d o w 1 5 1 ,1 5 1c XWindo w 1 5 1 ,1 5 1c X W i n d o w I m p 1 5 2 , 1 5 2 c , 1 5 8 V Validato r 3 23 VariableEx p 2 52 V a r i a b l e R e f N o d e 3 3 3c ViewManager 2 8 1 , 2 8 1 o ptgI n t e r a c t i o n D i a g r a m N o t a t i o n Object Diagram NotationClass Diagram Notation ptg"
}