{
  "title": "Learning from Data Yaser S. Abu-Mostafa, Malik Magdon-Ismail & Hsuan-Tien Lin",
  "source": "Libros/Learning from Data Yaser S. Abu-Mostafa, Malik Magdon-Ismail & Hsuan-Tien Lin.pdf",
  "content": "LEARNING FROM DATA The book website AMLbook. com contains supporting material for instructors and readers. LEARNING FROM DATA A SHORT COURSE Yaser S. Abu-Mo stafa California Institute of Technology Malik Magdon-Ismail Rensselaer Polytechnic Institute Hsuan-Tien Lin National Taiwan University AMLbook.com Yaser S. Abu 1/fost afa Departments of Electrical Engineering and Computer Science California Institute of Technology Pasadena, CA 91125, USA yaser©caltech.edu HsuanTien Lin Department of Computer Science and Information Engineering National Taiwan University Taipei, 106, Taiwan htlin©csie.ntu.edu.tw ISBN 10: 1 60049 006 9 ISBN 13:9781 60049 006 4 Malik Magdon Ismail Department of Computer Science Rensselaer Polytechnic Institute Troy, NY 12180, USA magdon@cs.rpi.edu @2012 Yaser S. Abu Mostafa, Malik Magdon Ismail, Hsuan Tien Lin. 1.10 All rights reserved. This work may not be translated or copied in whole or in part without the written permission of the authors. No part of this publication may be reproduced, stored in a retrieval system, or transmitted in any form or by any means-electronic, mechanical, photocopying, scanning, or otherwise-without prior written permission of the authors, except as permitted under Section 107 or 108 of the 1976 United States Copyright Act. Limit of Liability /Disclaimer of Warranty: While the authors have used their best efforts in preparing this book, they make no representation or warranties with re spect to the accuracy or completeness of the contents of this book and specifically disclaim any implied warranties of merchantability or fitness for a particular purpose. No warranty may be created or extended by sales representatives or written sales materials. The advice and strategies contained herein may not be suitable for your situation. You should consult with a professional where appropriate. The authors shall not be liable for any loss of profit or any other commercial damages, including but not limited to special, incidental , consequential, or other damages. The use in this publication of tradenames, trademarks, service marks, and similar terms, even if they are not identified as such, is not to be taken as an expression of opinion as to whether or not they are subject to proprietary rights. This book was typeset by the authors and was printed and bound in the United States of America. To our teachers) and to our students Preface This book is designed for a short course on machine learning. It is a short course, not a hurried course. From over a decade of teaching this material, we have distilled what we believe to be the core topics that every student of the subject should know. We chose the title 'learning from data' that faithfully describes what the subject is about, and made it a point to cover the topics in a story-like fashion. Our hope is that the reader can learn all the fundamentals of the subject by reading the book cover to cover. Learning from data has distinct theoretical and practical tracks. If you read two books that focus on one track or the other, you may feel that you are reading about two different subjects altogether . In this book, we balance the theoretical and the practical, the mathematical and the heuristic. Our criterion for inclusion is relevance. Theory that establishes the conceptual framework for learning is included, and so are heuristics that impact the per­ formance of real learning systems. Strengths and weaknesses of the different parts are spelled out. Our philosophy is to say it like it is: what we know, what we don't know, and what we partially know. The book can be taught in exactly the order it is presented. The notable exception may be Chapter 2, which is the most theoretical chapter of the book. The theory of generalization that this chapter covers is central to learning from data, and we made an effort to make it accessible to a wide readership. However, instructors who are more interested in the practical side may skim over it, or delay it until after the practical methods of Chapter 3 are taught. You will notice that we included exercises (in gray boxes) throughout the text. The main purpose of these exercises is to engage the reader and enhance understanding of a particular topic being covered. Our reason for separating the exercises out is that they are not crucial to the logical flow. Nevertheless, they contain useful information, and we strongly encourage you to read them, even if you don't do them to completion. Instructors may find some of the exercises appropriate as 'easy' homework problems, and we also provide ad­ ditional problems of varying difficulty in the Problems section at the end of each chapter. To help instructors with preparing their lectures based on the book, we provide supporting material on the book's website (AMLbook. corn). There is also a forum that covers additional topics in learning from data. We will vii PREFACE discuss these further in the Epilogue of this book. Acknowledgment (in alphabetical order for each group): We would like to express our gratitude to the alumni of our Learning Systems Group at Caltech who gave us detailed expert feedback: Zehra Cataltepe, Ling Li, Amrit Pratap, and Joseph Sill. We thank the many students and colleagues who gave us useful feedback during the developmen t of this book, especially Chun-Wei Liu. The Caltech Library staff, especially Kristin Buxton and David McCaslin, have given us excellent advice and help in our self-publishing effort. We also thank Lucinda Acosta for her help throughout the writing of this book. Last, but not least, we would like to thank our families for their encourage­ ment, their support, and most of all their patience as they endured the time demands that writing a book has imposed on us. Yaser S. Abu-Mosta fa, Pasadena, California. Malik Magdon-Ismail, Troy, New York. Hsuan-Tien Lin, Taipei, Taiwan. March, 2012. viii /BV/D3/D2 /D8/CT/D2 /D8/D7/C8/D6/CT/CU/CP /CT /DA/CX/CX/BD /CC/CW/CT /C4/CT/CP/D6/D2/CX/D2/CV /C8/D6/D3/CQ/D0/CT/D1 /BD/BD/BA/BD /C8/D6/D3/CQ/D0/CT/D1 /CB/CT/D8/D9/D4 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BD/BA/BD/BA/BD /BV/D3/D1/D4 /D3/D2/CT/D2 /D8/D7 /D3/CU /C4/CT/CP/D6/D2/CX/D2/CV /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BF/BD/BA/BD/BA/BE /BT /CB/CX/D1/D4/D0/CT /C4/CT/CP/D6/D2/CX/D2/CV /C5/D3 /CS/CT/D0 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BH/BD/BA/BD/BA/BF /C4/CT/CP/D6/D2/CX/D2/CV /DA /CT/D6/D7/D9/D7 /BW/CT/D7/CX/CV/D2 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BL/BD/BA/BE /CC /DD/D4 /CT/D7 /D3/CU /C4/CT/CP/D6/D2/CX/D2/CV /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BD/BD/BA/BE/BA/BD /CB/D9/D4 /CT/D6/DA/CX/D7/CT/CS /C4/CT/CP/D6/D2/CX/D2/CV /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BD/BD/BA/BE/BA/BE /CA/CT/CX/D2/CU/D3/D6 /CT/D1/CT/D2 /D8 /C4/CT/CP/D6/D2/CX/D2/CV /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BE/BD/BA/BE/BA/BF /CD/D2/D7/D9/D4 /CT/D6/DA/CX/D7/CT/CS /C4/CT/CP/D6/D2/CX/D2/CV /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BF/BD/BA/BE/BA/BG /C7/D8/CW/CT/D6 /CE/CX/CT/DB/D7 /D3/CU /C4/CT/CP/D6/D2/CX/D2/CV /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BG/BD/BA/BF /C1/D7 /C4/CT/CP/D6/D2/CX/D2/CV /BY /CT/CP/D7/CX/CQ/D0/CT/BR /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BH/BD/BA/BF/BA/BD /C7/D9/D8/D7/CX/CS/CT /D8/CW/CT /BW/CP/D8/CP /CB/CT/D8 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BI/BD/BA/BF/BA/BE /C8/D6/D3/CQ/CP/CQ/CX/D0/CX/D8 /DD /D8/D3 /D8/CW/CT /CA/CT/D7 /D9/CT /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BK/BD/BA/BF/BA/BF /BY /CT/CP/D7/CX/CQ/CX/D0/CX/D8 /DD /D3/CU /C4/CT/CP/D6/D2/CX/D2/CV /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BE/BG/BD/BA/BG /BX/D6/D6/D3/D6 /CP/D2/CS /C6/D3/CX/D7/CT /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BE/BJ/BD/BA/BG/BA/BD /BX/D6/D6/D3/D6 /C5/CT/CP/D7/D9/D6/CT/D7 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BE/BK/BD/BA/BG/BA/BE /C6/D3/CX/D7/DD /CC /CP/D6/CV/CT/D8/D7 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BF/BC/BD/BA/BH /C8/D6/D3/CQ/D0/CT/D1/D7 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BF/BF/BE /CC /D6/CP/CX/D2/CX/D2/CV /DA /CT/D6/D7/D9/D7 /CC /CT/D7/D8/CX/D2/CV /BF/BL/BE/BA/BD /CC/CW/CT/D3/D6/DD /D3/CU /BZ/CT/D2/CT/D6/CP/D0/CX/DE/CP/D8/CX/D3/D2 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BF/BL/BE/BA/BD/BA/BD /BX/AR/CT /D8/CX/DA /CT /C6/D9/D1 /CQ /CT/D6 /D3/CU /C0/DD/D4 /D3/D8/CW/CT/D7/CT/D7 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BG/BD/BE/BA/BD/BA/BE /BU/D3/D9/D2/CS/CX/D2/CV /D8/CW/CT /BZ/D6/D3 /DB/D8/CW /BY /D9/D2 /D8/CX/D3/D2 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BG/BI/BE/BA/BD/BA/BF /CC/CW/CT /CE /BV /BW/CX/D1/CT/D2/D7/CX/D3/D2 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BH/BC/BE/BA/BD/BA/BG /CC/CW/CT /CE /BV /BZ/CT/D2/CT/D6/CP/D0/CX/DE/CP/D8/CX/D3/D2 /BU/D3/D9/D2/CS /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BH/BF/BE/BA/BE /C1/D2 /D8/CT/D6/D4/D6/CT/D8/CX/D2/CV /D8/CW/CT /BZ/CT/D2/CT/D6/CP/D0/CX/DE/CP/D8/CX/D3/D2 /BU/D3/D9/D2/CS /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BH/BH/BE/BA/BE/BA/BD /CB/CP/D1/D4/D0/CT /BV/D3/D1/D4/D0/CT/DC/CX/D8 /DD /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BH/BJ/BE/BA/BE/BA/BE /C8 /CT/D2/CP/D0/D8 /DD /CU/D3/D6 /C5/D3 /CS/CT/D0 /BV/D3/D1/D4/D0/CT/DC/CX/D8 /DD /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BH/BK/BE/BA/BE/BA/BF /CC/CW/CT /CC /CT/D7/D8 /CB/CT/D8 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BH/BL/BE/BA/BE/BA/BG /C7/D8/CW/CT/D6 /CC /CP/D6/CV/CT/D8 /CC /DD/D4 /CT/D7 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BI/BD/BE/BA/BF /BT/D4/D4/D6/D3 /DC/CX/D1/CP/D8/CX/D3/D2/B9/BZ/CT/D2/CT/D6/CP/D0/CX/DE/CP/D8/CX/D3/D2 /CC /D6/CP/CS/CT/D3/AR /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BI/BE/CX/DC /BV/D3/D2/D8/CT/D2/D8/D7/BE/BA/BF/BA/BD /BU/CX/CP/D7 /CP/D2/CS /CE /CP/D6/CX/CP/D2 /CT /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BI/BE/BE/BA/BF/BA/BE /CC/CW/CT /C4/CT/CP/D6/D2/CX/D2/CV /BV/D9/D6/DA /CT /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BI/BI/BE/BA/BG /C8/D6/D3/CQ/D0/CT/D1/D7 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BI/BL/BF /CC/CW/CT /C4/CX/D2/CT/CP/D6 /C5/D3 /CS/CT/D0 /BJ/BJ/BF/BA/BD /C4/CX/D2/CT/CP/D6 /BV/D0/CP/D7/D7/CX/AS /CP/D8/CX/D3/D2 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BJ/BJ/BF/BA/BD/BA/BD /C6/D3/D2/B9/CB/CT/D4/CP/D6/CP/CQ/D0/CT /BW/CP/D8/CP /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BJ/BL/BF/BA/BE /C4/CX/D2/CT/CP/D6 /CA/CT/CV/D6/CT/D7/D7/CX/D3/D2 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BK/BE/BF/BA/BE/BA/BD /CC/CW/CT /BT/D0/CV/D3/D6/CX/D8/CW/D1 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BK/BG/BF/BA/BE/BA/BE /BZ/CT/D2/CT/D6/CP/D0/CX/DE/CP/D8/CX/D3/D2 /C1/D7/D7/D9/CT/D7 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BK/BJ/BF/BA/BF /C4/D3/CV/CX/D7/D8/CX /CA/CT/CV/D6/CT/D7/D7/CX/D3/D2 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BK/BK/BF/BA/BF/BA/BD /C8/D6/CT/CS/CX /D8/CX/D2/CV /CP /C8/D6/D3/CQ/CP/CQ/CX/D0/CX/D8 /DD /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BK/BL/BF/BA/BF/BA/BE /BZ/D6/CP/CS/CX/CT/D2 /D8 /BW/CT/D7 /CT/D2 /D8 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BL/BF/BF/BA/BG /C6/D3/D2/D0/CX/D2/CT/CP/D6 /CC /D6/CP/D2/D7/CU/D3/D6/D1/CP/D8/CX/D3/D2 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BL/BL/BF/BA/BG/BA/BD /CC/CW/CTZ /CB/D4/CP /CT /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BL/BL/BF/BA/BG/BA/BE /BV/D3/D1/D4/D9/D8/CP/D8/CX/D3/D2 /CP/D2/CS /BZ/CT/D2/CT/D6/CP/D0/CX/DE/CP/D8/CX/D3/D2 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BC/BG/BF/BA/BH /C8/D6/D3/CQ/D0/CT/D1/D7 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BC/BL/BG /C7/DA /CT/D6/AS/D8/D8/CX/D2/CV /BD/BD/BL/BG/BA/BD /CF/CW/CT/D2 /BW/D3 /CT/D7 /C7/DA /CT/D6/AS/D8/D8/CX/D2/CV /C7 /D9/D6/BR /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BD/BL/BG/BA/BD/BA/BD /BT /BV/CP/D7/CT /CB/D8/D9/CS/DD/BM /C7/DA /CT/D6/AS/D8/D8/CX/D2/CV /DB/CX/D8/CW /C8 /D3/D0/DD/D2/D3/D1/CX/CP/D0/D7 /BA /BA /BA /BA /BA /BA /BD/BE/BC/BG/BA/BD/BA/BE /BV/CP/D8/CP/D0/DD/D7/D8/D7 /CU/D3/D6 /C7/DA /CT/D6/AS/D8/D8/CX/D2/CV /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BE/BF/BG/BA/BE /CA/CT/CV/D9/D0/CP/D6/CX/DE/CP/D8/CX/D3/D2 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BE/BI/BG/BA/BE/BA/BD /BT /CB/D3/CU/D8 /C7/D6/CS/CT/D6 /BV/D3/D2/D7/D8/D6/CP/CX/D2 /D8 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BE/BK/BG/BA/BE/BA/BE /CF /CT/CX/CV/CW /D8 /BW/CT /CP /DD /CP/D2/CS /BT/D9/CV/D1/CT/D2 /D8/CT/CS /BX/D6/D6/D3/D6 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BF/BE/BG/BA/BE/BA/BF /BV/CW/D3 /D3/D7/CX/D2/CV /CP /CA/CT/CV/D9/D0/CP/D6/CX/DE/CT/D6/BM /C8/CX/D0/D0 /D3/D6 /C8 /D3/CX/D7/D3/D2/BR /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BF/BG/BG/BA/BF /CE /CP/D0/CX/CS/CP/D8/CX/D3/D2 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BF/BJ/BG/BA/BF/BA/BD /CC/CW/CT /CE /CP/D0/CX/CS/CP/D8/CX/D3/D2 /CB/CT/D8 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BF/BK/BG/BA/BF/BA/BE /C5/D3 /CS/CT/D0 /CB/CT/D0/CT /D8/CX/D3/D2 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BG/BD/BG/BA/BF/BA/BF /BV/D6/D3/D7/D7 /CE /CP/D0/CX/CS/CP/D8/CX/D3/D2 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BG/BH/BG/BA/BF/BA/BG /CC/CW/CT/D3/D6/DD /CE /CT/D6/D7/D9/D7 /C8/D6/CP /D8/CX /CT /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BH/BD/BG/BA/BG /C8/D6/D3/CQ/D0/CT/D1/D7 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BH/BG/BH /CC/CW/D6/CT/CT /C4/CT/CP/D6/D2/CX/D2/CV /C8/D6/CX/D2 /CX/D4/D0/CT/D7 /BD/BI/BJ/BH/BA/BD /C7 /CP/D1/B3/D7 /CA/CP/DE/D3/D6 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BI/BJ/BH/BA/BE /CB/CP/D1/D4/D0/CX/D2/CV /BU/CX/CP/D7 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BJ/BD/BH/BA/BF /BW/CP/D8/CP /CB/D2/D3 /D3/D4/CX/D2/CV /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BJ/BF/BH/BA/BG /C8/D6/D3/CQ/D0/CT/D1/D7 /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BA /BD/BJ/BK/BX/D4/CX/D0/D3/CV/D9/CT /BD/BK/BD/BY /D9/D6/D8/CW/CT/D6 /CA/CT/CP/CS/CX/D2/CV /BD/BK/BF/DC /BV/D3/D2/D8/CT/D2/D8/D7/BT/D4/D4 /CT/D2/CS/CX/DC /C8/D6/D3 /D3/CU /D3/CU /D8/CW/CT /CE /BV /BU/D3/D9/D2/CS /BD/BK/BJ/BT/BA/BD /CA/CT/D0/CP/D8/CX/D2/CV /BZ/CT/D2/CT/D6/CP/D0/CX/DE/CP/D8/CX/D3/D2 /BX/D6/D6/D3/D6 /D8/D3 /C1/D2/B9/CB/CP/D1/D4/D0/CT /BW/CT/DA/CX/CP/D8/CX/D3/D2/D7 /BA /BA /BA /BA /BA /BD/BK/BK/BT/BA/BE /BU/D3/D9/D2/CS/CX/D2/CV /CF /D3/D6/D7/D8 /BV/CP/D7/CT /BW/CT/DA/CX/CP/D8/CX/D3/D2 /CD/D7/CX/D2/CV /D8/CW/CT /BZ/D6/D3 /DB/D8/CW /BY /D9/D2 /D8/CX/D3/D2 /BA /BA /BD/BL/BC/BT/BA/BF /BU/D3/D9/D2/CS/CX/D2/CV /D8/CW/CT /BW/CT/DA/CX/CP/D8/CX/D3/D2 /CQ /CT/D8 /DB /CT/CT/D2 /C1/D2/B9/CB/CP/D1/D4/D0/CT /BX/D6/D6/D3/D6/D7 /BA /BA /BA /BA /BA /BA /BA /BD/BL/BD/C6/D3/D8/CP/D8/CX/D3/D2 /BD/BL/BF/C1/D2/CS/CT/DC /BD/BL/BJ/DC/CX NOTATION A complete table of the notation used in this book is included on page 193, right before the index of terms. We suggest referring to it as needed. xii Chapter 1 The Learning Pro bl em If you show a picture to a three-year-old and ask if there is a tree in it, you will likely get the correct answer. If you ask a thirty-year-old what the definition of a tree is, you will likely get an inconclusi ve answer. We didn't learn what a tree is by studying the mathematical definition of trees. We learned it by looking at trees. In other words, we learned from 'data'. Learning from data is used in situations where we don't have an analytic solution, but we do have data that we can use to construct an empirical solu­ tion. This premise covers a lot of territory, and indeed learning from data is one of the most widely used techniques in science, engineering, and economics, among other fields. In this chapter, we present examples of learning from data and formalize the learning problem. We also discuss the main concepts associated with learning, and the different paradigms of learning that have been developed. 1.1 Problem Setup What do financial forecasting, medical diagnosis, computer vision, and search engines have in common? They all have successful ly utilized learning from data. The repertoire of such applications is quite impressive. Let us open the discussion with a real-life application to see how learning from data works. Consider the problem of predicting how a movie viewer would rate the various movies out there. This is an important problem if you are a company that rents out movies, since you want to recommend to different viewers the movies they will like. Good recommender systems are so important to business that the movie rental company Netflix offered a prize of one million dollars to anyone who could improve their recommendations by a mere 103. The main difficulty in this problem is that the criteria that viewers use to rate movies are quite complex. Trying to model those explicitly is no easy task, so it may not be possible to come up with an analytic solution. However, we 1 1. THE LEARNING PROBLEM viewer movie l:t\\fatch movie and viewer factors 1.1. PROBLEM SETUP add contributions from each factor Figure 1.1: A model for how a viewer rates a movie know that the historical rating data reveal a lot about how people rate movies, so we may be able to construct a good empirical solution. There is a great deal of data available to movie rental companies, since they often ask their viewers to rate the movies that they have already seen. Figure 1.1 illustrates a specific approach that was widely used in the million-dollar competition. Here is how it works. You describe a movie as a long array of different factors, e.g., how much comedy is in it, how com­ plicated is the plot, how handsome is the lead actor, etc. Now, you describe each viewer with corresponding factors; how much do they like comedy, do they prefer simple or complicated plots, how important are the looks of the lead actor, and so on. How this viewer will rate that movie is now estimated based on the match/mismatch of these factors. For example, if the movie is pure comedy and the viewer hates comedies, the chances are he won't like it. If you take dozens of these factors describing many facets of a movie's content and a viewer's taste, the conclusion based on matching all the factors will be a good predictor of how the viewer will rate the movie. The power of learning from data is that this entire process can be auto­ mated, without any need for analyzing movie content or viewer taste. To do so, the learning algorithm 'reverse-engineers' these factors based solely on pre- 2 1. THE LEARNING PROBLEM 1.1. PROBLEM SETUP vious ratings. It starts with random factors, then tunes these factors to make them more and more aligned with how viewers have rated movies before, until they are ultimately able to predict how viewers rate movies in general. The factors we end up with may not be as intuitive as 'comedy content', and in fact can be quite subtle or even incomprehensible. After all, the algorithm is only trying to find the best way to predict how a viewer would rate a movie, not necessarily explain to us how it is done. This algorithm was part of the winning solution in the million-dollar competition. 1.1.1 Compon ents of Learning The movie rating application captures the essence of learning from data, and so do many other applications from vastly different fields. In order to abstract the common core of the learning problem, we will pick one application and use it as a metaphor for the different components of the problem. Let us take credit approval as our metaphor. Suppose that a bank receives thousands of credit card applications every day, and it wants to automate the process of evaluating them. Just as in the case of movie ratings, the bank knows of no magical formula that can pinpoint when credit should be approved, but it has a lot of data. This calls for learning from data, so the bank uses historical records of previous customers to figure out a good formula for credit approval. Each customer record has personal information related to credit, such as annual salary, years in residence, outstanding loans, etc. The record also keeps track of whether approving credit for that customer was a good idea, i.e., did the bank make money on that customer. This data guides the construction of a successful formula for credit approval that can be used on future applicants. Let us give names and symbols to the main components of this learning problem. There is the input x (customer information that is used to make a credit decision), the unknown target function f: X -- Y (ideal formula for credit approval), where Xis the input space (set of all possible inputs x), and Y is the output space (set of all possible outputs, in this case just a yes/no deci­ sion). There is a data set D of input-output examples (x1,Y1), · · ·, (xN,YN), where Yn = f (xn) for n = 1, ... , N (inputs correspon ding to previous customers and the correct credit decision for them in hindsight). The examples are often referred to as data points. Finally, there is the learning algorithm that uses the data set D to pick a formula g: X -- Y that approximates f. The algorithm chooses g from a set of candidate formulas under consideration, which we call the hypothesis set 1-l. For instance, 1-l could be the set of all linear formulas from which the algorithm would choose the best linear fit to the data, as we will introduce later in this section. When a new customer applies for credit, the bank will base its decision on g (the hypothesis that the learning algorithm produced), not on f (the ideal target function which remains unknown) . The decision will be good only to the extent that g faithfully replicates f. To achieve that, the algorithm 3 1. THE LEARNING PROBLEM UNKNOWN TARGET FUNCTION f :X Y (ideal cred'il approval forrn'Ulo) TRAINING EXAMPLES · · ·, (xN, YN) HYPOTHESIS SET 1- (set of cand,idate form'alas) 1.1. PROBLEM SETUP FINAL HYPOTHESIS g�f (learned credit approval forrn'Ula) Figure 1.2: Basic setup of the learning problem chooses g that best matches f on the training examples of previous customers, with the hope that it will continue to match f on new customers. Whether or not this hope is justified remains to be seen. Figure 1.2 illustrates the components of the learning problem. Exercise 1.1 Express each of the following tasks in the framework of learning from data by specifying the input space X, output space Y, target function f: Y. and the specifics of the data set that we will learn from. (a) Medical diagnosis: A patient walks in with a medical history and some symptoms, and you want to identify the problem. (b) Handwritten digit recognition (for example postal zip code recognition for mail sorting). ( c) Determining if an email is spam or not. ( d) Predicting how an electric load varies with price, temperature, and day of the week. ( e) A problem of interest to you for which there is no analytic solution, but you hav e data from which to construct an empirical solution. 4 1. THE LEARNING PROBLEM 1.1. PROBLEM SETUP We will use the setup in Figure 1.2 as our definition of the learning problem. Later on, we will consider a number of refinements and variations to this basic setup as needed. However, the essence of the problem will remain the same. There is a target to be learned. It is unknown to us. We have a set of examples generated by the target. The learning algorithm uses these examples to look for a hypothesis that approximates the target. 1.1.2 A Simple Learning Model Let us consider the different components of Figure 1.2. Given a specific learn­ ing problem, the target function and training examples are dictated by the problem. However, the learning algorithm and hypothesis set are not. These are solution tools that we get to choose. The hypothesis set and learning algorithm are referred to informally as the learning model. Here is a simple model. Let X =]Rd be the input space, where JRd is the d-dimensional Euclidean space, and let Y = { + 1, -1} be the output space, denoting a binary (yes/no) decision. In our credit example, different coor­ dinates of the input vector x E JRd correspond to salary, years in residence, outstanding debt, and the other data fields in a credit application. The bi­ nary output y corresponds to approving or denying credit. We specify the hypothesis set 1{ through a functional form that all the hypotheses h E 1{ share. The functional form h(x) that we choose here gives different weights to the different coordinates of x, reflecting their relative importance in the credit decision. The weighted coordinates are then combined to form a 'credit score' and the result is compared to a threshold value. If the applicant passes the threshold, credit is approved; if not, credit is denied: d Approve credit if I: WiXi >threshold, i=l d Deny credit if I: WiXi < threshold. i=l This formula can be written more compactly as (1.1) where xi,··· ,xd are the components of the vector x; h(x) = +1 means 'ap­ prove credit' and h(x) = -1 means 'deny credit'; sign(s) = +1 ifs> 0 and sign(s) = -1 ifs < 0.1 The weights are w1, · · · , wd, and the threshold is determined by the bias term b since in Equation (1.1), credit is approved if I::=l WiXi > -b. This model of 1{ is called the perceptron, a name that it got in the context of artificial intelligenc e. The learning algorithm will search 1{ by looking for 1The value of sign(s) whens 0 is a simple technicality that we ignore for the moment. 5 1. THE LEARNING PR OBLEM 1.1. PROBLEM SETUP (a) Misclassified data (b) Perfectly classified data Figure 1.3: Perceptron classification of linearly separable data in a two dimensional input space (a) Some training examples will be misclassified (blue points in red region and vice versa) for certain values of the weight parameters which define the separating line. (b) A final hypothesis that classifies all training examples correctly. is + 1 and is -1.) weights and bias that perform well on the data set. Some of the weights w1, · · · , Wd may end up being negative, corresponding to an adverse effect on credit approval. For instance, the weight of the 'outstanding debt' field should come out negative since more debt is not good for credit. The bias value b may end up being large or small, reflecting how lenient or stringent the bank should be in extending credit. The optimal choices of weights and bias define the final hypothesis g E 1-l that the algorithm produces. Exercise 1. 2 Suppose that we use a perceptron to detect spam messages. Let's say that each email message is represented by the frequency of occurrence of keywords, and the output is if the message is considered spam. (a) Can you think of some keywords that will end up with a large positive weight in the perceptron? (b) How about keywords that will get a negative weight? ( c) What parameter in the perceptron directly affects how many border­ line messages end up being classified as spam? Figure 1.3 illustrates what a perceptron does in a two-dimensional case (d = 2). The plane is split by a line into two regions, the + 1 decision region and the -1 decision region. Different values for the parameters w1, w2, b correspond to different lines w1x1 + w2x2 + b = 0. If the data set is linearly separable, there will be a choice for these parameters that classifies all the training examples correctly. 6 1. THE LEARNING PROBLEM 1.1. PROBLEM SETUP To simplify the notation of the perceptron formula, we will treat the bias b as a weight wo = b and merge it with the other weights into one vector w = [w0, w1, · · · , wd]T, where T denotes the transpose of a vector, so w is a column vector. We also treat x as a column vector and modify it to become x = [x0, xi, · · · , xd]T, where the added coordinate x0 is fixed at x0 = 1. Formally speaking, the input space is now With this convention, wTx = ��=O WiXi, and so Equation (1.1) can be rewrit­ ten in vector form as h(x) = sign(wTx). (1.2) We now introduce the perceptron learning algorithm (PLA). The algorithm will determine what w should be, based on the data. Let us assume that the data set is linearly separable, which means that there is a vector w that makes (1.2) achieve the correct decision h(xn) = Yn on all the training exam­ ples, as shown in Figure 1.3. Our learning algorithm will find this w using a simple iterative method. Here is how it works. At iteration t, where t = 0, 1, 2, ... , there is a current value of the weight vector, call it w(t). The algorithm picks an example from (x1, Y1) · · · (xN, YN) that is currently misclassified, call it (x(t), y(t)), and uses it to update w(t). Since the example is misclassified, we have y(t) #­ sign(wT(t )x(t)). The update rule is w(t + 1) = w(t) + y(t)x(t). (1.3) This rule moves the boundary in the direction of classifying x(t) correctly, as depicted in the figure above. The algorithm continues with further iterations until there are no longer misclassified examples in the data set. 7 1. THE LEARNING PROBLEM 1.1. PROBLEM SETUP Exercise 1.3 The weight update rule in {1.3) has the nice interpretation that it moves in the direction of classifying x(t) correctly. (a) Show that y(t)wT(t)x(t) < 0. [Hint: x(t) is misclassified by w(t).] (b) Show that y(t)wT(t l)x(t) > y(t)wT(t)x(t). [Hint: Use (1.3).] ( c) As far as classifying x(t) is concerned, argue that the move from w(t) to w(t + 1) is a move 'in the right direction'. Although the update rule in (1.3) considers only one training example at a time and may 'mess up' the classification of the other examples that are not involved in the current iteration, it turns out that the algorithm is guaranteed to arrive at the right solution in the end. The proof is the subject of Prob­ lem 1.3. The result holds regardless of which example we choose from among the misclassified examples in (x1, Y1) · · · (xN, YN) at each iteration, and re­ gardless of how we initialize the weight vector to start the algorithm. For simplicity, we can pick one of the misclassified examples at random (or cycle through the examples and always choose the first misclassified one), and we can initialize w(O) to the zero vector. Within the infinite space of all weight vectors, the perceptron algorithm manages to find a weight vector that works, using a simple iterative process. This illustrates how a learning algorithm can effectively search an infinite hypothesis set using a finite number of simple steps. This feature is character­ istic of many techniques that are used in learning, some of which are far more sophisticated than the perceptron learning algorithm. Exercise 1.4 Let us create our own target function f and data set 1) and see how the perceptron learning algorithm works. Take d = 2 so you can visualize the problem, and choose a random line in the plane as your target function, where one side of the line maps to 1 and the other maps to -1. Choose the inputs Xn of the data set as random points in the plane, and evaluate the target function on each Xn to get the corresponding output Yn· Now, generate a data set of size 20. Try the perceptron learning algorithm on your data set and see how long it takes to converge and how well the final hypothesis g matches your target f. You can find other ways to play with this experiment in Problem 1.4. The perceptron learning algorithm succeeds in achieving its goal; finding a hy­ pothesis that classifies all the points in the data set V = { ( x 1, y1) · · · ( x N, y N)} correctly. Does this mean that this hypothesis will also be successful in classi­ fying new data points that are not in V? This turns out to be the key question in the theory of learning, a question that will be thoroughly examined in this book. 8 1. THE LEARNING PROBLEM 1.1. PROBLEM SETUP Size Size (a) Coin data (b) Learned classifier Figure 1.4: The learning approach to coin classification (a) Training data of pennies, nickels, dimes, and quarters (1, 5, 10, and 25 cents) are represented in a size mass space where they fall into clusters. (b) A classification rule is learned from the data set by separating the four clusters. A new coin will be classified according to the region in the size mass plane that it falls into. 1.1. 3 Learning versus Design So far, we have discussed what learning is. Now, we discuss what it is not. The goal is to distinguish between learning and a related approach that is used for similar problems. While learning is based on data, this other approach does not use data. It is a 'design' approach based on specifications, and is often discussed alongside the learning approach in pattern recognition literature. Consider the problem of recognizing coins of different denomina tions, which is relevant to vending machines, for example. We want the machine to recog­ nize quarters, dimes, nickels and pennies. We will contrast the 'learning from data' approach and the 'design from specifications' approach for this prob­ lem. We assume that each coin will be represented by its size and mass, a two-dimensional input. In the learning approach, we are given a sample of coins from each of the four denominations and we use these coins as our data set. We treat the size and mass as the input vector, and the denomination as the output. Figure 1.4( a) shows what the data set may look like in the input space. There is some variation of size and mass within each class, but by and large coins of the same denomination cluster together. The learning algorithm searches for a hypothesis that classifies the data set well. If we want to classify a new coin, the machine measures its size and mass, and then classifies it according to the learned hypothesis in Figure l.4(b). In the design approach, we call the United States Mint and ask them about the specifications of different coins. We also ask them about the number 9 1. THE LEARNING PROBLEM 1.1. PROBLEM SETUP Size Size (a) Probabilistic model of data (b) Inferred classifier Figure 1.5: The design approach to coin classification (a) A probabilistic model for the size, mass, and denomination of coins is derived from known specifications. The figure shows the high probability region for each denom ination (1, 5, 10, and 25 cents) according to the model. (b) A classification rule is derived analytically to minimize the probability of error in classifying a coin based on size and mass. The resulting regions for each denomination are shown. of coins of each denomination in circulation, in order to get an estimate of the relative frequency of each coin. Finally, we make a physical model of the variations in size and mass due to exposure to the elements and due to errors in measurement . We put all of this information together and compute the full joint probability distribution of size, mass, and coin denomination (Figure 1.5( a)). Once we have that joint distribution, we can construct the optimal decision rule to classify coins based on size and mass (Figure 1. 5 (b)). The rule chooses the denomination that has the highest probability for a given size and mass, thus achieving the smallest possible probability of error. 2 The main difference between the learning approach and the design ap­ proach is the role that data plays. In the design approach, the problem is well specified and one can analytically derive f without the need to see any data. In the learning approach, the problem is much less specified, and one needs data to pin down what f is. Both approaches may be viable in some applications , but only the learning approach is possible in many applications where the target function is un­ known. We are not trying to compare the utility or the performance of the two approaches. We are just making the point that the design approach is distinct from learning. This book is about learning. 2This is called Bayes optimal decision theory. Some learning models are based on the same theory by estimating the probability from data. 10 1. THE LEARNING PROBLEM 1.2. TYPES OF LEARNING Exercise 1. 5 Which of the following problems are more suited for the learning approach and which are more suited for the design approach? (a) Determining the age at which a particular medical test should be performed (b) Classifying numbers into primes and non-prime s ( c) Detecting potential fraud in credit card charges ( d) Determining the time it would take a falling object to hit the ground ( e) Determining the optimal cycle for traffic lights in a busy intersection 1.2 Types of Lea rning The basic premise of learning from data is the use of a set of observations to uncover an underlying process. It is a very broad premise, and difficult to fit into a single framework. As a result, different learning paradigms have arisen to deal with different situations and different assumptions. In this section, we introduce some of these paradigms . The learning paradigm that we have discussed so far is called supervised learning. It is the most studied and most utilized type of learning, but it is not the only one. Some variations of supervised learning are simple enough to be accommodated within the same framework. Other variations are more profound and lead to new concepts and techniques that take on lives of their own. The most important variations have to do with the nature of the data set. 1.2.1 Supervised Learning When the training data contains explicit examples of what the correct output should be for given inputs, then we are within the supervised learning set­ ting that we have covered so far. Consider the hand-written digit recognition problem (task (b) of Exercise 1.1). A reasonable data set for this problem is a collection of images of hand-written digits, and for each image, what the digit actually is. We thus have a set of examples of the form ( image , digit ). The learning is supervised in the sense that some 'supervisor' has taken the trouble to look at each input, in this case an image, and determine the correct output, in this case one of the ten categories {O, 1, 2, 3, 4, 5, 6, 7, 8, 9}. While we are on the subject of variations, there is more than one way that a data set can be presented to the learning process. Data sets are typically cre­ ated and presented to us in their entirety at the outset of the learning process. For instance, historical records of customers in the credit-card application, and previous movie ratings of customers in the movie rating application, are already there for us to use. This protocol of a 'ready' data set is the most 11 1. THE LEARNING PROBLEM 1.2. TYPES OF LEARNING common in practice, and it is what we will focus on in this book. However, it is worth noting that two variations of this protocol have attracted a significant body of work. One is active learning, where the data set is acquired through queries that we make. Thus, we get to choose a point x in the input space, and the supervisor reports to us the target value for x. As you can see, this opens the possibility for strategic choice of the point x to maximize its information value, similar to asking a strategic question in a game of 20 questions. Another variation is called online learning, where the data set is given to the algorithm one example at a time. This happens when we have stream­ ing data that the algorithm has to process 'on the run'. For instance, when the movie recommendation system discussed in Section 1.1 is deployed, on­ line learning can process new ratings from current users and movies. Online learning is also useful when we have limitations on computing and storage that preclude us from processing the whole data as a batch. We should note that online learning can be used in different paradigms of learning, not just in supervised learning. 1. 2. 2 Reinforcement Learning When the training data does not explicitly contain the correct output for each input, we are no longer in a supervised learning setting. Consider a toddler learning not to touch a hot cup of tea. The experience of such a toddler would typically comprise a set of occasions when the toddler confronted a hot cup of tea and was faced with the decision of touching it or not touching it. Presumably, every time she touched it, the result was a high level of pain, and every time she didn't touch it, a much lower level of pain resulted (that of an unsatisfied curiosity). Eventually, the toddler learns that she is better off not touching the hot cup. The training examples did not spell out what the toddler should have done, but they instead graded different actions that she has taken. Nevertheless, she uses the examples to reinforce the better actions, eventually learning what she should do in similar situations . This characterizes reinforcement learning, where the training example does not contain the target output, but instead contains some possible output together with a measure of how good that out­ put is. In contrast to supervised learning where the training examples were of the form ( input , correct output ), the examples in reinforcement learning are of the form ( input , some output , grade for this output ). Importantly, the example does not say how good other outputs would have been for this particular input. Reinforcement learning is especially useful for learning how to play a game. Imagine a situation in backgammon where you have a choice between different actions and you want to identify the best action. It is not a trivial task to ascertain what the best action is at a given stage of the game, so we cannot 12 1. THE LEARNING PROBLEM 1. 2. TYPES OF LEARNING 0 0 Size Size (a) Unlabeled Coin data (b) Unsupervised learning Figure 1.6: Unsupervised learning of coin classification (a) The same data set of coins in Figure 1.4(a) is again represented in the size mass space, but without being labeled. They still fall into clusters. (b) An unsupervised classification rule treats the four clusters as different types. The rule may be somewhat ambiguous, as type 1 and type 2 could be viewed as one cluster easily create supervised learning examples. If you use reinforcement learning instead, all you need to do is to take some action and report how well things went, and you have a training example. The reinforcement learning algorithm is left with the task of sorting out the information coming from different ex­ amples to find the best line of play. 1.2.3 Unsupervised Learning In the unsupervised setting, the training data does not contain any output information at all. We are just given input examples xi,··· , XN. You may wonder how we could possibly learn anything from mere inputs. Consider the coin classification problem that we discussed earlier in Figure 1.4. Suppose that we didn't know the denomination of any of the coins in the data set. This unlabeled data is shown in Figure l.6(a). We still get similar clusters, but they are now unlabeled so all points have the same 'color'. The decision regions in unsupervised learning may be identical to those in supervised learning, but without the labels (Figure 1. 6 (b)). However, the correct clustering is less obvious now, and even the number of clusters may be ambiguous. Nonetheless, this example shows that we can learn something from the inputs by themselves. Unsupervised learning can be viewed as the task of spontaneously finding patterns and structure in input data. For instance, if our task is to categorize a set of books into topics, and we only use general properties of the various books, we can identify books that have similar prop­ erties and put them together in one category, without naming that category. 13 1. THE LEARNING PROBLEM 1. 2. TYPES OF LEARNING Unsupervised learning can also be viewed as a way to create a higher­ level representation of the data. Imagine that you don't speak a word of Spanish, but your company will relocate you to Spain next month. They will arrange for Spanish lessons once you are there, but you would like to prepare yourself a bit before you go. All you have access to is a Spanish radio station. For a full month, you continuously bombard yourself with Spanish; this is an unsupervised learning experience since you don't know the meaning of the words. However, you gradually develop a better representation of the language in your brain by becoming more tuned to its common sounds and structures . When you arrive in Spain, you will be in a better position to start your Spanish lessons. Indeed, unsupervised learning can be a precursor to supervised learning. In other cases, it is a stand-alone technique. Exercise 1.6 For each of the following tasks, identify which type of learning is involved (supervised, reinforcement, or unsupervised) and the training data to be used. If a task can fit more than one type, explain how and describe the training data for each type. (a) Recommending a book to a user in an online bookstore (b) Playing tictac toe ( c) Categorizing movies into different types ( d) Learning to play music ( e) Credit limit: Deciding the maximum allowed debt for each bank cus­ tomer Our main focus in this book will be supervised learning, which is the most popular form of learning from data. 1. 2 .4 Other Views of Learning The study of learning has evolved somewhat independently in a number of fields that started historically at different times and in different domains, and these fields have developed different emphases and even different jargons. As a result, learning from data is a diverse subject with many aliases in the scientific literature. The main field dedicated to the subject is called machine learning, a name that distinguishes it from human learning. We briefly mention two other important fields that approach learning from data in their own ways. Statistics shares the basic premise of learning from data, namely the use of a set of observations to uncover an underlying process. In this case, the process is a probability distribution and the observations are samples from that distribution. Because statistics is a mathematical field, emphasis is given to situations where most of the questions can be answered with rigorous proofs. As a result, statistics focuses on somewhat idealized models and analyzes them in great detail. This is the main difference between the statistical approach 14 1. THE LEARNING PROBLEM 1. 3. Is LEARNING FEASIBLE? f -1 f +1 f ? Figure 1.7: A visual learning problem. The first two rows show the training examples (each input x is a 9 bit vector represented visually as a 3 x 3 black and white array). The inputs in the first row have f(x) = -1, and the inputs in the second row have f ( x) = + 1. Your task is to learn from this data set what f is, then apply f to the test input at the bottom. Do you get -1 or +1? to learning and how we approach the subject here. We make less restrictive assumptions and deal with more general models than in statistics. Therefore, we end up with weaker results that are nonetheless broadly applicable . Data mining is a practical field that focuses on finding patterns, correla­ tions, or anomalies in large relational databases. For example, we could be looking at medical records of patients and trying to detect a cause-effect re­ lationship between a particular drug and long-term effects. We could also be looking at credit card spending patterns and trying to detect potential fraud. Technically, data mining is the same as learning from data, with more empha­ sis on data analysis than on prediction. Because databases are usually huge, computational issues are often critical in data mining. Recommender systems, which were illustrated in Section 1.1 with the movie rating example, are also considered part of data mining. 1.3 Is Learning Feasible? The target function f is the object of learning. The most important assertion about the target function is that it is unknown. We really mean unknown. This raises a natural question. How could a limited data set reveal enough information to pin down the entire target function? Figure 1. 7 illustrates this 15 1. THE LEARNING PROBLEM 1.3. Is LEARNING FEASIBLE? difficulty. A simple learning task with 6 training examples of a ±1 target function is shown. Try to learn what the function is then apply it to the test input given. Do you get -1 or + 1? Now, show the problem to your friends and see if they get the same answer. The chances are the answers were not unanimous, and for good reason. There is simply more than one function that fits the 6 training examples, and some of these functions have a value of -1 on the test point and others have a value of + 1. For instance, if the true f is + 1 when the pattern is symme tric, the value for the test point would be + 1. If the true f is + 1 when the top left square of the pattern is white, the value for the test point would be -1. Both functions agree with all the examples in the data set, so there isn't enough information to tell us which would be the correct answer. This does not bode well for the feasibility of learning. To make matters worse, we will now see that the difficulty we experienced in this simple problem is the rule, not the exception. 1.3.1 Outside the Data Set When we get the training data V, e.g., the first two rows of Figure 1.7, we know the value off on all the points in V. This doesn't mean that we have learned f, since it doesn't guarantee that we know anything about f outside of V. We know what we have already seen, but that's not learning. That's memorizing. Does the data set V tell us anything outside of V that we didn't know before? If the answer is yes, then we have learned something. If the answer is no, we can conclude that learning is not feasible. Since we maintain that f is an unknown function, we can prove that f remains unknown outside of V. Instead of going through a formal proof for the general case, we will illustrate the idea in a concrete case. Consider a Boolean target function over a three-dimensional input space X = {O, 1 }3. We are given a data set V of five examples represented in the table below. We denote the binary output by o / • for visual clarity, Xn Yn 000 0 0 0 1 • 0 1 0 • 0 11 0 1 0 0 • where Yn = f (xn) for n = 1, 2, 3, 4, 5. The advantage of this simple Boolean case is that we can enumerate the entire input space (since there are only 23 = 8 distinct input vectors), and we can enumerate the set of all possible target functions (since f is a Boolean function on 3 Boolean inputs, and there are only 223 = 256 distinct Boolean functions on 3 Boolean inputs). 16 1. THE LEARNING PROBLEM 1.3. ls LEARNING FEASIBLE? Let us look at the problem of learning i. Since i is unknown except inside D, any function that agrees with D could conceivably be i. The table below shows all such functions Ji,··· , is. It also shows the data set D (in blue) and what the final hypothesis g may look like. x f4 f5 f6 fs 0 0 0 0 0 0 0 0 • • • • • • • • • • • • • • • • 0 0 0 0 0 0 0 0 • • • • • • • • 0 0 0 0 • • • • 0 0 • • 0 0 • • 0 • 0 • 0 • 0 • The final hypothesis g is chosen based on the five examples in D. The table shows the case where g is chosen to match ion these examples. If we remain true to the notion of unknown target, we cannot exclude any of Ji,··· , is from being the true i· Now, we have a dilemma. The whole purpose of learning i is to be able to predict the value of f on points that we haven't seen before. The quality of the learning will be determined by how close our prediction is to the true value. Regardless of what g predicts on the three points we haven't seen before (those outside of D, denoted by red question marks), it can agree or disagree with the target, depending on which of Ji,··· , is turns out to be the true target. It is easy to verify that any 3 bits that replace the red question marks are as good as any other 3 bits. Exercise 1. 7 For each of the following learning scenarios in the above problem, evaluate the performance of g on the three points in outside V. To measure the performance, compute how many of the 8 possible target functions agree with g on all three points, on two of them, on one of them, and on none of them. (a) 1-l has only two hypotheses, one that always returns'•' and one that always returns 'o'. The learning algorithm picks the hypothesis that matches the data set the most. (b) The same 1-l, but the learning algorithm now picks the hypothesis that matches the data set the least. (c) 1-l = {XOR} (only one hypothesis which is always picked), where XOR is defined by XOR(x) = • if the number of l's in x is odd and XOR(x) = o if the number is even. ( d) 1-l contains all possible hypotheses (all Boolean functions on three variables), and the learning algorithm picks the hypothesis that agrees with all training examples, but otherwise disagrees the most with the XOR. 17 1. THE LEAR NING PROBLEM 1.3. Is LEARNING FEASIBLE? BIN SAMPLE µ=probability of red marbles Figure 1.8: A random sample is picked from a bin ofred and green marbles. The probability µ of red marbles in the bin is unknown. What does the fraction v of red marbles in the sample tell us about µ? It doesn't matter what the algorithm does or what hypothesis set 1-l is used. Whether 1-l has a hypothesis that perfectly agrees with V (as depicted in the table) or not, and whether the learning algorithm picks that hypothesis or picks another one that disagrees with V (different green bits), it makes no difference whatsoever as far as the performance outside of Vis concerned. Yet the performance outside V is all that matters in learning! This dilemma is not restricted to Boolean functions, but extends to the general learning problem. As long as f is an unknown function, knowing V cannot exclude any pattern of values for f outside of V. Therefo re, the pre­ dictions of g outside of V are meaningless. Does this mean that learning from data is doomed? If so, this will be a very short book @. Fortunately, learning is alive and well, and we will see why. We won't have to change our basic assumption to do that. The target function will continue to be unknown, and we still mean unknown. 1.3.2 Probability to the Rescue We will show that we can indeed infer something outside V using only V, but in a probabilistic way. What we infer may not be much compared to learning a full target function, but it will establish the principle that we can reach outside V. Once we establish that, we will take it to the general learning problem and pin down what we can and cannot learn. Let's take the simplest case of picking a sample, and see when we can say something about the objects outside the sample. Consider a bin that contains red and green marbles, possibly infinitely many. The proportion of red and green marbles in the bin is such that if we pick a marble at random, the probability that it will be red is µ and the probability that it will be green is 1 -µ. We assume that the value ofµ is unknown to us. 18 1. THE LEARNING PROBLEM 1.3. Is LEARNING FEASIBLE? We pick a random sample of N independent marbles (with replacement) from this bin, and observe the fraction v of red marbles within the sample (Figure 1.8). What does the value of v tell us about the value ofµ? One answer is that regardless of the colors of the N marbles that we picked, we still don't know the color of any marble that we didn't pick. We can get mostly green marbles in the sample while the bin has mostly red marbles. Although this is certainly possible, it is by no means probable. Exercise 1.8 If µ = 0.9, what is the probability that a sample of 10 marbles will have v :: 0.1? [Hints: 1. Use binomial distribution. 2. The answer is a very small number.] The situation is similar to taking a poll. A random sample from a population tends to agree with the views of the population at large. The probability distribution of the random variable v in terms of the parameter µ is well understood, and when the sample size is big, v tends to be close to µ. To quantify the relationship between v and µ, we use a simple bound called the H oeff ding Inequality. It states that for any sample size N, for any E > 0. (1.4) Here, JP>[·] denotes the probability of an event, in this case with respect to the random sample we pick, and E is any positive value we choose. Putting Inequality (1.4) in words, it says that as the sample size N grows, it becomes exponentially unlikely that v will deviate fromµ by more than our 'tolerance' E. The only quantity that is random in (1.4) is v which depends on the random sample. By contrast, µ is not random. It is just a constant, albeit unknown to us. There is a subtle point here. The utility of (1.4) is to infer the value ofµ using the value of v, although it is µ that affects v, not vice versa. However, since the effect is that v tends to be close to µ, we infer that µ 'tends' to be close to v. Although JP> [Iv µI > E] depends onµ, asµ appears in the argument and also affects the distribution of v, we are able to bound the probability by 2e-2E2 N which does not depend onµ. Notice that only the size N of the sample affects the bound, not the size of the bin. The bin can be large or small, finite or infinite, and we still get the same bound when we use the same sample size. Exercise 1. 9 Ifµ = 0.9, use the Hoeffding Inequality to bound the probability that a sample of 10 marbles will have v :: 0.1 and compare the answer to the previous exercise. If we choose E to be very small in order to make v a good approximation of µ, we need a larger sample size N to make the RHS oflnequality (1.4) small. We 19 1. THE LEARNING PROBLEM 1.3. Is LEARNING FEASIBLE? can then assert that it is likely that v will indeed be a good approximation ofµ. Although this assertion does not give us the exact value ofµ, and doesn't even guarantee that the approximate value holds, knowing that we are within ±E of µ most of the time is a significant improvement over not knowing anything at all. The fact that the sample was randomly selected from the bin is the reason we are able to make any kind of statement about µ being close to v. If the sample was not randomly selected but picked in a particular way, we would lose the benefit of the probabilistic analysis and we would again be in the dark outside of the sample. How does the bin model relate to the learning problem? It seems that the unknown here was just the value ofµ while the unknown in learning is an entire function f: X -+ Y. The two situations can be connected. Take any single hypothesis h E 'H and compare it to f on each point x E X. If h(x) = f(x), color the point x green. If h(x) =/- f (x), color the point x red. The color that each point gets is not known to us, since f is unknown. However, if we pick x at random according to some probability distribution P over the input space X, we know that x will be red with some probability, call itµ, and green with probability 1 -µ. Regardless of the value ofµ, the space X now behaves like the bin in Figure 1.8. The training examples play the role of a sample from the bin. If the inputs xi,··· , XN in V are picked independ ently according to P, we will get a random sample of red (h(xn) =/-J(xn)) and green (h(xn) = f(xn)) points. Each point will be red with probability µ and green with probability 1-µ. The color of each point will be known to us since both h(xn) and f (xn) are known for n = 1, · · · , N (the function h is our hypothesis so we can evaluate it on any point, and f (xn) = Yn is given to us for all points in the data set V). The learning problem is now reduced to a bin problem, under the assumption that the inputs in V are picked independently according to some distribution P on X. Any P will translate to some µ in the equivalent bin. Since µ is allowed to be unknown, P can be unknown to us as well. Figure 1. 9 adds this probabilistic component to the basic learning setup depicted in Figure 1.2. With this equivalenc e, the Hoeffding Inequality can be applied to the learn­ ing problem, allowing us to make a prediction outside of V. Using v to pre­ dict µ tells us something about f, although it doesn't tell us what f is. What µ tells us is the error rate h makes in approximating f. If v happens to be close to zero, we can predict that h will approximate f well over the entire input space. If not, we are out of luck. Unfortunatel y, we have no control over v in our current situation, since v is based on a particular hypothesis h. In real learning, we explore an entire hypothesis set 'H, looking for some h E 'H that has a small error rate. If we have only one hypothesis to begin with, we are not really learning, but rather 'verifying' whether that particular hypothesis is good or bad. Let us see if we can extend the bin equivalence to the case where we have multiple hypotheses in order to capture real learning. 20 1. THE LEARNING PROBLEM UNKNOWN TARGET FUNCTION f :,Yr-tY TRAINING EXAMPLES HYPOTHESIS SET H 1.3. Is LEARNING FEASIBLE? FINAL HYPOTHESIS g Figure 1.9: Probability added to the basic learning setup To do that, we start by introducing more descriptive names for the dif­ ferent components that we will use. The error rate within the sample, which corresponds to v in the bin model, will be called the in-sample error, (fraction of 'D where f and h disagree) 1 N [h(xn) f f(xn)], n=l where [statement] = 1 if the statement is true, and = 0 if the statement is false. We have made explicit the dependency of Ein on the particular h that we are considering. In the same way, we define the out-of-sample error Eout(h) = JPl [h(x) ff (x)], which corresponds to µ in the bin model. The probability is based on the distribution P over X which is used to sample the data points x. 21 1. THE LEARNING PROBLEM 1. 3. Is LEARNING FEASIBLE? Figure 1.10: Multiple bins depict the learning problem with M hypotheses Substituting the new notation Ein for v and Eout for µ, the Hoeffding Inequality (1.4) can be rewritten as for any E > 0, (1.5) where N is the number of training examples. The in-sample error Ein, just like v, is a random variable that depends on the sample. The out-of-sample error Eout, just likeµ, is unknown but not random. Let us consider an entire hypothesis set H instead of just one hypothesis h, and assume for the moment that H has a finite number of hypotheses We can construct a bin equivalent in this case by having M bins as shown in Figure 1.10. Each bin still represents the input space X, with the red marbles in the mth bin corresponding to the points x E X where hm(x) -f f(x). The probability of red marbles in the mth bin is Eout(hm) and the fraction of red marbles in the mth sample is Ein(hm), form= 1, · · · , M. Although the Hoeffding Inequality (1.5) still applies to each bin individua lly, the situation becomes more complicated when we consider all the bins simultaneously. Why is that? The inequality stated that for any E > 0, where the hypothesis h is fixed before you generate the data set, and the probability is with respect to random data sets V; we emphasize that the assumption \"h is fixed before you generate the data set\" is critical to the validity of this bound. If you are allowed to change h after you generate the data set, the assumptions that are needed to prove the Hoeffding Inequality no longer hold. With multiple hypotheses in H, the learning algorithm picks 22 1. THE LEARNING PROBLEM 1.3. Is LEARNING FEASIBLE? the final hypothesis g based on D, i.e. after generating the data set. The statement we would like to make is not \"JP>[IEin(hm) -Eout(hm)I > E] is small\" (for any particular, fixed hm E 1-l), but rather \"JP>[IEin(g) -Eout(g)I > E] is small\" for the final hypothesis g. The hypothesis g is not fixed ahead of time before generating the data, because which hypothesis is selected to beg depends on the data. So, we cannot just plug in g for h in the Hoeffding inequality. The next exercise considers a simple coin experimen t that further illustrates the difference between a fixed h and the final hypothesis g selected by the learning algorithm. Exercise 1.10 Here is an experiment that illustrates the difference between a single bin and multiple bins. Run a computer simulation for flipping 1, 000 fair coins. Flip each coin independently times. Let's focus on 3 coins as follows: c1 is the first coin flipped; Crand is a coin you choose at random; Cmin is the coin that had the minimum frequency of heads (pick the earlier one in case of a tie). Let v1, Vrand and Vmin be the fraction of heads you obtain for the respective three coins. (a) What isµ for the three coins selected? (b) Repeat this entire experiment a large number of times (e.g., 100, 000 runs of the entire experiment) to get several instances of v1, Vrand and Vmin and plot the histograms of the distributions of v1, Vrand and Vmin· Notice that which coins end up being Crand and Cmin may differ from one run to another. (c) Using (b), plot estimates for JP[jv-µj > E] as a function of E, together with the Hoeffding bound 2e-2c:2N (on the same graph). (d) Which coins obey the Hoeffding bound, and which ones do not? Ex­ plain why. (e) Relate part (d) to the multiple bins in Figure 1.10. The way to get around this is to try to bound JP>[IEin(g) - Eout(g)I > E] in a way that does not depend on which g the learning algorithm picks. There is a simple but crude way of doing that. Since g has to be one of the hm's regardless of the algorithm and the sample, it is always true that \"IEin(g) -Eout(g)I > E\" == \" 23 IEin(h1) -Eout(h1)I > E or IEin(h2) -Eout(h2)I > E 1. THE LEARNING PROBLE!VI 1.3. Is LEARNING FEASIBLE? where B1 ==:;:. B 2 means that event B1 implies event B2. Although the events on the RHS cover a lot more than the LHS, the RHS has the property we want; the hypotheses hm are fixed. We now apply two basic rules in probability; and, if B1, B2, · · · , BM are any events, then The second rule is known as the union bound. Putting the two rules together, we get IP'[ IEin(g) -Eout(g)I > E] < JP'[ IEin(h1) -Eout(h1)I > E or IEin(h2) -Eout(h2)I > E or IEin(hM) -Eout(hM )I > E] M < LIP' [IEin(hm) Eout(hm)I > E]. m=l Applying the Hoeffding Inequality (1.5) to the M terms one at a time, we can bound each term in the sum by 2e-2E2 N. Substituting, we get (1.6) Mathemati cally, this is a 'uniform' version of (1.5). We are trying to simul­ taneously approximate all Eout(hm)'s by the corresponding Ein(hm)'s. This allows the learning algorithm to choose any hypothesis based on Ein and ex­ pect that the corresponding Eout will uniformly follow suit, regardless of which hypothesis is chosen. The downside for uniform estimates is that the probability bound 21\\lf e-2E2 N is a factor of ]\\If looser than the bound for a single hypothesis, and will only be meaningful if ]\\If is finite. We will improve on that in Chapter 2. 1.3.3 Feasibility of Learning We have introduced two apparently conflicting arguments about the feasibility of learning. One argument says that we cannot learn anything outside of V, and the other says that we can. We would like to reconcile these two arguments and pinpoint the sense in which learning is feasible: 1. Let us reconcile the two arguments. The question of whether V tells us anything outside of V that we didn't know before has two different answers. If we insist on a deterministic answer, which means that V tells us something certain about f outside of V, then the answer is no. If we accept a probabilistic answer, which means that V tells us something likely about f outside of V, then the answer is yes. 24 1. THE LEARNING PROBLEM 1.3. ls LEARNING FEASIBLE? Exercise 1.11 We are given a data set 'D of 25 training examples from an unknown target function j: Y, where =JR and = {-1,+1}. learn f, we use a simple hypothesis set = {h1, h2} where h1 is the constant function and h2 is the constant -1. We consider two learning algorithms, S (smart) and (crazy). S chooses the hypothesis that agrees the most with and chooses the other hy­ pothesis deliberately. Let us see how these algorithms perform out of sam­ ple from the deterministic and probabilistic points of view. Assume in the probabilistic view that there is a probability distribution on X, and let JID[f(x) = = p. (a) Can S produce a hypothesis that is guaranteed to perform better than random on any point outside 'D? (b) Assume for the rest of the exercise that all the examples in have Yn = 1. Is it possible that the hypothesis that produces turns out to be better than the hypothesis that S produces? ( c) If p = 0.9, what is the probability that S will produce a better hy­ pothesis than C? ( d) Is there any value of p for which it is more likely than not that C will produce a better hypothesis than S? By adopting the probabilistic view, we get a positive answer to the feasibility question without paying too much of a price. The only assumption we make in the probabilistic framework is that the examples in V are generated inde­ pendently. We don't insist on using any particular probability distribution, or even on knowing what distribution is used. However, whatever distribu­ tion we use for generating the examples, we must also use when we evaluate how well g approximates f (Figure 1.9). That's what makes the Hoeffding Inequality applicable . Of course this ideal situation may not always happen in practice, and some variations of it have been explored in the literature. 2. Let us pin down what we mean by the feasibility of learning. Learning pro­ duces a hypothesis g to approximate the unknown target function f. If learning is successful, then g should approximate f well, which means Eout(g) Rj 0. However, this is not what we get from the probabilistic analysis. What we get instead is Eout (g) Rj Ein (g). We still have to make Ein (g) Rj 0 in order to conclude that Eout (g) Rj 0. We cannot guarantee that we will find a hypothesis that achieves Ein (g) Rj 0, but at least we will know if we find it. Remember that Eout (g) is an unknown quantity, since f is unknown, but Ein (g) is a quantity that we can evaluate. We have thus traded the condition Eout (g) Rj 0, one that we cannot ascertain, for the condition Ein (g) Rj 0, which we can ascertain. What enabled this is the Hoeffding Inequality (1.6): lP[JEin(g) Eout(g)J > E] :S 2Me2E2N 25 1. THE LEARNING PROBLEM 1.3. Is LEARNING FEASIBLE? that assures us that Eout (g) � Ein (g) so we can use Ein as a proxy for Eout. Exercise 1.12 friend comes to you with a learning problem. She says the target func­ tion is completely unknown, but she has 4, 000 data points. She is willing to pay you to solve her problem and produce for her a g which approximates f. What is the best that you can promise her among the following: (a) After learning you will provide her with a g that you will guarantee approximates well out of sample. (b) After learning you will provide her with a g, and with high probability the g which you produce will approximate well out of sample. ( c) One of two things will happen. (i) You will produce a hypothesis g; (ii) You will declare that you failed. If you do return a hypothesis g, then with high probability the g which you produce will approximate well out of sample. One should note that there are cases where we won't insist that Ein (g) � 0. Financial forecasting is an example where market unpredict ability makes it impossible to get a forecast that has anywhere near zero error. All we hope for is a forecast that gets it right more often than not. If we get that, our bets will win in the long run. This means that a hypothesis that has Ein (g) somewhat below 0.5 will work, provided of course that Eout(g) is close enough to Ein(g). The feasibility of learning is thus split into two questions: 1. Can we make sure that Eout (g) is close enough to Ein (g)? 2. Can we make Ein(g) small enough? The Hoeffding Inequality (1.6) addresses the first question only. The second question is answered after we run the learning algorithm on the actual data and see how small we can get Ein to be. Breaking down the feasibility of learning into these two questions provides further insight into the role that different components of the learning problem play. One such insight has to do with the 'complexity ' of these componen ts. The complexit y of }{. If the number of hypotheses ]VJ goes up, we run more risk that Ein (g) will be a poor estimator of Eout (g) according to In­ equality (1.6). ]VJ can be thought of as a measure of the 'complexity ' of the 26 1. THE LEARNING PROBLEM 1.4. ERROR AND NOISE hypothesis set 1{ that we use. If we want an affirmative answer to the first question, we need to keep the complexity of 1{ in check. However, if we want an affirmative answer to the second question, we stand a better chance if 1{ is more complex, since g has to come from 1{. So, a more complex 1{ gives us more flexibility in finding some g that fits the data well, leading to small Ein (g). This tradeoff in the complexity of 1{ is a major theme in learning theory that we will study in detail in Chapter 2. The complexit y of f. Intuitively, a complex target function f should be harder to learn than a simple f. Let us examine if this can be inferred from the two questions above. A close look at Inequality (1.6) reveals that the complexity of f does not affect how well Ein (g) approximates Eout (g). If we fix the hypothesis set and the number of training examples, the inequality provides the same bound whether we are trying to learn a simple f (for instance a constant function) or a complex f (for instance a highly nonlinear function). However, this doesn't mean that we can learn complex functions as easily as we learn simple functions. Remember that (1.6) affects the first question only. If the target function is complex, the second question comes into play since the data from a complex f are harder to fit than the data from a simple f. This means that we will get a worse value for Ein(g) when f is complex. We might try to get around that by making our hypothesis set more complex so that we can fit the data better and get a lower Ein (g), but then Eout won't be as close to Ein per (1.6). Either way we look at it, a complex f is harder to learn as we expected. In the extreme case, if f is too complex, we may not be able to learn it at all. Fortunately, most target functions in real life are not too complex; we can learn them from a reasonable V using a reasonable H. This is obviously a practical observation, not a mathematical statement. Even when we cannot learn a particular f, we will at least be able to tell that we can't. As long as we make sure that the complexity of 1{ gives us a good Hoeffding bound, our success or failure in learning f can be determined by our success or failure in fitting the training data. 1.4 Error and Noise We close this chapter by revisiting two notions in the learning problem in order to bring them closer to the real world. The first notion is what approximation means when we say that our hypothesis approximates the target function well. The second notion is about the nature of the target function. In many situations, there is noise that makes the output off not uniquely determined by the input. What are the ramifications of having such a 'noisy' target on the learning problem? 27 1. THE LEARNING PROBLEM 1.4. ERROR AND NOISE 1.4.1 Error Measures Learning is not expected to replicate the target function perfectly. The final hypothesis g is only an approximation of f. To quantify how well g approxi­ mates f, we need to define an error measure3 that quantifies how far we are from the target. The choice of an error measure affects the outcome of the learning process. Different error measures may lead to different choices of the final hypothesis, even if the target and the data are the same, since the value of a particular error measure may be small while the value of another error measure in the same situation is large. Therefore, which error measure we use has consequences for what we learn. What are the criteria for choosing one error measure over another? We address this question here. First, let's formalize this notion a bit. An error measure quantifies how well each hypothesis h in the model approximates the target function f, Error = E(h, f). While E(h, f) is based on the entirety of h and f, it is almost universally de­ fined based on the errors on individual input points x. If we define a pointwise error measure e(h(x), f(x)), the overall error will be the average value of this pointwise error. So far, we have been working with the classification error e(h(x), f(x)) = [h(x) f-J(x)]. In an ideal world, E(h, J) should be user-specified. The same learning task in different contexts may warrant the use of different error measures. One may view E(h, J) as the 'cost' of using h when you should use f. This cost depends on what his used for, and cannot be dictated just by our learning techniques. Here is a case in point. Example 1.1 (Fingerprint verification). Consider the problem of verifying that a fingerprint belongs to a particular person. What is the appropriate error measure? f {+1 -1 you The target function takes as input a fingerprint, and returns + 1 if it belongs to the right person, and -1 if it belongs to an intruder. 3This measure is also called an error function in the literature, and sometimes the error is referred to as cost, objective, or risk. 28 1. THE LEARNING PROBLEM 1.4. ERROR AND NOISE There are two types of error that our hypothesis h can make here. If the correct person is rejected (h = -1 but f = +1), it is called false reject, and if an incorrect person is accepted (h = +1 but f = -1), it is called false accept. h +1 -1 +1 no error false reject f -1 false accept no error How should the error measure be defined in this problem? If the right person is accepted or an intruder is rejected, the error is clearly zero. We need to specify the error values for a false accept and for a false reject. The right values depend on the application. Consider two potential clients of this fingerprint system. One is a super­ market who will use it at the checkout counter to verify that you are a member of a discount program. The other is the CIA who will use it at the entrance to a secure facility to verify that you are authorized to enter that facility. For the supermarket, a false reject is costly because if a customer gets wrongly rejected, she may be discouraged from patronizing the supermarket in the future. All future revenue from this annoyed customer is lost. On the other hand, the cost of a false accept is minor. You just gave away a discount to someone who didn't deserve it, and that person left their fingerprint in your system they must be bold indeed. For the CIA, a false accept is a disaster. An unauthorized person will gain access to a highly sensitive facility. This should be reflected in a much higher cost for the false accept. False rejects, on the other hand, can be tolerated since authorized persons are employees (rather than customers as with the supermarket). The inconvenience of retrying when rejected is just part of the job, and they must deal with it. The costs of the different types of errors can be tabulated in a matrix. For our examples, the matrices might look like: f f +1 -1 +1 -1 h +1 0 1 h +1 0 1000 -1 10 0 -1 1 0 Supermarket CIA These matrices should be used to weight the different types of errors when we compute the total error. When the learning algorithm minimizes a cost­ weighted error measure, it automatically takes into consideration the utility of the hypothesis that it will produce. In the supermarket and CIA scenarios, this could lead to two completely different final hypotheses. D The moral of this example is that the choice of the error measure depends on how the system is going to be used, rather than on any inherent criterion 29 1. THE LEARNING PROBLEM Ix) TRAINING EXAMPLES HYPOTHESIS SET 1.4. ERROR AND NOISE UNKNOWN INPUT DISTRIBUTION Figure 1.11: The general (supervised) learning problem that we can independently determine during the learning process. However, this ideal choice may not be possible in practice for two reasons. One is that the user may not provide an error specification, which is not uncommon. The other is that the weighted cost may be a difficult objective function for optimizers to work with. Therefore, we often look for other ways to define the error measure, sometimes with purely practical or analytic considerations in mind. We have already seen an example of this with the simple binary error used in this chapter, and we will see other error measures in later chapters. 1.4.2 Noisy Targets In many practical applications, the data we learn from are not generated by a deterministic target function. Instead, they are generated in a noisy way such that the output is not uniquely determined by the input. For instance, in the credit-card example we presented in Section 1.1, two customers may have identical salaries, outstanding loans, etc., but end up with different credit behavior. Therefore, the credit 'function' is not really a deterministic function, 30 1. THE LEARNING PROBLEM 1.4. ERROR AND NOISE but a noisy one. This situation can be readily modeled within the same framework that we have. Instead of y = f(x), we can take the output y to be a random variable that is affected by, rather than determined by, the input x. Formally, we have a target distribution P(y I x) instead of a target function y = f (x). A data point (x, y) is now generated by the joint distribution P(x, y) = P(x)P(y I x). One can think of a noisy target as a deterministic target plus added noise. If y is real-valued for example, one can take the expected value of y given x to be the deterministic f (x), and consider y - f (x) as pure noise that is added to f. This view suggests that a deterministic target function can be considered a special case of a noisy target, just with zero noise. Indeed, we can formally express any function f as a distribution P(y I x) by choosing P(y I x) to be zero for all y except y = f (x). Therefore, there is no loss of generality if we consider the target to be a distribution rather than a function. Figure 1.11 modifies the previous Figures 1.2 and 1.9 to illustrate the general learning problem, covering both deterministic and noisy targets. Exercise 1.13 Consider the bin model for a hypothesis h that makes an error with prob ability µ in approximating a deterministic target function (both h and ar� binary functions). If we use the same h to approximate a noisy version off given by P(y I x) = y = f(x), 1-.A y f(x). (a) What is the probability of error that h makes in approximating y? (b) At what value of A will the performance of h be independent ofµ? [Hint: The noisy target will look completely random.] There is a difference between the role of P(y I x) and the role of P(x) in the learning problem. While both distributions model probabilistic aspects of x and y, the target distribution P(y I x) is what we are trying to learn, while the input distribution P(x) only quantifies the relative importance of the point x in gauging how well we have learned. Our entire analysis of the feasibility of learning applies to noisy target functions as well. Intuitively, this is because the Hoeffding Inequality (1.6) applies to an arbitrary, unknown target function. Assume we randomly picked all the y's according to the distribution P(y I x) over the entire input space X. This realization of P(y I x) is effectively a target function. Therefore, the inequality will be valid no matter which particular random realization the 'target function' happens to be. This does not mean that learning a noisy target is as easy as learning a deterministic one. Remember the two questions of learning? With the same learning model, Eout may be as close to Ein in the noisy case as it is in the 31 1. THE LEARNING PROBLEM 1.4. ERROR AND NOISE deterministic case, but Ein itself will likely be worse in the noisy case since it is hard to fit the noise. In Chapter 2, where we prove a stronger version of (1.6), we will assume the target to be a probability distribution P(y Ix), thus covering the general case. 32 1. THE LEARNING PROBLEM 1.5. PROBLEMS 1.5 Problems Probl em 1.1 We have 2 opaque bags, each containing 2 balls. One bag has 2 black balls and the other has a black and a white ball. You pick a bag at random and then pick one of the balls in that bag at random. When you look at the ball it is black. You now pick the second ball from that same bag. What is the probability that this ball is also black? {Hint: Use Bayes' Theorem: JID[A and B] = JID[A I B] JID [BJ = JID[B I A] JID [A].] Problem 1.2 Consider the perceptron in two dimensions: h(x) = sign(wTx) where w = [wo, w1, w2r and x = [1, x1, x2r. Technically, x has three coordinates, but we call this perceptron two-dimensional because the first coordinate is fixed at 1. (a) Show that the regions on the plane where h(x) = +1 and h(x) = -1 are separated by a line. If we express this line by the equation x2 = ax1 + b, what are the slope a and intercept bin terms of wo, w1, w2? (b) Draw a picture for the cases w = [1, 2, 3r and w = -[1, 2, 3r. In more than two dimensions, the +1 and -1 regions are separated by a hy perplane, the generalization of a line. Problem 1.3 Prove that the PLA eventually converges to a linear separator for separable data. The following steps will guide you through the proof. Let w* be an optimal set of weights (one which separates the data). The essential idea in this proof is to show that the PLA weights w(t) get \"more aligned\" with w* with every iteration. For simplicity, assume that w(O) = 0. (a) Let p = min1::n::N Yn(wnxn). Show that p > 0. (b) Show that wT (t)w* � wT(t-l)w* +p, and conclude that wT(t)w* � tp. [Hint: Use induction.] (c) Show that llw(t)ll2 :: llw(t -1)112 + llx(t -1)112. {Hint: y(t - 1) · (wT(t -l)x(t-1)):: 0 because x(t -1) was misclas sified byw(t -1).j (d) Show by induction that llw(t)ll2:: tR2, where R = max1::n::N llxnll· (continued on next page) 33 1. THE LEARNING PROBLEM (e) Using (b) and (d), show that and hence prove that WT(t) * Vt p ll w(t)llw � t·R' [ J Hint: llw(t)l/ llw*ll :: 1. Why? 1.5. PROBLEMS In practice, PLA converges more quickly than the bound suggests. p Nevertheless, because we do not know p in advance, we can't determine the number of iterations to convergence, which does pose a problem if the data is non-separable. Problem 1.4 In Exercise 1.4, we use an artificial data set to study the perceptron learning algorithm. This problem leads you to explore the algorithm further with data sets of different sizes and dimensions. (a) Generate a linearly separable data set of size 20 as indicated in Exer­ cise 1.4. Plot the examples { (xn, Yn)} as well as the target function f on a plane. Be sure to mark the examples from different classes differently, and add labels to the axes of the plot. (b) Run the perceptron learning algorithm on the data set above. Report the number of updates that the algorithm takes before converging. Plot the examples { (xn, Yn)}, the target function f, and the final hypothesis g in the same figure. Comment on whether f is close tog. (c) Repeat everything in (b) with another randomly generated data set of size 20. Compare your results with (b ). ( d) Repeat everything in (b) with another randomly generated data set of size 100. Compare your results with (b). (e) Repeat everything in (b) with another randomly generated data set of size 1, 000. Compare your results with (b ). (f) Modify the algorithm such that it takes Xn E JR10 instead of JR2. Ran­ domly generate a linearly separable data set of size 1, 000 with Xn E JR10 and feed the data set to the algorithm. How many updates does the algorithm take to converge? (g) Repeat the algorithm on the same data set as (f) for 100 experiments. In the iterations of each experiment, pick x(t) randomly instead of determin­ istically. Plot a histogram for the number of updates that the algorithm takes to converge. (h) Summarize your conclusions with respect to accuracy and running time as a function of N and d. 34 1. THE LEARNING PROBLEM 1.5. PROBLEMS Probl em 1.5 The perceptron learning algorithm works like this: In each it eration t, pick a random (x(t), y(t)) and compute the 'signal' s(t) = wT(t)x(t). If y(t) · s(t) ::=:; 0, update w by w(t + 1) +-w(t) + y(t) · x(t) ; One may argue that this algorithm does not take the 'closeness' between s(t) and y(t) into consideration. Let's look at another perceptron learning algo­ rithm: In each iteration, pick a random (x(t), y(t)) and compute s(t). If y(t) · s(t) ::; 1, update w by w(t + 1) +-w(t) + 'T/ • (y(t) s(t)) · x(t) , where 'T/ is a constant. That is, if s(t) agrees with y(t) well (their product is > 1), the algorithm does nothing. On the other hand, if s(t) is further from y(t), the algorithm chang es w(t) more. In this problem, you are asked to implement this algorithm and study its performance. (a) Generate a training data set of size 100 similar to that used in Exercise 1.4. Generate a test data set of size 10, 000 from the same process. To get g, run the algorithm above with 'T/ = 100 on the training data set, until a maximum of 1, 000 updates has been reached. Plot the training data set, the target function f, and the final hypothesis g on the same figure. Report the error on the test set. (b) Use the data set in (a) and redo everything with 'T/ = 1. (c) Use the data set in (a) and redo everything with 'T/ = 0.01. (d) Use the data set in (a) and redo everything with 'T/ = 0.0001. (e) Compare the results that you get from (a) to (d). The algorithm above is a variant of the so called Adaline (Adaptive Linear Neuron) algorithm for perceptron learning. Problem 1.6 Consider a sample of 10 marbles drawn independently from a bin that holds red and green marbles. The probability of a red marble is µ. Forµ= 0.05, µ = 0.5, and µ = 0.8, compute the probability of getting no red marbles (v = 0) in the following cases. (a) We draw only one such sample. Compute the probability that v = 0. (b) We draw 1, 000 independent samples. Compute the probability that (at least) one of the samples has v = 0. ( c) Repeat (b) for 1, 000, 000 independent samples. 35 1. THE LEARNING PROBLEM 1.5. PROBLEMS Problem 1. 7 A sample of heads and tails is created by tossing a coin a number of times independen tly. Assume we have a number of coins that generate different samples independently. For a given coin, let the probability of heads (probability of error) be µ. The probability of obtaining k heads in N tosses of this coin is given by the binomial distribution: Remember that the training error v is �. (a) Assume the sample size (N) is 10. If all the coins haveµ = 0.05 compute the probability that at least one coin will have v = 0 for the case of 1 coin, 1, 000 coins, 1, 000, 000 coins. Repeat forµ= 0.8. (b) For the case N = 6 and 2 coins with µ = 0.5 for both coins, plot the probability P[m�x IVi - µii > E] i for E in the range [O, 1] (the max is over coins). On the same plot show the bound that would be obtained using the Hoeffding Inequality. Remember that for a single coin, the Hoeffding bound is [Hint: Use P[A or B] = P[A] + P[B] P[A and BJ = P[A] + P[B] - P[A]P[B], where the last equality follows by independence, to evaluate P[max ... ]} Problem 1.8 The Hoeffding Inequality is one form of the law of large numbers. One of the simplest forms of that law is the Chebyshev Inequality, which you will prove here. (a) If t is a non negative random variable, prove that for any a > 0, JP'[t �a] :S; JE(t)/a. (b) If u is any random variable with mean µ and variance 0\"2, prove that for any a> 0, JP'[(u µ)2 2: a] :S; [Hint: Use (a)] (c) If u1, · • • , UN are iid random variables, each with meanµ and variance 0\"2, and u = tr l.:�=l Un, prove that for any a> 0, (]\"2 JP'[(u µ)2 2: a] :S; Na . Notice that the RHS of this Chebyshev Inequality goes down linearly in N, while the counterpart in Hoeffding's Inequality goes down exponentially. In Problem 1.9, we develop an exponential bound using a similar approach. 36 1. THE LEARNING PROBLEM 1. 5. PROBLEMS Probl em 1.9 In this problem, we derive a form of the law of large numbers that has an exponential bound, called the Chernoff bound. We focus on the simple case of flipping a fair coin, and use an approach similar to Problem 1.8. (a) Lett be a (finite) random variable, a be a positive constant, and s be a positive parameter. If T(s) =Et( est), prove that [Hint: est is monotonically increasing in t.] (b) Let u1, · · · ,uN be iid random variables, and let u = if L::=l Un. If U(s) = lEun (esun) (for any n), prove that (c) Suppose lP'[un = O] = IP[un = 1] = � (fair coin). Evaluate U(s) as a function of s, and minimize e-sau(s) with respect to s for fixed a, O<a<l . (d) Conclude in (c) that, for 0 < E < �. JP'[u � JE(u) + E] :: Tf3N , where (3 = 1 + (� + E)log2(� + E) + (� -E)log2(� -E) and E(u) = �· Show that (3 > 0, hence the bound is exponentially decreasing in N. Problem 1.10 Assume that X = {x1,x2, ... ,xN,XN+1, ... ,xN+M} and Y = {-1, +1} with an unknown target function f: X--+ Y. The training data set V is (x1, y1), .. · , (xN, YN ). Define the off-training-set error of a hypothesis h with respect to f by 1 M Eoff(h, f) = M I: [h(xN+m) -I f(XN+m)]. m=l (a) Say f (x) = +1 for all x and h(x) = { +1, for x = Xk and k is odd and 1 :: k :: M + N -1, otherwise What is Eoff(h, f)? (b) We say that a target function f can 'generate' V in a noiseless setting if Yn = f (xn) for all (xn, Yn) E D. For a fixed V of size N, how many possible f: X--+ Y can generate V in a noiseless setting? ( c) For a given hypothesis hand an integer k between 0 and M, how many of those f in (b) satisfy Eoff (h, f) = -it? ( d) For a given hypothesis h, if all those f that generate V in a noiseless setting are equally likely in probability, what is the expected offtraining­ set error E1 [Eoff(h, !)]? (continued on next page) 37 1. THE LEARNING PROBLEM 1.5. PROBLEMS ( e) A deter ministic algorithm A is defined as a procedure that takes V as an input, and outputs a hypothesis h = A(V). Argue that for any two deterministic algorithms Ai and A2, You have now proved that in a noiseless setting, for a fixed V, if all possible f are equally likely, any two deterministic algorithms are equivalent in terms of the expected offtrainingset error. Similar results can be proved for more general settings. Problem 1.11 The matrix which tabulates the cost of various errors for the CIA and Supermarket applications in Example 1.1 is called a risk or loss matrix. For the two risk matrices in Example 1.1, explicitly write down the insample error Ein that one should minimize to obtain g. This in-sample error should weight the different types of errors based on the risk matrix. [Hint: Consider Yn = + 1 and Yn = -1 separately.] Problem 1.12 This problem investigates how changing the error measure can change the result of the learning process. You have N data points y1 :: · · · :: YN and wish to estimate a 'representative' value. (a) If your algorithm is to find the hypothesis h that minimizes the insample sum of squared deviations, N Ein(h) = L(h -Yn)2, n=l then show that your estimate will be the insample mean, 1 N hmean = N LYn· n=l (b) If your algorithm is to find the hypothesis h that minimizes the insample sum of absolute deviations, N Ein(h) = L lh-Ynl, n=l then show that your estimate will be the insample median hmed. which is any value for which half the data points are at most hmed and half the data points are at least hmed· (c) Suppose YN is perturbed to YN + E, where E-+ oo. So, the single data point YN becomes an outlier. What happens to your two estimators hmean and hmed? 38 Chapter 2 Training versus Testing Before the final exam, a professor may hand out some practice problems and solutions to the class. Although these problems are not the exact ones that will appear on the exam, studying them will help you do better. They are the 'training set' in your learning. If the professor's goal is to help you do better in the exam, why not give out the exam problems themselves? Well, nice try @. Doing well in the exam is not the goal in and of itself. The goal is for you to learn the course material. The exam is merely a way to gauge how well you have learned the material. If the exam problems are known ahead of time, your performance on them will no longer accurately gauge how well you have learned. The same distinction between training and testing happens in learning from data. In this chapter, we will develop a mathematical theory that characterizes this distinction. We will also discuss the conceptual and practical implications of the contrast between training and testing. 2.1 Theory of Generaliz ation The out-of-sample error Eout measures how well our training on D has gener­ alized to data that we have not seen before. Eout is based on the performance over the entire input space X. Intuitively, if we want to estimate the value of Eout using a sample of data points, these points must be 'fresh' test points that have not been used for training, similar to the questions on the final exam that have not been used for practice. The in sample error Ein, by contrast, is based on data points that have been used for training. It expressly measures training performance, similar to your performance on the practice problems that you got before the final exam. Such performance has the benefit of looking at the solutions and adjusting according ly, and may not reflect the ultimate performance in a real test. We began the analysis of in-sample error in Chapter 1, and we will extend this 39 2. TRAINING VERSUS TESTING 2.1. THEORY OF GENERALIZATION analysis to the general case in this chapter. We will also make the contrast between a training set and a test set more precise. A word of warning: this chapter is the heaviest in this book in terms of mathematical abstraction. To make it easier on the not-so-mathematically inclined, we will tell you which part you can safely skip without 'losing the plot'. The mathematical results provide fundamental insights into learning from data, and we will interpret these results in practical terms. Generalization error. We have already discussed how the value of Ein does not always generalize to a similar value of Eout. Generalization is a key issue in learning. One can define the generalization error as the discrepancy between Ein and Eout· 1 The Hoeffding Inequality (1.6) provides a way to characterize the generalization error with a probabilistic bound, for any E > 0. This can be rephrased as follows. Pick a tolerance level 8, for example o = 0.05, and assert with probability at least 1 o that 2M. 2N o (2.1) We refer to the type of inequality in (2.1) as a generalization bound because it bounds Eout in terms of Ein . To see that the Hoeffding Inequality implies this generalization bound, we rewrite (1.6) as follows: with probability at least 1 21Vle2NE2, IEout Einl ::; E, which implies Eout ::; Ein + E. We may now identify o = 2M e2N E2, from which E = ln and (2.1) follows. Notice that the other side of IEout Einl ::; E also holds, that is, Eout 2: Ein - E for all h E 1-l. This is important for learning, but in a more subtle way. Not only do we want to know that the hypothesis g that we choose (say the one with the best training error) will continue to do well out of sample (i.e., Eout ::; Ein + E), but we also want to be sure that we did the best we could with our 1-l (no other hypothesis h E 1-l has Eout ( h) significantly better than Eout (g)). The Eout (h) 2: Ein ( h) - E direction of the bound assures us that we couldn't do much better because every hypothesis with a higher Ein than the g we have chosen will have a comparably higher Eout. The error bound ln in (2.1), or 'error bar' if you will, depends on IV!, the size of the hypothesis set 1-l. If 1-l is an infinite set, the bound goes to infinity and becomes meaningle ss. Unfortunately, almost all interesting learning models have infinite 1-l, including the simple perceptron which we discussed in Chapter 1. In order to study generalization in such models, we need to derive a coun­ terpart to (2.1) that deals with infinite 1-l. We would like to replace M with 1Sometimes 'generalization error' is used as another name for Eout, but not in this book. 40 2. TR AINING VERSUS TESTING 2.1. THEORY OF GENERALIZATION something finite, so that the bound is meaningful. To do this, we notice that the way we got the M factor in the first place was by taking the disjunction of events: \"JEin(h1) Eout(h1)J > E\" or \"JEin(h2) Eout(h2)J > E\" or (2.2) which is guaranteed to include the event \"JEin (g) Eout (g) J > E\" since g is al­ ways one of the hypotheses in 1-l. We then over-estimated the probability using the union bound. Let Bm be the (Bad) event that \"JEin(hm)Eout(hm)J > E\". Then, If the events B1, B2, · · · , BM are strongly overlapping, the union bound becomes par­ ticularly loose as illustrated in the figure to the right for an example with 3 hypotheses; the areas of different events correspond to their probabilities. The union bound says that the total area covered by 81, B2, or Bs is smaller than the sum of the individual ar­ eas, which is true but is a gross overestimate when the areas overlap heavily as in this ex­ ample. The events \"JEin(hm) Eout(hm)J > E\"; m = 1, · · · , JV[, are often strongly overlap­ ping. If h1 is very similar to h2 for instance, the two events \"JEin(h1) Eout(h1)J > E\" and \"JEin(h2) Eout(h2)J > E\" are likely to coincide for most data sets. In a typical learning model, many hy­ potheses are indeed very similar. If you take the perceptron model for instance, as you slowly vary the weight vector w, you get infinitely many hypotheses that differ from each other only infinitesimally. The mathematical theory of generalization hinges on this observation. Once we properly account for the overlaps of the different hypotheses, we will be able to replace the number of hypotheses M in (2.1) by an effective number which is finite even when ]\\If is infinite, and establish a more useful condition under which Eout is close to Ein. 2.1.1 Effective Number of Hypotheses We now introduce the growth function, the quantity that will formalize the effective number of hypotheses. The growth function is what will replace 11/f 41 2. TRAINING VERSUS TESTING 2.1. THEORY OF GENERALIZATION in the generalization bound (2.1). It is a combinatorial quantity that cap­ tures how different the hypotheses in 1-l are, and hence how much overlap the different events in (2.2) have. We will start by defining the growth function and studying its basic prop­ erties. Next, we will show how we can bound the value of the growth function. Finally, we will show that we can replace M in the generalization bound with the growth function. These three steps will yield the generalization bound that we need, which applies to infinite 1-l. We will focus on binary target functions for the purpose of this analysis, so each h E 1-l maps X to { -1, + 1}. The definition of the growth function is based on the number of different hypotheses that 1-l can implement , but only over a finite sample of points rather than over the entire input space X. If h E 1-l is applied to a finite sample x1, ... ,xN EX,wegetanN-tupleh(x1), ... ,h(xN)of±l's. SuchanN-tuple is called a dichotomy since it splits x1, · · · , XN into two groups: those points for which h is -1 and those for which h is + 1. Each h E 1-l generates a dichotomy on x1, · · · , XN, but two different h's may generate the same dichotomy if they happen to give the same pattern of ±1 's on this particular sample. Definition 2.1. Let x1, · · · , XN E X. The dichotomies generated by 1-l on these points are defined by 1-l(x1, .. · , XN) = { (h(x1), .. · , h(xN )) I h E 1-l}. (2.3) One can think of the dichotomies 1-l(xi, · · · , XN) as a set of hypotheses just like 1-l is, except that the hypotheses are seen through the eyes of N points only. A larger 1-l(x1, · · · , XN) means 1-l is more 'diverse' generating more dichotomies on x1, · · · , XN. The growth function is based on the number of dichotom ies. Definition 2.2. The growth function is defined for a hypothesis set 1-l by where I · I denotes the cardinality (number of elements) of a set. In words, mti ( N) is the maximum number of dichotomies that can be gen­ erated by 1-l on any N points. To compute mH(N), we consider all possible choices of N points x1, · · · , XN from X and pick the one that gives us the most dichotomies . Like]\\![, mH(N) is a measure of the number of hypotheses in 1-l, except that a hypothesis is now considered on N points instead of the entire X. For any 1-l, since 1-l(x1, · · · ,xN) � {-1, +l}N (the set of all possible dichotomies on any N points), the value of mH(N) is at most l{-1,+l}NI, hence mH(N)::; 2N. If 1-l is capable of generating all possible dichotomies on x1, · · · , XN, then 1-l(x1, · · · , XN) = {-1, + 1 }N and we say that 1-l can shatter x1, · · · , XN. This signifies that 1-l is as diverse as can be on this particular sample. 42 2. TRAINING VERSUS TESTING 2.1. THEORY OF GENERALI ZATION • (a) (b) (c) Figure 2.1: Illustration of the growth function for a two dimensional per ceptron. The dichotomy of red versus blue on the 3 colinear points in part (a) cannot be generated by a perceptron, but all 8 dichotomies on the 3 points in part (b) can. By contrast, the dichotomy of red versus blue on the 4 points in part (c) cannot be generated by a perceptron. At most 14 out of the possible 16 dichotomies on any 4 points can be generated. Example 2.1. If X is a Euclidean plane and 1-l is a two-dimensional percep­ tron, what are m1-l(3) and m1-l(4)? Figure 2.l(a) shows a dichotomy on 3 points that the perceptron cannot generate, while Figure 2.l(b) shows another 3 points that the perceptron can shatter, generating all 23 = 8 dichotomies. Because the definition of m1-l ( N) is based on the maximum number of di­ chotomies, m1-l(3) = 8 in spite of the case in Figure 2.l(a). In the case of 4 points, Figure 2 .1 ( c) shows a dichotomy that the perceptron cannot generate. One can verify that there are no 4 points that the perceptron can shatter. The most a perceptron can do on any 4 points is 14 dichotomies out of the possible 16, where the 2 missing dichotomies are as depicted in Figure 2.l(c) with blue and red corresponding to -1, +1 or to +1, -1. Hence, m1-l(4) = 14. D Let us now illustrate how to compute mH(N) for some simple hypothesis sets. These examples will confirm the intuition that m1-l ( N) grows faster when the hypothesis set 1-l becomes more complex. This is what we expect of a quantity that is meant to replace l\\!f in the generalization bound ( 2 .1). Example 2.2. Let us find a formula for mH(N) in each of the following cases. 1. Positive rays: 1-l consists of all hypotheses h: R -7 {-1, + 1} of the form h(x) = sign(x -a), i.e., the hypotheses are defined in a one-dimensional input space, and they return -1 to the left of some value a and + 1 to the right of a. 43 2. TRAINING VERSUS TESTING 2.1. THEORY OF GENERALIZATION To compute m1-l ( N), we notice that given N points, the line is split by the points into N + 1 regions. The dichotomy we get on the N points is decided by which region contains the value a. As we vary a, we will get N + 1 different dichotomies. Since this is the most we can get for any N points, the growth function is Notice that if we picked N points where some of the points coincided (which is allowed), we will get less than N + 1 dichotomi es. This does not affect the value of m1-l ( N) since it is defined based on the maximum number of dichot omies. 2. Positive intervals: 1-l consists of all hypotheses in one dimension that return + 1 within some interval and -1 otherwise. Each hypothesis is specified by the two end values of that interval. To compute m1-l ( N), we notice that given N points, the line is again split by the points into N + 1 regions. The dichotomy we get is decided by which two regions contain the end values of the interval, resulting in (Nil) different dichotomies. If both end values fall in the same region, the resulting hypothesis is the constant -1 regardless of which region it is. Adding up these possibilities, we get (N+l) 1 1 m1-l (N) = 2 + 1 = 2 N2 + 2 N + 1. Notice that m1-l ( N) grows as the square of N, faster than the lin­ ear m1-l (N) of the 'simpler' positive ray case. 3. Convex sets: 1-l consists of all hypotheses in two dimensions h: JR2 -+ { -1, + 1} that are positive inside some convex set and negative elsewhere (a set is convex if the line segment connecting any two points in the set lies entirely within the set). To compute m1-l ( N) in this case, we need to choose the N points care­ fully. Per the next :figure, choose N points on the perimeter of a circle. Now consider any dichotomy on these points, assigning an arbitrary pat­ tern of ±1 's to the N points. If you connect the + 1 points with a polygon, the hypothesis made up of the closed interior of the polygon (which has to be convex since its vertices are on the perimeter of a circle) agrees with the dichotomy on all N points. For the dichotomies that have less than three + 1 points, the convex set will be a line segment, a point, or an empty set. 44 2. TRAINING VERSUS TESTING 2.1. THEORY OF GENERALIZATION This means that any dichotomy on these N points can be realized using a convex hypothesis, so 1-l manages to shatter these points and the growth function has the maximum possible value Notice that if the N points were chosen at random in the plane rather than on the perimeter of a circle, many of the points would be 'internal' and we wouldn't be able to shatter all the points with convex hypotheses as we did for the perimeter points. However, this doesn't matter as far as mH(N) is concerned, since it is defined based on the maximum (2N in this case) . D It is not practical to try to compute m11 ( N) for every hypothesis set we use. Fortunately, we don't have to. Since mH(N) is meant to replace ]\\If in (2.1), we can use an upper bound on m1l ( N) instead of the exact value, and the inequality in (2.1) will still hold. Getting a good bound on mH(N) will prove much easier than computing m1l ( N) itself, thanks to the notion of a break point. Definition 2.3. If no data set of size k can be shattered by 1-l, then k is said to be a break point for 1-l. If k is a break point, then mH(k) < 2k. Example 2.1 shows that k = 4 is a break point for two-dimensional perceptrons. In general, it is easier to find a break point for 1-l than to compute the full growth function for that 1-l. Exercise 2.1 By inspection, find a break point k for each hypothesis set in Example 2.2 (if there is one). Verify that m11,(k) < 2k using the formulas derived in that Example. We now use the break point k to derive a bound on the growth function m11(N) for all values of N. For example, the fact that no 4 points can be shattered by 45 2. TRAINING VERSUS TESTING 2.1. THEORY OF GENERALIZATION the two-dimensional perceptron puts a significant constraint on the number of dichotomies that can be realized by the perceptron on 5 or more points. We will exploit this idea to get a significant bound on m1-l ( N) in general. 2.1.2 Bounding the Growth Function The most important fact about growth functions is that if the condition m1-l ( N) = 2N breaks at any point, we can bound m1-l ( N) for all values of N by a simple polynomial based on this break point. The fact that the bound is polynomial is crucial. Absent a break point (as is the case in the convex hypothesis example), m1-l(N) = 2N for all N. If m1-l(N) replaced Min Equa- tion ( 2 .1), the bound ln on the generalization error would not go to zero regardless of how many training examples N we have. However, if m1-l ( N) can be bounded by a polynomial any polynomial , the generalization error will go to zero as N -- oo. This means that we will generalize well given a sufficient number of examples. safe skip: If you trust our math, you can the following part without compromising the sequence. A similar green box will tell you when rejoin. To prove the polynomial bound, we will introduce a combinatorial quantity that counts the maximum number of dichotomies given that there is a break point, without having to assume any particular form of 1-l. This bound will therefore apply to any 1-l. Definition 2.4. B(N, k) is the maximum number of dichotomies on N points such that no subset of size k of the N points can be shattered by these di­ chotomies. The definition of B(N, k} assumes a break point k, then tries to find the most dichotomies on N points without imposing any further restrictions . Since B ( N, k) is defined as a maximum, it will serve as an upper bound for any m1-l(N) that has a break point k; m1-l (N) ::; B(N, k) if k is a break point for 1-l. The notation B comes from 'Binomial' and the reason will become clear shortly. To evaluate B(N, k), we start with the two boundary conditions k = 1andN=1. B(N, 1) B(l, k) 1 2 for k > 1 . 46 2. TRAINING VERSUS TESTING 2 .1. THEORY OF GENERALIZATION B ( N, 1) = 1 for all N since if no subset of size 1 can be shattered, then only one dichotomy can be allowed. A second different dichotomy must differ on at least one point and then that subset of size 1 would be shattered. B(l, k) = 2 for k > 1 since in this case there do not even exist subsets of size k; the constraint is vacuously true and we have 2 possible dichotomies ( + 1 and -1) on the one point. We now assume N 2: 2 and k 2: 2 and try to develop a recursion. Consider the B(N, k) dichotomies in definition 2.4, where no k points can be shattered. We list these dichotomies in the following table, #of rows X1 X2 XN-1 XN +1 +1 +1 +1 -1 +1 +1 -1 S1 +1 -1 -1 -1 -1 +1 -1 +1 +1 -1 +1 -1 -1 +1 (3 +1 -1 +1 -1 -1 -1 S2 +1 -1 +1 -1 -1 +1 (3 +1 -1 +1 -1 -1 -1 where x1, · · · , XN in the table are labels for the N points of the dichotomy. We have chosen a convenient order in which to list the dichotomies, as follows. Consider the dichotomies on xi,··· , XN-l· Some dichotomies on these N -l points appear only once (with either +1 or -1 in the XN column, but not both). We collect these dichotomies in the set S1. The remaining dichotomies on the first N -1 points appear twice, once with + 1 and once with -1 in the XN column. We collect these dichotomies in the set S2 which can be divided into two equal parts, St and S-;; (with+ 1 and -1 in the XN column, respectivel y). Let S1 have a rows, and let st ands-;; have (3 rows each. Since the total number of rows in the table is B(N, k) by construction, we have B(N, k) =a+ 2(3. (2.4) The total number of different dichotomies on the first N -1 points is given by a+ (3; since st and S2 are identical on these N -1 points, their di­ chotomies are redundant . Since no subset of k of these first N -1 points can 47 2. TRAINING VERSUS TESTING 2.1. THEORY OF GENERALIZATION be shattered (since no k-subset of all N points can be shattered), we deduce that a+ ,B::; B(N 1,k) (2.5) by definition of B. Further, no subset of size k -1 of the first N -1 points can be shattered by the dichotomies in st. If there existed such a subset, then taking the corresponding set of dichotomies in 82 and adding XN to the data points yields a subset of size k that is shattered, which we know cannot exist in this table by definition of B ( N, k). Therefore, ,8::; B(N -1, k 1). (2.6) Substituting the two Inequalities (2.5) and (2.6) into (2.4), we get B(N, k)::; B(N -1, k) + B(N 1, k 1). (2.7) We can use (2.7) to recursively compute a bound on B(N, k), as shown in the following table. k 1 2 3 4 5 6 1 1 2 2 2 2 2 2 1 3 4 4 4 4 3 1 4 7 8 8 8 N \\i + 4 1 5 11 5 1 6 6 1 7 where the first row (N = 1) and the first column (k = 1) are the bound­ ary conditions that we already calculated. We can also use the recursion to bound B ( N, k) analytically. Lemma 2.3 (Sauer's Lemma). B(N, k) '.O ( �) Proof. The statement is true whenever k = 1 or N = 1, by inspection. The proof is by induction on N. Assume the statement is true for all N ::; N0 and all k. We need to prove the statement for N = N0 + 1 and all k. Since the statement is already true when k = 1 (for all values of N) by the initial condition, we only need to worry about k 2: 2. By (2. 7), B(No + 1, k) ::; B(No, k) + B(No, k -1). 48 2. TRAINING VERSUS TESTING 2 .1. THEORY OF GENERALIZ ATION Applying the induction hypothesis to each term on the RHS, we get B(No+l,k) < �(�0)+�(�0) 1+ � ( �o) + � c �o 1) 1+�[(�0)+(;�\"1)] where the combinatorial identity ( N°t1) ( 1:0) + ( i1!_01) has been used. This identity can be proved by noticing that to calculate the number of ways to pick i objects from N0+1 distinct objects, either the first object is included, in ( i1!_01) ways, or the first object is not included, in ( 1:0) ways. We have thus proved the induction step, so the statement is true for all N and k. II It turns out that B(N, k) in fact equals 2=7:� ( �) (see Problem 2.4), but we only need the inequality of Lemma 2.3 to bound the growth function. For a given break point k, the bound 2=7:� ( �) is polynomial in N, as each term in the sum is polynomial (of degree i :: k -1). Since B ( N, k) is an upper bound on any mH(N) that has a break point k, we have proved End safe skip: Those who skipped are now rejoining us. The next theorem states that any growth function m1l ( N) with a break point is bounded by a polyno­ mial. Theorem 2.4. If m1l (k) < 2k for some value k, then for all N. The RHS is polynomial in N of degree k -1. (2.8) The implication of Theorem 2.4 is that if H has a break point, we have what we want to ensure good generalization; a polynomial bound on mH(N). 49 2. TRAINING VERSUS TESTING 2.1. THEORY OF GENERALIZATION Exercise 2.2 (a) Verify the bound of Theorem 2.4 in the three cases of Example 2.2: (i) Positive rays: 1-l consists of all hypotheses in one dimension of the form h(x) = sign(x -a). (ii) Positive intervals: 1-l consists of all hypotheses in one dimension that are positive within some interval and negative elsewhere. (iii) Convex sets: 1-l consists of all hypotheses in two dimensions that are positive inside some convex set and negative elsewhere. (Note: you can use the break points you found in Exercise 2.1.) (b) Does there exist a hypothesis set for which m1i(N) = N 2LN/2J (where LN/2j is the largest integer� N/2)? 2.1.3 The VC Dimension Theorem 2.4 bounds the entire growth function in terms of any break point. The smaller the break point, the better the bound. This leads us to the fol­ lowing definition of a single parameter that characterizes the growth function. Definition 2.5. The Vapnik-Chervonenkis dimension of a hypothesis set ti, denoted by dvc(ti) or simply dvc, is the largest value of N for which mH(N) = 2N. If mH(N) = 2N for all N, then dvc(ti) = oo. If dvc is the VC dimension of ti, then k = dvc + 1 is a break point for m1-l since m1-l ( N) cannot equal 2N for any N > dvc by definition. It is easy to see that no smaller break point exists since ti can shatter dvc points, hence it can also shatter any subset of these points. Exercise 2.3 Compute the VC dimension of 1-l for the hypothesis sets in parts (i), (ii), (iii) of Exercise 2.2(a). Since k = dvc + 1 is a break point for m1-l, Theorem 2.4 can be rewritten in terms of the VC dimension: dvc (N) mH(N) � � i . (2.9) Therefore, the VC dimension is the order of the polynomial bound on m1-l ( N). It is also the best we can do using this line of reasoning, because no smaller break point than k = dvc + 1 exists. The form of the polynomial bound can be further simplified to make the dependency on dvc more salient. We state a useful form here, which can be proved by induction (Problem 2.5). (2.10) 50 2. TRAINING VERSUS TESTING 2 .1. THEORY OF GENERALIZATION Now that the growth function has been bounded in terms of the VC dimen­ sion, we have only one more step left in our analysis, which is to replace the number of hypotheses JV[ in the generalization bound (2.1) with the growth function m1-l (N). If we manage to do that, the VC dimension will play a pivotal role in the generalization question. If we were to directly replace M by mH(N) in (2.1), we would get a bound of the form Unless dvc(H) = oo, we know that mH(N) is bounded by a polynomial in N; thus, ln m1-l (N) grows logarithmic ally in N regardless of the order of the poly­ nomial, and so it will be crushed by the -k factor. Therefore , for any fixed tolerance 8, the bound on Eout will be arbitrarily close to Ein for sufficiently large N. Only if dvc(H) = oo will this argument fail, as the growth function in this case is exponential in N. For any finite value of dvc, the error bar will converge to zero at a speed determined by dvc, since dvc is the order of the polynomial. The smaller dvc is, the faster the convergence to zero. It turns out that we cannot just replace M with m1-l (N) in the generaliza­ tion bound (2.1), but rather we need to make other adjustments as we will see shortly. However, the general idea above is correct, and dvc will still play the role that we discussed here. One implication of this discussion is that there is a division of models into two classes. The 'good models' have finite dvc, and for sufficiently large N, Ein will be close to Eout; for good models, the in-sample performance generalizes to out of sample. The 'bad models' have infinite dvc. With a bad model, no matter how large the data set is, we cannot make generalization conclusions from Ein to Eout based on the VC analysis. 2 Because of its significant role, it is worthwhile to try to gain some insight about the VC dimension before we proceed to the formalities of deriving the new generalization bound. One way to gain insight about dvc is to try to compute it for learning models that we are familiar with. Perceptrons are one case where we can compute dvc exactly. This is done in two steps. First, we show that dvc is at least a certain value, then we show that it is at most the same value. There is a logical difference in arguing that dvc is at least a certain value, as opposed to at most a certain value. This is because dvc 2. N � there exists D of size N such that }{ shatters D, hence we have different conclusions in the following cases. 1. There is a set of N points that can be shattered by}{. In this case, we can conclude that dvc 2. N. 2In some cases with infinite dvc, such as the convex sets that we discussed, alternative analysis based on an 'average' growth function can establish good generalization behavior. 51 2. TRAINING VERSUS TESTING 2.1. THEORY OF GENERALIZATION 2. Any set of N points can be shattered by 1-l. In this case, we have more than enough information to conclude that dvc � N. 3. There is a set of N points that cannot be shattered by 1-l. Based only on this information, we cannot conclude anything about the value of dvc· 4. No set of N points can be shattered by 1-l. In this case, we can conclude that dvc < N. Exercise 2.4 Consider the input space x ]Rd (including the constant coordinate xo = 1). Show that the dimension of the perceptron (with d 1 parameters, counting wo) is exactly 1 by showing that it is at least d 1 and at most d 1, as follows. (a) To show that dvc 1, find 1 points in that the perceptron can shatter. [Hint: Construct a nonsingular 1) x 1) matrix whose rows represent the d 1 points, then use the nonsingu/arity to argue that the perceptron can shatter these points.] (b) To show that dvc d 1, show that no set of d 2 points in can be shattered by the perceptron. [Hint: Represent each point in as a vector of length d 1, then use the fact that any d 2 vectors of length d 1 have to be linearly dependent. This means that some vector is a linear combination of all the other vectors. Now, if you choose the class of these other vectors carefully, then the classification of the dependent vector will be dictated. Conclude that there is some dichotomy that cannot be implemented, and therefore that for N d 2, m1-l(N) < 2N.J The VC dimension of a d-dimensional perceptron 3 is indeed d + 1. This is consistent with Figure 2.1 for the case d = 2, which shows a VC dimension of 3. The perceptron case provides a nice intuition about the VC dimension, since d + 1 is also the number of parameters in this model. One can view the VC dimension as measuring the 'effective' number of parameters. The more parameters a model has, the more diverse its hypothesis set is, which is reflected in a larger value of the growth function mH ( N). In the case of perceptrons, the effective parameters correspond to explicit parameters in the model, namely wo, wi, · · · , Wd· In other models, the effective parameters may be less obvious or implicit. The VC dimension measures these effective parameters or 'degrees of freedom' that enable the model to express a diverse set of hypotheses. Diversity is not necessarily a good thing in the context of generalization. For example, the set of all possible hypotheses is as diverse as can be, so mH(N) = 2N for all N and dvc(H) = oo. In this case, no generalization at all is to be expected, as the final version of the generalization bound will show. 3 X {1} x JRd is considered d dimensional since the first coordinate xo 1 is fixed. 52 2. TRAINING VERSUS TESTING 2.1. THEORY OF GENERALIZA TION 2.1.4 The VC Generalization Bound If we treated the growth function as an effective number of hypotheses, and replaced Min the generalization bound (2.1) with m1-l(N), the resulting bound would be ? 1 l 2m1-l (N) Eout(g) :s; Ein(g) + 2N n 8 . (2.11) It turns out that this is not exactly the form that will hold. The quantities in red need to be technically modified to make (2.11) true. The correct bound, which is called the VC generalization bound, is given in the following theorem; it holds for any binary target function f, any hypothesis set 1-l, any learning algorithm A, and any input probability distribution P. Theorem 2.5 (VC generalization bound). For any tolerance 8 > 0, 8 l 4m1-l (2N) Eout(g) :s; Ein(g) + N n 8 with probability 2 1 -8. (2.12) If you compare the blue items in (2.12) to their red counterparts in (2.11), you notice that all the blue items move the bound in the weaker direction. How­ ever, as long as the VC dimension is finite, the error bar still converges to zero (albeit at a slower rate), since m1-l(2N) is also polynomial of order dvc in N, just like m1-l(N). This means that, with enough data, each and every hypoth­ esis in an infinite 1-l with a finite VC dimension will generalize well from Ein to Eout. The key is that the effective number of hypotheses, represented by the finite growth function, has replaced the actual number of hypotheses in the bound. The VC generalization bound is the most important mathematical result in the theory of learning. It establishes the feasibility of learning with infinite hypothesis sets. Since the formal proof is somewhat lengthy and technical, we illustrate the main ideas in a sketch of the proof, and include the formal proof as an appendix. There are two parts to the proof; the justification that the growth function can replace the number of hypotheses in the first place, and the reason why we had to change the red items in (2.11) into the blue items in (2.12). Sketch of the proof. The data set V is the source of randomization in the original Hoeffding Inequality. Consider the space of all possible data sets. Let us think of this space as a 'canvas' (Figure 2.2(a)). Each Vis a point on that canvas. The probability of a point is determined by which Xn 's in X happen to be in that particular V, and is calculated based on the distribution P over X. Let's think of probabilities of different events as areas on that canvas, so the total area of the canvas is 1. 53 2.TRAINING VERSUS TESTING • space of data sets (a) Hoeffding Inequality2.1. THEORY OF GENERALIZA TION (b) Union Bound (c) VC Bound Figure 2.2: Illustration of the proof of the VC bound, where the 'canvas' represents the space of all data sets, with areas corresponding to probabili ties. (a) For a given hypothesis, the colored points correspond to data sets where Ein does not generalize well to Eout· The Hoeffding Inequality guar antees a small colored area. (b) For several hypotheses, the union bound assumes no overlaps, so the total colored area is large. ( c) The VC bound keeps track of overlaps, so it estimates the total area of bad generalization to be relatively small. For a given hypothesis h E 1-i, the event \"IEin(h) Eout(h)I > E\" consists of all points V for which the statement is true. For a particular h, let us paint all these 'bad' points using one color. What the basic Hoeffding Inequality tells us is that the colored area on the canvas will be small (Figure 2.2(a)). Now, if we take another h E 1-i, the event \"IEin(h) Eout(h)I > E\" may contain different points, since the event depends on h. Let us paint these points with a different color. The area covered by all the points we colored will be at most the sum of the two individual areas, which is the case only if the two areas have no points in common. This is the worst case that the union bound considers. If we keep throwing in a new colored area for each h E 1-i, and never overlap with previous colors, the canvas will soon be mostly covered in color (Figure 2.2(b)). Even if each h contributed very little, the sheer number of hypotheses will eventually make the colored area cover the whole canvas. This was the problem with using the union bound in the Hoeffding Inequality (1.6), and not taking the overlaps of the colored areas into consideration. The bulk of the VC proof deals with how to account for the overlaps. Here is the idea. If you were told that the hypotheses in 1-i are such that each point on the canvas that is colored will be colored 100 times (because of 100 different h's), then the total colored area is now 1/100 of what it would have been if the colored points had not overlapped at all. This is the essence of the VC bound as illustrated in (Figure 2.2(c)). The argument goes as follows. 54 2. TRAINING VERSUS TESTING 2.2. INTERPRETING THE BOUND Many hypotheses share the same dichotomy on a given D, since there are finitely many dichotomies even with an infinite number of hypotheses. Any statement based on D alone will be simultaneously true or simultaneously false for all the hypotheses that look the same on that particular D. What the growth function enables us to do is to account for this kind of hypothesis redundancy in a precise way, so we can get a factor similar to the '100' in the above example. When 1-l is infinite, the redundancy factor will also be infinite since the hypotheses will be divided among a finite number of dichotomies. Therefore, the reduction in the total colored area when we take the redundancy into consideration will be dramatic. If it happens that the number of dichotomies is only a polynomial, the reduction will be so dramatic as to bring the total probability down to a very small value. This is the essence of the proof of Theorem 2.5. The reason m1-l ( 2N) appears in the VC bound instead of m1-l ( N) is that the proof uses a sample of 2N points instead of N points. Why do we need 2N points? The event \"IEin(h)Eout(h)J > E\" depends not only on D, but also on the entire X because Eout ( h) is based on X. This breaks the main premise of grouping h's based on their behavior on D, since aspects of each h outside of D affect the truth of \"JEin(h) Eout(h)J > E.\" To remedy that, we consider the artificial event \"IEin(h) E{n(h)J > E\" instead, where Ein and E{n are based on two samples D and D' each of size N. This is where the 2N comes from. It accounts for the total size of the two samples D and D'. Now, the truth of the statement \"IEin(h)E{n(h)J > E\" depends exclusively on the total sample of size 2N, and the above redundancy argument will hold. Of course we have to justify why the two-sample condition \"JEin ( h) E{n(h)J > E\" can replace the original condition \"JEin(h) Eout(h)J > E.\" In doing so, we end up having to shrink the E's by a factor of 4, and also end up with a factor of 2 in the estimate of the overall probability. This accounts for the � instead of in the VC bound and for having 4 instead of 2 as the multiplicative factor of the growth function. When you put all this together, you get the formula in (2.12). D 2.2 Interpreting the Generalizat ion Bound The VC generalization bound (2.12) is a universal result in the sense that it applies to all hypothesis sets, learning algorithms, input spaces, probability distributions, and binary target functions. It can be extended to other types of target functions as well. Given the generality of the result, one would suspect that the bound it provides may not be particularly tight in any given case, since the same bound has to cover a lot of different cases. Indeed, the bound is quite loose. 55 2. TRAINING VERSUS TESTING 2.2. INTERPRETING THE BOUND Exercise 2.5 Suppose we have a simple learning model whose growth function is m1l(N) = N 1, hence dvc = Use the VC bound (2.12) to esti­ mate the probability that Eout will be within 0.1 of Ein given 100 training examples. [Hint: The estimate will be ridiculous.} Why is the VC bound so loose? The slack in the bound can be attributed to a number of technical factors. Among them, 1. The basic Hoeffding Inequality used in the proof already has a slack. The inequality gives the same bound whether Eout is close to 0.5 or close to zero. However, the variance of Ein is quite different in these two cases. Therefore, having one bound capture both cases will result in some slack. 2. Using mH(N) to quantify the number of dichotomies on N points, re­ gardless of which N points are in the data set, gives us a worst-case estimate. This does allow the bound to be independen t of the prob­ ability distribution P over X. However, we would get a more tuned bound if we considered specific x1, · · · , XN and used IH(x1, · · · , XN) I or its expected value instead of the upper bound mH(N). For instance, in the case of convex sets in two dimensions, which we examined in Exam­ ple 2.2, if you pick N points at random in the plane, they will likely have far fewer dichotomies than 2N, while mH ( N) = 2N. 3. Bounding mH (N) by a simple polynomial of order dvc, as given in (2.10), will contribute further slack to the VC bound. Some effort could be put into tightening the VC bound, but many highly technical attempts in the literature have resulted in only diminishing returns. The reality is that the VC line of analysis leads to a very loose bound. Why did we bother to go through the analysis then? Two reasons. First, the VC analysis is what establishes the feasibility of learning for infinite hypothesis sets, the only kind we use in practice. Second, although the bound is loose, it tends to be equally loose for different learning models, and hence is useful for comparing the generalization performance of these models. This is an observation from practical experience, not a mathematical statement . In real applications, learning models with lower dvc tend to generalize better than those with higher dvc· Because of this observation, the VC analysis proves useful in practice, and some rules of thumb have emerged in terms of the VC dimension. For instance, requiring that N be at least 10 x dvc to get decent generalization is a popular rule of thumb. Thus, the VC bound can be used as a guideline for generaliza tion, relatively if not absolutely. With this understanding, let us look at the different ways the bound is used in practice. 56 2. TRA INING VERSUS TESTING 2.2. INTERPRETING THE BOUND 2.2.1 Sample Compl exity The sample complexity denotes how many training examples N are needed to achieve a certain generalization performance. The performance is specified by two parameters , E and 8. The error tolerance E determines the allowed generalization error, and the confidence parameter 8 determines how often the error tolerance E is violated. How fast N grows as E and 8 become smaller4 indicates how much data is needed to get good generalization. We can use the VC bound to estimate the sample complexity for a given learning model. Fix 8 > 0, and suppose we want the generalization error to be at most E. From Equation (2.12), the generalization error is bounded by ln and so it suffices to make ln ::; E. It follows that N > � ln (4m1-l(2N)) -E2 8 suffices to obtain generalization error at most E (with probability at least 1-8). This gives an implicit bound for the sample complexity N, since N appears on both sides of the inequality. If we replace m1-l (2N) in (2.12) by its polynomial upper bound in (2.10) which is based on the the VC dimension, we get a similar bound 8 (4((2N)dvc+l)) N � E2 ln 8 ' (2.13) which is again implicit in N. We can obtain a numerical value for N using simple iterative methods. Example 2.6. Suppose that we have a learning model with dvc = 3 and would like the generalization error to be at most 0.1 with confidence 90% (so E = 0.1 and 8 = 0.1). How big a data set do we need? Using (2.13), we need N > 1n + . -0.12 0.1 Trying an initial guess of N = 1, 000 in the RHS, we get N > ln x 1000)3 + � 21 193. -0.12 0.1 ' We then try the new value N = 21, 193 in the RHS and continue this iterative process, rapidly converging to an estimate of N � 30, 000. If dvc were 4, a similar calculation will find that N � 40, 000. For dvc = 5, we get N � 50, 000. You can see that the inequality suggests that the number of examples needed is approximately proportional to the VC dimension, as has been observed in practice. The constant of proportionality it suggests is 10,000, which is a gross overestima te; a more practical constant of proportiona lity is closer to 10. D 4The term 'complexity' comes from a similar metaphor in computational complexity. 57 2. TRAINING VERSUS TESTING 2.2. INTERPRETING THE BOUND 2.2.2 Penalty for Model Compl exity Sample complexity fixes the performance parameters E (generalization error) and 8 (confidence parameter ) and estimates how many examples N are needed. In most practical situations, however, we are given a fixed data set V, so N is also fixed. In this case, the relevant question is what performance can we expect given this particular N. The bound in (2.12) answers this question: with probability at least 1 -8, N8 ln . Eout(g) � Ein(g) + If we use the polynomial bound based on dvc instead of m1-l ( 2N), we get another valid bound on the out-of-sample error, ( ) ( ) � l (4((2N)dvc + 1)) Eout g � Ein g + N n 8 (2.14) Example 2.7. Suppose that N = 100 and we have a 903 confidence require­ ment (8 = 0.1). We could ask what error bar can we offer with this confidence, if 1{ has dvc = 1. Using (2.14), we have 8 (4(201)) Eout(g) � Ein(g) + lOO ln Q:-1 � Ein(g) + 0.848 (2.15) with confidence � 903. This is a pretty poor bound on Eout· Even if Ein = 0, Eout may still be close to 1. If N = 1, 000, then we get Eaut(g) � Ein(g)+0.301, a somewhat more respectable bound. D Let us look more closely at the two parts that make up the bound on Eout in (2.12). The first part is Ein, and the second part is a term that increases as the VC dimension of 1{ increases. where Eout(g) � Ein(g) + fl(N, 1-l, 8), rl(N, 1-l, 8) < � l + N n 8 . (2.16) One way to think of rl(N, 1{, 8) is that it is a penalty for model complexity. It penalizes us by worsening the bound on Eout when we use a more complex 1{ (larger dv0). If someone manages to fit a simpler model with the same training 58 2. TRAINING VERSUS TESTING 2.2. INTERPRETING THE BOUND d�c VC dimension, dvc Figure 2.3: When we use a more complex learning model, one that has higher VC dimension dvc, we are likely to fit the training data better re sulting in a lower in sample error, but we pay a higher penalty for model complexity. A combination of the two, which estimates the out ofsample error, thus attains a minimum at some intermediate d�0• error, they will get a more favorable estimate for Eout· The penalty O(N, 1-i, o) gets worse if we insist on higher confidence (lower o), and it gets better when we have more training examples, as we would expect. Although O(N, 1-i, o) goes up when 1i has a higher VC dimension, Ein is likely to go down with a higher VC dimension as we have more choices within 1{ to fit the data. Therefore, we have a tradeoff: more complex models help Ein and hurt O(N, 1-i, o). The optimal model is a compromise that minimizes a combination of the two terms, as illustrated informally in Figure 2.3. 2.2.3 The Test Set As we p.ave seen, the generalization bound gives us a loose estimate of the out-of-sample error Eout based on Ein. While the estimate can be useful as a guideline for the training process, it is next to useless if the goal is to get an accurate forecast of Eout. If you are developing a system for a customer, you need a more accurate estimate so that your customer knows how well the system is expected to perform. An alternative approach that we alluded to in the beginning of this chapter is to estimate Eout by using a test set, a data set that was not involved in the training process. The final hypothesis g is evaluated on the test set, and the result is taken as an estimate of Eout· We would like to now take a closer look at this approach. Let us call the error we get on the test set Etest. When we report Etest as our estimate of Eout, we are in fact asserting that Etest generalizes very well to Eout. After all, Etest is just a sample estimate like Ein. How do we know 59 2. TRAINING VERSUS TESTING 2.2. INTERPRETING THE BOUND that Etest generalizes well? We can answer this question with authority now that we have developed the theory of generalization in concrete mathematical terms. The effective number of hypotheses that matters in the generalization be­ havior of Etest is 1. There is only one hypothesis as far as the test set is concerned, and that's the final hypothesis g that the training phase produced. This hypothesis would not change if we used a different test set as it would if we used a different training set. Therefore, the simple Hoeffding Inequality is valid in the case of a test set. Had the choice of g been affected by the test set in any shape or form, it wouldn't be considered a test set any more and the simple Hoeffding Inequality would not apply. Therefore, the generalization bound that applies to Etest is the simple Hoeffding Inequality with one hypothesis. This is a much tighter bound than the VC bound. For example, if you have 1, 000 data points in the test set, Etest will be within ±53 of Eout with probability � 983. The bigger the test set you use, the more accurate Etest will be as an estimate of Eout. Exercise 2.6 A data set has 600 examples. To properly test the performance of the final hypothesis, you set aside a randomly selected subset of 200 examples which are never used in the training phase; these form a test set. You use a learning model with 1, 000 hypotheses and select the final hypothesis g based on the 400 training examples. We wish to estimate Eout(g). We have access to two estimates: Ein(g), the insample error on the 400 training examples; and, Etest(g), the test error on the 200 test examples that were set aside. (a) Using a 53 error tolerance (8 = 0.05), which estimate has the higher 'error bar'? (b) Is there any reason why you shouldn't reserve even more examples for testing? Another aspect that distinguishes the test set from the training set is that the test set is not biased. Both sets are finite samples that are bound to have some variance due to sample size, but the test set doesn't have an optimistic or pessimistic bias in its estimate of Eout. The training set has an optimistic bias, since it was used to choose a hypothesis that looked good on it. The VC generalization bound implicitly takes that bias into consideration, and that's why it gives a huge error bar. The test set just has straight finite-sample variance, but no bias. When you report the value of Etest to your customer and they try your system on new data, they are as likely to be pleasantly surprised as unpleasantly surprised, though quite likely not to be surprised at all. There is a price to be paid for having a test set. The test set does not affect the outcome of our learning process, which only uses the training set. The test set just tells us how well we did. Therefore, if we set aside some 60 2. TRAINING VERSUS TESTING 2.2. INTERPRETING THE BOUND of the data points provided by the customer as a test set, we end up using fewer examples for training. Since the training set is used to select one of the hypotheses in 1-l, training examples are essential to finding a good hypothesis. If we take a big chunk of the data for testing and end up with too few examples for training, we may not get a good hypothesis from the training part even if we can reliably evaluate it in the testing part. We may end up reporting to the customer, with high confidence mind you, that the g we are delivering is terrible ©. There is thus a tradeoff to setting aside test examples. We will address that tradeoff in more detail and learn some clever tricks to get around it in Chapter 4. In some of the learning literatu re, Etest is used as synonymous with Eout. When we report experimental results in this book, we will often treat Etest based on a large test set as if it was Eout because of the closeness of the two quantities. 2.2.4 Other Target Types Although the VC analysis was based on binary target functions, it can be extended to real-valued functions, as well as to other types of functions. The proofs in those cases are quite technical, and they do not add to the insight that the VC analysis of binary functions provides. Therefore, we will introduce an alternative approach that covers real-valued functions and provides new insights into generalization. The approach is based on bias-variance analysis, and will be discussed in the next section. In order to deal with real-valued functions, we need to adapt the definitions of Ein and Eout that have so far been based on binary functions. We defined Ein and Eout in terms of binary error; either h(x) = f (x) or else h(x) -/= f (x). If f and hare real-valued, a more appropriate error measure would gauge how far f (x) and h(x) are from each other, rather than just whether their values are exactly the same. An error measure that is commonly used in this case is the squared error e(h(x), J(x)) = (h(x) -f(x))2. We can define in-sample and out-of-sample versions of this error measure. The out-of-sample error is based on the ex­ pected value of the error measure over the entire input space X, Eout(h) = lE [(h(x) -J(x))2], while the in-sample error is based on averaging the error measure over the data set, 1 N Ein(h) = N L(h(xn) -f(xn))2. n=l These definitions make Ein a sample estimate of Eout just as it was in the case of binary functions. In fact, the error measure used for binary functions can also be expressed as a squared error. 61 2. TR AINING VERSUS TESTING 2.3. APPROXIMATION GENERALIZATION Exercise 2. 7 For binary target functions, show that JP>[h(x) f(x)] can be written as an expected value of a mean squared error measure in the following cases. (a) The convention used for the binary function is 0 or (b) The convention used for the binary function is ±1. [Hint: The difference between (a) and (b) is just a scale.} Just as the sample frequency of error converges to the overall probability of error per Hoeffding's Inequality, the sample average of squared error converges to the expected value of that error (assuming finite variance). This is a man­ ifestation of what is referred to as the 'law of large numbers' and Hoeffding's Inequality is just one form of that law. The same issues of the data set size and the hypothesis set complexity come into play just as they did in the VC analysis. 2.3 Appro ximat ion-Generaliza tion Tradeo ff The VC analysis showed us that the choice of 1-l needs to strike a balance between approximating f on the training data and generalizing on new data. The ideal 1-l is a singleton hypothesis set containing only the target function. Unfortunatel y, we are better off buying a lottery ticket than hoping to have this 1-l. Since we do not know the target function, we resort to a larger model hoping that it will contain a good hypothesis, and hoping that the data will pin down that hypothesis. When you select your hypothesis set, you should balance these two conflicting goals; to have some hypothesis in 1-l that can approximate f, and to enable the data to zoom in on the right hypothesis. The VC generalization bound is one way to look at this tradeoff. If 1-l is too simple, we may fail to approximate f well and end up with a large in­ sample error term. If 1-l is too complex, we may fail to generalize well because of the large model complexity term. There is another way to look at the approximation-generalization tradeoff which we will present in this section. It is particularly suited for squared error measures, rather than the binary error used in the VC analysis. The new way provides a different angle; instead of bounding Eout by Ein plus a penalty term 0, we will decompose Eout into two different error terms. 2.3.1 Bias and Variance The bias-variance decomposition of out-of-sample error is based on squared error measures. The out-of-sample error is (2.17) 62 2. TRAINING VERSUS TESTING 2.3. APPROXIMATIONGENERALIZATION where lEx denotes the expected value with respect to x (based on the probabil­ ity distribution on the input space X). We have made explicit the dependence of the final hypothesis g on the data V, as this will play a key role in the cur­ rent analysis. We can rid Equation (2.17) of the dependence on a particular data set by taking the expectation with respect to all data sets. We then get the expected out-of-sample error for our learning model, independent of any particular realization of the data set, lEv [lEx[(g(D)(x) -f(x))2J] lEx [lEv[(g(D)(x) -f(x))2J] lEx [ lEv [g(D) (x)2] -2 lEv [g(D) (x)]f (x) + f (x)2 J . The term lEv[g(D)(x)] gives an 'average function', which we denote by g(x). One can interpret g(x) in the following operational way. Generate many data sets V1, ... , V K and apply the learning algorithm to each data set to produce final hypotheses 91, ... , 9K. We can then estimate the average function for any x by g(x) � -k 1=�=l gk(x). Essentially, we are viewing g(x) as a random variable, with the randomness coming from the randomness in the data set; g(x) is the expected value of this random variable (for a particular x), and g is a function, the average function, composed of these expected values. The function g is a little counterintuitive; for one thing, g need not be in the model's hypothesis set, even though it is the average of functions that are. Exercise 2.8 (a) Show that if 1-l is closed under linear combination (any linear combi­ nation of hypotheses in 1-l is also a hypothesis in 1-l), then g E 1-l. (b) Give a model for which the average function g is not in the model's hypothesis set. [Hint: Use a very simple model.] (c) For binary classification, do you expect g to be a binary function? We can now rewrite the expected out-of-sample error in terms of g: lEv [ Eout (g(V))] lEx [lEv[gCD) (x)2] -2g(x)f (x) + f (x)2 J , lEx [ lEv[gCD)(x)2] -g(x)2 + g(x)2 -2g(x)f (x) + f (x)2 lEv [ (g(D) (x) -g(x) )2] (g(x) -f (x) )2 where the last reduction follows since g(x) is constant with respect to V. The term (g(x) -f(x))2 measures how much the average function that we would learn using different data sets V deviates from the target function that generated these data sets. This term is appropriately called the bias: bias(x) = (g(x) -f (x) )2, 63 2. TR AINING VERSUS TESTING 2. 3. APPROXIMATIONGENERALIZATION as it measures how much our learning model is biased away from the target function. 5 This is because g has the benefit of learning from an unlimited number of data sets, so it is only limited in its ability to approximate f by the limitation in the learning model itself. The term 1Ev [ (g(V) (x) g(x) )2] is the variance of the random variable g(V) ( x), var(x) = 1Ev[(g('.D)(x) -g(x))2], which measures the variation in the final hypothesis, depending on the data set. We thus arrive at the bias-variance decomposition of out-of-sample error, 1Ex[bias(x) + var(x)] bias+ var, where bias = 1Ex[bias(x)] and var= 1Ex[var(x)]. Our derivation assumed that the data was noiseless. A similar derivation with noise in the data would lead to an additional noise term in the out-of-sample error (Problem 2.22). The noise term is unavoidable no matter what we do, so the terms we are interested in are really the bias and var. The approximat ion-generalization tradeoff is captured in the bias-variance decomposition. To illustrate, let's consider two extreme cases: a very small model (with one hypothesis) and a very large one with all hypotheses . Very small model. Since there is only one hypothesis, both the av erage function g and the fnal hy pothesis g(D) will be the same, for any data set. Thus, var = 0. The bias will depend solely on how well this single hypothesis approximates the target f, and unless we are ex tremely lucky, we expect a large bias. Very large model. The target function is in 1-i. Different data sets will lead to different hypotheses that agree with f on the data set, and are spread around f in the red region. Thus, bias � 0 because g is likely to be close to f. The var is large (heuristically represented by the size of the red region in the figure). One can also view the variance as a measure of 'instability' in the learning model. Instability manifests in wild reactions to small variations or idiosyn­ crasies in the data, resulting in vastly different hypotheses. 5What we call bias is sometimes called bias2 in the literature. 64 2. TRAINING VERSUS TESTING 2.3. APPROXIMATIONGENERALIZATION Example 2.8. Consider a target function f(x) = sin(nx) and a data set of size N = 2. We sample x uniformly in [-1, 1) to generate a data set (x1, Y1), (x2, Y2); and fit the data using one of two models: Ho: Set of all lines of the form h(x) = b; H1: Set of all lines of the form h(x) =ax+ b. For Ho, we choose the constant hypothesis that best fits the data (the hori­ zontal line at the midpoint, b = For H1, we choose the line that passes through the two data points (x1, Y1) and (x2, y2). Repeating this process with many data sets, we can estimate the bias and the variance. The figures which follow show the resulting fits on the same (random) data sets for both models. x x 1-lo With H1, the learned hypothesis is wilder and varies extensively depending on the data set. The bias-var analysis is summarized in the next figures. x 1-lo bias= 0.50; var= 0.25. x 1-l1 bias= 0.21; var= 1.69. Average hypothesis g (red) with var(x) indicated by the gray shaded region that is g(x) ± For Hi, the average hypothesis g (red line) is a reasonable fit with a fairly small bias of 0.21. However, the large variability leads to a high var of 1.69 resulting in a large expected out-of-sample error of 1.90. With the simpler 65 2. TR AINING VERSUS TESTING 2.3. APPROXIMATIONGENERALIZATION model 1-lo, the fits are much less volatile and we have a significantly lower var of 0.25, as indicated by the shaded region. However, the average fit is now the zero function, resulting in a higher bias of 0.50. The total out-of-sample error has a much smaller expected value of 0.75. The simpler model wins by significantly decreasing the var at the expense of a smaller increase in bias. Notice that we are not comparing how well the red curves (the average hy­ potheses) fit the sine. These curves are only conceptual, since in real learning we do not have access to the multitude of data sets needed to generate them. We have one data set, and the simpler model results in a better out-of-sample error on average as we fit our model to just this one data. However, the var term decreases as N increases, so if we get a bigger and bigger data set, the bias term will be the dominant part of Eout, and 1-l 1 will win. D The learning algorithm plays a role in the bias-variance analysis that it did not play in the VC analysis. Two points are worth noting. 1. By design, the VC analysis is based purely on the hypothesis set 1-l, in­ dependently of the learning algorithm A. In the bias-variance analysis, both 1-l and the algorithm A matter. With the same 1-l, using a differ­ ent learning algorithm can produce a different g(V). Since g(V) is the building block of the bias-variance analysis, this may result in different bias and var terms. 2. Although the bias-variance analysis is based on squared-error measure, the learning algorithm itself does not have to be based on minimizing the squared error. It can use any criterion to produce g(V) based on V. However, once the algorithm produces gCTJ), we measure its bias and variance using squared error. Unfortunately, the bias and variance cannot be computed in practice, since they depend on the target function and the input probability distribution (both unknown). Thus, the bias-variance decomposition is a conceptual tool which is helpful when it comes to developing a model. There are two typical goals when we consider bias and variance. The first is to try to lower the variance without significantly increasing the bias, and the second is to lower the bias without significantly increasing the variance. These goals are achieved by different techniques, some principled and some heuristic. Regularization is one of these techniques that we will discuss in Chapter 4. Reducing the bias without increasing the variance requires some prior information regarding the target function to steer the selection of 1-l in the direction of f, and this task is largely application- specific. On the other hand, reducing the variance without compromising the bias can be done through general techniques. 2.3.2 The Learning Curve We close this chapter with an important plot that illustrates the tradeoffs that we have seen so far. The learning curves summarize the behavior of the 66 2. TRAINING VERSUS TESTING 2.3. APPROXIMATIONGENERALIZATION in-sample and out-of-sample errors as we vary the size of the training set. After learning with a particular data set ]) of size N, the final hypothe­ sis gCD) has in-sample error Ein (g(TJ)) and out-of-sample error Eout (g(TJ)), both of which depend on JJ. As we saw in the bias-variance analysis, the expectation with respect to all data sets of size N gives the expected errors: 1Ev[Ein(g(TJ))] and 1Ev[Eout(g('D))]. These expected errors are functions of N, and are called the learning curves of the model. We illustrate the learning curves for a simple learning model and a complex one , based on actual experiments. Number of Data Points, N Simple Model H 0 t: µ:i '\"O <!) t) <!) Number of Data Points, N Complex Model Notice that for the simple model, the learning curves converge more quickly but to worse ultimate performance than for the complex model. This behavior is typical in practice. For both simple and complex models, the out-of-sample learning curve is decreasing in N, while the in-sample learning curve is in­ creasing in N. Let us take a closer look at these curves and interpret them in terms of the different approaches to generalization that we have discussed. In the VC analysis, Eout was expressed as the sum of Ein and a generaliza­ tion error that was bounded by n, the penalty for model complexity. In the bias-variance analysis, Eaut was expressed as the sum of a bias and a variance. The following learning curves illustrate these two approaches side by side. Number of Data Points, N Number of Data Points, N VC Analysis Bias-Variance Analysis 67 2. TRAINING VERSUS TESTING 2.3. APPROXIMATIONGENERALIZATION The VC analysis bounds the generalization error which is illustrated on the left.6 The bias-variance analysis is illustrated on the right. The bias-variance illustration is somewhat idealized, since it assumes that, for every N, the aver­ age learned hypothesis g has the same performance as the best approximation to f in the learning model. When the number of data points increases, we move to the right on the learning curves and both the generalization error and the variance term shrink, as expected. The learning curve also illustrates an important point about Ein· As N increases, Ein edges toward the smallest error that the learning model can achieve in approximating f. For small N, the value of Ein is actually smaller than that 'smallest possible' error. This is because the learning model has an easier task for smaller N; it only needs to approximate f on the N points regardless of what happens outside those points. Therefore, it can achieve a superior fit on those points, albeit at the expense of an inferior fit on the rest of the points as shown by the corresponding value of Eaut. 6For the learning curve, we take the expected values of all quant ities with respect to 'D of size N. 68 2. TRAINING VERSUS TESTING 2.4. PROBLEMS 2.4 Problems Problem 2.1 In Equation (2.1), set 8 = 0.03 and let (a) For M = 1, how many examples do we need to make E � 0.05? (b) For M = 100, how many examples do we need to make E � 0.05? ( c) For M = 10, 000, how many examples do we need to make E � 0.05? Problem 2.2 Show that for the learning model of positive rectangles (aligned horizontally or vertically), mH(4) = 24 and mH(5) < 25. Hence, give a bound for mH(N). Problem 2.3 Compute the maximum number of dichotomies, mH(N), for these learning models, and consequently compute dvc, the VC dimension. (a) Positive or negative ray: 1-l contains the functions which are + 1 on [a, oo) (for some a) together with those that are +1 on (-oo, a] (for some a). (b) Positive or negative interval: 1-l contains the functions which are + 1 on an interval [a, b] and -1 elsewhere or -1 on an interval [a, b] and +1 elsewhere. (c) Two concentric spheres in JRd: 1-l contains the functions which are +1 for a � xf + ... + x� � b. Problem 2.4 Show that B(N, k) = I::==-i ( �) by showing the other direction to Lemma 2.3, namely that B(N,k) � � ( �) To do so, construct a specific set of I::==-i ( �) dichotomies that does not shatter any subset of k variables. [Hint: Try limiting the number of -1 'sin each dichotomy.] D Problem 2.5 Prove by induction that 'I: ( �) �ND+ 1, hence i=O m'H(N) � Ndvc + 1. 69 2. TRAINING VERSUS TESTING Problem 2.6 Prove that for N ;: d, We suggest you first show the following intermediate steps. (a) t ( �) � t ( 1:) ( Jt) di � ( Jt) d t ( 1:) ( 1J) i. i=O i=O i=O N . 2.4. PROBLEMS (b) I: ( �) (1J f �ed. {Hints: Binomial theorem; (1 + �r � e for x > O.j i=O ( )dvc Hence, argue that m11,(N) � . Problem 2. 7 Plot the bounds for m11, (N) given in Problems 2.5 and 2.6 for dva = 2 and dvc = 5. When do you prefer one bound over the other? Problem 2.8 Which of the following are possible growth functions m11,(N) for some hypothesis set: l+N·, 1 N N(N -1) 2N· 2l v'N J. 2LN/2J. 1 N N(N -l)(N -2) ++ 2;' ' ' ++ 6 . Problem 2.9 [hard] For the perceptron in d dimensions, show that d (N 1) m11, (N) = 2 t; � . {Hint: Cover(1965) in Further Reading.} Use this formula to verify that dvc = d + 1 by evaluating m11,(d + 1) and m11,(d + 2). Plot m11,(N)/2N ford= 10 and N E [1, 40]. If you generate a random dichotomy on N points in 10 dimensions, give an upper bound on the probability that the dichotomy will be separable for N = 10, 20, 40. Problem 2.10 Show that m11,(2N) � m11,(N)2, and hence obtain a genera I ization bound which only involves m11, ( N). Problem 2.11 Suppose m11,(N) = N + 1, so dva = 1. You have 100 training examples. Use the generalization bound to give a bound for Eaut with confidence 90%. Repeat for N = 10, 000. 70 2. TRAINING VERSUS TESTING 2.4. PROBLEMS Problem 2.12 For an 1-l with dvc = 10, what sample size do you need (as prescribed by the generalization bound) to have a 95% confidence that your generalization error is at most 0.05? Problem 2.13 (a) Let 1-l = {h1,h2, ... ,hM} with some finite M. Prove that dvc(1-l)::; log2M. ( b) For hypothesis sets 1-l 1, 1-l2, · · · , 1-lK with finite VC dimensions dvc ( 1-lk), derive and prove the tightest upper and lower bound that you can get on dvc (n�11-lk)· (c) For hypothesis sets 1-l1, 1-l2, · · ·, 1-lK with finite VC dimensions dvc(1-lk), derive and prove the tightest upper and lower bounds that you can get on dvc (uf;=11-lk)· Problem 2.14 Let 1-l1, 1-l2, ... , 1-lK be K hypothesis sets with finite VC dimension dvc· Let 1-l = 1-l1 U 1-l2U···U1-lK be the union of these models. (a) Show that dvc(1-l) < K(dvc + 1). (b) Suppose that f satisfies 2£ > 2Kfdvc. Show that dvc(1-l)::; £. ( c) Hence, show that dvc(1-l) =S; min(K(dvc + 1), 7(dvc + K) log2(dvcK)). That is, dvc(1-l) = O(max(dvc,K)log2max(dvc,K)) is not too bad. Problem 2.15 The monotonically increasing hypothesis set is where x1 ;: x2 if and only if the inequality is satisfied for every component. (a) Give an example of a monotonic classifier in two dimensions, clearly show ing the +1 and -1 regions. (b) Compute m1-1.(N) and hence the VC dimension. {Hint: Consider a set of N points generated by first choosing one point, and then generating the next point by increasing the first component and decreasing the second component until N points are obtained.} 71 2. TRAINING VERSUS TESTING 2.4. PROBLEMS Problem 2.16 In this problem, we will consider X = R That is, x x is a onedimensional variable. For a hypothesis set prove that the VC dimension of 1-l is exactly (D + 1) by showing that (a) There are (D + 1) points which are shattered by 1-l. (b) There are no (D + 2) points which are shattered by 1-l. Problem 2.17 The VC dimension depends on the input space as well as 1-l. For a fixed 1-l, consider two input spaces X1 s:;:; X2. Show that the VC dimension of 1-l with respect to input space X1 is at most the VC dimension of 1-l with respect to input space X2. How can the result of this problem be used to answer part (b) in Problem 2.16? [Hint: How is Problem 2.16 related to a perceptron in D dimensions?} Problem 2.18 The VC dimension of the perceptron hypothesis set corresponds to the number of parameters ( w0, w1, • · · , wd) of the set, and this observation is 'usually' true for other hypothesis sets. However, we will present a counterexample here. Prove that the following hypothesis set for x E IR has an infinite VC dimension: 1-l = {ha I ha(x) = (-l)LaxJ, where a E IR}, where LAJ is the biggest integer � A (the floor function). This hypothesis has only one parameter a but 'enjoys' an infinite VC dimension. [Hint: Con­ sider x1, ... , x N, where Xn 10n, and show how to implement an arbitrary dichotomy Y1, ... , YN.J Problem 2.19 This problem derives a bound for the VC dimension of a complex hypothesis set that is built from simpler hypothesis sets via composi tion. Let 1-l1, ... , 1-LK be hypothesis sets with VC dimension d1, ... , dK. Fix hi, ... , hK, where hi E 1-Li. Define a vector z obtained from x to have com­ ponents hi(x). Note that x E JRd, but z E {-1, +l}K. Let fl be a hypothesis set of functions that take inputs in IRK. So h E fl: z E IRK 1- {+l,-1}, and suppose that il has VC dimension J. 72 2. TRAINING VERSUS TESTING 2.4. PROBLEMS We can apply a hypothesis in iL to the z constructed from (hi, ... , hK). This is the composition of the hypothesis set iL with (Hi, ... , 1-LK ). More formally, the composed hypothesis set 1l = iL o (Hi, ... , 1-LK) is defined by h E 1l if h(x) = h(hi(x), ... , hK(x)), (a) Show that K m1i(N):: mi{(N) IT m1ii (N). (2.18) i=i {Hint: Fix N points xi, ... , XN and fix hi, ... , hK. This generates N transformed points zi, ... , ZN. These zi, ... , ZN can be dichotomized in at most mi{(N) ways, hence for fixed (hi, ... , hK), (xi, ... ,xN) can be dichotomized in at most mi{ (N) ways. Through the eyes of xi, ... , XN, at most how many hypotheses are there (effectively) in 1-Li? Use this bound to bound the effective number of K-tuples (hi, ... , hK) that need to be considered. Finally, argue that you can bound the number of dichotomies that can be implemented by the product of the number of possible K-tuples (hi, ... , hK) and the number of dichotomies per K-tuple.j (b) Use the bound m(N) :: rvc to get a bound for m1i (N) in terms of d, di, ... , dK. ( c) Let D = d + 2=�i di, and assume that D > 2e log2 D. Show that ( d) If 1-Li and iL are all perceptron hypothesis sets, show that dvc(H) = O(dK log(dK)). In the next chapter, we will further develop the simple linear model. This linear model is the building block of many other models, such as neural networks. The results of this problem show how to bound the VC dimension of the more complex models built in this manner. Problem 2.20 There are a number of bounds on the generalization error E, all holding with probability at least 1 -8. (a) Original VC-bound: < !}_ 1 4m1i (2N) 8 . (b) Rademacher Penalty Bound: (continued on next page) 73 2. TRAINING VERSUS TESTING 2.4. PROBLEMS ( c) Pa rrondo and Van den Broek: E _< 1 (2 1 6m1-l(2N)) N E+ 11 b . ( d) Devroye: Note that ( c) and ( d) are implicit bounds in E. Fix dvc = 50 and b = 0.05 and plot these bounds as a function of N. Which is best? Problem 2.21 Assume the following theorem to hold Theorem JP> [Eout(g) -Ein(g) >El ::; c. m1-l(2N) exp (-E24N) ' where c is a constant that is a little bigger than 6. This bound is useful because sometimes what we care about is not the absolute generalization error but instead a relative generalization error (one can imagine that a generalization error of 0.01 is more significant when Eout = 0.01 than when Eout = 0.5). Convert this to a generalization bound by showing that with probability at least 1 -b, ( ) ( ) � [ l 4Ein (g) l Eout g ::; Ein g + 2 1 + + � ' where � = ft log (2N) . Problem 2.22 When there is noise in the data, Eout(g(D)) = lEx,y[(g(D)(x) -y(x))2], where y(x) = J(x) + E. If E is a zeromean noise random variable with variance o-2, show that the biasvariance decomposition becomes lEv[Eout(/D))] = o-2 +bias+ var. Problem 2.23 Consider the learning problem in Example 2.8, where the input space is X = [-1, +1], the target function is f(x) = sin(?rx), and the input probability distribution is uniform on X. Assume that the training set V has only two data points (picked independen tly), and that the learning algorithm picks the hypothesis that minimizes the insample mean squared error. In this problem, we will dig deeper into this case. 74 2. TRAINING VERSUS TESTING 2.4. PROBLEMS For each of the following learning models, find (analytically or numerically) (i) the best hypothesis that approximates f in the mean squared error sense (assume that f is known for this part), (ii) the expected value (with respect to 'D) of the hypothesis that the learning algorithm produces, and (iii) the expected out of sample error and its bias and var components. (a) The learning model consists of all hypotheses of the form h(x) =ax+ b (if you need to deal with the infinitesimal probability case of two identical data points, choose the hypothesis tangential to f). (b) The learning model consists of all hypotheses of the form h(x) = ax. This case was not covered in Example 2.8. ( c) The learning model consists of all hypotheses of the form h(x) = b. Problem 2.24 Consider a simplified learning scenario. Assume that the input dimension is one. Assume that the input variable x is uniformly distributed in the interval [-1, 1]. The data set consists of 2 points { x1, x2} and assume that the tar get function is f (x) = x2. Thus, the full data set is 'D = {(x1, xt), (x2, x§)}. The learning algorithm returns the line fitting these two points as g (1-l consists of functions of the form h(x) = ax+ b). We are interested in the test performance (Bout) of our learning system with respect to the squared error measure, the bias and the var. (a) Give the analytic expression for the average fu nction g(x). (b) Describe an experiment that you could run to determine (numerically) g(x), Bout, bias, and var. ( c) Run your experiment and report the results. Compare Bout with bias+var. Provide a plot of your g(x) and f(x) (on the same plot). ( d) Compute analytically what Bout. bias and var should be. 75 76 Chapter 3 The Linear Model We often wonder how to draw a line between two categories; right versus wrong, personal versus professional life, useful email versus spam, to name a few. A line is intuitively our first choice for a decision boundary. In learning, as in life, a line is also a good first choice. In Chapter 1, we (and the machine @))learned a procedure to 'draw a line' between two categories based on data (the perceptron learning algorithm ). We started by taking the hypothesis set 1{ that included all possible lines (actually hyperplanes ). The algorithm then searched for a good line in 1{ by iteratively correcting the errors made by the current candidate line, in an attempt to improve Ein. As we saw in Chapter 2, the linear model set of lines has a small VC dimension and so is able to generalize well from Ein to Eout. The aim of this chapter is to further develop the basic linear model into a powerful tool for learning from data. We branch into three important prob­ lems: the classification problem that we have seen and two other important problems called regression and probability estimation. The three problems come with different but related algorithms , and cover a lot of territory in learning from data. As a rule of thumb, when faced with learning problems, it is generally a winning strategy to try a linear model first. 3.1 Linear Classifica tion The linear model for classifying data into two classes uses a hypothesis set of linear classifiers, where each h has the form h(x) = sign(wTx), for some column vector w E JR.d+l, where dis the dimensiona lity of the input space, and the added coordinate x0 = 1 corresponds to the bias 'weight' w0 (recall that the input space X = {1} x JR.d is considered d-dimensional since the added coordinate x0 = 1 is fixed). We will use h and w interchangeably 77 3. THE LINEAR MO DEL 3.1. LINEAR CLASSIFICATION to refer to the hypothesis when the context is clear. When we left Chapter 1, we had two basic criteria for learning: 1. Can we make sure that Eout(g) is close to Ein(g)? This ensures that what we have learned in sample will generalize out of sample. 2. Can we make Ein(g) small? This ensures that what we have learned in sample is a good hypothesis. The first criterion was studied in Chapter 2. Specifically, the VC dimension of the linear model is only d + 1 (Exercise 2.4). Using the VC generalization bound (2.12), and the bound (2.10) on the growth function in terms of the VC dimension, we conclude that with high probability, Eout(g) = E;n(9) + 0 ( � . (3.1) Thus, when N is sufficiently large, Ein and Eout will be close to each other (see the definition of 0(-) in the Notation table), and the first criterion for learning is fulfilled. The second criterion, making sure that Ein is small, requires first and foremost that there is some linear hypothesis that has small Ein. If there isn't such a linear hypothesis, then learning certainly can't find one. So, let's suppose for the moment that there is a linear hypothesis with small Ein. In fact, let's suppose that the data is linearly separable, which means there is some hypothesis w* with Ein(w*) = 0. We will deal with the case when this is not true shortly. In Chapter 1, we introduced the perceptron learning algorithm (PLA). Start with an arbitrary weight vector w(O). Then, at every time step t 2: 0, select any misclassified data point (x(t),y(t)), and update w(t) as follows: w(t + 1) = w(t) + y(t)x(t). The intuition is that the update is attempting to correct the error in classify­ ing x(t). The remarkable thing is that this incremental approach of learning based on one data point at a time works. As discussed in Problem 1.3, it can be proved that the PLA will eventually stop updating, ending at a solution wPLA with Ein(wPLA) = 0. Although this result applies to a restricted setting (lin­ early separable data), it is a significant step. The PLA is clever it doesn't na1vely test every linear hypothesis to see if it (the hypothesis) separates the data; that would take infinitely long. Using an iterative approach, the PLA manages to search an infinite hypothesis set and output a linear separator in (provably) finite time. As far as PLA is concerned, linear separability is a property of the data, not the target. A linearly separable V could have been generated either from a linearly separable target, or (by chance) from a target that is not linearly separable. The convergence proof of PLA guarantees that the algorithm will 78 3. THE LINEAR MODEL 3.1. LINEAR CLASSIFICA TION (a) Few noisy data. (b) Nonlinearly separable. Figure 3.1: Data sets that are not linearly separable but are (a) linearly separable after discarding a few examples, or (b) separable by a more so phisticated curve. work in both these cases, and produce a hypothesis with Ein = 0. Further, in both cases, you can be confident that this performance will generalize well out of sample, according to the VC bound. Exercise 3.1 Will PLA ever stop updating if the data is not linearly separable? 3.1.1 Non-Separable Data We now address the case where the data is not linearly separable. Figure 3.1 shows two data sets that are not linearly separable. In Figure 3.l(a), the data becomes linearly separable after the removal of just two examples, which could be considered noisy examples or outliers. In Figure 3.l(b), the data can be separated by a circle rather than a line. In both cases, there will always be a misclassified training example if we insist on using a linear hypothesis, and hence PLA will never terminate. In fact, its behavior becomes quite unstable, and can jump from a good perceptron to a very bad one within one update; the quality of the resulting Ein cannot be guaranteed. In Figure 3.l(a), it seems appropriate to stick with a line, but to somehow tolerate noise and output a hypothesis with a small Ein, not necessarily Ein = 0. In Figure 3.l(b), the linear model does not seem to be the correct model in the first place, and we will discuss a technique called nonlinear transformation for this situation in Section 3.4. 79 3. THE LINEAR MODEL 3 .1. LINEAR CLASSIFICATION The situation in Figure 3.l(a) is actually encountered very often: even though a linear classifier seems appropriate, the data may not be linearly sep­ arable because of outliers or noise. To find a hypothesis with the minimum Ein, we need to solve the combinatorial optimization problem: 1 N min [sign(wTxn) # Yn]. wE�d+1 n=l (3.2) The difficulty in solving this problem arises from the discrete nature of both sign(·) and[-]. In fact, minimizing Ein(w) in (3.2) in the general case is known to be NP-hard, which means there is no known efficient algorithm for it, and if you discovered one, you would become really, really famous ©. Thus, one has to resort to approximately minimizing Ein. One approach for getting an approximate solution is to extend PLA through a simple modification into what is called the pocket algorithm. Essentially, the pocket algorithm keeps 'in its pocket' the best weight vector encountered up to iteration t in PLA. At the end, the best weight vector will be reported as the final hypothesis. This simple algorithm is shown below. The pocket algorithm: 1: Set the pocket weight vector w to w(O) of PLA. 2: for t = 0, ... , T 1 do 3: Run PLA for one update to obtain w(t + 1). 4: Evaluate Ein(w(t + 1)). 5: If w(t + 1) is better than w in terms of Ein, set w to w(t + 1). 6: Return w. The original PLA only checks some of the examples using w(t) to identify (x(t), y(t)) in each iteration, while the pocket algorithm needs an additional step that evaluates all examples using w(t + 1) to get Ein(w(t + 1)). The additional step makes the pocket algorithm much slower than PLA. In addi­ tion, there is no guarantee for how fast the pocket algorithm can converge to a good Ein. Nevertheless, it is a useful algorithm to have on hand because of its simplicity. Other, more efficient approaches for obtaining good approximate solutions have been developed based on different optimization techniques, as shown later in this chapter. Exercise 3.2 Take d = 2 and create a data set 'D of size N = 100 that is not linearly separable. You can do so by first choosing a random line in the plane as your target function and the inputs Xn of the data set as random points in the plane. Then, evaluate the target function on each Xn to get the corresponding output Yn· Finally, flip the labels of ft randomly selected Yn's and the data set will likely become nonseparable. 80 3. THE LINEAR MODEL 3 .1. LINEAR CLASSIFICATION Now, try the pocket algorithm on your data set using = 1, 000 iterations. Repeat the experiment 20 times. Then, plot the average Ein(w(t)) and the average Ein(w) (which is also a function oft) on the same figure and see how they behave when t increases. Similarly, use a test set of size 1, 000 and plot a figure to show how Eout(w(t)) and Eout(w) behave. Example 3.1 (Handwritten digit recognition ). We sample some digits from the US Postal Service Zip Code Database. These 16 x 16 pixel images are preprocessed from the scanned handwritten zip codes. The goal is to recognize the digit in each image. We alluded to this task in part (b) of Exercise 1.1. A quick look at the images reveals that this is a non-trivial task (even for a human), and typical human Eout is about 2.5%. Common confusion occurs between the digits { 4, 9} and {2, 7}. A machine-learned hypothesis which can achieve such an error rate would be highly desirable. ITl Let's first decompose the big task of separating ten digits into smaller tasks of separating two of the digits. Such a decomposition approach from multiclass to binary classification is commonly used in many learning algorithms . We will focus on digits {1, 5} for now. A human approach to determining the digit corresponding to an image is to look at the shape (or other properties ) of the black pixels . Thus, rather than carrying all the information in the 256 pixels, it makes sense to summarize the information contained in the image into a few features. Let's look at two important features here: intensity and symmetry. Digit 5 usually occupies more black pixels than digit 1, and hence the average pixel intensity of digit 5 is higher. On the other hand, digit 1 is symmetric while digit 5 is not. Therefore, if we define asymmetry as the average absolute difference between an image and its flipped versions, and symmetry as the negation of asymmetry, digit 1 would result in a higher symmetry value. A scatter plot for these intensity and symmetry features for some of the digits is shown next. 81 3. THE LINEAR MODEL 3.2. LINEAR REGRESSION While the digits can be roughly separated by a line in the plane representing these two features, there are poorly written digits (such as the '5' depicted in the top-left corner) that prevent a perfect linear separation. We now run PLA and pocket on the data set and see what happens. Since the data set is not linearly separable, PLA will not stop updating. In fact, as can be seen in Figure 3.2(a), its behavior can be quite unstable. When it is forcibly terminated at iteration 1, 000, PLA gives a line that has a poor Ein = 2.243 and Eout = 6.373. On the other hand, if the pocket algorithm is applied to the same data set, as shown in Figure 3.2(b), we can obtain a line that has a better Ein = 0.453 and a better Eout = 1.893. D 3.2 Linear Regression Linear regression is another useful linear model that applies to real-valued target functions.1 It has a long history in statistics, where it has been studied in great detail, and has various applications in social and behavioral sciences. Here, we discuss linear regression from a learning perspective, where we derive the main results with minimal assumptions. Let us revisit our application in credit approval, this time considering a regression problem rather than a classification problem. Recall that the bank has customer records that contain information fields related to personal credit, such as annual salary, years in residence, outstanding loans, etc. Such variables can be used to learn a linear classifier to decide on credit approval. Instead of just making a binary decision (approve or not), the bank also wants to set a proper credit limit for each approved customer. Credit limits are traditionally determined by human experts. The bank wants to automate this task, as it did with credit approval. 1 Regression, a term inherited from earlier work in statistics, means y is real valued. 82 3. THE LINEAR MODEL 50% 250 500 750 1000 Iteration Number, t Average Intensity (a) PLA 50% 3.2. LINEAR REGRESSION 250 500 750 1000 Iteration Number, t Average Intensity (b) Pocket Figure 3.2: Comparison of two linear classification algorithms for sep arating digits 1 and 5. Ein and Bout are plotted versus iteration number and below that is the learned hypothesis g. (a) A version of the PLA which selects a random training example and updates w if that example is misclas sified (hence the fiat regions when no update is made). This version avoids searching all the data at every iteration. (b) The pocket algorithm. This is a regression learning problem. The bank uses historical records to construct a data set 'D of examples (xi, Y1), (x2, Y2), ... , (xN, YN ), where Xn is customer information and Yn is the credit limit set by one of the human experts in the bank. Note that Yn is now a real number (positive in this case) instead of just a binary value ±1. The bank wants to use learning to find a hypothesis g that replicates how human experts determine credit limits. Since there is more than one human expert, and since each expert may not be perfectly consistent, our target will not be a deterministic function y = f (x). Instead, it will be a noisy target formalized as a distribution of the random variable y that comes from the different views of different experts as well as the variation within the views of each expert. That is, the label Yn comes from some distribution P(y I x) instead of a deterministic function f (x). Nonetheless, as we discussed in previous chapters, the nature of the problem is not changed. We have an unknown distribution P(x, y) that generates 83 3. THE LINEAR MODEL 3.2. LINEAR REGRESSION each ( Xn, Yn), and we want to find a hypothesis g that minimizes the error between g(x) and y with respect to that distribution. The choice of a linear model for this problem presumes that there is a linear combination of the customer information fields that would properly approx­ imate the credit limit as determined by human experts. If this assumption does not hold, we cannot achieve a small error with a linear model. We will deal with this situation when we discuss nonlinear transformation later in the chapter. 3.2.1 The Algorithm The linear regression algorithm is based on minimizing the squared error be­ tween h(x) and y.2 Eout(h) = lE [(h(x) y)2], where the expected value is taken with respect to the joint probability distri­ bution P(x, y). The goal is to find a hypothesis that achieves a small Eout(h). Since the distribution P(x, y) is unknown, Eout(h) cannot be computed. Sim­ ilar to what we did in classification, we resort to the in-sample version instead, 1 N 2 Ein(h) = N L (h(xn) Yn) . n=l In linear regression, h takes the form of a linear combination of the components of x. That is, d h(x) = L WiXi = wTx, i=O where x0 = 1 and x E {1} x .!Rd as usual, and w E JRd+1. For the special case of linear h, it is very useful to have a matrix representation of Ein(h). First, define the data matrix XE JRNx(d+l) to be the N x (d+ 1) matrix whose rows are the inputs Xn as row vectors, and define the target vector y E JRN to be tlie column vector whose components are the target values Yn· The in-sample error is a function of w and the data X, y: N � L (wTXn yn)2 n=l 1 2 NJJXw-yll 1 N (wTXTXw - 2wTXTy + yTy), (3.3) (3.4) where II · II is the Euclidean norm of a vector, and (3.3) follows because the nth component of the vector X w -y is exactly w T Xn Yn. The linear regression 2The term 'linear regression' has been historically confined to squared error measures. 84 3. THE LINEAR MODEL 3.2. LINEAR REGRESSION x (a) one dimension (line) (b) two dimensions (hyperplane) Figure 3.3: The solution hypothesis (in blue) of the linear regression algo rithm in one and two dimensions. The sum of squared errors is minimized. algorithm is derived by minimizing Ein ( w) over all possible w E JRd+l, as formalized by the following optimization problem: WHn = argmin Ein ( w). wEJRd+1 (3.5) Figure 3.3 illustrates the solution in one and two dimensions. Since Equa­ tion ( 3.4) implies that Ein ( w) is differentiable, we can use standard matrix calculus to find the w that minimizes Ein ( w) by requiring that the gradient of Ein with respect tow is the zero vector, i.e., '\\! Ei11(w) = 0. The gradient is a (column) vector whose ith component is ['\\!Ein(w)]i = By ex- plicitly computing the reader can verify the following gradient identities, These identities are the matrix analog of ordinary differentiation of quadratic and linear functions. To obtain the gradient of Ein, we take the gradient of each term in (3.4) to obtain Note that both wand '\\!Ei11(w) are column vectors. Finally, to get '\\!Ei11(w) to be 0, one should solve for w that satisfies If XTX is invertible, w = xt y where xt = (XTx)-1 XT is the pseudo-inverse of X. The resulting w is the unique optimal solution to (3.5). If XTX is not 85 3. THE LINEAR MODEL 3.2. LINEAR REGRESSION invertible, a pseudo-inverse can still be defined, but the solution will not be unique (see Problem 3.15). In practice, XTX is invertible in most of the cases since N is often much bigger than d + 1, so there will likely be d + 1 linearly independent vectors Xn. We have thus derived the following linear regression algorithm. Linear regression algorithm: 1: Construct the matrix X and the vector y from the data set (x1,Y1), · · ·, (xN,YN), where each x includes the xo = 1 bias coordinate, as follows X=[ l' y = [ :t l '- input data matrix target vector 2: Compute the pseudo-inverse xt of the matrix x. If XTX is invertible, 3: Return Wlin = xty. This algorithm is sometimes referred to as ordinary least squares ( OLS). It may seem that, compared with the perceptron learning algorithm, linear regression doesn't really look like 'learning', in the sense that the hypothesis Wiin comes from an analytic solution (matrix inversion and multiplications) rather than from iterative learning steps. Well, as long as the hypothesis Wlin has a decent out-of-sample error, then learning has occurred. Linear regression is a rare case where we have an analytic formula for learning that is easy to evaluate. This is one of the reasons why the technique is so widely used. It should be noted that there are methods for computing the pseudo-inverse directly without inverting a matrix, and that these methods are numerically more stable than matrix inversion. Linear regression has been analyzed in great detail in statistics. We would like to mention one of the analysis tools here since it relates to in-sample and out-of-sample errors, and that is the hat matrix H. Here is how H is defined. The linear regression weight vector W!in is an attempt to map the inputs X to the outputs y. However, wlin does not produce y exactly, but produces an estimate y =XW!in which differs from y due to in-sample error. Substituting the expression for Wiin (assuming XTX is invertible), we get y-= x(xTx)-1XTy. 86 3. THE LINEAR MODEL 3.2. LINEAR REGRESSION Therefore the estimate y is a linear transformation of the actual y through matrix multiplication with H, where (3.6) Since y = Hy, the matrix H 'puts a hat' on y, hence the name. The hat matrix is a very special matrix. For one thing, H2 = H, which can be verified using the above expression for H. This and other properties of H will facilitate the analysis of in-sample and out-of-sample errors of linear regression. Exercise 3.3 Consider the hat matrix H = X(XTX)1XT, where X is an N by d 1 matrix, and XTX is invertible. (a) Show that His symmetric. (b) Show that HK= H for any positive integer K. (c) If I is the identity matrix of size N, show that (I -H)K =I-H for any positive integer K. ( d) Show that trace(H) = d 1, where the trace is the sum of diagonal elements. {Hint: trace(AB) = trace(BA).J 3.2.2 Generalization Issues Linear regression looks for the optimal weight vector in terms of the in-sample error Ein, which leads to the usual generalization question: Does this guarantee decent out-of-sample error Eout? The short answer is yes. There is a regression version of the VC generalization bound (3.1) that similarly bounds Eout· In the case of linear regression in particular, there are also exact formulas for the expected Eout and Ein that can be derived under simplifying assumptions. The general form of the result is Eout(g) = E,n(g) + o(�), where Eout (g) and Ein (g) are the expected values. This is comparable to the classification bound in ( 3 .1). Exercise 3 .4 Consider a noisy target y = w*Tx + E for generating the data, where E is a noise term with zero mean and 0\"2 variance, independently generated for every example (x, y). The expected error of the best possible linear fit to this target is thus 0\"2. For the data 'D = {(x1,y1), ... ,(xN,YN)}, denote the noise in Yn as En and let E = [E1,E2, ... ,ENr; assume that XTX is invertible. By following (continued on next page) 87 3. THE LINEAR 1\\!IODEL 3.3. LO GISTIC REGRESSION the steps below, show that the expected insample error of linear regression with respect to 'D is given by lEv[Ein(Wiin)] = 0\"2 1 . (a) Show that the insample estimate of is given by = Xw* +HE. (b) Show that the insample error vector - can be expressed by a matrix times E. What is the matrix? ( c) Express Ein(W!in) in terms of E using (b ), and simplify the expression using Exercise 3.3( c). ( d) Prove that JEv(Ein(WHn)] = 0\"2 (1 - using ( c) and the indepen­ dence of E1, · · · , EN. [Hint: The sum of the diagonal elements of a matrix (the trace) will play a role. See Exercise 3.3{d).J For the expected outofsample error, we take a special case which is easy to analyze. Consider a test data set 'Dtest = {(x1,yi), ... , (xN,y�)}. which shares the same input vectors Xn with but with a different realization of the noise terms. Denote the noise in y� as and let E1 = [ Ei' E�' ••• ' E� r. Define Etest(W!in) to be the average squared error on 'Dtest· (e) Prove that lEv,e1[Etest(Wiin)] = 0\"2 (1 ). The special test error Etest is a very restricted case of the general out­ ofsample error. Some detailed analysis shows that similar results can be obtained for the general case, as shown in Problem 3.11. Figure 3.4 illustrates the learning curve of linear regression under the assump­ tions of Exercise 3.4. The best possible linear fit has expected error a2• The expected in-sample error is smaller, equal to a2(1 - for N � d + 1. The learned linear fit has eaten into the in-sample noise as much as it could with the d + 1 degrees of freedom that it has at its disposal. This occurs because the fitting cannot distinguish the noise from the 'signal.' On the other hand, the expected out-of-sample error is a2(1 + ), which is more than the un­ avoidable error of a2. The additional error reflects the drift in Wun due to fitting the in-sample noise. 3.3 Logistic Regression The core of the linear model is the 'signal' s = wTx that combines the input variables linearly. ·v. have seen two models based on this signal, and we are now going to introduce a third. In linear regression, the signal itself is taken as the output, which is appropriate if you are trying to predict a real response that could be unbounded. In linear classification, the signal is thresholded at zero to produce a ±1 output, appropriate for binary decisions. A third possibility, which has wide application in practice, is to output a probability, 88 3. THE LINEAR MODEL 3.3. LOGISTIC REGRESSION Number of Data Points, N Figure 3.4: The learning curve for linear regression. a value between 0 and 1. Our new model is called logistic regression. It has similarities to both previous models, as the output is real (like regression ) but bounded (like classification ). Example 3.2 (Prediction of heart attacks). Suppose we want to predict the occurrence of heart attacks based on a person's cholesterol level, blood pres­ sure, age, weight, and other factors. Obviously, we cannot predict a heart attack with any certainty, but we may be able to predict how likely it is to occur given these factors. Therefore, an output that varies continuously be­ tween 0 and 1 would be a more suitable model than a binary decision. The closer y is to 1, the more likely that the person will have a heart attack. D 3.3.1 Predicting a Probability Linear classification uses a hard threshold on the signal s = w T x, h(x) = sign(wTx), while linear regression uses no threshold at all, In our new model, we need something in between these two cases that smoothly restricts the output to the probability range [O, l]. One choice that accom­ plishes this goal is the logistic regression model, where 8 is the so-called logistic function B(s) = whose output is between 0 and 1. 89 3. THE LINEAR IVIODEL 3.3. LOGISTIC REGRESSION The output can be interpreted as a probabil­ ity for a binary event (heart attack or no heart attack, digit 'l' versus digit '5', etc.). Linear classification also deals with a binary event, but the difference is that the 'classification' in logis­ tic regression is allowed to be uncertain, with intermediate values between 0 and 1 reflecting 1 this uncertainty. The logistic function B is referred to as a soft threshold, in contrast to the hard threshold in classification. It is also called a sigmoid because its shape looks like a flattened out 's'. Exercise 3.5 Another popular soft threshold is the hyperbolic tangent es -es tanh(s) = es+ es (a) How is tanh related to the logistic function()? [Hint: shift and scale] (b) Show that tanh(s) converges to a hard threshold for large jsj, and converges to no threshold for small Isl [Hint: Formalize the figure below.] The specific formula of B ( s) will allow us to define an error measure for learning that has analytical and computational advantages, as we will see shortly. Let us first look at the target that logistic regression is trying to learn. The target is a probability, say of a patient being at risk for heart attack, that depends on the input x (the characteristics of the patient). Formally, we are trying to learn the target function f(x) = JP[y = +1 I x). The data does not give us the value of f explicitly. Rather, it gives us samples generated by this probability, e.g., patients who had heart attacks and patients who didn't. Therefore, the data is in fact generated by a noisy target P(y Ix), P(y I x) = {f (x) 1 -f(x) for y = +1; for y = -1. (3.7) To learn from such data, we need to define a proper error measure that gauges how close a given hypothesis his to f in terms of these noisy ±1 examples. 90 3. THE LINEAR MODEL 3.3. LOGISTIC REGRESSION Error measure. The standard error measure e(h(x), y) used in logistic re­ gression is based on the notion of likelihood; how 'likely' is it that we would get this output y from the input x if the target distribution P(y I x) was indeed captured by our hypothesis h(x)? Based on (3.7), that likelihood would be p x {h(x) (y I ) - 1 h(x) for y = +1; for y = -1. We substitute for h(x) by its value B(wTx), and use the fact that 1 B(s) = e( s) (easy to verify) to get P(y Ix) = B(y wTx). (3.8) One of our reasons for choosing the mathematical form e ( s) = es I ( 1 + es) is that it leads to this simple expression for P(y Ix). Since the data points (x1, Y1), ... , (xN, YN) are independently generated, the probability of getting all the Yn 's in the data set from the correspond­ ing Xn 's would be the product N IT P(yn I Xn)· n=l The method of maximum likelihood selects the hypothesis h which maximizes this probability.3 We can equivalently minimize a more convenient quantity, 1 (N ) 1 N ( 1 ) -Nln g P(yn I Xn) = N �ln P(yn I Xn) , since '--ft ln(·)' is a monotonically decreasing function. Substituting with Equation (3.8), we would be minimizing �tin( 1 ) N n=l e(Yn wTxn) with respect to the weight vector w. The fact that we are minimizing this quantity allows us to treat it as an 'error measure.' Substituting the func­ tional form for B(yn WTXn) produces the in-sample error measure for logistic regression, (3.9) The implied pointwise error measure is e(h(xn), Yn) = ln(l+e-YnwTxn ). Notice that this error measure is small when Yn wTxn is large and positive, which would imply that sign(wTxn) = Yn· Therefore, as our intuition would expect, the error measure encourages w to 'classify' each Xn correctly. 3 Although the method of maximum likelihood is intuitively plausible, its rigorous justi fication as an inference tool continues to be discussed in the statistics community. 91 3. THE LINEAR MODEL 3.3. LOGISTIC REGRESSION Exercise 3.6 [Cross-en tropy error measure] (a) More genera lly, if we are learning from ±1 data to predict a noisy target P(y Ix) with candidate hypothesis h, show that the maximum likelihood method reduces to the task of finding h that minimizes N 1 1 Ein(w) = [Yn = +l] ln h(xn) [yn = -1] ln l -h(xn) · (b) For the case h(x) = B(wTx), argue that minimizing the insample error in part (a) is equivalent to minimizing the one in (3.9). For two probability distributions {p, 1-p} and {q, 1q} with binary out­ comes, the cross entropy (from information theory) is 1 1 p log -+ (1 -p) log . q -q The insample error in part (a) corresponds to a crossentropy error measur e on the data point (xn, Yn), with p = [Yn = +1] and q = h(xn). For linear classification, we saw that minimizing Ein for the perceptron is a combinatorial optimization problem; to solve it, we introduced a number of al­ gorithms such as the perceptron learning algorithm and the pocket algorithm. For linear regression, we saw that training can be done using the analytic pseudo-inverse algorithm for minimizing Ein by setting \\7 Ein ( w) = 0. These algorithms were developed based on the specific form of linear classification or linear regression, so none of them would apply to logistic regression. To train logistic regression, we will take an approach similar to linear re­ gression in that we will try to set \\7 Ein ( w) = 0. Unfortunately, unlike the case of linear regression, the mathematical form of the gradient of Ein for logistic regression is not easy to manipulate, so an analytic solution is not feasible. Exercise 3. 7 For logistic regression, show that \\7 Ein(w) Argue that a 'misclassified' example contributes more to the gradient than a correctly classified one. Instead of analytically setting the gradient to zero, we will iteratively set it to zero. To do so, we will introduce a new algorithm, gradient descent. Gradient 92 3. THE LINEAR MODEL 3.3. LOGISTIC REGRESSION descent is a very general algorithm that can be used to train many other learning models with smooth error measures. For logistic regression, gradient descent has particularly nice properties. 3.3.2 Gradient Descent Gradient descent is a general technique for minimizing a twice-differentiable function, such as Ein ( w) in logistic regression. A useful phys­ ical analogy of gradient descent is a ball rolling down a hilly surface. If the ball is placed on a hill, it will roll down, coming to rest at the bottom of a valley. The same basic idea under­ lies gradient descent. Ein(w) is a 'surface' in a high-dimensional space. At step 0, we start somewhere on this surface, at w(O), and try to roll down this surface, thereby decreasing Ein· One thing which you imme­ diately notice from the physical analogy is that the ball will not necessarily come to rest in the lowest valley of the entire surface. Depending on where you start the ball rolling, you will end up at the bottom of one of the valleys a local minimum. In general, the same applies to gradient descent. Depending on your starting weights, the path of descent will take you to a local minimum in the error surface. A particular advantage for logistic regression with the cross-entropy error is that the picture looks much nicer. There is only one valley! So, it does not matter where you start your ball rolling, it will always roll down to the same (unique) global minimum. This is a consequence of the fact that Ein ( w) is a convex function of w, a mathematical property that implies a single 'valley' as shown to the right. This means that gradient descent will not be trapped in lo­ cal minima when minimizing such convex error measures. 4 Weights, w Let's now determine how to 'roll' down the Bin-surface. We would like to take a step in the direction of steepest descent, to gain the biggest bang for our buck. Suppose that we take a small step of size T/ in the direction of a unit vector v. The new weights are w(O) + TJV. Since T/ is small, using the Taylor expansion to first order, we compute the change in Ein as �Ein Ein(w(O) + TJV) Ein(w(O)) TJV7 Ein(w(O))Tv + 0(TJ2) > TJllV7Ein(w(O))ll, 4In fact, the squared in-sample error in linear regression is also convex, which is why the analytic solution found by the pseudo-in verse is guaranteed to have optimal in-sample error. 93 3. THE LINEAR MODEL 3.3. LOGISTIC REGRESSION where we have ignored the small term 0(TJ2). Since vis a unit vector, equality holds if and only if v= \\7 Ein (w(O)) JJV Ein (w(O)) JI' (3.10) This direction, specified by v, leads to the largest decrease in Ein for a given step size T/. Exercise 3.8 The claim that v is the direction which gives largest decrease in Ein only holds for small 77. Why? There is nothing to prevent us from continuing to take steps of size 17, re­ evaluating the direction Vt at each iteration t = 0, 1, 2, .... How large a step should one take at each iteration? This is a good question, and to gain some insight, let's look at the following examples. Weights, w T/ too small Weights, w TJ too large ·weights, w variable T/ just right A fixed step size (if it is too small) is inefficient when you are far from the local minimum. On the other hand, too large a step size when you are close to the minimum leads to bouncing around, possibly even increasing Ein. Ideally, we would like to take large steps when far from the minimum to get in the right ballpark quickly, and then small (more careful) steps when close to the minimum. A simple heuristic can accomplish this: far from the minimum, the norm of the gradient is typically large, and close to the minimum, it is small. Thus, we could set T/t = 17JJV Einll to obtain the desired behavior for the variable step size; choosing the step size proportional to the norm of the gradient will also conveniently cancel the term normalizing the unit vector v in Equation (3.10), leading to the fixed learning rate gradient descent algorithm for minimizing Ein (with redefined TJ): 94 3. THE LINEAR MODEL 3.3. LOGISTIC REGRESSION Fixed learning rate gradient descent : 1: Initialize the weights at time step t = 0 to w(O). 2: for t = 0, 1, 2, ... do 3: Compute the gradient gt= \\l Ein(w(t)). 4: Set the direction to move, Vt = -gt. 5: Update the weights: w(t + 1) = w(t) + TJVt. 6: Iterate to the next step until it is time to stop. 7: Return the final weights. In the algorithm, v t is a direction that is no longer restricted to unit length. The parameter 77 (the learning rate) has to be specified. A typically good choice for 77 is around 0.1 (a purely practical observation). To use gradient descent, one must compute the gradient. This can be done explicitly for logistic regression (see Exercise 3. 7). Example 3.3. Gradient descent is a general algorithm for minimizing twice­ differentiable functions. We can apply it to the logistic regression in-sample error to return weights that approximately minimize 1 N T Ein(w) =NL ln ( 1 + e YnW Xn). n=l Logistic regression algorithm: 1: Initialize the weights at time step t = 0 to w(O). 2: for t = 0, 1, 2, ... do 3: Compute the gradient 4: Set the direction to move, Vt = -gt. 5: Update the weights: w(t + 1) = w(t) + TJVt. 6: Iterate to the next step until it is time to stop. 7: Return the final weights w. D Initialization and termination. We have two more loose ends to tie: the first is how to choose w(O), the initial weights, and the second is how to set the criterion for \" ... until it is time to stop\" in step 6 of the gradient descent algorithm. In some cases, such as logistic regression, initializing the weights w(O) as zeros works well. However, in general, it is safer to initialize the weights randomly, so as to avoid getting stuck on a perfectly symmetric hilltop. Choosing each weight independently from a Normal distribution with zero mean and small variance usually works well in practice. 95 3. THE LINEAR MODEL 3.3. LOGISTIC REGRESSION That takes care of initialization, so we now move on to termination. How do we decide when to stop? Termination is a non-trivial topic in optimization. One simple approach, as we encountered in the pocket algorithm, is to set an upper bound on the number of iterations, where the upper bound is typically in the thousands, depending on the amount of training time we have. The problem with this approach is that there is no guarantee on the quality of the final weights. Another plausible approach is based on the gradient being zero at any min­ imum. A natural termination criterion would be to stop once llgtll drops below a certain threshold. Eventually this must happen, but we do not know when it will happen. For logistic regression, a combination of the two conditions (setting a large upper bound for the number of iterations, and a small lower bound for the size of the gradient) usually works well in practice. There is a problem with relying solely on the size of the gradient to stop, which is that you might stop prematurely as illustrated on the right. When the iteration reaches a relatively kf fl.at region (which is more common than you might suspect), the algorithm will prematurely stop when we may want to continue. So one so-Weights, w lution is to require that termination occurs only if the error change is small and the error itself is small. Ultimately a combina­ tion of termination criteria (a maximum number of iterations, marginal error improvement, coupled with small value for the error itself) works reasonably well. Example 3.4. By way of summarizing linear models, we revisit our old friend the credit example. If the goal is to decide whether to approve or deny, then we are in the realm of classification; if you want to assign an amount of credit line, then linear regression is appropriate; if you want to predict the probability that someone will default, use logistic regression. Credit Analysis Approve or Deny Amount of Credit Probability of Default Perceptron Linear Regression Logistic Regression The three linear models have their respective goals, error measures, and al­ gorithms. Nonetheles s, they not only share similar sets of linear hypotheses, but are in fact related in other ways. We would like to point out one impor­ tant relationship: Both logistic regression and linear regression can be used in linear classification. Here is how. Logistic regression produces a final hypothesis g(x) which is our estimate of JP>[y = + 1 I x). Such an estimate can easily be used for classification by 96 3. THE LINEAR MODEL 3.3. LOGISTIC REGRESSION setting a threshold on g(x); a natural threshold is �' which corresponds to classifying + 1 if + 1 is more likely. This choice for threshold corresponds to using the logistic regression weights as weights in the perceptron for classifica­ tion. Not only can logistic regression weights be used for classification in this way, but they can also be used as a way to train the perceptron model. The perceptron learning problem (3.2) is a very hard combinatorial optimization problem. The convexity of Ein in logistic regression makes the optimization problem much easier to solve. Since the logistic function is a soft version of a hard threshold, the logistic regression weights should be good weights for classification using the perceptron. A similar relationship exists between classification and linear regression. Linear regression can be used with any real-valued target function, which includes real values that are ±1. If wlinx is fit to ±1 values, sign(wlinx) will likely agree with these values and make good classification predictions. In other words, the linear regression weights WHn, which are easily computed using the pseudo-inverse, are also an approximate solution for the perceptron model. The weights can be directly used for classification, or used as an initial condition for the pocket algorithm to give it a head start. D Exercise 3. 9 Consider pointwise error measures eclass(s, y) [y sign(s)], esq(s, y) = (y - s and e10g( s, y) = ln(l +exp( -ys)), where the signal s = wT x. (a) For y = +1, plot eclassr esq and versus s, on the same plot. (b) Show that ec1ass(s,y) esq(s,y), and hence that the classification error is upper bounded by the squared error. (c) Show that ec1ass(s,y) and, as in part (b), get an upper bound (up to a constant factor) using the logistic regression error. These bounds indicate that minimizing the squared or logistic regression error should also decrease the classification error, which justifies using the weights returned by linear or logistic regression as approximations for clas­ sification. Stochastic gradient descent. The version of gradient descent we have de­ scribed so far is known as batch gradient descent the gradient is computed for the error on the whole data set before a weight update is done. A sequen­ tial version of gradient descent known as stochastic gradient descent (SGD) turns out to be very efficient in practice. Instead of considering the full batch gradient on all N training data points, we consider a stochastic version of the gradient. First, pick a training data point (xn, Yn) uniformly at random (hence the name 'stochastic'), and consider only the error on that data point 97 3. THE LINEAR MODEL 3.3. LOGISTIC REGRESSION (in the case of logistic regression), The gradient of this single data point's error is used for the weight update in exactly the same way that the gradient was used in batch gradient descent. The gradient needed for the weight update of SGD is (see Exercise 3.7) and the weight update is w f-w77\\len(w). Insight into why SGD works can be gained by looking at the expected value of the change in the weight (the expectation is with respect to the random point that is selected). Since n is picked uniformly at random from { 1, ... , N}, the expected weight change is 1 N TJ \\len(w). n=l This is exactly the same as the deterministic weight change from the batch gradient descent weight update. That is, 'on average' the minimization pro­ ceeds in the right direction, but is a bit wiggly. In the long run, these random fluctuations cancel out. The computational cost is cheaper by a factor of N, though, since we compute the gradient for only one point per iteration, rather than for all N points as we do in batch gradient descent. Notice that SGD is similar to PLA in that it decreases the error with re­ spect to one data point at a time. Minimizing the error on one data point may interfere with the error on the rest of the data points that are not considered at that iteration. However, also similar to PLA, the interference cancels out on average as we have just argued. Exercise 3.10 (a) Define an error for a single data point (xn, Yn) to be en(w) = max(O, -ynwTxn)· Argue that PLA can be viewed as SGD on en with learning rate 7J = 1. (b) For logistic regression with a very large w, argue that minimizing Ein using SGD is similar to PLA. This is another indication that the lo­ gistic regression weights can be used as a good approximation for classification. SGD is successful in practice, often beating the batch version and other more sophisticated algorithms. In fact, SGD was an important part of the algorithm that won the million-dollar Netflix competition, discussed in Section 1.1. It scales well to large data sets, and is naturally suited to online learning, where 98 3. THE LINEAR MODEL 3.4. NONLINEAR TRANSFORMATION a stream of data present themselves to the learning algorithm sequentially. The randomness introduced by processing one data point at a time can be a plus, helping the algorithm to avoid flat regions and local minima in the case of a complicated error surface. However, it is challenging to choose a suit­ able termination criterion for SGD. A good stopping criterion should consider the total error on all the data, which can be computationally demanding to evaluate at each iteration. 3.4 Nonlinear Transf ormation All formulas for the linear model have used the sum d WTX= LWiXi i=O (3.11) as the main quantity in computing the hypothesis output. This quantity is linear, not only in the xi's but also in the w/s. A closer inspection of the corresponding learning algorithms shows that the linearity in wi 's is the key property for deriving these algorithms; the Xi's are just constants as far as the algorithm is concerned. This observation opens the possibility for allowing nonlinear versions of Xi's while still remaining in the analytic realm of linear models, because the form of Equation (3.11) remains linear in the wi param­ eters. Consider the credit limit problem for instance. It makes sense that the 'years in residence' field would affect a person's credit since it is correlated with stability. However, it is less plausible that the credit limit would grow linearly with the number of years in residence. More plausibly, there is a threshold (say 1 year) below which the credit limit is affected negatively and another threshold (say 5 years) above which the credit limit is affected positively. If Xi is the input variable that measures years in residence, then two nonlinear 'features' derived from it, namely [xi < 1] and [xi > 5], would allow a linear formula to reflect the credit limit better. We have already seen the use of features in the classification of handwritten digits, where intensity and symmetry features were derived from input pixels. Nonlinear transforms can be further applied to those features, as we will see shortly, creating more elaborate features and improving the performance. The scope of linear methods expands significantly when we represent the input by a set of appropriate features. 3.4.1 The Z Space Consider the situation in Figure 3.1 (b) where a linear classifier can't fit the data. By transforming the inputs x1, x2 in a nonlinear fashion, we will be able to separate the data with more complicated boundaries while still using the 99 3. THE LINEAR MODEL 3.4. NONLINEAR TRANSFORMATION simple PLA as a building block. Let's start by looking at the circle in Fig­ ure 3.5(a), which is a replica of the non-separable case in Figure 3.l(b). The circle represents the following equation: xi+ x� = 0.6. That is, the nonlinear hypothesis h(x) = sign(-0.6 +xi+ x�) separates the data set perfectly. We can view the hypothesis as a linear one after applying a nonlinear transformation on x. In particular, consider zo = 1, z1 = xi and Z2 = X�, h(x) sign ((-0.6) · 1 + 1 · xi + 1 · x� ) \"-v-\" '-v-' '-v-' '-v-' '-v-' '-v-' Wo Zo w1 Zl W2 Z2 sign [Wo W1 W2] [ :� ] WT z where the vector z is obtained from x through a nonlinear transform <I>, z = <I>(x). We can plot the data in terms of z instead of x, as depicted in Figure 3.5(b ). For instance, the point x1 in Figure 3.5(a) is transformed to the point z1 in Figure 3 .5 (b) and the point x2 is transformed to the point z2• The space Z, which contains the z vectors, is referred to as the feature space since its coor­ dinates are higher-level features derived from the raw input x. We designate different quantities in Z with a tilde version of their counterparts in X, e.g., the dimensionality of Z is d and the weight vector is w.5 The transform <I> that takes us from X to Z is called a feature transform, which in this case is <I>(x) = (1, xi, x�). (3.12) In general, some points in the Z space may not be valid transforms of any x E X, and multiple points in X may be transformed to the same z E Z, depending on the nonlinear transform <I>. The usefulness of the transform above is that the nonlinear hypothesis h (circle) in the X space can be represented by a linear hypothesis (line) in the Z space. Indeed, any linear hypothesis h in z corresponds to a (possibly nonlinear) hypothesis of x given by h(x) = h(<I>(x)). 5 Z {1} x JRd, where d 2 in this case. We treat Z as ddimensional since the added coordinate zo 1 is fixed. 100 3. THE LINEAR MODEL 3.4. NONLINEAR TRANSFO RMATION 0 1 0 0 0.5 (b) Transformed data in Z space z = P{x) = [i!] Figure 3.5: (a) The original data set that is not linearly separable, but separable by a circle. (b) The transformed data set that is linearly separable in the Z space. In the figure, x1 maps to z1 and x2 maps to z2; the circular separator in the X space maps to the linear separator in the Z space. The set of these hypotheses h is denoted by 1-lcp. For instance, when using the feature transform in (3.12), each h E 1-lcp is a quadratic curve in X that corresponds to some line h in Z. Exercise 3.11 Consider the feature transform <I> in (3.12). What kind of boundary in does a hyperplane in Z correspond to in the following cases? Draw a picture that illustrates an example of each case. (a) 'li1 0, w2 0 (b) 'li1 > 0, w2 = 0 (c) w1 > O,w2 > O,wo < o (d) w1 > o,w2 > o,wo > o Because the transformed data set (zi, Y1), · · · , (zN, YN) in Figure 3.5(b) is linearly separable in the feature space Z, we can apply PLA on the transformed data set to obtain wPLAi the PLA solution, which gives us a final hypothesis g(x) = sign(w�LAz) in the X space, where z = <I>(x). The whole process of applying the feature transform before running PLA for linear classification is depicted in Figure 3.6. The in-sample error in the input space X is the same as in the feature space Z, so Ein(g) = 0. Hyperplanes that achieve Ein(wPLA) = 0 in Z cor­ respond to separating curves in the original input space X. For instance, 101 3. THE LINEAR MODEL 3.4. NONLINEAR TRANSFORMATION <I> 0.5 � 0 1. Original data Xn EX 0 4. Classify in X-space g ( x) = g (<I> ( x)) = sign ( w T <I> ( x)) 0 0 0 0 0.5 2. Transform the data Zn = <I>(xn) E Z + 0.5 3. Separate data in Z-space g(z) = sign(wTz) Figure 3.6: The nonlinear transform for separating non separable data. as shown in Figure 3.6, the PLA may select the line wPLA = ( -0.6, 0.6, 1) that separates the transformed data (z1, Y1), · · · , (zN, YN ). The correspond­ ing hypothesis g(x) = sign(-0.6 + 0.6 ·xi+ x�) will separate the original data (x1,Y1), · · ·, (xN,YN)· In this case, the decision boundary is an ellipse in X. How does the feature transform affect the VC bound (3.1)? If we honestly decide on the transform <P before seeing the data, then with probability at least 1 -6, the bound (3.1) remains true by using dvc(1-lcp) as the VC dimen­ sion. For instance, consider the feature transform <I> in (3.12). We know that Z = {1} x�2. Since 1-lcp is the perceptron in Z, dvc(1-lcp):: 3 (the:: is because some points z E Z may not be valid transforms of any x, so some dichotomies may not be realizable). We can then substitute N, dvc(1-lcp), and 6 into the VC bound. After running PLA on the transformed data set, if we succeed in 102 3. THE LINE AR MODEL 3.4. NONLINEAR TRANSFORMATION getting some g with Ein (g) = 0, we can claim that g will perform well out of sample. It is very important to understand that the claim above is valid only if you decide on <P before seeing the data or trying any algorithms . What if we first try using lines to separate the data, fail, and then use the circles? Then we are effectively using a model that contains both lines and circles, and dvc is no longer 3. Exercise 3.12 We know that in the Euclidean plane, the perceptron model 1-l cannot implement all 16 dichotomies on 4 points. That is, m1-1.(4) < 16. Take the feature transform <I> in (3.12). (a) Show that m1-1.<I,(3) = 8. (b) Show that m1-1.<I> ( 4) 16. ( c) Show that m1-1.u1-1.<I> ( 4) = 16. That is, if you used lines, dvc = 3; if you used elipses, dvc = 3; if you used lines and elipses, dvc > 3. Worse yet, if you actually look at the data (e.g., look at the points in Fig­ ure 3.l(a)) before deciding on a suitable <P, you forfeit most of what you learned in Chapter 2 ©. You have inadvertently explored a huge hypothesis space in your mind to come up with a specific <P that would work for this data set. If you invoke a generalization bound now, you will be charged for the VC dimension of the full space that you explored in your mind, not just the space that <P creates. This does not mean that <P should be chosen blindly. In the credit limit problem for instance, we suggested nonlinear features based on the 'years in residence' field that may be more suitable for linear regression than the raw input. This was based on our understanding of the problem, not on 'snooping' into the training data. Therefore, we pay no price in terms of generalization, and we may well gain a dividend in performance because of a good choice of features. The feature transform <P can be general, as long as it is chosen before seeing the data set (as if we cannot emphasize this enough). For instance, you may have noticed that the feature transform in (3.12) only allows us to get very limited types of quadratic curves. Ellipses that do not center at the origin in X cannot correspond to a hyperplane in Z. To get all possible quadratic curves in X, we could consider the more general feature transform z = <P2(x), <P2(x) = (1,x1,x2,xi,x1x2,x�), (3.13) which gives us the flexibility to represent any quadratic curve in X by a hy­ perplane in Z (the subscript 2 of <P is for polynomials of degree 2 -quadratic curves). The price we pay is that Z is now five-dimensional instead of two­ dimensional, and hence dvc is doubled from 3 to 6. 103 3. THE LINEAR MODEL 3.4. NONLINE AR TRANSFORMATION Exercise 3.13 Consider the feature transform z = <1>2(x) in (3.13). How can we use a hyperplane in to represent the following boundar ies in (a) parabola (x1 3)2 x2 = (b) The circle (x1 3)2 (x2 -4)2 = ( c) The ellipse 2(x1 - 3)2 (x2 4)2 = hyperbola (x1 -3)2 (x2 4)2 (e) ellipse 2(x1 x2 3)2 (x1 -x2 -4)2 = (f) line 2x1 x2 = One may further extend <1>2 to a feature transform <1>3 for cubic curves in X, or more generally define the feature transform <I> Q for degree-Q curves in X. The feature transform <I>Q is called the Qth order polynomial transform. The power of the feature transform should be used with care. It may not be worth it to insist on linear separability and employ a highly complex surface to achieve that. Consider the case of Figure 3.l(a). If we insist on a feature transform that linearly separates the data, it may lead to a significant increase of the VC dimension. As we see in Figure 3.7, no line can separate the training examples perfectly, and neither can any quadratic nor any third-order polynomial curves. Thus, we need to use a fourth-order polynomial transform: ( ) (1 2 2 3 2 2 3 4 3 2 2 3 4) X = , Xi, X2, X1, X1X2, X2, X1, X1 X2, X1X2, X2, X1, X1 X2, X1 X2, X1X2, X2 . If you look at the fourth-order decision boundary in Figure 3.7(b), you don't need the VC analysis to tell you that this is an overkill that is unlikely to generalize well to new data. A better option would have been to ignore the two misclassified examples in Figure 3.7(a), separate the other examples perfectly with the line, and accept the small but nonzero Ein. Indeed, sometimes our best bet is to go with a simpler hypothesis set while tolerating a small Ein. While our discussion of feature transforms has focused on classification problems, these transforms can be applied equally to regression problems. Both linear regression and logistic regression can be implemented in the feature space Z instead of the input space X. For instance, linear regression is often coupled with a feature transform to perform nonlinear regression. The N by d + 1 input matrix X in the algorithm is replaced with the N by J + 1 matrix Z, while the output vector y remains the same. 3.4.2 Computation and Generalization Although using a larger Q gives us more flexibility in terms of the shape of decision boundaries in X, there is a price to be paid. Computa tion is one issue, and generalization is the other. Computa tion is an issue because the feature transform <I>Q maps a two­ dimensional vector x to J = dimensions , which increases the memory 104 3. THE LINEAR MODEL 3.4. NONLINEAR TRANSFORMATION (a) Linear fit (b) 4th order polynomial fit Figure 3.7: Illustration of the nonlinear transform using a data set that is not linearly separable; (a) a line separates the data after omitting a few points, (b) a fourth order polynomial separates all the points. and computational costs. Things could get worse if x is in a higher dimension to begin with. Exercise 3.14 Consider the Qth order polynomial transform 4>Q for = Rd. What is the dimensionality d of the feature space Z (excluding the fixed coordinate zo = 1). Evaluate your result on d E {2, 3, 5, 10} and E {2, 3, 5, 10}. The other important issue is generalization. If <Pq is the feature transform of a two-dimensional input space, there will bed= dimensions in Z, and dv0(H<P) can be as high as + 1. This means that the second term in the VC bound (3.1) can grow significantly. In other words, we would have a weaker guarantee that Eout will be small. For instance, if we use Cf? = <f?50, the VC dimension of 1-lcp could be as high as C50)2C53) + 1 = 1326 instead of the original dvc = 3. Applying the rule of thumb that the amount of data needed is proportional to the VC dimension, we would need hundreds of times more data than we would if we didn't use a feature transform, in order to achieve the same level of generalization error. Exercise 3.15 High-dimensional feature transforms are by no means the only transforms that we can use. We can take the tradeoff in the other direction, and use low dimensional feature transforms as well (to achieve an even lower generalization error bar). (continued on next page) 105 3. THE LINEAR MODEL 3.4. NONLINE AR TRANSFORMA TION Consider the following feature transform, which maps a d-dimensional x to a one-dimensional z, keeping only the kth coordinate of x. <J>(k) (x) = (1, Xk)· (3.14) Let 1-lk be the set of perceptrons in the feature space. (a) Prove that dvc(1lk) = 2. (b) Prove that dvc(U�=l 1-lk) :S 2(log2 d 1). 1-lk is called the decision stump model on dimension k. The problem of generalization when we go to high-dimensional space is some­ times balanced by the advantage we get in approximating the target better. As we have seen in the case of using quadratic curves instead of lines, the trans­ formed data became linearly separable, reducing Ein to 0. In general, when choosing the appropriate dimension for the feature transform, we cannot avoid the approximat ion-generalization tradeoff, higher d better chance of being linearly separable (Ein .t) lower d possibly not linearly separable ( Ein t) Therefore, choosing a feature transform before seeing the data is a non-trivial task. When we apply learning to a particular problem, some understanding of the problem can help in choosing features that work well. More generally, there are some guidelines for choosing a suitable transform, or a suitable model, which we will discuss in Chapter 4. Exercise 3.16 Write down the steps of the algorithm that combines <!>3 with linear re­ gression. How about using <!>10 instead? Where is the main computational bottleneck of the resulting algorithm? Example 3.5. Let's revisit the handwritten digit recognition example. We can try a different way of decomposing the big task of separating ten digits to smaller tasks. One decomposition is to separate digit 1 from all the other digits. Using intensity and symmetry as our input variables like we did before, the scatter plot of the training data is shown next. A line can roughly separate digit 1 from the rest, but a more complicated curve might do better. 106 3. THE LINEAR MODEL 3.4. NONLINEAR TRANSFORMATION Average Intensity We use linear regression ( for classification ), first without any feature transform. The results are shown below (LHS). We get Ein = 2.13% and Eout = 2.38%. Average Intensity Linear model Ein = 2.13% Eout = 2.38% Average Intensity 3rd order polynomial model Ein = 1.75% Eout = 1.87% Classification of the digits data ('1' versus 'not 1') using linear and third order polynomial models. When we run linear regression with <1>3, the third-order polynomial transform, we obtain a better fit to the data, with a lower Ein = 1. 75%. The result is depicted in the RHS of the figure. In this case, the better in-sample fit also resulted in a better out-of-sample performance, with Eout = 1.87%. D Linear models, a final pitch. The linear model (for classification or regres­ sion) is an often overlooked resource in the arena of learning from data. Since efficient learning algorithms exist for linear models, they are low overhead. They are also very robust and have good generalization properties. A sound 107 3. THE LINEAR MODEL 3.4. NONLINEAR TRANSFOR MATION policy to follow when learning from data is to first try a linear model. Because of the good generalization properties of linear models, not much can go wrong. If you get a good fit to the data (low Ein), then you are done. If you do not get a good enough fit to the data and decide to go for a more complex model, you will pay a price in terms of the VC dimension as we have seen in Exercise 3.12, but the price is modest. 108 3. THE LINEAR MODEL 3.5. PROBL EMS 3.5 Problems Problem 3.1 Consider the double semi-circle \"toy\" learning task below. There are two semi circles of width thk with inner radius rad, separated by sep as shown (red is -1 and blue is +1). The center of the top semi circle is aligned with the middle of the edge of the bottom semicircle. This task is linearly separable when sep 2: 0, and not so for sep < 0. Set rad = 10, thk = 5 and sep = 5. Then, generate 2, 000 examples uniformly, which means you will have approximately 1, 000 examples for each class. (a) Run the PLA starting from w = 0 until it converges. Plot the data and the final hypothesis. (b) Repeat part (a) using the linear regression (for classification) to obtain w. Explain your observations. Problem 3.2 For the double semi circle task in Problem 3.1, vary sep in the range {0.2, 0.4, ... , 5}. Generate 2, 000 examples and run the PLA starting with w = 0. Record the number of iterations PLA takes to converge. Plot sep versus the number of iterations taken for PLA to converge. Explain your observations. [Hint: Problem 1.3.} Problem 3.3 For the double semi circle task in Problem 3.1, set sep = -5 and generate 2, 000 examples. (a) What will happen if you run PLA on those examples? (b) Run the pocket algorithm for 100, 000 iterations and plot Ein versus the iteration number t. ( c) Plot the data and the final hypothesis in part (b ). (continued on next page) 109 3. THE LINEAR MODEL 3.5. PROBLEMS ( d) Use the linear regression algorithm to obtain the weights w, and compare this result with the pocket algorithm in terms of computation time and quality of the solution. (e) Repeat (b) -(d) with a 3rd order polynomial feature transform. Problem 3.4 In Problem 1.5, we introduced the Adaptive Linear Neu­ ron (Adaline) algorithm for classification. Here, we derive Adaline from an optimization perspective . (a) Consider En(w) = (max(O, 1-ynwTxn))2. Show that En(w) is con­ tinuous and differentiable. Write down the gradient \\7 En(w). (b) Show that En(w) is an upper bound for [sign(wTxn) i-Yn]. Hence, tr L:;:r=l En(w) is an upper bound for the insample classification er­ ror Ein(w). (c) Argue that the Adaline algorithm in Problem 1.5 performs stochastic gradient descent on tr L::=l En(w). Problem 3.5 (a) Consider En(w) = max(O, 1-ynWTXn)· Show that En(w) is continuous and differentiable except when Yn = WTXn. (b) Show that En(w) is an upper bound for [sign(wTxn) i-Ynl Hence, tr L:;:r=l En(w) is an upper bound for the insample classification er­ ror Ein(w). (c) Apply stochastic gradient descent on tr L:;:r=l En(w) (ignoring the sin­ gular case of wT Xn = Yn) and derive a new perceptron learning algorithm. Problem 3.6 Derive a linear programming algorithm to fit a linear model for classification using the following steps. A linear program is an optimization problem of the following form: min z subject to T c z Az :Sh. A, b and care parameters of the linear program and z is the optimization va ri­ able. This is such a well studied optimization pr oblem that most mathematics software have canned optimization functions which solve linear programs. (a) For linearly separable data, show that for some w, Yn(wTxn) 2: 1 for n= l, ... ,N. 110 3. THE LINEAR MODEL 3.5. PROBLEMS (b) Formula te the task of finding a separating w for separable data as a linear program. You need to specify what the parameters A, b, c are and what the optimization variable z is. (c) If the data is not separable, the condition in (a) cannot hold for every n. Thus introduce the violation t;,n 2: 0 to capture the amount of violation for example Xn. So, for n = 1, ... , N, Yn(WTXn) 2: 1-t;,n, t;,n 2: 0. Naturally, we would like to minimize the amoun t of violation. One intu itive approach is to minimize 2:,:=1 t;,n, i.e., we want w that solves n=l subject to Yn(wTxn) 2: 1 -t;,n, t;,n 2: 0, where the inequalities must hold for n = 1, ... , N. Formulate this prob lem as a linear program. ( d) Argue that the linear program you derived in ( c) and the optimization problem in Problem 3.5 are equivalent. Problem 3. 7 Use the linear programming algorithm from Problem 3.6 on the learning task in Problem 3.1 for the separable (sep = 5) and the non­ separable (sep = -5) cases. Compare your results to the linear regression approach with and without the 3rd order polynomial feature transform. Problem 3.8 For linear regression, the outofsample error is Eout(h) = lE [(h(x) -y)2] • Show that among all hypotheses, the one that minimizes Eout is given by h*(x) = JE[y Ix]. The function h* can be treated as a deterministic target function, in which case we can write y = h* (x) + E(x) where E(x) is an (input dependent) noise variable. Show that E(x) has expected value zero. 111 3. THE LINEAR MODEL 3.5. PROBLEMS Problem 3.9 Assuming that XTX is invertible, show by direct comparison with Equation (3.4) that Ein(w) can be written as Ein(w) = (w - (XTx)1XTyr(XTX)(w - (XTx)1XTy) + yT(I -X(XTx)1XT)y. Use this expression for Ein to obtain W!in· What is the insample error? [Hint: The matrix XTX is positive definite.] Problem 3.10 Exercise 3.3 studied some properties of the hat matrix H = X(XTX)1XT, where X is a N by d + 1 matrix, and XTX is invertible. Show the following additional properties. (a) Every eigenvalue of H is either 0 or 1. [Hint: Exercise 3.3(b ).] (b) Show that the trace of a symmetric matrix equals the sum of its eigen­ values. [Hint: Use the spectral theorem and the cyclic property of the trace. Note that the same result holds for non-symmetric matrices, but is a little harder to prove.] ( c) How many eigenvalues of H are 1? What is the rank of H? [Hint: Exercise 3.3(d).j Problem 3.11 Consider the linear regression problem setup in Exercise 3.4, where the data come s from a genuine linear relationship with added noise. The noise for the different data points is assumed to be iid with zero mean and variance CJ2. Assume that the 2nd moment matrix I:= lEx[xxT] is non-singular. Follow the steps below to show that, with high probability, the out-of-sample error on average is 2( d+l 1) Eout(W!in) = (5 1 + + o(N) . (a) For a test point x, show that the error y -g(x) is E-XT(XTX)lXTE, where E is the noise realization for the test point and E is the vector of noise realizations on the data. (b) Take the expectation with respect to the test point, i.e., x and E, to obtain an expression for Eaut· Show that Eaut = CJ2 +trace (I:(XTX)1XTEETXT(XTX)1). [Hints: a= trace( a) for any scalar a; trace(AB) = trace(BA); expecta tion and trace commute.] (c) What is lEe[EET]? 112 3. THE LINEAR MODEL 3.5. PROBLEMS ( d) Take the expectation with respect to E to show that, on average, 2 0-2 1 T -1 Bout= a-+ N trace (I:(NX X) ) . Note that :KrXTX = :Kr L::=l XnX� is an Nsample estimate of I:. So :KrXTX � I:. If :KrXTX = I:, then what is Bout on average? ( e) Show that (after taking the expectation over the data noise) with high probability, Bout = o-2 ( 1 + d l + o( :Kr)) . [Hint: By the law of large numbers :Kr XTX converges in probability to I:, and so by continuity of the inverse at I:, ( :KrXTX)-1 converges in probability to I:-1. J Problem 3.12 In linear regression, the insample predictions are given by y =Hy, where H = X(XTX)-1XT. Show that H is a projection matrix, i.e. H2 = H. So y is the projection of y onto some space. What is this space? Problem 3.13 This problem creates a linear regression algorithm from a good algorithm for linear classification. As illustrated, the idea is to take the original data and shift it in one direction to get the +1 data points; then, shift it in the opposite direction to get the -1 data points. x Original data for the one dimensional regression prob lem x Shifted data viewed as a twodimensional classifica tion problem More generally, The data (xn, Yn) can be viewed as data points in JRd+1 by treating the y value as the ( d + 1 )th coordinate. (continued on next page) 113 3. THE LIN EAR MODEL Now, construct positive and negative points D+ (x1, y1) +a, ... , (xN, YN) +a 1)_ (x1, y1) -a, ... , (xN, YN) -a, 3.5. PROBLEMS where a is a perturbation parameter. You can now use the linear programming algorithm in Problem 3.6 to separate D+ from 1)_. The resulting separating hyperplane can be used as the regression 'fit' to the original data. (a) How many weights are learned in the classification problem? How many weights are needed for the linear fit in the regression problem? (b) The linear fit requires weights w, where h(x) = wTx. Suppose the weights returned by solving the classification problem are w class. Derive an expression for was a function of Wc1ass· (c) Generate a data set Yn = x;;, +O\"En with N = 50, where Xn is uniform on [O, 1] and En is zero mean Gaussian noise; set O\" = 0.1. Plot D+ and 1)_ for a= [ 0�1]. ( d) Give comparisons of the resulting fits from running the classification ap­ proach and the analytic pseudo-inverse algorithm for linear regression. Problem 3.14 In a regression setting, assume the target function is linear, so f(x) = xTWf, and y = Xw1 + E, where the entries in E are zero mean, iid with variance 0\"2. In this problem derive the bias and variance as follows. (a) Show that the average function is g(x) = f(x), no matter what the size of the data set, as long as XTX is invertible. What is the bias? (b) What is the variance? [Hint: Problem 3.11] Problem 3.15 In the text we derived that the linear regression solution weights must satisfy XTXw = XTy. If XTX is not invertible, the solution Wiin = (XTX)1XTy won't work. In this event, there will be many solutions for w that minimize Ein· Here, you will derive one such solution. Let p be the rank of X. Assume that the singular value decomposition (SVD) of X is x = urvT' where u E JRNXp satisfies UTU = Ip. v E JR(d+l) Xp satisfies VTV =Ip. and r E ]RPXP is a positive diagonal matrix. (a) Show that p < d + 1. (b) Show that W!in = vr1uTy satisfies XTXW!in = XTy, and hence is a solution. (c) Show that for any other solution that satisfies XTXw = XTy, llwlinll < llwll · That is, the solution we have constructed is the minimum norm set of weights that minimizes Ein· 114 3. THE LINEAR MODEL 3.5. PROBLEMS Probl em 3.16 In Example 3.4, it is mentioned that the output of the final hypothesis g(x) learned using logistic regression can be thresholded to get a 'hard' (±1) classification. This problem shows how to use the risk matrix introduced in Example 1.1 to obtain such a threshold. Consider fingerprint verification, as in Example 1.1. After learning from the data using logistic regression, you produce the final hypothesis g(x) = P[y = +1 I x), which is your estimate of the probability that y = +1. Suppose that the cost matrix is given by you say +1 -1 True classification + 1 (correct person) -1 (intruder) 0 Ca 0 For a new person with fingerprint x, you compute g(x) and you now need to de cide whether to accept or reject the person (i.e., you need a hard classification). So, you will accept if g(x) � K, where K is the threshold. (a) Define the cost(accept) as your expected cost if you accept the person. Similarly define cost(reject). Show that cost( accept) cost( reject) (1 -g(x) )ca, g(x)cr. (b) Use part (a) to derive a condition on g(x) for accepting the person and hence show that Ca K,= --. Ca+ Cr ( c) Use the costmatrices for the Supermarket and CIA applications in Ex­ ample 1.1 to compute the threshold K for each of these two cases. Give some intuition for the thresholds you get. Problem 3.17 Consider a function E(u, v) = eu + e2v + euv + u2 -3uv + 4v2 -3u -5v, (a) Approximate E(u + b.u, v + b.v) by E1 (b.u, b.v), where E1 is the first-order Taylor's expansion of E around (u,v) = (0,0). Suppose E1(b.u,b.v) = aub.u + avb.v +a. What are the values of au, av, and a? (continued on next page) 115 3. THE LINEAR MODEL 3.5. PROBLEMS (b) Minimize E 1 over all possible (L\\u, L\\v) such that ll(L\\u, L\\v)ll = 0.5. In this chapter, we proved that the optimal column vector [ ��] is parallel to the column vector -\\i'E(u,v), which is called the negative gradient direction. Compute the optimal (L\\u, L\\v) and the resulting E(u + L\\u, v + L\\v). (c) Approximate E(u+L\\u, v+L\\v) by E2(L\\u, L\\v), where E2 is the second order Taylor's expansion of E around ( u, v) = (0, 0). Suppose What are the values of buu, bvv, buv, bu, bv, and b? (d) Minimize E2 over all possible (L\\u, L\\v) (regardless of length). Use the fact that \\72 E( u, v) I (o,o) (the Hessian matrix at (0, 0)) is positive definite to prove that the optimal column vector [L\\u*] ( 2 )-1 L\\v* = -\\7 E(u, v) \\7 E(u, v), which is called the Newton direction. ( e) Numerically compute the following values: (i) the vector (L\\u, L\\v) of length 0.5 along the Newton direction, and the resulting E(u + L\\u, v + L\\v). (ii) the vector (L\\u, L\\v) of length 0.5 that minimizes E(u+L\\u, v+L\\v), and the resulting E(u + L\\u, v + L\\v). (Hint: Let L\\u = 0.5sin8.) Compare the values of E(u+L\\u,v+L\\v) in (b), (ei), and (eii). Briefly state your findings. The negative gradient direction and the Newton direction are quite fundamental for designing optimization algorithms. It is important to understand these directions and put them in your toolbox for designing learning algorithms. Problem 3.18 Take the feature transform <I>2 in Equation (3.13) as <I>. (a) Show that dvc (1-icp) :S 6. (b) Show that dvc(Hq,) > 4. {Hint: Exercise 3.12} (c) Give an upper bound on dvc(Hq,k) for X = IRd. (d) Define -9 Argue that dvc(Hq,2) = dvc(H;p2). In other words, while <I>2(X) E IR , dvc(1-l;p2) :S 6 < 9. Thus, the dimension of <I>(X) only gives an upper bound of dvc(Hq,), and the exact value of dvc(1icp) can depend on the components of the transform. 116 3. THE LINEAR MODEL 3.5. PROBLEMS Problem 3.19 A Transformer thinks the following procedures would work well in learning from two-dimensional data sets of any size. Please point out if there are any potential problems in the procedures: (a) Use the feature tra nsform { (0, ... '0, 1, 0, ... ) <T?(x)= � (0, 0, ... '0) if X = Xn otherwise . before running PLA. (b) Use the feature transform 1? with using some very small 'Y· (c) Use the feature transform 1? that consists of all before running PLA, with i E {O, ... , 1} and j E {O, ... , 1}. 117 118 Chapter 4 Overfitting Paraskavedekatriaphobia 1 (fear of Friday the 13th), and superstitions in gen­ eral, are perhaps the most illustrious cases of the human ability to overfit. Unfortunate events are memorable, and given a few such memorable events, it is natural to try and find an explanation. In the future, will there be more unfortunate events on Friday the 13th's than on any other day? Overfitting is the phenomenon where fitting the observed facts (data) well no longer indicates that we will get a decent out-of-sample error, and may actually lead to the opposite effect. You have probably seen cases of overfit­ ting when the learning model is more complex than is necessary to represent the target function. The model uses its additional degrees of freedom to fit idiosyncrasies in the data (for example, noise), yielding a final hypothesis that is inferior. Overfitting can occur even when the hypothesis set contains only functions which are far simpler than the target function, and so the plot thick­ ens @). The ability to deal with overfitting is what separates professionals from amateurs in the field of learning from data. We will cover three themes: When does overfitting occur? What are the tools to combat overfitting? How can one estimate the degree of overfitting and 'certify' that a model is good, or better than another? Our emphasis will be on techniques that work well in practice. 4.1 When Does Overfitting Occur? Overfitting literally means \"Fitting the data more than is warranted.\" The main case of overfitting is when you pick the hypothesis with lower Ein, and it results in higher Eout. This means that Ein alone is no longer a good guide for learning. Let us start by identifying the cause of overfitting. 1from the Greek paraskevi (Friday), dekatreis (thirteen ), phobia (fear) 119 4. 0VERFITTING 4.1. WHEN DOES 0VERFITTING OCCUR? Consider a simple one-dimensional regression problem with five data points. We do not know the target function, so let's select a general model, maximiz­ ing our chance to capture the target function. Since 5 data points can be fit by a 4th order polynomial, we select 4th order polynomials . The result is shown on the right. The target function is a 2nd order polynomial (blue curve), with a little added noise in the data points. Though the target is simple, the learning algorithm used the full power of the 4th order polynomial to fit the data exactly, but the result does not look anything like the target function. The data has been 'overfit.' The little 0 Data -Target Fit noise in the data has misled the learning, x for if there were no noise, the fitted red curve would exactly match the target. This is a typical overfitting scenario, in which a complex model uses its additional degrees of freedom to 'learn' the noise. The fit has zero in-sample error but huge out-of-sample error, so this is a case of bad generalization (as discussed in Chapter 2) a likely outcome when overfitting is occurring. However, our definition of overfitting goes beyond bad generalization for any given hypothesis. Instead, overfitting applies to a process: in this case, the process of picking a hypothesis with lower and lower Ein resulting in higher and higher Eout. 4.1.1 A Case Study: Overfitting with Polynomials Let's dig deeper to gain a better understanding of when overfitting occurs. We will illustrate the main concepts using data in one-dimension and polynomial regression, a special case of a linear model that uses the feature transform x f- (1, x, x2, · · · ). Consider the two regression problems below: 0 0 x 0 O Data -Target (a) 10th order target function x O Data -Target (b) 50th order target function In both problems, the target function is a polynomial and the data set V contains 15 data points. In (a), the target function is a 10th order polynomial 120 4. 0VERFITTIN G x 0 OData -2nd Order Fit 10th Order Fit (a) Noisy low order target 4.1. WHEN DOES 0VERFITTING OCCUR 7 x OData 2nd Order Fit 10th Order Fit (b) Noiseless high order target Figure 4.1: Fits using 2nd and 10th order polynomials to 15 data points. In (a), the data are noisy and the target is a 10th order polynomial. In (b) the data are noiseless and the the target is a 50th order polynomial. and the sampled data are noisy (the data do not lie on the target function curve). In (b), the target function is a 50th order polynomial and the data are noiseless. The best 2nd and 10th order fits are shown in Figure 4.1, and the in-sample and out-of-sample errors are given in the following table. 10th order noisy target 2nd Order 10th Order Ein 0.050 0.034 Eout 0.127 9.00 50th order noiseless target 2nd Order 10th Order 0.029 10- 0.120 7680 What the learning algorithm sees is the data, not the target function. In both cases, the 10th order polynomial heavily overfits the data, and results in a nonsensical final hypothesis which does not resemble the target function. The 2nd order fits do not capture the full nature of the target function either, but they do at least capture its general trend, resulting in significantly lower out-of­ sample error. The 10th order fits have lower in-sample error and higher out-of­ sample error, so this is indeed a case of overfitting that results in pathologically bad generalizat ion. Exercise 4.1 Let 1-fo and 1-l10 be the 2nd and 10th order hypothesis sets respectively. Specify these sets as parameterized sets of functions. Show that 1-l2 C 1-l10. These two examples reveal some surprising phenomena. Let's consider first the 10th order target function, Figure 4.l(a). Here is the scenario. Two learners, 0 (for overfitted) and R (for restricted), know that the target function is a 10th order polynomial, and that they will receive 15 noisy data points. Learner 0 121 4. 0VERFITTING 4.1. WHEN DOES 0VERFITTING OCCUR? H 0 H H µ;:i '\"O (].) -+.:> u (].) � µ;:i Learning curves for 1-l2 H 0 t: µ;:i '\"O (].) -+.:> u (].) Learning curves for 1-l 10 Number of Data Points, N Number of Data Points, N Figure 4.2: Overfitting is occurring for Nin the shaded gray region because by choosing 1-l10 which has better Ein, you get worse Eout· uses model 1-l10, which is known to contain the target function, and finds the best fitting hypothesis to the data. Learner R uses model 1-{2, and similarly finds the best fitting hypothesis to the data. The surprising thing is that learner R wins (lower out-of-sample error) by using the smaller model, even though she has knowingly given up the ability to implement the true target function. Learner R trades off a worse in-sample error for a huge gain in the generalization error, ultimately resulting in lower out-of-sample error. What is funny here? A folklore belief about learning is that best results are obtained by incorporating as much information about the target function as is available. But as we see here, even if we know the order of the target and naively incorporate this knowledge by choosing the model accordingly (1-l10), the performance is inferior to that demonstrated by the more 'stable' 2nd order model. The models 1-l2 and 1-l 10 were in fact the ones used to generate the learn­ ing curves in Chapter 2, and we use those same learning curves to illustrate overfitting in Figure 4.2. If you mentally superimpose the two plots, you can see that there is a range of N for which 1-l10 has lower Ein but higher Eout than 1-{2 does, a case in point of overfitting. Is learner R always going to prevail? Certainly not. For example, if the data was noiseless, then indeed learner 0 would recover the target function exactly from 15 data points, while learner R would have no hope. This brings us to the second example, Figure 4.l(b). Here, the data is noiseless, but the target function is very complex (50th order polynomia l). Again learner R wins, and again because learner 0 heavily overfits the data. Overfitting is not a disease inflicted only upon complex models with many more degrees of freedom than warranted by the complexity of the target function. In fact the reverse is true here, and overfitting is just as bad. What matters is how the model complexity matches the quantity and quality of the data we have, not how it matches the target function. 122 4. 0VERFITTING 4.1. WHEN DoEs OvERFITTING OccuR? 4.1.2 Catalysts for Overfitting A skeptical reader should ask whether the examples in Figure 4.1 are just pathological constructions created by the authors, or is overfitting a real phe­ nomenon which has to be considered carefully when learning from data? The next exercise guides you through an experimental design for studying overfit­ ting within our current setup. We will use the results from this experiment to serve two purposes: to convince you that overfitting is not the result of some rare pathological construction, and to unravel some of the conditions conducive to overfitting. Exercise 4.2 [Experim ental design for studying overfitting] This is a reading exercise that sets up an experimental framework to study various aspects of overfitt ing. The reader interested in implementing the experiment can find the details fleshed out in Problem 4.4. The input space is X = [-1, 1]. with uniform input probability density, P(x) = �· We consider the two models H2 and H10. The target is a degree-Qi polynomial, which we write f(x) ��!,_0 aqLq(x), where Li(x) are polynomials of increasing complexity (the Legendre polynomials). The data set is D = (x1, y1), ... , (xN, YN ), where Yn = f(xn) + <YEn and En are iid (independent and identically distributed) standard Normal random variates. For a single experiment, with specified values for Q1, N, a-, generate a ran­ dom degree-Qi target function by selecting coefficients ai independently from a standard Normal, rescaling them so that lEa,x [f2] = Gen­ erate a data set, selecting x1, ... , XN independently according to P(x) and Yn = f(xn) + <YEn. Let g2 and g10 be the best fit hypotheses to the data from 1{2 and H10 respectively, with out-of-sample errors Eout(g2) and Bout (gw). Vary Q1, N, a-, and for each combination of parameters, run a large number of experiments, each time computing Eout(g2) and Eout(g10). Averaging these out-of-sample errors gives estimates of the expected out-of-sample error for the given learning scenario (QI, N, a-) using H2 and 1-lw. Exercise 4.2 set up an experiment to study how the noise level cr2, the target complexity Q f, and the number of data points N relate to overfitting. We compare the final hypothesis 910 E 1{10 (larger model) to the final hypothesis 92 E 1-l2 (smaller model). Clearly, Ein (910) :: Ein (92) since 910 has more degrees of freedom to fit the data. What is surprising is how often 910 overfits the data, resulting in Eout(910) > Eout(92). Let us define the overfit measure as Eout(910) Eout(92). The more positive this measure is, the more severe overfitting would be. Figure 4.3 shows how the extent of overfitting depends on certain parame­ ters of the learning problem (the results are from our implementation of Exer­ cise 4.2). In the figure, the colors map to the level of overfitting, with redder 123 4. 0VERFITTING IN 2 b t .. Q) 1 rn ·s z 80 100 120 Number of Data Points, N (a) Stochastic noise 4.1. WHEN DOES 0VERFITTING OCCUR? �00 0 _e; 75 ·;; � 0. s 50 0 0 \"t) 25 � � 80 100 120 Number of Data Points, N (b) Deterministic noise Figure 4.3: How overfitting depends on the noise CT2, the target function complexity QJ, and the number of data points N. The colors map to the overfit measure Eout(1-l10)-Eout(1-fo). In (a) we see how overfitting depends on CT2 and N, with QJ = 20. As CT2 increases we are adding stochastic noise to the data. In (b) we see how overfitting depends on Qf and N, with CT2 = 0.1. As Q f increases we are adding deterministic noise to the data. regions showing worse overfi tting. These red regions are large overfitting is real, and here to stay. Figure 4.3( a) reveals that there is less overfitting when the noise level <52 drops or when the number of data points N increases (the linear pattern in Figure 4.3(a) is typical). Since the 'signal' f is normalized to IE[j2] = 1, the noise level <52 is automatically calibrated to the signal level. Noise leads the learning astray, and the larger, more complex model is more susceptible to noise than the simpler one because it has more ways to go astray. Figure 4.3(b) reveals that target function complexity Q f affects overfitting in a similar way to noise, albeit nonlinea rly. To summarize, Deterministic noise. Why does a higher target complexity lead to more overfitting when comparing the same two models? The intuition is that for a given learning model, there is a best approximation to the target function. The part of the target function 'outside' this best fit acts like noise in the data. We can call this deterministic noise to differentiate it from the random stochastic noise. Just as stochastic noise cannot be modeled, the deterministic noise is that part of the target function which cannot be modeled. The learning algorithm should not attempt to fit the noise; however, it cannot distinguish noise from signal. On a finite data set, the algorithm inadvertently uses some 124 4. 0VERFITTING 4.1. WHEN DOES 0VERFITTING OCCUR? x Figure 4.4: Deterministic noise. h* is the best fit to f in 1-l2. The shading illustrates deterministic noise for this learning problem. of the degrees of freedom to fit the noise, which can result in overfitting and a spurious final hypothesis. Figure 4.4 illustrates deterministic noise for a quadratic model fitting a more complex target function. While stochastic and deterministic noise have similar effects on overfitting, there are two basic differences between the two types of noise. First, if we generated the same data (x values) again, the deterministic noise would not change but the stochastic noise would. Second, different models capture different 'parts' of the target function, hence the same data set will have different deterministic noise depending on which model we use. In reality, we work with one model at a time and have only one data set on hand. Hence, we have one realization of the noise to work with and the algorithm cannot differentiate between the two types of noise. Exercise 4.3 Deterministic noise depends on 1-l, as some models approximate f better than others. (a) Assume 1-l is fixed and we increase the complexity off. Will deter­ ministic noise in general go up or down? Is there a higher or lower tendency to overfit? (b) Assume f is fixed and we decrease the complexity of 1-l. Will deter­ ministic noise in general go up or down? Is there a higher or lower tendency to overfit? [Hint: There is a race between two factors that affect overfitting in opposite ways, but one wins.} The bias-variance decomposition, which we discussed in Section 2.3.1 (see also Problem 2.22) is a useful tool for understanding how noise affects performance: 1Ev[Eout] = a-2 +bias+ var. The first two terms reflect the direct impact of the stochastic and determin­ istic noise. The variance of the stochastic noise is a-2 and the bias is directly 125 4. 0VERFITTING 4.2. REGULARIZATION related to the deterministic noise in that it captures the model's inability to approximate f. The var term is indirectly impacted by both types of noise, capturing a n1.odel's susceptibility to being led astray by the noise. 4.2 Regula rization Regularization is our first weapon to combat overfitting. It constrains the learning algorithm to improve out-of-sample error, especially when noise is present. To whet your appetite, look at what a little regularization can do for our first overfitting example in Section 4.1. Though we only used a very small 'amount' of regularization, the fit improves dramatically. x O Data -Target Fit without regularization x with regularization Now that we have your attention, we would like to come clean. Regularization is as much an art as it is a science. J\\/Iost of the methods used successfully in practice are heuristic methods. However, these methods are grounded in a mathematical framework that is developed for special cases. We will discuss both the mathematical and the heuristic, trying to maintain a balance that reflects the reality of the field. Speaking of heuristics, one view of regularization is through the lens of the VC bound, which bounds Eout using a model complexity penalty 0(1-l): for all h E 1-l. ( 4.1) So, we are better off if we fit the data using a simple 1-l. Extrapolating one step further, we should be better off by fitting the data using a 'simple' h from 1-l. The essence of regularization is to concoct a measure O(h) for the complexity of an individual hypothesis. Instead of minimizing Ein ( h) alone, one minimizes a combination of Ein(h) and O(h). This avoids overfitting by constraining the learning algorithm to fit the data well using a simple hypothesis. Example 4.1. One popular regularization technique is weight decay, which measures the complexity of a hypothesis h by the size of the coefficients used to represent h (e.g. in a linear model). This heuristic prefers mild lines with 126 4. 0VERFITTING 4.2. REGULARIZATION small offset and slope, to wild lines with bigger offset and slope. We will get to the mechanics of weight decay shortly, but for now let's focus on the outcome. We apply weight decay to fitting the target f ( x) = sin( ?TX) using N = 2 data points (as in Example 2.8). Vve sample x uniformly in [1, 1], generate a data set and fit a line to the data (our model is H 1). The figures below show the resulting fits on the same (random) data sets with and without regularization. x x without regularization with regularization Without regularization, the learned function varies extensively depending on the data set. As we have seen in Example 2.8, a constant model scored Eout = 0.75, handily beating the performance of the (unregulariz ed) linear model that scored Eout = 1.90. With a little weight decay regulariza tion, the fits to the same data sets are considerably less volatile. This results in a significantly lower Eout = 0.56 that beats both the constant model and the unregularized linear model. The bias-variance decomposition helps us to understand how the regular­ ized version beat both the unregularized version as well as the constant model. x without regularization bias= 0.21; var = 1.69. x with regularization bias= 0.23; var= 0.33. Average hypothesis g (red) with var(x) indicated by the gray shaded region that is g(x) ± As expected, regularization reduced the var term rather dramatically from 1.69 down to 0.33. The price paid in terms of the bias (quality of the average fit) was 127 4. 0VERFITTING 4.2. REGULARIZA TION modest, only slightly increasing from 0.21 to 0.23. The result was a significant decrease in the expected out-of-sample error because bias+var decreased. This is the crux of regularization. By constraining the learning algorithm to select 'simpler' hypotheses from 1-l, we sacrifice a little bias for a significant gain in the var. D This example also illustrates why regularization is needed. The linear model is too sophisticated for the amount of data we have, since a line can perfectly fit any 2 points. This need would persist even if we changed the target function, as long as we have either stochastic or deterministic noise. The need for regularization depends on the quantity and quality of the data. Given our meager data set, our choices were either to take a simpler model, such as the model with constant functions, or to constrain the linear model. It turns out that using the complex model but constraining the algorithm toward simpler hypotheses gives us more flexibility, and ends up giving the best Eout. In practice, this is the rule not the exception. Enough heuristics. Let's develop the mathematics of regularization. 4.2.1 A Soft Order Constraint In this section, we derive a regularization method that applies to a wide va­ riety of learning problems. To simplify the math, we will use the concrete setting of regression using Legendre polynomials, the polynomials of increas­ ing complexity used in Exercise 4.2. So, let's first formally introduce you to the Legendre polynomials. Consider a learning model where 1-l is the set of polynomials in one vari­ able x E [1, 1). Instead of expressing the polynomials in terms of consecutive powers of x, we will express them as a combination of Legendre polynomials in x. Legendre polynomials are a standard set of polynomials with nice ana­ lytic properties that result in simpler derivations. The zeroth-order Legendre polynomial is the constant Lo ( x) = 1, and the first few Legendre polynomials are illustrated below. L2 L3 L4 Ls �(3x2 1) H5x3 3x) �(35x4 30x2 + 3) �(63x5 .. ·) As you can see, when the order of the Legendre polynomial increases, the curve gets more complex. Legendre polynomials are orthogonal to each other within x E [1, 1], and any regular polynomial can be written as a linear combination of Legendre polynomials, just like it can be written as a linear combination of powers of x. 128 4. 0VERFITTIN G 4.2. REGULARIZATION Polynomial models are a special case of linear models in a space Z, under a nonlinear transformation <I? : X -+ Z. Here, for the Qth order polynomial model, <I? transforms x into a vector z of Legendre polynomials, z [L1�x)] · LQ(x) Our hypothesis set HQ is a linear combination of these polynomials, where Lo ( x) 1. As usual, we will sometimes refer to the hypothesis h by its weight vector w.2 Since each h is linear in w, we can use the machinery of linear regression from Chapter 3 to minimize the squared error N Ein(w) � I)wTZn yn)2• n=l (4.2) The case of polynomial regression with squared-error measure illustrates the main ideas of regularization well, and facilitates a solid mathematical deriva­ tion. Nonetheless, our discussion will generalize in practice to non-linear , multi-dimensional settings with more general error measures. The baseline al­ gorithm (without regularization) is to minimize Ein over the hypotheses in HQ to produce the final hypothesis g(x) w�nz, where WHn argminEin(w). w Exercise 4.4 Let Z [z1 ZNr be the data matrix (assume Z has full column rank); let Wiin (ZTz)-1Vy; and let H Z(ZTz)-1ZT (the hat matrix of Exercise 3.3). Show that E. ( ) _ (w WlinfVZ(w Wlin) yT(lH)y mW -N , where I is the identity matrix. (a) What value of w minimizes Ein? (b) What is the minimum insample error? (4.3) The task of regularization, which results in a final hypothesis w reg instead of the simple WHn, is to constrain the learning so as to prevent overfitting the 2We used w and d for the weight vector and dimension in Z. Since we are explicitly dealing with polynomials and Z is the only space around, we use w and Q for simplicity. 129 4. 0VERFITTING 4.2. REGULARIZATION data. We have already seen an example of constraining the learning; the set 1-l2 can be thought of as a constrained version of 1-l 10 in the sense that some of the 1-l10 weights are required to be zero. That is, 1-l2 is a subset of 1-l10 defined by 1-l2 { w I w E 1-l10; Wq 0 for q � 3}. Requiring some weights to be 0 is a hard constraint. We have seen that such a hard constraint on the order can help, for example 1-l2 is better than 1-l10 when there is a lot of noise and N is small. Instead of requiring some weights to be zero, we can force the weights to be small but not necessarily zero through a softer constraint such as This is a 'soft order' constraint because it only encourages each weight to be small, without changing the order of the polynomial by explicitly setting some weights to zero. The in-sample optimization problem becomes: minEin(w) subject to wTw � C. w (4.4) The data determines the optimal weight sizes, given the total budget C which determines the amount of regularization; the larger C is, the weaker the con­ straint and the smaller the amount of regularization. We can define the soft­ order-constrained hypothesis set 1-l( C) by Equation (4.4) is equivalent to minimizing Ein over 1-l(C). If C1 < 02, then 1-l(C1) C 1-l(C2) and so dvc(1-l(C1)) � dvc(1-l(C2)), and we expect better generalization with 1-l( C1). Let the regularized weights Wreg be the solution to (4.4). Solving for Wreg• If wiin Wlin � c then Wreg Wlin because Wlin E 1-l ( C). If W1in tj_ 1-l ( C), then not only is wieg Wreg � C, but in fact wieg Wreg C (wreg uses the entire budget C; see Problem 4.10). We thus need to minimize Ein subject to the equality constraint wTw C. The situation is illustrated to the right. The weights w must lie on the surface of the sphere , the normal vector to this surface at w is the vector w itself (also in red). A surface of constant Ein is shown in blue; this surface is a quadratic surface (see Exercise 4.4) and the normal to this surface is . In this case, w cannot be optimal because \\7 Ein ( w) is not parallel to the red normal vector. This means that \\1 Ein ( w) has some non­ zero component along the constraint surface, and by moving a small amount in the opposite direction of this component we can improve Ein, while still 130 4. OvERFITTING 4.2. REGULARIZA TION remaining on the surface. If Wreg is to be optimal, then for some positive parameter Ac i.e., \\7 Ein must be parallel to Wreg, the normal vector to the constraint surface (the scaling by 2 is for mathematical convenience and the negative sign is because \\7 Ein and w are in opposite directions ). Equivalently, Wreg satisfies because V(wTw) 2w. So, for some Ac > 0, Wreg locally minimizes (4.5) The parameter Ac and the vector Wreg (both of which depend on C and the data) must be chosen so as to simultaneously satisfy the gradient equality and the weight norm constraint w;egWreg C.3 That Ac > 0 is intuitive since we are enforcing smaller weights, and minimizing Ein(w) + AcwTw would not lead to smaller weights if Ac were negative. Note that if wlin W1in :: C, Wreg WHn and minin1izing ( 4.5) still holds with Ac 0. Therefore, we have an equivalence between solving the constrained problem ( 4.4) and the unconstrained minimization of ( 4.5). This equivalence means that minimiz­ ing ( 4.5) is similar to minimizing Ein using a smaller hypothesis set, which in turn means that we can expect better generalization by minimizing ( 4.5) than by just minimizing Ein. Other variations of the constraint in ( 4.4) can be used to emphasize some weights over the others. Consider the constraint ��=O /qW� :: C. The im­ portance /q given to weight Wq determines the type of regulariza tion. For example, /q q or /q eq encourages a low-order fit, and /q (1 + q)-1 or /q e-q encourages a high-order fit. In extreme cases, one recovers hard-order constraints by choosing some / q 0 and some / q -+ oo. Exercise 4.5 [Tikhonov regularizer] A more general soft constraint is the Tikhonov regularization constraint which can capture relationships among the Wi (the matrix r is the Tikhonov regularizer). (a) What should r be to obtain the constraint I:�=o w� :: C? (b) What should r be to obtain the constraint (2.:�=0 Wq )2 :: C? 3 >.c is known as a Lagrange multiplier and an alternate derivation of these same results can be obtained via the theory of Lagrange multipliers for constrained optimization. 131 4. 0VERFITTING 4.2. REGULARIZATION 4.2.2 Weight Decay and Augmented Error The soft-order constraint for a given value of C is a constrained minimiza­ tion of Ein· Equation (4.5) suggests that we may equivalently solve an un­ constrained minimization of a different function. Let's define the augmented error, (4.6) where,\\ 2:'.: 0 is now a free parameter at our disposal. The augmented error has two terms. The first is the in-sample error which we are used to minimizing, and the second is a penalty term. Notice that this fits the heuristic view of regularization that we discussed earlier, where the penalty for complexity is defined for each individual h instead of 1-l as a whole. When ,\\ 0, we have the usual in-sample error. For,\\> 0, minimizing the augmented error corresponds to minimizing a penalized in-sample error. The value of,\\ controls the amount of regularization. The penalty term wTw enforces a tradeoff between making the in-sample error small and making the weights small, and has become known as weight decay. As discussed in Problem 4.8, if we minimize the augmented error using an iterative method like gradient descent, we will have a reduction of the in-sample error together with a gradual shrinking of the weights, hence the name weight 'decay.' In the statistics community, this type of penalty term is a form of ridge regression. There is an equivalence between the soft order constraint and augmented error minimization. In the soft-order constraint , the amount of regularization is controlled by the parameter C. From (4.5), there is a particular .Ac (depend­ ing on C and the data 'D), for which minimizing the augmented error Eaug(w) leads to the same final hypothesis w reg. A larger C allows larger weights and is a weaker soft-order constraint ; this corresponds to smaller ..\\, i.e., less em­ phasis on the penalty term wTw in the augmented error. For a particular data set, the optimal value C* leading to minimum out-of-sample error with the soft-order constraint corresponds to an optimal value ,\\ * in the augmented error minimization. If we can find ,\\ *, we can get the minimum Eout. Have we gained from the augmented error view? Yes, because augmented error minimization is unconstrai ned, which is generally easier than constrained minimization. For example, we can obtain a closed form solution for linear models or use a method like stochastic gradient descent to carry out the mini­ mization. However, augmented error minimization is not so easy to interpret. There are no values for the weights which are explicitly forbidden, as there are in the soft-order constraint . For a given C, the soft-order constraint cor­ responds to selecting a hypothesis from the smaller set 1-l ( C), and so from our VC analysis we should expect better generalization when C decreases (..\\ increases). It is through the relationship between ,\\ and C that one has a theoretical justification of weight decay as a method for regularization. We focused on the soft-order constraint wTw :: C with corresponding augmented error Eaug(w) Ein(w) + .AwTw. However, our discussion applies more generally. There is a duality between the minimization of the in-sample 132 4. OvERFITTIN G 4.2. REGULARIZATION error over a constrained hypothesis set and the unconstrained minimization of an augmented error. We may choose to live in either world, but more often than not, the unconstrained minimization of the augmented error is more convenient . In our definition of Eaug(w) in Equation (4.6), we only highlighted the dependence on w. There are two other quantities under our control, namely the amount of regularization, .\\, and the nature of the regularizer which we chose to be wTw. In general, the augmented error for a hypothesis h E 1-l is (4.7) For weight decay, D(h) wTw, which penalizes large weights. The penalty term has two components: the regularizer fJ(h) (the type of regularization) which penalizes a particular property of h; and the regularization parameter ,\\ (the amount of regularization ). The need for regularization goes down as the number of data points goes up, so we factored out -ft; this allows the optimal choice for ,\\ to be less sensitive to N. This is just a redefinition of the ,\\ that we have been using, in order to make it a more stable parameter that is easier to interpret. Notice how Equation ( 4. 7) resembles the VC bound ( 4.1) as we anticipated in the heuristic view of regularization. This is why we use the same notation n for both the penalty on individual hypotheses D(h) and the penalty on the whole set 0(1-l). The correspondence between the complexity of 1-l and the complexity of an individual h will be discussed further in Section 5.1. The regularizer fJ is typically fixed ahead of time, before seeing the data; sometimes the problem itself can dictate an appropriate regularizer. Exercise 4.6 We have seen both the hard-order constraint and the soft-order constraint. Which do you expect to be more useful for binary classification using the perceptron model? [Hint: sign(wTx) sign(awTx) for any a> O.} The optimal regularization parameter, however, typically depends on the data. The choice of the optimal ,\\is one of the applications of validation, which we will discuss shortly. Example 4.2. Linear models with weight decay. Linear models are important enough that it is worthwhile to spell out the details of augmented error minimization in this case. From Exercise 4.4, the augmented error is where Z is the transformed data matrix and WHn (ZTz)-1ZTy. The reader may verify, after taking the derivatives of Eaug and setting \\7 wEaug 0, that 133 4. 0VERFITTING 4.2. REGULARIZATION As expected, Wreg will go to zero as ,\\--- oo, due to the ,\\I term. The predic­ tions on the in-sample data are given by y Zwreg H(,\\)y, where The matrix H(,\\) plays an important role in defining the effective complexity of a model. When ,\\ 0, H is the hat matrix of Exercises 3.3 and 4.4, which satisfies H2 H and trace(H) d + 1. The vector of in-sample errors, which are also called residuals, is y -y (I H(,\\))y, and the in-sample error Ein is Ein(Wreg) = :hYT(I H(,\\))2y. D We can now apply weight decay regularization to the first overfitting example that opened this chapter. The results for different A's are shown in Figure 4.5. ,\\ 0.0001 ,\\ 0.01 .?: x .?: Figure 4.5: Weight decay applied to Example 4.2 with different values for the regularization parameter ..\\. The red fit gets flatter as we increase ..\\. As you can see, even very little regularization goes a long way, but too much regularization results in an overly flat curve at the expense of in-sample fit. Another case we saw earlier is Example 4.1, where we fit a linear model to a sinusoid. The regularization used there was also weight decay, with ,\\ 0.1. 4.2.3 Choosing a Regularizer : Pill or Poison? We have presented a number of ways to constrain a model: hard-order con­ straints where we simply use a lower-order model, soft-order constraints where we constrain the parameters of the model, and augmented error where we add a penalty term to an otherwise unconstrained minimization of error. Aug­ mented error is the most popular form of regularization, for which we need to choose the regularizer fl(h) and the regularization parameter ,\\. In practice, the choice of D, is largely heuristic. Finding a perfect fl is as difficult as finding a perfect 1-l. It depends on information that, by the very nature of learning, we don't have. However, there are regularizers we can work with that have stood the test of time, such as weight decay. Some forms of regularization work and some do not, depending on the specific application and the data. Figure 4.5 illustrated that even the amount of regularization 134 4. 0VERFITTING 0.84 0.5 1 1.5 2 Regularization Parameter, ,\\ (a) Uniform regularizer 4.2. REGULARIZATION 0.84 ;; kf 'rj 0.8 <!.) tl <!.) � i:Ll0.76 0.5 1 1.5 2 Regularization Parameter, ,\\ (b) Low order regularizer Figure 4.6: Outof sample performance for the uniform and low order reg ularizers using model H15, with o-2 = 0.5, Q1 = 15 and N = 30. Overfitting occurs in the shaded region because lower Ein (lower A) leads to higher Eout. Underfitting occurs when A is too large, because the learning algorithm has too little flexibility to fit the data. has to be chosen carefully. Too much regularization (too harsh a constraint) leaves the learning too little flexibility to fit the data and leads to under.fitting, which can be just as bad as overfitting. If so many choices can go wrong, why do we bother with regularization in the first place? Regularization is a necessary evil, with the operative word being necessary. If our model is too sophisticated for the amount of data we have, we are doomed. By applying regulariza tion, we have a chance. By applying the proper regularization, we are in good shape. Let us experiment with two choices of a regularizer for the model H15 of 15th order polynomials, using the experimental design in Exercise 4.2: 1. A uniform regularizer: f2unif( w) L:�:o w�. 2. A low-order regularizer: f210w(w) = L:�:o qw�. The first encourages all weights to be small, uniformly; the second pays more attention to the higher order weights, encouraging a lower order fit. Figure 4.6 shows the performance for different values of the regularization parameter .:\\. As you decrease .:\\, the optimization pays less attention to the penalty term and more to Ein, and so Ein will decrease (Problem 4.7). In the shaded region, Eout increases as you decrease Ein (decrease ,:\\) the regularization parameter is too small and there is not enough of a constraint on the learning, leading to decreased performance because of overfitting. In the unshaded region, the regularization parameter is too large, over-constraining the learning and not giving it enough flexibility to fit the data, leading to decreased performance because of underfitting. As can be observed from the figure, the price paid for overfitting is generally more severe than underfitting. It usually pays to be conservative. 135 4. 0VERFITTING 0.5 1 1.5 2 Regularization Parameter, ,\\ (a) Stochastic noise 4.2. REGULARIZATION 0.5 1 1.5 2 Regularization Parameter, ,\\ (b) Deterministic noise Figure 4. 7: Performance of the uniform regularizer at different levels of noise. The optimal >. is highlighted for each curve. The optimal regularization parameter for the two cases is quite different and the performance can be quite sensitive to the choice of regularization parameter. However, the promising message from the figure is that though the behaviors are quite different, the performances of the two regularizers are comparable (around 0. 76), if we choose the right ,,\\ for each. We can also use this experiment to study how performance with regular­ ization depends on the noise. In Figure 4.7(a), when a2 = 0, no amount of regularization helps (i.e., the optimal regularization parameter is ,,\\ 0), which is not a surprise because there is no stochastic or deterministic noise in the data (both target and model are 15th order polynomia ls). As we add more stochastic noise, the overall performance degrades as expected. Note that the optimal value for the regularization parameter increases with noise, which is also expected based on the earlier discussion that the potential to overfit in­ creases as the noise increases; hence, constraining the learning more should help. Figure 4. 7(b) shows what happens when we add deterministic noise, keeping the stochastic noise at zero. This is accomplished by increasing Q f (the target complexity), thereby adding deterministic noise, but keeping ev­ erything else the same. Comparing parts (a) and (b) of Figures 4.7 provides another demonstration of how the effects of deterministic and stochastic noise are similar. When either is present, it is helpful to regularize, and the more noise there is, the larger the amount of regularization you need. What happens if you pick the wrong regularizer? To illustrate, we picked a regularizer which encourages large weights (weight growth) versus weight decay which encourages small weights. As you can see, in this case, weight growth does not help the cause of overfitting. If we happened to choose weight growth as our regularizer, we would still be OK as long as we have 136 rij Q) t) <J.) decay Regularization Parameter, ,\\ 4. 0VERFITTING 4.3. VALIDATION a good way to pick the regularization parameter the optimal regularization parameter in this case is,\\= 0, and we are no worse off than not regularizing. No regularizer will be ideal for all settings, or even for a specific setting since we never have perfect information, but they all tend to work with varying success, if the amount of regularization ,\\ is set to the correct level. Thus, the entire burden rests on picking the right ,\\, a task that can be addressed by a technique called validation, which is the topic of the next section. The lesson learned is that some form of regularization is necessary, as learn­ ing is quite sensitive to stochastic and deterministic noise. The best way to constrain the learning is in the 'direction' of the target function, and more of a constraint is needed when there is more noise. Even though we don't know either the target function or the noise, regularization helps by reducing the impact of the noise. Most common models have hypothesis sets which are naturally parameterized so that smaller parameters lead to smoother hypothe­ ses. Thus, a weight decay type of regularizer constrains the learning towards smoother hypotheses. This helps, because stochastic noise is 'high frequency' (non-smooth). Similarly, deterministic noise (the part of the target function which cannot be modeled) also tends to be non-smooth. Thus, constraining the learning towards smoother hypotheses 'hurts' our ability to overfit the noise more than it hurts our ability to fit the useful information. These are empirical observations, not theoretica lly justifiable statements. Regularizat ion and the VC dimension. Regularization (for example soft-order selection by minimizing the augmented error) poses a problem for the VC line of reasoning. As ,\\ goes up, the learning algorithm changes but the hypothesis set does not, so dvc will not change. We argued that ,\\ t in the augmented error corresponds to C .J, in the soft-order constrained model. So, more regularization corresponds to an effectively smaller model, and we expect better generalization for a small increase in Ein even though the VC dimension of the model we are actually using with augmented error does not change. This suggests a heuristic that works well in practice, which is to use an 'effective VC dimension' instead of the VC dimension. For linear perceptrons, the VC dimension equals the number of free parameters d + 1, and so an effec­ tive number of parameters is a good surrogate for the VC dimension in the VC bound. The effective number of parameters will go down as ,\\ increases, and so the effective VC dimension will reflect better generalization with increased regularization. Problems 4.13, 4.14, and 4.15 explore the notion of an effective number of parameters. 4.3 Validation So far, we have identified overfitting as a problem, noise (stochastic and deter­ ministic) as a cause, and regularization as a cure. In this section, we introduce another cure, called validation. One can think of both regularization and val- 137 4. 0VERFITTIN G 4.3. VALIDATION idation as attempts at minimizing Eout rather than just Ein . Of course the true Eout is not available to us, so we need an estimate of Eout based on in­ formation available to us in sample. In some sense, this is the Holy Grail of machine learning: to find an in-sample estimate of the out-of-sample error. Regularization attempts to minimize Eout by working through the equation Eout(h) Ein(h) + overfit penalty, � and concocting a heuristic term that emulates the penalty term. Validation, on the other hand, cuts to the chase and estimates the out-of-sample error directly. Eout(h) Ein(h) + overfit penalty. '- Estimating the out-of-sample error directly is nothing new to us. In Sec­ tion 2.2.3, we introduced the idea of a test set, a subset of V that is not involved in the learning process and is used to evaluate the final hypothesis. The test error Etest, unlike the in-sample error Ein, is an unbiased estimate of Eout· 4.3.1 The Validation Set The idea of a validation set is almost identical to that of a test set. V\\Te remove a subset from the data; this subset is not used in training. We then use this held-out subset to estimate the out-of-sample error. The held-out set is effectively out-of-sample, because it has not been used during the learning. However, there is a difference between a validation set and a test set. Although the validation set will not be directly used for training, it will be used in making certain choices in the learning process. The minute a set affects the learning process in any way, it is no longer a test set. However, as we will see, the way the validation set is used in the learning process is so benign that its estimate of Eout remains almost intact. Let us first look at how the validation set is created. The first step is to partition the data set V into a training set Dtrain of size (N -K) and a validation set Dval of size K. Any partitioning method which does not depend on the values of the data points will do; for exan1ple, we can select N -K points at random for training and the remaining for validation. Now, we run the learning algorithm using the training set Dtrain to obtain a final hypothesis gE 1-l, where the 'minus' superscript indicates that some data points were taken out of the training. We then compute the validation error for gusing the validation set Dval: 138 4. 0VERFITTIN G 4.3. VALIDATION where e (g(x), y) is the pointwise error measure which we introduced in Sec­ tion 1.4.1. For classification, e(g(x), y) [g(x) -/=-y] and for regression using squared error, e(g(x),y) (g(x) y)2. The validation error is an unbiased estimate of Eout because the final hy­ pothesis gwas created indep endently of the data points in the validation set. Indeed, taking the expectation of Eval with respect to the data points in 'Dval, 1 K 1 K XnEVval XnEVval (4.8) The first step uses the linearity of expectation, and the second step follows because e (g( Xn), Yn) depends only on Xn and so lEvval [e (g(xn), Yn)] lExn [e (g(xn), Yn)] Eout(g). How reliable is Eval at estimating Eout? In the case of classification, one can use the VC bound to predict how good the validation error is as an estimate for the out-of-sarn.ple error. We can view 'Dval as an 'in-sample ' data set on which we computed the error of the single hypothesis g. We can thus apply the VC bound for a finite model with one hypothesis in it (the Hoeffding bound ). With high probability, Eout (g) :=:; Eval (g) + 0 ( . ( 4.9) While Inequality ( 4.9) applies to binary target functions, we may use the variance of Eval as a more generally applicable measure of the reliability. The next exercise studies how the variance of Eval depends on K (the size of the validation set), and implies that a similar bound holds for regression. The conclusion is that the error between Eva1(g) and Eout(g ) drops as CJ(g)/VK, where O\"(g ) is bounded by a constant in the case of classification. Exercise 4. 7 Fix g(learned from 'Dtrain) and define o-;al �,fVarvvai[Eva1(g-)]. We con­ sider how o-;al depends on K. Let be the pointwise variance in the out-of-sample error of g . (a) Show that o-;al f<o2(g). (b) In a classification problem, where e(g(x), y) [g(x) =J y], express o-;al in terms of JP>[g-(x) =J y]. (c) Show that for any g-in a classification problem, o-;al s; (continued on next page) 139 4. 0VERFITTIN G 4.3. VALIDATION (d) Is there a uniform upper bound for Var[Eva1(g)] similar to (c) in the case of regression with squared error e(g(x), y) (g(x) -y)2? {Hint: The squared error is unbounded.] ( e) For regression with squared error, if we train using fewer points (smaller N K) to get g , do you expect a2(g-) to be higher or lower? {Hint: For continuous, non-negative random variables, higher mean often implies higher variance.] (f) Conclude that increasing the size of the validation set can result in a better or a worse estimate of Eout· The expected validation error for 1-l2 is illustrated in Figure 4.8, where we used the experimental design in Exercise 4.2, with Qf = 10, N 40 and noise level 0.4. The expected validation error equals Eout(g), per Equation (4.8). 10 20 30 Size of Validation Set, K Figure 4.8: The expected validation error lE[Eva1(g-)] as a function of K; the shaded area is lE[Eval] ± aval· The figure clearly shows that there is a price to be paid for setting aside K data points to get this unbiased estimate of Eout: when we set aside more data for validation, there are fewer training data points and so gbecomes worse; Eout(g), and hence the expected validation error, increases (the blue curve). As we expect, the uncertainty in Eval as measured by aval (size of the shaded region) is decreasing with K, up to the point where the variance a2(g) gets really bad. This point comes when the number of training data points becomes critically small, as in Exercise 4.7(e). If K is neither too small nor too large, Eval provides a good estimate of Eout. A rule of thumb in practice is to set K = � (set aside 203 of the data for validation). We have established two conflicting demands on K. It has to be big enough for Eval to be reliable, and it has to be small enough so that the training set with N -K points is big enough to get a decent g. Inequality ( 4. 9) quantifies the first demand. The second demand is quantified by the learning curve 140 4. 0VERFITTING 4.3. VALIDATION discussed in Section 2.3.2 (also the blue curve in Figure 4.8, from right to left), which shows how the expected out-of-sample error goes down as the number of training data points goes up . The fact that more training data lead to a better final hypothesis has been extensively verified empirically, although it is challenging to prove theoretica lly. Restoring V. Although the learning curve suggests that taking out K data points for validation and using only N -K for train­ ing will cost us in terms of Eout, we do not have to pay that price! The purpose of vali­ dation is to estimate the out-of-sample per­ formance, and Eval happens to be a good estimate of Eout (g). This does not mean that we have to output gas our final hy­ pothesis. The primary goal is to get the best possible hypothesis, so we should out­ put g, the hypothesis trained on the en­ tire set V. The secondary goal is to esti­ mate Eout, which is what validation allows us to do. Based on our discussion of learn­ ing curves, Eout (g) :: Eout (g), so g g- Eval(g) Figure 4.9: Using a valida tion set to estimate Eout. Eout(g) � Eout(g) :: Eval(g) + 0 · (4.10) The first inequality is subdued because it was not rigorously proved. If we first train with N -K data points, validate with the remaining K data points and then retrain using all the data to get g, the validation error we got will likely still be better at estimating Eout (g) than the estimate using the VG-bound with Ein (g), especially for large hypothesis sets with big dvc. So far, we have treated the validation set as a way to estimate Eout, without involving it in any decisions that affect the learning process. Estimating Eout is a useful role by itself a customer would typically want to know how good the final hypothesis is (in fact, the inequalities in ( 4.10) suggest that the validation error is a pessimistic estimate of Eout, so your customer is likely to be pleasantly surprised when he tries your system on new data). However, as we will see next, an important role of a validation set is in fact to guide the learning process. That's what distinguishes a validation set from a test set. 4.3.2 Model Selection By far, the most important use of validation is for model selection. This could mean the choice between a linear model and a nonlinear model, the choice of the order of polynomial in a model, the choice of the value of a regularization 141 4. 0VERFITTIN G H 0 H H � 'Cl 2 (.) <l � � 0.8 0.7 0.6 0.5 5 15 Validation Set Size, I< 4.3. VALIDATION 25 Figure 4.10: Optimistic bias of the validation error when using a validation set for the model selected. parameter, or any other choice that affects the learning process. In almost every learning situation, there are some choices to be made and we need a principled way of making these choices. The leap is to realize that validation can be used to estimate the out-of­ sample error for more than one model. Suppose we have]\\![ models 1-l1, ... , 1-lM. Validation can be used to select one of these models. Use the training set Dtrain to learn a final hypothesis g;, for each model. Now evaluate each model on the validation set to obtain the validation errors Ei, · · · , EM, where Em= Eva1(g�); m = 1, ... ,M. The validation errors estimate the out-of-sample error Eout (g;,) for each 1-lm. Exercise 4.8 Is Em an unbiased estimate for the outof sample error Eaut(g�)? It is now a simple matter to select the model with lowest validation error. Let m* be the index of the model which achieves the minimum validation error. So for 1-lm*, Em* :: Em form= 1, ... , J\\I[. The model 1-lm* is the model selected based on the validation errors. Note that Em* is no longer an unbiased estimate of Eout(g;,* ). Since we selected the model with minimum validation error, Em* will have an optimistic bias. This optimistic bias when selecting between 1-l2 and 1-l5 is illustrated in Figure 4.10, using the experimental design described in Exercise 4.2 with Q f = 3, o-2 = 0.4 and N = 35. Exercise 4.9 Referring to Figure 4.10, why are both curves increasing with K? Why do they converge to each other with increasing K? 142 4. 0VERFITTIN G 4.3. VALIDATION How good is the generalization error for this entire process of model selection using validation? Consider a new model Hval consisting of the final hypotheses learned from the training data using each model 1-{1, ... , HM: Hval {gi, g2, · · · 'g�}. Model selection using the validation set chose one of the hypotheses in Hval based on its performance on 'Dval. Since the model Hval was obtained before ever looking at the data in the validation set, this process is entirely equivalent to learning a hypothesis from Hval using the data in 'Dval. The validation errors Eval (g�) are 'in-sample' errors for this learning process and so we may apply the VC bound for finite hypothesis sets, with IHva1I M: Eout(g;,,) <:'. Eval(g;,,.) + 0 ( /¥). (4.11) What if we didn't use a validation set to choose the model? One alternative would be to use the in-sample errors from each model as the model selection criterion. Specifically, pick the model which gives a final hypothesis with min­ imum in-sample error. This is equivalent to picking the hypothesis with mini­ mum in-sample error from the grand model which contains all the hypotheses in each of the NI original models. If we want a bound on the out-of-sample error for the final hypothesis that results from this selection, we need to apply the VC-penalty for this grand hypothesis set which is the union of the !YI hypothesis sets (see Problem 2.14). Since this grand hypothesis set can have a huge VC-dimension, the bound in ( 4.11) will generally be tighter. The goal of model selection is to se­ lect the best model and output the best hypothesis from that model. Specifi­ cally, we want to select the model m for which Eout (gm) will be minimum when we retrain with all the data. Model se­ lection using a validation set relies on the leap of faith that if Eout(gm) is minimum, then Eout (g�) is also minimum. The val­ idation errors Em estimate Eout (g�), so modulo our leap of faith, the validation set should pick the right model. No mat­ ter which model m* is selected, however, based on the discussion of learning curves in the previous section, we should not out­ put g�* as the final hypothesis. Rather, · · 91 92 9N! Ei E2 ... EM i pick the best (1-l m*, Em*) 9m* Figure 4.11: Using a validation set for model selection once m* is selected using validation, learn using all the data and output gm*, which satisfies Eout (gm' ) $ Eout (g;, •) <:'. Eva! (g;,,,) + 0 ( /¥) . (4.12) Again, the first inequality is subdued because we didn't prove it. 143 4. 0VERFITTING 0.56 0.48 in sample: gm, validation: 9m* 5 15 25 Validation Set Size, K 4.3. VALIDATION Figure 4.12: Model selection between 1-l2 and 1-l5 using a validation set. The solid black line uses Ein for model selection, which always selects 1-l5• The dotted line shows the optimal model selection, if we could select the model based on the true out of sample error. This is unachievable, but a useful benchmark. The best performer is clearly the validation set, outputting 9m*. For suitable K, even g� * is better than in sample selection. Continuing our experiment from Figure 4.10, we evaluate the out-of-sample performance when using a validation set to select between the models 1-l2 and 1-l5. The results are shown in Figure 4.12. Validation is a clear winner over using Ein for model selection. Exercise 4.10 (a) From Figure 4.12, lE[Eout(9�* )] is initially decreasing. How can this be, ifIE.[Eout(g�)] is increasing in for each m? (b) From Figure 4.12 we see that IE.[Eout(9m* )] is initially decreasing, and then it starts to increase. What are the possible reasons for this? ( c) When K = 1, IE.[Eout(9�* )) < lE[Eout(9m* )). How can this be, if the learning curves for both models are decreasing? Example 4.3. We can use a validation set to select the value of the reg­ ularization parameter in the augmented error of (4.6). Although the most important part of a model is the hypothesis set, every hypothesis set has an associated learning algorithm which selects the final hypothesis g. Two mod­ els may be different only in their learning algorithm, while working with the same hypothesis set. Changing the value of,\\ in the augmented error changes the learning algorithm (the criterion by which g is selected) and effectively changes the model. Based on this discussion, consider the Ji.If different models corresponding to the same hypothesis set 1-l but with Ji.If different choices for ,\\ in the augmented error. So, we have (1-l, ,\\1), (1-l, A2), ... , (1-l, AM) as our Ji.If different models. We 144 4. 0VERFITTING 4.3. VALIDATION may, for example, choose .\\1 0, .\\2 0.01, A3 0.02, ... , AM 10. Using a validation set to choose one of these M models amounts to determining the value of A to within a resolution of 0.01. D We have analyzed validation for model selection based on a finite number of models. If validation is used to choose the value of a parameter, for example A as in the previous example, then the value of l'i1 will depend on the resolution to which we determine that parameter. In the limit, the selection is actually among an infinite number of models since the value of A can be any real number. What happens to bounds like (4.11) and (4.12) which depend on M? Just as the Hoeffding bound for a finite hypothesis set did not collapse when we moved to infinite hypothesis sets with finite VG-dimension, bounds like (4.11) and (4.12) will not completely collapse either. We can derive VC-type bounds here too, because even though there are an infinite number of models, these models are all very similar; they differ only slightly in the value of.\\. As a rule of thumb, what matters is the number of parameters we are trying to set. If we have only one or a few parameters, the estimates based on a decent­ sized validation set would be reliable. The more choices we make based on the same validation set, the more 'contamina ted' the validation set becomes and the less reliable its estimates will be. The more we use the validation set to fine tune the model, the more the validation set becomes like a training set used to 'learn the right model'; and we all know how limited a training set is in its ability to estimate Eout. You will be hard pressed to find a serious learning problem in which valida­ tion is not used. Validation is a conceptually simple technique, easy to apply in almost any setting, and requires no specific knowledge about the details of a model. The main drawback is the reduced size of the training set, but that can be significantly mitigated through a modified version of validation which we discuss next. 4.3.3 Cross Validation Validation relies on the following chain of reasoning, which highlights the dilemma we face in trying to select K. We are going to output g. When K is large, there is a discrepancy between the two out-of­ sample errors Eout(g ) (which Eval directly estimates) and Eout(g) (which is the final error when we learn using all the data 'D). We would like to choose K as small as possible in order to minimize the discrepancy between Eout (g ) and Eout(g); ideally K 1. However, if we make this choice, we lose the reliability of the validation estimate as the bound on the RHS of ( 4.9) becomes huge. The validation error Eval (g ) will still be an unbiased estimate of Eout (g ) 145 4. 0VERFITTING 4.3. VALIDATION (gis trained on N -1 points), but it will be so unreliable as to be useless since it is based on only one data point. This brings us to the cross validation estimate of out-of-sample error. We will focus on the leave-one-out version which corresponds to a validation set of size K 1, and is also the easiest case to illustrate. More popular versions typically use larger K, but the essence of the method is the same. There are N ways to partition the data into a training set of size N -1 and a validation set of size 1. Specifically, let be the data set V after leaving out data point (xn, Yn), which has been shaded in red. Denote the final hypothesis learned from Vn by g�. Let en be the error made by g� on its validation set which is just a single data point { (xn, Yn)}: The cross validation estimate is the average value of the en's, x x x Figure 4.13: Illustration of leave one out cross validation for a linear fit using three data points. The average of the three red errors obtained by the linear fits leaving out one data point at a time is Ecv· Figure 4.13 illustrates cross validation on a simple example. Each en is a wild, yet unbiased estimate for the corresponding Eout(g�), which follows after setting K 1 in (4.8). With cross validation, we have N functions g1, ... ,g]v together with the N error estimates e1, ... , eN. The hope is that these N errors together would be almost equivalent to estimating Eout on a reliable validation set of size N, while at the same time we managed to use N -1 points to obtain each g�. Let's try to understand why Ecv is a good estimator of Eout· 146 4. 0VERFITTING 4.3. VALIDATION First and foremost, Ecv is an unbiased estimator of 'Eout(g )'. We have to be a little careful here because we don't have a single hypothesis g , as we did when using a single validation set. Depending on the (xn, Yn) that was taken out, each g;, can be a different hypothesis. To understand the sense in which Ecv estimates Eout, we need to revisit the concept of the learning curve. Ideally, we would like to know Eout (g). The final hypothesis g is the result of learning on a random data set 'D of size N. It is almost as useful to know the expected performance of your model when you learn on a data set of size N; the hypothesis g is just one such instance of learning on a data set of size N. This expected performance averaged over data sets of size N, when viewed as a function of N, is exactly the learning curve shown in Figure 4.2. More formally, for a given model, let Bout ( N) 1Ev [ Eout (g)) be the expectation (over data sets 'D of size N) of the out-of-sample error produced by the model. The expected value of Ecv is exactly Eout(N -1). This is true because it is true for each individual validation error en: 1Evn 1E(xn,Yn) [e(g�(xn),yn)], 1Evn [Eout (g�)), Eout(N -1). Since this equality holds for each en, it also holds for the average. We highlight this result by making it a theorem. Theorem 4.4. Ecv is an unbiased estimate of Eout(N -1) (the expectation of the model performance, JE[EoutJ, over data sets of size N -1). Now that we have our cross validation estimate of Eout, there is no need to out­ put any of the g;, as our final hypothesis. We might as well squeeze every last drop of performance and retrain using the entire data set 'D, outputting g as the final hy­ pothesis and getting the benefit of going from N -1 to N on the learning curve. In this case, the cross validation estimate will on average be an upper estimate for the out-of-sample error: Eout (g) :S; Ecv' so expect to be pleasantly surprised, albeit slightly. With just simple validation and a val­ idation set of size K 1, we know that the validation estimate will not be reliable. g g]_ g?, (x1, yi)i (x2, Y2)i ei e2 Figure 4.14: Using cross vali dation to estimate Eout How reliable is the cross valida- tion estimate Ecv? We can measure the reliability using the variance of Ecv· 147 4. 0VERFITTING 4.3. VALIDATION Unfortunat ely, while we were able to pin down the expectation of Ecv, the variance is not so easy. If the N cross validation errors e1, ... , eN were equivalent to N errors on a totally separate validation set of size N, then Ecv would indeed be a reliable estimate, for decent-sized N. The equivalence would hold if the individual en's were independent of each other. Of course, this is too optimistic. Consider two validation errors en, em. The validation error en depends on g;, which was trained on data containing (xm, Ym)· Thus, en has a dependency on (xm, Ym)· The validation error em is computed using (xm, Ym) directly, and so it also has a dependency on ( Xm, Ym). Consequently, there is a possible correlation between en and em through the data point ( Xm, Ym). That correlation wouldn't be there if we were validating a single hypothesis using N fresh (independent ) data points. How much worse is the cross validation estimate as compared to an esti­ mate based on a truly independent set of N validation errors? A VC-type probabilistic bound, or even computation of the asymptotic variance of the cross validation estimate (Problem 4.23), is challenging. One way to quantify the reliability of Ecv is to compute how many fresh validation data points would have a comparable reliability to Ecv, and Problem 4.24 discusses one way to do this. There are two extremes for this effective size. On the high end is N, which means that the cross validation errors are essentially independent. On the low end is 1, which means that Ecv is only as good as any single one of the individual cross validation errors en, i.e., the cross validation errors are totally dependent . While one cannot prove anything theoretically, in practice the reliability of Ecv is much closer to the higher end. Effective number of fresh examples giving a comparable estimate of Eout Cross validation for model selection. In Figure 4.11, the estimates Em for the out-of-sample error of model 1-lm were obtained using the validation set. Instead, we may use cross validation estimates to obtain Em: use cross valida­ tion to obtain estimates of the out-of-sample error for each model 1-li, ... , 1-lM, and select the model with the smallest cross validation error. Now, train this model selected by cross validation using all the data to output a final hypoth­ esis, making the usual leap of faith that Eout (g ) tracks Eout (g) well. Example 4.5. In Figure 4.13, we illustrated cross validation for estimat­ ing Eout of a linear model ( h( x) ax + b) using a simple experiment with three data points generated from a constant target function with noise. We now consider a second model, the constant model (h(x) b). We can also use cross validation to estimate Eout for the constant model, illustrated in Figure 4.15. 148 4. 0VERFITTING 4.3. VALIDATION 0 0 0 0 x x x Figure 4.15: Leave one-out cross validation error for a constant fit. If we use the in-sample error after fitting all the data (three points), then the linear model wins because it can use its additional degree of freedom to fit the data better. The same is true with the cross validation data sets of size two -the linear model has perfect in-sample error. But, with cross validation, what matters is the error on the outstand ing point in each of these fits. Even to the naked eye, the average of the cross validation errors is smaller for the constant model which obtained Ecv 0.065 versus Ecv 0.184 for the linear model. The constant model wins, according to cross validation. The constant model also has lower Eout and so cross validation selected the correct model in this example. D One important use of validation is to estimate the optimal regularization parameter A, as described in Example 4.3. We can use cross validation for the same purpose as summarized in the algorithm below. Cross validation for selecting A: 1: Define .NI models by choosing different values for A in the augmented error: (1-l, Ai), (1-l, A2), ... , (1-l, AM) 2: for each model m 1, ... , ]\\![ do 3: Use the cross validation module in Figure 4.14 to esti­ mate Ecv(m), the cross validation error for model m. 4: Select the model m * with minimum Ecv ( m *). 5: Use model (1-l, Am*) and all the data V to obtain the fi­ nal hypothesis gm*. Effectively, you have estimated the optimal A. We see from Figure 4.14 that estimating Ecv for just a single model requires N rounds of learning on V1, ... , V N, each of size N 1. So the cross validation algorithm above requires MN rounds of learning. This is a formidable task. If we could analytically obtain Ecv, that would be a big bonus, but analytic results are often difficult to come by for cross validation. One exception is in the case of linear models, where we are able to derive an exact analytic formula for the cross validation estimate. 149 4. 0VERFITTING 4.3. VALIDATION Analytic computation of Ecv for linear models. Recall that for linear regression with weight decay, Wreg (ZTZ + .\\I)-1ZTy, and the in-sample predictions are y H(.\\)y, where H(.\\) Z(ZTZ + .\\I)-1ZT. Given H, y, and y, it turns out that we can analytically compute the cross validation estimate as: Yn -yn 1 N ( ,... )2 Ecv N � 1 Hnn(A) ( 4.13) Notice that the cross validation estimate is very similar to the in-sample error, Ein 1:J L,n (fJn -Yn)2, differing only by a normalization of each term in the sum by a factor 1/(1 Hnn(.\\))2. One use for this analytic formula is that it can be directly optimized to obtain the best regularization parameter .\\. A proof of this remarkable formula is given in Problem 4.26. Even when we cannot derive such an analytic characterization of cross validation, the technique widely results in good out-of-sample error estimates in practice, and so the computational burden is often worth enduring. Also, as with using a validation set, cross validation applies in almost any setting without requiring specific knowledge about the details of the models. So far, we have lived in a world of unlimited computation, and all that mattered was out-of-sample error; in reality, computation time can be of con­ sequence, especially with huge data sets. For this reason, leave-one-out cross validation may not be the method of choice.4 A popular derivative of leave­ one-out cross validation is V-fold cross validation. 5 In V-fold cross validation, the data are partitioned into V disjoint sets (or folds) D1, ... , Dv, each of size approximately N /V; each set Dv in this partition serves as a validation set to compute a validation error for a hypothesis glearned on a training set which is the complement of the validation set, D \\ Dv. So, you always validate a hypothesis on data that was not used for training that particular hypothesis. The V-fold cross validation error is the average of the V validation errors that are obtained, one from each validation set Dv. Leave-one-out cross validation is the same as N-fold cross validation. The gain from choosing V « N is computational. The drawback is that you will be estimating Eout for a hy­ pothesis gtrained on less data (as compared with leave-one-out ) and so the discrepancy between Eout(g) and Eout(g) will be larger. A common choice in practice is 10-fold cross validation, and one of the folds is illustrated below. v train validate train 4Stability problems have also been reported in leaveone out. 5Some authors call it K fold cross validation, but we choose V so as not to confuse with the size of the validation set K. 150 4. 0VERFITTING 4.3. VALIDATION 4.3.4 Theory Versus Practice Both validation and cross validation present challenges for the mathematical theory of learning, similar to the challenges presented by regulariza tion. The theory of generalization, in particular the VC analysis, forms the foundation for learnability. It provides us with guidelines under which it is possible to make a generalization conclusion with high probability. It is not straightfor­ ward, and sometimes not possible, to rigorously carry these conclusions over to the analysis of validation, cross validation, or regularization. What is pos­ sible, and indeed quite effective, is to use the theory as a guideline. In the case of regulariza tion, constraining the choice of a hypothesis leads to bet­ ter generalization, as we would intuitively expect, even if the hypothesis set remains technically the same. In the case of validation, making a choice for few parameters does not overly contaminate the validation estimate of Eout, even if the VC guarantee for these estimates is too weak. In the case of cross validation, the benefit of averaging several validation errors is observed, even if the estimates are not independent. Although these techniques were based on sound theoretical foundation, they are to be considered heuristics because they do not have a full mathe­ matical justification in the general case. Learning from data is an empirical task with theoretical underpinnings . We prove what we can prove, but we use the theory as a guideline when we don't have a conclusive proof. In a practical application, heuristics may win over a rigorous approach that makes unrealis­ tic assumptions. The only way to be convinced about what works and what doesn't in a given situation is to try out the techniques and see for yourself. The basic message in this chapter can be summarized as follows. 1. Noise (stochastic or deterministic ) affects learning adversely, leading to overfitting. 2. Regularization helps to prevent overfitting by con­ straining the model, reducing the impact of the noise, while still giving us flexibility to fit the data. 3. Validation and cross validation are useful techniques for estimating Eout. One important use of valida­ tion is model selection, in particular to estimate the amount of regularization to use. Example 4.6. We illustrate validation on the handwritten digit classification task of deciding whether a digit is 1 or not (see also Example 3.1) based on the two features which measure the symmetry and average intensity of the digit. The data is shown in Figure 4.16(a). 151 4. 0VERFITTING 0.03 0.01 Average Intensity (a) Digits classification task 4.3. VALIDATION 10 15 #Features Used (b) Error curves 20 Figure 4.16: (a) The digits data of which 500 are selected as the training set. (b) The data are transformed via the 5th order polynomial transform to a 20 dimensional feature vector. We show the performance curves as we vary the number of these features used for classifica tion. We have randomly selected 500 data points as the training data and the remaining are used as a test set for evaluation. We considered a nonlinear feature transform to a 5th order polynomial feature space: (1 ) (1 2 2 3 2 5 4 3 2 2 3 4 5) ,Xi,X2 -+ ,x1,X2,x1,X1X2,x2,X1,X1X2, ... ,x1,X1X2,X1X2,X1X2,X1X2,X2 . Figure 4.16(b) shows the in-sample error as you use more of the transformed features, increasing the dimension from 1 to 20. As you add more dimensions (increase the complexity of the model), the in-sample error drops, as expected. The out-of-sample error drops at first, and then starts to increase, as we hit the approximation-generalization tradeoff. The leave-one-out cross validation error tracks the behavior of the out-of-sample error quite well. If we were to pick a model based on the in-sample error, we would use all 20 dimensions. The cross validation error is minimized between 5-7 feature dimensions; we take 6 feature dimensions as the model selected by cross validation. The table below summarizes the resulting performance metrics: No Validation 0% Cross Validation 0.8% Eout 2.5% 1.5% Cross validation results in a performance improvement of about 1 %, which is a massive relative improvement ( 40% reduction in error rate). Exercise 4.11 In this particular experiment, the black curve (Ecv) is sometimes below and sometimes above the the red curve (Eout). If we repeated this experiment many times, and plotted the average black and red curves, would you expect the black curve to lie above or below the red curve? 152 4. 0VERFITTIN G 4.3. VALIDATION It is illuminating to see the actual classification boundaries learned with and without validation. These resulting classifiers, together with the 500 in-sample data points, are shown in the next figure. Average Intensity 20 dim classifier (no validation) Ein = 03 Eout 2.53 Average Intensity 6 dim classifier (LOO-CV) Ein = 0.83 Eout = 1.53 It is clear that the worse out-of-sample performance of the classifier picked without validation is due to the overfitting of a few noisy points in the training data. While the training data is perfectly separa ted, the shape of the resulting boundary seems highly contorted, which is a symptom of overfitting. Does this remind you of the first example that opened the chapter? There, albeit in a toy example, we similarly obtained a highly contorted fit. As you can see, overfitting is real, and here to stay! D 153 4. 0VERFITTING 4.4. PROBLEMS 4.4 Problems Problem 4.1 Plot the monomials of order i, </>i(x) =xi. As you increase the order, does this correspond to the intuitive notion of increasing complexity? Problem 4.2 Consider the feature transform z = [L0(x), L1(x), L2(xW and the linear model h(x) = wTz. For the hypothesis with w = [1, -1, 1r, what is h(x) explicitly as a function of x. What is its degree? Problem 4.3 The Legendre Polynomials are a family of orthogonal polynomials which are useful for regression. The first two Legendre Polynomials are Lo(x) = 1, L1(x) = x. The higher order Legendre Polynomials are defined by the recursion: 2k -1 k -1 Lk(x) = - -;;-Lk-2(x). (a) What are the first six Legendre Polynomials? Use the rec ursion to de velop an efficient algorithm to compute Lo(x), ... , LK(x) given x. Your algorithm should run in time linear in K. Plot the first six Legendre polynomials. (b) Show that Lk(x) is a linear combination of monomials xk, xk-2, ... (ei ther all odd or all even order, with highest order k ). Thus, Lk(-x) = (-l)kLk(x). (c) Show that x2k-1 = xLk(x) - Lk-1(x). [Hint: use induction.} ( d) Use part ( c) to show that Lk satisfies Legendre's differential equation !:_(x2 -1) dLk(x) = k(k + l)Lk(x). dx dx This means that the Legendre Polynomials are eigenfunctions of a Her mitian linear differential operator and, from SturmLiouville theory, they form an orthogonal basis for continuous functions on [-1, 1]. (e) Use the recurrence to show directly the orthogonality property: dx Lk(x)Le(x) = {O 2 e = k, 2k+l g k. [Hint: use induction on k, with e ::; k. Use the recurrence for Lk and consider separatel y the four cases e = k, k -1, k - 2 and e < k -2. For the case e = k you will need to compute the integral J�1 dx x2 LL1(x). In order to do this, you could use the differential equation in part ( c), multiply by xLk and then integrate both sides (the LHS can be integrated by parts). Now solve the resulting equation for f1 dx x2 LL1(x).j 154 4. 0VERFITTING 4.4. PROBLEMS Problem 4.4 LAMi This problem is a detailed version of Exercise 4.2. We set up an experimental framework which the reader may use to study var ious aspects of overfitting. The input space is X = [-1, 1]. with uniform input probability density, P(x) = �· We consider the two models 1-l2 and 1-l10. The target function is a polynomial of degree Qf, which we write as f(x) = I:,�!,0 aqLq(x), where Lq(x) are the Legendre polynomials. We use the Legendre polynomials because they are a convenient orthogonal basis for the polynomials on [-1, 1] (see Section 4.2 and Problem 4.3 for some basic infor mation on Legendre polynomials). The data set is V = (x1, y1), ... , (xN, YN ), where Yn = f (xn) + CJEn and En are iid standard Normal random variates. For a single experiment, with specified values for QJ, N, CJ, generate a random degree-Q f target function by selecting coefficients aq independently from a standard Normal, rescaling them so that IEa,x [f2] = 1. Generate a data set, selecting x1, ... , XN independently from P(x) and Yn = f(xn) + CJEn. Let g2 and g10 be the best fit hypotheses to the data from 1-l2 and 7-l10 respectively, with respective outof-sample errors Eout(g2) and Eout(g10). (a) Why do we normalize j? [Hint: how would you interpret CJ?] (b) How can we obtain g2, g10? [Hint: pose the problem as linear regression and use the technology from Chapter 3.} ( c) How can we compute Eout analytically for a given g10? ( d) Vary Q f, N, CJ and for each combination of parameters, run a large num ber of experiments, each time computing Eout(g2) and Eout(g10). Aver aging these out-of-sample errors gives estimates of the expected out-of sample error for the given learning scenario (QJ, N, CJ) using 7-l2 and 1-l10. Let Eout(1-l2) Eout(1-l10) average over experiments(Eout(g2)), average over experiments( Eout (g10)). Define the overfit measure Eout(1-l10) -Eout(1-l2). When is the over­ fit measure significantly positive (i.e., overfitting is serious) as opposed to significantly negative? Try the choices QJ E {1, 2, ... , 100}, N E {20, 25, ... , 120}, CJ2 E {O, 0.05, 0.1, ... , 2}. Explain your observations. ( e) Why do we take the average over many experiments? Use the variance to select an acceptable number of experiments to average over. (f) Repeat this experiment for classification, where the target function is a noisy perceptron, f = sign (\"L�!,1 aqLq(x) + E). Notice that ao = 0, and the aq's should be normalized so that IEa,x [0=�!,1 aqLq(x))2] = 1. For classification, the models H2, H10 contain the sign of the 2nd and 10th order polynomials respectively. You may use a learning algorithm for non-separable data from Chapter 3. 155 4. 0VERFITTING 4.4. PROBLEMS Problem 4.5 If>. < 0 in the augmented error Eaug(w) = Ein(w)+>.wTw, what soft order constraint does this correspond to? [Hint: >. < 0 encourages large weights.} Problem 4.6 In the augmented error minimization with r =I and >. > 0: (a) Show that llwregll � llwHnll. justifying the term weight decay. [Hint: start by assuming that llwregll > llwHnll and derive a contradicti on.] In fact a stronger statement holds: llwregll is decreasing in >.. (b) Explicitly verify this for linear models. [Hint: where u = ZT y and Z is the transformed data matrix. Show that ZTZ + >.I has the same eigenvectors with correspondingly larger eigenvalues as ZTZ. Expand u in the eigenbasis of ZTZ. For a matrix A, how are the eigenvectors and eigenvalue s of A -2 related to those of A?] Problem 4.7 Show that the in-sample error from Example 4.2 is an increasing function of>., where H(>.) = Z(VZ+>.r)-1V and Z is the transformed data matrix. To do so, let the SVD of z = urvT and let ZTZ have eigenvalues O'i' ... 'O'�. Define the vector a= UTy. Show that and proceed from there. Problem 4.8 In the augmented error minimization with r =I and >. > 0, assume that Ein is differentiable and use gradient descent to minimize Eaug: w(t + 1) +-w(t) -r/\\7 Eaug(w(t)). Show that the update rule above is the same as w(t + 1) +-(1-2rJ>.)w(t) -rJ\\lEin(w(t)). Note: This is the origin of the name 'weight decay': w(t) decays before being updated by the gradient of Ein· 156 4. OvERFITTING 4.4. PROBLEMS Problem 4.9 In Tikhonov regularization, the regularized weights are given by Wreg (ZTZ + >.rTr)-lZTy. The Tikhonov regularizer r is a k x (d + 1) matrix, each row corresponding to a d + 1 dimensional vector. Each row of Z corresponds to a d + 1 dimensional vector (the first component is 1). For each row of r, construct a virtual example (zi, 0) for i = 1, ... , k, where Zi is the vector obtained from the ith row of r after scaling it by V>,., and the target value is 0. Add these k virtual examples to the data, to construct an augmented data set, and consider non-regularized regression with this augmented data. (a) Show that, for the augmented data, Zaug [.J. r] and Yaug [�] (b) Show that solving the least squares problem with Zaug and Yaug results in the same regularized weight Wreg, i.e. Wreg (Z�ugZaug)1Z�ugYaug· This result may be interpreted as follows: an equivalent way to accomplish weight-decay-type regularization with linear models is to create a bunch of virtual examples all of whose target values are zero. Problem 4.10 In this problem, you will investigate the relationship between the soft order constraint and the augmented error. The regularized weight Wreg is a solution to minEin(w) subject to wTrTrw s C. (a) If Wun rTrwlin s c' then what is w reg? (b) If wlinrTrwlin > C, the situation is illustrated below, The constraint is satisfied in the shaded region and the contours of con­ stant Ein are the ellipsoids (why ellipsoids?). What is w�egrTrwreg? (c) Show that with AC= - W�eg \\7Ein(Wreg), Wreg minimizes Ein(w) + >.cwTrTrw. [Hint: use the previous part to solve for Wreg as an equality constrained optimization problem using the method of Lagrange multipliers.] (continued on next page) 157 4. 0VERFITTING 4.4. PROBLEMS (d) Show that the following hold for Ac: (i) If wlinI'TI'W!in s; C then Ac = 0 (w!in itself satisfies the constraint). (ii) If wlinI'TI'W!in > C, then Ac > 0 (the penalty term is positive). (iii) If wlinrTrwlin > C, then Ac is a strictly decreasing function of C. [Hint: show that < 0 for CE [O, wlinI'TI'Wiin].} Problem 4.11 For the linear model in Exercise 4.2, the target function is a polynomial of degree Qf; the model is 1-lQ, with polynomials up to order Q. Assume Q 2: QJ. W!in = (ZTz)1ZTy, and y = Zwr + E, where wr is the target function and Z is the matrix containing the transformed data. (a) Show that W!in = wr + (ZTz)1ZT E. What is the average function g? Show that bias= 0 (recall that: bias( x) = (g(x) -f(x))2). (b) Show that 2 trace (�<I> lEz [(-Kr-ZTZ)1]), where �<I>= IE[<I>(x)<I>T(x)]. {Hints: var= IE[(g('D) -g)2]; first take the expectation with respect to E, then with respect to <I>(x), the test point, and the last remaining expectation will be with respect to Z. You will need the cyclic property of the trace.} (c) Argue that to first order in -Kr. var � l). {Hint: -Kr-VZ =-Kr l::=l <I>(xn)<I>T(xn) is the in-sample estimate of'L,cp. By the law of large numbers, -Kr-VZ = �<P + o(l).} For the well specified linear model, the bias is zero and the variance is increasing as the model gets larger (Q increases), but decreasing in N. Problem 4.12 Use the setup in Problem 4.11 with Q 2: QJ. Con­ sider regression with weight decay using a linear model 1-l in the transformed space with input proba bility distribution such that IE[zzT] =I. The regularized weights are given by Wreg = (ZTZ + AI)1Vy, where y = Zwr + E. (a) Show that Wreg = Wf -A(ZTZ + AI)1wr + (ZTZ + >.I)1VE. (b) Argue that, to first order in -Kr, bias � var � A2 (A+ N)2 llwrll2' 0\"2 NIE [trace(H2(A))], where H(A) = Z(VZ + AI)1V. 158 4. 0VERFITTIN G If we plot the bias and var, we get a figure that is very similar to Figure 2.3, where the tradeoff was based on fit and com plexity rather than bias and var. Here, the bias is increasing in .A (as expected) and in llwfll; the variance is decreasing in .A. When .A= 0, trace(H2(.A)) = Q + 1 and so trace(H2(.A)) appears to be playing the role of an effective number of parameters. 4.4. PROBLEMS Regularization Parameter, >. Problem 4.13 Within the linear regression setting, many attempts have been made to quantify the effective number of parameters in a model. . Three possibilities are: (i) deff(.A) = 2trace(H(.A)) -trace(H2(.A)) (ii) deff(.A) = trace(H(.A)) (iii) deff(.A) = trace(H2(.A)) where H(.A) = Z(VZ + .AI)1ZT and Z is the transformed data matrix. To obtain deff. one must first compute H(.A) as though you are doing regression. One can then heuristically use deff in place of dvc in the VCbound. (a) When .A= 0, show that for all three choices, deff = d+ 1, where dis the dimension in the Z space. (b) When A > 0, show that 0 :: deff :: d + 1 and deff is decreasing in A for all three choices. [Hint: Use the singular value decomposition.} Problem 4.14 The observed target values y can be separated into the true target values f and the noise E, y = f + E. The components of E are iid with variance o-2 and expectation 0. For linear regression with weight decay regularization, by taking the expected value of the insample error in (4.2), show that 1 T 2 0-2 ( ( 2) Nf (I -H(.A)) f + N trace (I -H .A)) , �e(I-H(.A))2f + o-2 (i -�) , where deff = 2trace(H(.A)) -trace(H2(.A)), as defined in Problem 4.13(i), H(.A) = Z(ZTZ + .AI)1ZT and Z is the transformed data matrix. (continued on next page) 159 4. 0VERFITTING 4.4. PROBLEMS (a) If the noise was not overfit, what shou ld the term involving 0\"2 be, and why? (b) Hence, argue that the degree to which the noise has been overfit is 0\"2deff/N. Interpret the dependenc e of this result on the parameters deff and N, to justify the use of deff as an effective number of parameters. Problem 4.15 We further investigate deff of Problems 4.13 and 4.14. We know that H(..\\) = Z(VZ + ..\\rTr)-1ZT. When r is square and invertible, as is usually the case (for examp le with weight decay, r =I), denote Z = zr-1. Let s5, ... , s� be the eigenvalues of ZTZ (s; > 0 when Z has full column rank). (a) For deff(,\\) = trace(2H(,\\) -H2(..\\)), show that d (b) For deff(,\\) = trace(H(..\\)), show that deff(,\\) = d + 1 -I: i=O ' -2 -d s[ (c) For deff(,\\) -trace(H (..\\)),show that deff(,\\) -?= (s'.?+>-)2• i=O ' In all cases, for,\\ � 0, 0 :=: deff(,\\) :=: d+ l, deff(O) = d+ 1 and deff is decreasing in ..\\. [Hint: use the singular value decomposition Z = USVT, where U, V are orthogonal and S is diagonal with entries Bi.] Problem 4.16 For linear models and the general Tikhonov regularizer r with penalty term �wTrTrw in the augmented error, show that Wreg = (ZTZ + ..\\rTr)lZTy, where Z is the feature matrix. (a) Show that the in-sample predictions are y = H(..\\)y, where H(..\\) = Z(VZ + .ArTr)1ZT. (b) Simplify this in the case r = Z and obtain Wreg in terms of Wlin· This is called uniform weight decay. Problem 4.17 To model uncertainty in the measurement of the inputs, assume that the true inputs Xn are the observed inputs Xn perturbed by some noise En: the true inputs are given by Xn = Xn +En. Assume that the En are independent of (xn, Yn) with covariance matrix E[EnE�] = O\";r and mean 160 4. 0VERFITTING 4.4. PROBLEMS lE[En] = 0. The learning algorithm minimizes the expected in sample error Bin, where the expectation is with respect to the uncertainty in the true Xn. Show that the weights W!in which result from minimizing Bin are equiva lent to the weights which would have been obtained by minimizing Ein = -f:t L;:=l (wTxn -Yn)2 for the observed data, with Tikhonov regularization. What are r and >. (see Problem 4.16 for the general Tikhonov regularizer)? One can interpret this result as follows: regularization enforces a robustness to potential measurement errors (noise) in the observed inputs. Problem 4.18 In a regression setting, assume the target function is linear, so f(x) = w}x, and y = Zw f + E, where the entries in E are iid with zero mean and variance o-2. Assume a regularization term ftwTZTZw and that lE[xxT] =I. In this problem derive the optimal value for >. as follows. (a) Show that the average function is g(x) = What is the bias? (b) Sh h . . II 0\"2(d+1) J ow t at var rs asymptot1ca y N(i+>.)2• Problem 4.12. (c) Use the bias and asymptotic variance to obtain an expression for JE[Eout]. Optimize this with respect to >. to obtain the optimal regularization pa- . >. * -0\"2(d+i) J rameter. nswer. -N!lwill2 • ( d) Explain the dependenc e of the optimal regularization parameter on the parameters of the learning problem. {Hint: write>.* = Problem 4.19 [The Lasso algorithm] Rather than a soft order constraint on the squares of the weights, one could use the absolute values of the weights: d minEin(w) subject to L lwil :SC. i=O The model is called the lasso algorithm. (a) Formulate and implement this as a quadratic program. Use the exper­ imental design in Problem 4.4 to compare the lasso algorithm with the quadratic penalty by giving plots of Eout versus regularization parameter. (b) What is the augmented error? Is it more convenient to optimize? (c) With d = 5 and N = 3, compare the weights from the lasso versus the quadratic penalty. [Hint: Look at the number of non-zero weights.] 161 4. 0VERFITTING 4.4. PROBLEivIS Problem 4.20 In this problem, you will explore a consistency condition for weight decay. Suppose that we make an invertible linear transform of the data, Yn = ayn. Intuitively, linear regression should no t be affected by a linear transform. This means that the new optimal weights should be given by a corresponding linear transform of the old optimal weights. (a) Suppose w minimizes the insample error for the original problem. Show that for the transformed problem, the optimal weights are (b) Suppose the regularization penalty term in the augmented error is wTXTXw for the original data and wTZTZw for the transformed data. On the original data, the regularized solution is Wreg(.A). Show that for the transformed problem, the same linear transform of Wreg(.A) gives the corresponding regularized weights for the transformed problem: Problem 4.21 The Tikhonov smoothness penalty which penalizes derivatives of h is fJ(h) = J dx ( 2. Show that, for linear models, this reduces to a penalty of the form wTrTrw. What is r? Problem 4.22 You have a data set with 100 data points. You have 100 models each with VCdimension 10. You set aside 25 points for validation. You select the model which produced minimum validation error of 0.25. Give a bound on the outofsample error for this selected function. Suppose you instead trained each model on all the data and selected the func tion with minimum insample error. The resulting insample error is 0.15. Give a bound on the out of sample error in this case. [Hint: Use the bound in Problem 2.14 to bound the VCdimension of the union of all the models.] Problem 4.23 This problem investigates the covariance of the leave one out cross validation errors, Covv[en, em]. Assume that for well behaved models, the learning process is 'stable', and so the change in the learned hypothesis should be small, 'O (-f:t) ', if a new data point is added to a data set of size N. Write g;, = g<N2) +On and g� = g<N2) +Om, where g<N2) is the learned hypothesis on vCN-2)' the data minus the nth and mth data points, and On, Om are the corrections after addition of the nth and mth data points respective ly. 162 4. 0VERFITTING 4.4. PROBLEMS (a) Show that Varv[Bev] = 2=:=l Varv [en] + 2=:#m Covv[en, em]· (b) Show Covv[en, em]= Varv(N 2) [Bout(g(N-2))]+ higher order in 8n, Om. ( c) Assume that any terms involving On, Om are O( tr). Argue that Does Varv[e1] decay to zero with N? What about Varv[Bout(g)]? (d) Use the experimental design in Problem 4.4 to study Varv[Bev] and give a loglogplot of Varv[Bev]/Varv[e1] versus N. What is the decay rate? Problem 4.24 Ford= 3, generate a random data set with N points as follows. For each point, each dimension of x has a standard Normal distribution. Similarly, generate a (d+ 1)dimensional target weight vector Wf, and set Yn = w'f Xn +O\"En where En is noise (also from a standard Normal distribution) and O\" is the noise variance; set O\" to 0.5. Use linear regression with weight decay regularization to estimate Wf with Wreg· Set the regularization parameter to 0.05/N. (a) For NE {d+15, d+25, ... , d+115}, compute the cross validation errors ei, ... , eN and Bev· Repeat the experiment (say) 105 times, maintaining the average and variance over the experiments of e1, e2 and Bev· (b) How should your average of the e1 's relate to the average of the Bev's; how about to the average of the e2's? Support your claim using results from your experiment. (c) What are the contributors to the variance of the e1's? ( d) If the cross validation errors were truly independent, how should the vari­ ance of the ei's relate to the variance of the Bev's? ( e) One measure of the effective number of fresh examples used in comput­ ing Bev is the ratio of the variance of the ei 's to that of the Bev's. Explain why, and plot, versus N, the effective number of fresh examples (Neff) as a percentage of N. You should find that Neff is close to N. (f) If you increase the amount of regularization, will Neff go up or down? Explain your reasoning. Run the sa me experiment with A= 2.5/N and compare your results from part ( e) to verify your conjecture. Problem 4.25 When using a validation set for model selection, all models were learned on the same Dtrain of size N -K, and validated on the same Dval of size K. We have the VCbound (see Equation ( 4.12) ): Eout (g;, • ) <: Eval (g;, • ) + 0 ( J1f) (continued on next page) 163 4. 0VERFITTIN G 4.4. PROBLEMS Suppose that instead, you had no control over the validation process. So M learners, each with their own models present you with the results of their val idation processes on different validation sets. Here is what you know about each learner: Each learner m reports to you the size of their validation set Km, and the validation error Eva! ( m). The learners may have used dif­ ferent data sets, except that they faithfully learned on a training set and validated on a held out validation set which was only used for validation purposes. As the model selector, you have to decide which learner to go with. (a) Should you select the learner with minimum validation error? If yes, why? If no, why not? {Hint: think VC-bound.j (b) If all models are validated on the same validation set as described in the text, why is it okay to select the learner with the lowest validation error? ( c) After selecting learner m * (say), show that JP>[Eout(m*) > Eva1(m*) + E] :: Me-2€2\"\"(E), where K,(E) = _ _L ln (.l e2€2Km) is an \"average\" validation 2E2 111 set size. (d) Show that with probability at least 1 -0, Eout :: Eva!+ E*, for any E* which satisfies E* ?: In(M/8) 2K,(E*) ' (e) Show that minm Km :: K,(E) :: l:�=l Km. Is this bound better or worse than the bound when all models use the same validation set size (equal to the average validation set size -k l:�=l Km)? Problem 4.26 In this problem, derive the formula for the exact expression for the leave-oneout cross validation error for linear regression. Let Z be the data matrix whose rows correspond to the transformed data points Zn = <P(xn). (a) Show that: N N ZTZ= LZnz�; ZTy = LZnYni n=l n=l where A = A(,\\) ZTZ + ,\\rTr and H(,\\) = ZA(,\\)1V. Hence, show that when (zn, Yn) is left out, ZTZ -+ ZTZ -ZnZ�, and ZTy -+ ZTy -ZnYn· (b) Compute w�, the weight vector learned when the nth data point is left out, and show that: (A 1 A lZnZ�A l) (ZT ) w� + 1 T A1 y ZnYn . -Zn Zn 164 4. 0VERFITTIN G use the identity (A -xxT)-1 =A -1 + A-1xxT A-1 .] 1-xTAlx 4.4. PROBLEMS (c) Using (a) and (b), show that w -; = w+ A-1zn, where w is the regression weight vector using all the data. (d) The prediction on the validation point is given by z�w-;. Show that T Yn -HnnYn Zn W n = 1 -Hnn • {e) Show that en= ( r, and hence prove Equation (4.13). Problem 4.27 Cross validation gives an accurate estimate of Eout(N-1), but it can be quite sensitive, leading to problems in model selection. A common heuristic for 'regularizing' cross validation is to use a measure of error O-cv(1-l) for the cross validation estimate in model selection. (a) One choice for o-0v is the standard deviation of the leave-one-out errors divided by Vi, 0-cv � ... 'en). Why divide by VN? (b) For linear models, show that VNo-cv = f.I 'L,;:=1 E;v. ( c) (i) Given the best model 1-l*, the conservative one-sigma approach se lects the simplest model within O-cv(1-l*) of the best. (ii) The bound minimizing approach selects the model which minimizes Ecv(1-l) + O-cv(1-l). Use the experimental design in Problem 4.4 to compare these approaches with the 'unregularized' cross validation estimate as follows. Fix Q1 = 15, Q = 20, and o-= 1. Use each of the two methods proposed here as well as traditional cross validation to select the optimal value of the regularization parameter >. in the range {0.05, 0.10, 0.15, ... , 5} using weight decay regularization, O(w) = ftwTw. Plot the resulting out-of-sample error for the model selected using each method as a function of N, with N in the range {2 x Q,3xQ, ... ,10 x Q}. What are your conclusions? 165 166 Chapter 5 Three Learning Principles The study of learning from data highlights some general principles that are fascinating concepts in their own right. Having gone through the mathematical analysis and empirical illustrations of the first few chapters, we have a good foundation from which to articulate some of these principles and explain them in concrete terms. In this chapter, we will discuss three principles. The first one is related to the choice of model and is called Occam's razor. The other two are related to data; sampling bias establishes an important principle about obtaining the data, and data snooping establishes an important principle about handling the data. A genuine understanding of these principles will protect you from the most common pitfalls in learning from data, and allow you to interpret generalization performance properly. 5.1 Occam's Razor Although it is not an exact quote of Einstein's, it is often attributed to him that \"An explanation of the data should be made as simple as possible, but no simpler.\" A similar principle, Occam's Razor, dates from the 14th century and is attributed to William of Occam, where the 'razor' is meant to trim down the explanation to the bare minimum that is consistent with the data. In the context of learning, the penalty for model complexity which was introduced in Section 2.2 is a manifestation of Occam's razor. If Ein (g) 0, then the explanation (hypothesis ) is consistent with the data. In this case, the most plausible explanation, with the lowest estimate of Eout given in the VC bound (2.14), happens when the complexity of the explanation (measured by dvc(H)) is as small as possible. Here is a statement of the underlying principle. The simplest model that fits the data is also the most plausible. 167 5. THREE LEARNING PRINCIPLES 5.1. OCCAM'S RAZOR Applying this principle, we should choose as simple a model as we think we can get away with. Although the principle that simpler is better may be intuitive, it is neither precise nor self-evident . When we apply the principle to learning from data, there are two basic questions to be asked. 1. What does it mean for a model to be simple? 2. How do we know that simpler is better? Let's start with the first question. There are two distinct approaches to defin­ ing the notion of complexity, one based on a family of objects and the other based on an individual object. We have already seen both approaches in our analysis. The VC dimension in Chapter 2 is a measure of complexity, and it is based on the hypothesis set 1-l as a whole, i.e., based on a family of objects. The regularization term of the augmented error in Chapter 4 is also a measure of complexity, but in this case it is the complexity of an individual object, namely the hypothesis h. The two approaches to defining complexity are not encountered only in learning from data; they are a recurring theme whenever complexity is dis­ cussed. For instance, in information theory, entropy is a measure of complexity based on a family of objects, while minimum description length is a related measure based on individual objects. There is a reason why this is a recurring theme. The two approaches to defining complexity are in fact related. When we say a family of objects is complex, we mean that the family is 'big'. That is, it contains a large variety of objects. Therefore, each individual object in the family is one of many. By contrast, a simple family of objects is 'small'; it has relatively few objects, and each individual object is one of few. Why is the sheer number of objects an indication of the level of complexity? The reason is that both the number of objects in a family and the complexity of an object are related to how many parameters are needed to specify the object. When you increase the number of parameters in a learning model, you simultaneously increase how diverse 1-l is and how complex the individual h is. For example, consider 17th order polynomials versus 3rd order polynomials. There is more variety in 17th order polynomials, and at the same time the individual 17th order polynomial is more complex than a 3rd order polynomial. The most common definitions of object complexity are based on the number of bits needed to describe an object. Under such definitions , an object is simple if it has a short description. Therefore, a simple object is not only intrinsically simple (as it can be described succinctly), but it also has to be one of few, since there are fewer objects that have short descriptions than there are that have long descriptions, as a matter of simple counting. Exercise 5.1 Consider hypothesis sets H1 and H100 that contain Boolean functions on 10 Boolean variables, so X = {-1, + 1 }10. H1 contains all Boolean functions 168 5. THREE LEARNING PRINCIPLES 5.1. OCCAM'S RAZOR which evaluate to 1 on exactly one input point, and to -1 elsewhere; 1-l100 contains all Boolean functions which evaluate to 1 on exactly 100 input points, and to 1 elsewhere. (a) How big (number of hypotheses ) are 1-l1 and 1-l100? (b) How many bits are needed to specify one of the hypotheses in 1-l1? ( c) How many bits are needed to specify one of the hypotheses in 1-l100? We now address the second question. When Occam's razor says that simpler is better, it doesn't mean simpler is more elegant. It means simpler has a better chance of being right. Occam's razor is about performance, not about aesthetics. If a complex explanation of the data performs better, we will take it. The argument that simpler has a better chance of being right goes as fol­ lows. We are trying to fit a hypothesis to our data 'D = {(x1, Y1), · · · , (xN, YN)} (assume Yn 's are binary). There are fewer simple hypotheses than there are complex ones. With complex hypotheses, there would be enough of them to shatter x1, · · · , XN, so it is certain that we can fit the data set regardless of what the labels Y1, · · · , YN are, even if these are completely random. There­ fore, fitting the data does not mean much. If, instead, we have a simple model with few hypotheses and we still found one that perfectly fits the dichotomy 'D ={(xi, Y1), · · · , (xN, YN )}, this is surprising, and therefore it means some­ thing. Occam's Razor has been formally proved under different sets of idealized conditions. The above argument captures the essence of these proofs; if some­ thing is less likely to happen, then when it does happen it is more significant. Let us look at an example. Example 5.1. Suppose that one constructs a physical theory about the re­ sistivity of a metal under various temperatures. In this theory, aside from some constants that need to be determined, the resistivity p has a linear de­ pendence on the temperature T. In order to verify that the theory is correct and to obtain the unknown constants, 3 scientists conduct the following three experiments and present their data to you. / / / :f ] .. :� .. .. .. .� .� .� rn rn rn Q) Q) Q) r-; r-; r-; temperature T temperature T temperature T Scientist 1 Scientist 2 Scientist 3 169 5. THREE LEARNING PRINCIPLES 5.1. OCCAM'S RAZOR It is clear that Scientist 3 has produced the most convincing evidence for the theory. If the measurements are exact, then, Scientist 2 has managed to falsify the theory and we are back to the drawing board. What about Scientist 1? While he has not falsified the theory, has he provided any evidence for it? The answer is no, for we can reverse the question. Suppose that the theory was not correct, what could the data have done to prove him wrong? Nothing, since any two points can be joined by a line. Therefore, the model is not just likely to fit the data in this case, it is certain to do so. This renders the fit totally insignificant when it does happen. D This example illustrates a concept related to Occam's Razor, which is the axiom of non-falsifiability. The axiom asserts that the data should have some chance of falsifying a hypothesis, if we are to conclude that it can provide evidence for the hypothesis. One way to guarantee that every data set has some chance at falsification is for the VC dimension of the hypothesis set to be less than N, the number of data points. This is discussed further in Problem 5.1. Here is another example of the same concept. Example 5.2. Financial firms try to pick good traders (predictors of whether the market will go up or no t). Suppose that each trader is tested on their prediction (up or down) over the next 5 days and those who perform well will be hired. One might think that this process should produce better and better traders on Wall Street. Viewed as a learning problem, consider each trader to be a prediction hypothesis. Suppose that the hiring pool is 'complex'; we are interviewing 25 traders who happen to be a diverse set of people such that their predictions over the next 5 days are all different. Necessarily one of these traders gets it all correct, and will be hired. Hiring the trader through this process may or may not be a good thing, since the process will pick someone even if the traders are just flipping coins to make their predictions. A perfect predictor always exists in this group, so finding one doesn't mean much. If we were interviewing only two traders, and one of them made perfect predictions, that would mean something. D Exercise 5.2 Suppose that for 5 weeks in a row, a letter arrives in the mail that predicts the outcome of the upcoming Monday night football game. You keenly watch each Monday and to your surprise, the prediction is correct each time. On the day after the fifth game, a letter arrives, stating that if you wish to see next week's prediction, a payment of $50.00 is required. Should you pay? (a) How many possible predictions of win-lose are there for 5 games? (b) If the sender wants to make sure that at least one person receives correct predictions on all 5 games from him, how many people should he target to begin with? 170 5. THREE LEARNING PRINCIPLES 5.2. SAMPLING BIAS (c) After the first letter 'predicting' the outc ome of the first game, how many of the original recipients does he target with the second letter? ( d) How many letters altogether will have been sent at the end of the 5 weeks? ( e) If the cost of printing and mailing out each letter is $0.50, how much would the sender make if the recipient of 5 correct predictions sent in the $50.00? (f) Can you relate this situation to the growth function and the credibility of fitting the data? Learning from data takes Occam's Razor to another level, going beyond \"as simple as possible, but no simpler.\" Indeed, we may opt for 'a simpler fit than possible', namely an imperfect fit of the data using a simple model over a perfect fit using a more complex one. The reason is that the price we pay for a perfect fit in terms of the penalty for model complexity in (2.14) may be too much in comparison to the benefit of the better fit. This idea was illustrated in Figure 3. 7, and is a manifestation of overfitting. The idea is also the rationale behind the recommended policy in Chapter 3: first try a linear model one of the simplest models in the arena of learning from data. 5.2 Sampling Bias A vivid example of sampling bias happened in the 1948 US presidential election between Truman and Dewey. On election night, a major newspaper carried out a telephone poll to ask people how they voted. The poll indicated that Dewey won, and the paper was so confident about the small error bar in its poll that it declared Dewey the winner in its headline. When the actual votes were counted, Dewey lost to the delight of a smiling Truman. @Associated Press 171 5. THREE LEARNING PRINCIPLES 5.2. SAMPLING BIAS This was not a case of statistical anomaly, where the newspaper was just incredibly unlucky (remember the 8 in the VC bound?). It was a case where the sample was doomed from the get-go, regardless of its size. Even if the experiment were repeated, the result would be the same. In 1948, telephones were expensive and those who had them tended to be in an elite group that favored Dewey much more than the average voter did. Since the newspaper did its poll by telephone, it inadvertently used an in-sample distribution that was different from the out-of-sample distribution. That is what sampling bias is. If the data is sampled in a biased way, learning will pro­ duce a similarly biased outcome. Applying this principle, we should make sure that the training and testing distributions are the same; if not, our results may be invalid, or, at the very least, require careful interpretation. If you recall, the VC analysis made very few assumptions, but one as­ sumption it did make was that the data set V is generated from the same distribution that the final hypothesis g is tested on. In practice, we may en­ counter data sets that were not generated under those ideal conditions. There are some techniques in statistics and in learning to compensate for the 'mis­ match' between training and testing, but not in cases where V was generated with the exclusion of certain parts of the input space, such as the exclusion of households with no telephones in the above example. There is nothing that can be done when this happens, other than to admit that the result will not be reliable statistical bounds like Hoeffding and VC require a match between the training and testing distributions. There are many examples of how sampling bias can be introduced in data collection. In some cases it is inadvertently introduced by an oversight, as in the case of Dewey and Truman. In other cases, it is introduced because certain types of data are not available. For instance, in our credit example of Chapter 1, the bank created the training set from the database of previous cus­ tomers and how they performed for the bank. Such a set necessarily excludes those who applied to the bank for credit cards and were rejected, because the bank does not have data on how they would have perf armed if they were ac­ cepted. Since future applicants will come from a mixed population including some who would have been rejected in the past, the 'test set' comes from a different distribution than the training set, and we have a case of sampling bias. In this particular case, if no data on the applicants that were rejected is available, nothing much can be done other than to acknowledge that there is a bias in the final predictor that learning will produce, since a representative training set is just not available. Exercise 5.3 In an experiment to determine the distribution of sizes of fish in a lake, a net might be used to catch a representative sample of fish. The sample is 172 5. THREE LEARNING PRINCIPLES 5.3. DATA SNOOPING then analyzed to find out the fractions of fish of different sizes. If the sample is big enough, statistical conclusions may be drawn about the actual distribution in the entire lake. Can you smell © sampling bias? There are other cases, arguably more common, where sampling bias is intro­ duced by human intervention. It is not that uncommon for someone to throw away training examples they don't like! A Wall Street firm who wants to de­ velop an automated trading system might choose data sets when the market was 'behaving well' to train the system, with the semi-legitimate justification that they don't want the noise to complicate the training process. They will surely achieve that if they get rid of the 'bad' examples , but they will create a system that can be trusted only in the periods when the market does behave well! What happens when the market is not behaving well is anybody's guess. In general, throwing away training examples based on their values, e.g., ex­ amples that look like outliers or don't conform to our preconceived ideas, is a fairly common sampling bias trap. Other biases. Sampling bias has also been called selection bias in the statis­ tics community. We will stick with the more descriptive term sampling bias for two reasons. First, the bias arises in how the data was sampled; second, it is less ambiguous because in the learning context, there is another notion of selection bias drifting around selection of a final hypothesis from the learning model based on the data. The performance of the selected hypothesis on the data is optimistica lly biased, and this could be denoted as a selection bias. We have referred to this type of bias simply as bad generalizat ion. There are various other biases that have similar flavor. There is even a special type of bias for the research community, called publication bias! This refers to the bias in published scientific results because negative results are often not published in the literature, whereas positive results are. The common theme of all of these biases is that they render the standard statistical conclusions invalid because the basic premise for such conclusions , that the sampling distribution is the same as the overall distribution, does not hold any more. In the field of learning from data, it is sampling bias in the training set that we need to worry about. 5.3 Data Snooping Data snooping is the most common trap for practitioners in learning from data. The principle involved is simple enough, If a data set has affected any step in the learning process, its ability to assess the outcome has been compromised. 173 5. THREE LEARNING PRINCIPLES 5.3. DATA SNOOPING Applying this principle, if you want an unbiased assessment of your learning performance, you should keep a test set in a vault and never use it for learning in any way. This is basically what we have been talking about all along in training versus testing, but it goes beyond that. Even if a data set has not been 'physically' used for training, it can still affect the learning process, sometimes in subtle ways. Exercise 5.4 Consider the following approach to learning. By looking at the data, it appears that the data is linearly separable, so we go ahead and use a simple perceptron, and get a training error of zero after determining the optimal set of weights. We now wish to make some generalization conclusions, so we look up the dvc for our learning model and see that it is d+ 1. Therefore, we use this value of dvc to get a bound on the test error. (a) What is the problem with this bound is it correct? (b) Do we know the dvc for the learning model that we actually used? It is this dvc that we need to use in the bound. To avoid the pitfall in the above exercise, it is extremely important that you choose your learning model before seeing any of the data. The choice can be based on general information about the learning problem, such as the num­ ber of data points and prior knowledge regarding the input space and target function, but not on the actual data set V. Failure to observe this rule will invalidate the VC bounds, and any generalization conclusions will be up in the air. Even a careful person can fall into the traps of data snooping. Consider the following example. Example 5.3. An investment bank wants to develop a system for forecasting currency exchange rates. It has 8 years worth of historical data on the US Dollar (USD) versus the British Pound (GBP), so it tries to use the data to see if there is any pattern that can be exploited. The bank takes the series of daily changes in the USD/GBP rate, normalizes it to zero mean and unit variance, and starts to develop a system for forecasting the direction of the change. For each day, it tries to predict that direction based on the fluctuations in the previous 20 days. 753 of the data is used for training, and the remaining 253 is set aside for testing the final hypothesis. The test shows great success. The final hypothesis has a hit rate (per­ centage of time getting the direction right) of 52.13. This may seem modest, but in the world of finance you can make a lot of money if you get that hit rate consistently. Indeed, over the 500 test days (2 years worth, as each year has about 250 trading days), the cumulative profit of the system is a respectable 223. 174 5. THREE LEARNING PRINCIPLES 100 200 300 Day 5.3. DATA SNOOPING 400 500 When the system is used in live trading, the performance deteriorates sig­ nificantly. In fact, it loses money. Why didn't the good test performance continue on the new data? In this case, there is a simple explanation and it has to do with data snooping. Although the bank was careful to set aside test points that were not used for training in order to properly evaluate the final hypothesis, the test data had in fact affected the training process in a subtle way. When the original series of daily changes was normalized to zero mean and unit variance, all of the data was involved in this step. Therefore , the test data that was extracted had already contributed to the choices made by the learning algorithm by contributing to the values of the mean and the variance that were used in normalization. Although this seems like a minor effect, it is data snooping. When you plot the cumulative profit on the test set with or without that snooping step, you see how snooping resulted in an over-optimistic expectation compared to the realistic expectation that avoids snooping. It is not the normalization that was a bad idea. It is the involvement of test data in that normalizat ion, which contaminated this data and rendered its estimate of the final performance inaccurate. D One of the most common occurrences of data snooping is the reuse of the same data set. If you try learning using first one model and then another and then another on the same data set, you will eventually 'succeed'. As the saying goes, if you torture the data long enough, it will confess ©. If you try all possible dichotomies, you will eventually fit any data set; this is true whether we try the dichotomies directly (using a single model) or indirectly (using a sequence of models). The effective VC dimension for the series of trials will not be that of the last model that succeeded, but of the entire union of models that could have been used depending on the outcomes of different trials. Sometimes the reuse of the same data set is carried out by different people. Let's say that there is a public data set that you would like to work on. Before you download the data, you read about how other people did with this data set 175 5. THREE LEARNING PRINCIPLES 5.3. DATA SNOOPING using different techniques. You naturally pick the most promising techniques as a baseline, then try to improve on them and introduce your own ideas. Although you haven't even seen the data set yet, you are already guilty of data snooping. Your choice of baseline techniques was affected by the data set, through the actions of others. You may find that your estimates of the performance will turn out to be too optimistic, since the techniques you are using have already proven well-suited to this particular data set. To quantify the damage done by data snooping, one has to assess the penalty for model complexity in (2.14) taking the snooping into consideration. In the public data set case, the effective VC dimension corresponds to a much bigger hypothesis set than the 1-l that your learning algorithm uses. It covers all hypotheses that were considered (and mostly rejected) by everybody else in the process of coming up with the solutions that they published and that you used as your baseline. This is a potentially huge set with very high VC dimension, hence the generalization guarantees in (2.14) will be much worse than without data snooping. Not all data sets subjected to data snooping are equally 'contamina ted'. The bounds in (1.6) in the case of a choice between a finite number of hy­ potheses, and in (2.12) in the case of an infinite number, provide guidelines for the level of contamination. The more elaborate the choice made based on a data set, the more contaminated the set becomes and the less reliable it will be in gauging the performance of the final hypothesis. Exercise 5.5 Assume we set aside 100 examples from that will not be used in training, but will be used to select one of three final hypotheses 91, 92, 93 produced by three different learning algorithms that train on the rest on the data. Each algorithm works with a different of size 500. We would like to characterize the accuracy of estimating Eout(9) on the selected final hypothesis if we use the same 100 examples to make that estimate. (a) What is the value of that should be used in (1.6) in this situation? (b) How does the level of contamination of these 100 examples compare to the case where they would be used in training rather than in the final selection? In order to deal with data snooping, there are basically two approaches. 1. Avoid data snooping: A strict discipline in handling the data is required. Data that is going to be used to evaluate the final performance should be 'locked in a safe' and only brought out after the final hypothesis has been decided. If intermediate tests are needed, separate data sets should be used for that. Once a data set has been used, it should be treated as contaminated as far as testing the performance is concerned. 2. Account for data snooping: If you have to use a data set more than once, keep track of the level of contamination and treat the reliability of 176 5. THREE LEARNING PRINCIPLES 5.3. DATA SNOOPING your performance estimates in light of this contamina tion. The bounds (1.6) and (2.12) can provide guidelines for the relative reliability of dif­ ferent data sets that have been used in different roles within the learning process. Data snooping versus sampling bias. Sampling bias was defined based on how the data was obtained before any learning; data snooping was defined based on how the data affected the learning, in particular how the learning model is selected. These are obviously different concepts. However, there are cases where sampling bias occurs as a consequence of 'snooping' looking at data that you are not supposed to look at. Here is an example. Consider predicting the performance of different stocks based on historical data. In order to see if a prediction rule is any good, you take all currently traded companies and test the rule on their stock data over the past 50 years. Let us say that you are testing the \"buy and hold\" strategy, where you would have bought the stock 50 years ago and kept it until now. If you test this 'hypothesis ', you will get excellent performance in terms of profit. Well, don't get too excited! You inadvertently biased the results in your favor by picking only currently traded companies, which means that the companies that did not make it are not part of your evaluation. When you put your prediction rule to work, it will be used on all companies whether they will survive or not, since you cannot identify which companies today will be the 'currently traded' companies 50 years from now. This is a typical case of sampling bias, since the problem is that the training data is not representative of the test data. However, if we trace the origin of the bias, we did 'snoop' in this case by looking at future data of companies to determine which of these companies to use in our training. Since we are using information in training that we would not have access to in real trading, this is viewed as a form of data snooping. 177 5. THREE LEARNING PRINCIPLES 5.4. PROBLE.MS 5.4 Problems Problem 5.1 The idea of falsifiability -that a claim can be rendered false by observed data -is an important principle in experimental science. Axiom of Non-Falsifiabil ity. If the outcome of an experiment has no chance of falsifying a particular proposition, then the result of that experiment does not provide evidence one way or another toward the truth of the proposition. Consider the proposition 'There is h E 1-l that approximates f as would be evidenced by finding such an h with insample error zero on x1, · · · , XN .\" We say that the proposition is falsified if no hypothesis in 1-l can fit the data perfectly. (a) Suppose that 1-l shatters x1, · · · , XN. Show that this proposition is not falsifiable for any f. (b) Suppose that f is random (f(x) = ±1 with probability�. independen tly on every x), so Eout(h) = � for every h E 1-l. Show that IfD[falsification] � 1 - . (c) Suppose dvc = 10 and N = 100. If you obtain a hypothesis h with zero Ein on your data, what can you 'conclude' from the result in part (b )? Problem 5.2 Structural Risk Minimization (SRM) is a useful framework for model selection that is related to Occam's Razor. Define a structure -a nested sequence of hypothesis sets: The SRM framework picks a hypothesis from each 1-li by mm1m1zmg Ein· That is, 9i = argmin Ein(h). Then, the framework selects the final hy­ hErli pothesis by minimizing Ein and the model complexity penalty n. That is, g* = argmin(Ein(9i)+D(1-li)). Note that D(1-li) should be non decreasing in i i=l,2,.·· because of the nested structure. (a) Show that the insample error Ein(9i) is non increasing in i. 178 5. THREE LEARNING PRINCIPLES 5.4. PROBLEMS ( b) Assume that the framework finds g* E 1-li with proba bi I ity Pi. How does Pi relate to the complexity of the target function? (c) Argue that the Pi1S are unknown but po :S p1 :S p2 :S · · · :S 1. (d) Suppose g* = 9i· Show that IP[IEin(9i) -Eout(gi)I >EI g* = gi] :S 2_ · 4m1-1,i(2N)eE2N/s. Pi Here, the conditioning is on selecting gi as the final hypothesis by SRM. [Hint: Use the Bayes theorem to decompose the probability and then apply the VC bound on one of the terms} You may interpret this result as follows: if you use SRM and end up with gi, then the generalization bound is a factor -!; worse than the bound you would have gotten had you simply started with 1-li. Problem 5.3 In our credit card example, the bank starts with some vague idea of what constitutes a good credit risk. So, as customers x1, x2, ... , XN arrive, the bank applies its vague idea to approve credit cards for some of these customers. Then, only those who got credit cards are monitored to see if they default or not. For simplicity, suppose that the first N customers were given credit cards. Now that the bank knows the behav ior of these customers, it comes to you to improve their algorithm for approving credit. The bank gives you the data (x1,y1), ... '(xN,YN). Before you look at the data, you do mathematical derivations and come up with a credit approval function. You now test it on the data and, to your delight, obtain perfect prediction. (a) What is M, the size of your hypothesis set? (b) With such an M, what does the Hoeffding bound say about the probability that the true performance is worse than 2% error for N = 10000? ( c) You give your g to the bank and assure them that the performance will be better than 2% error and your confidence is given by your answer to part (b ). The bank is thrilled and uses your g to approve credit for new clients. To their dismay, more than half their credit cards are being defaulted on. Explain the possible reason(s) behind this outcome. ( d) Is there a way in which the bank could use your credit approval function to have your probabilistic guarantee? How? [Hint: The answer is yes!} 179 5. THREE LEARNING PRINCIPLES 5.4. PROBLEMS Problem 5.4 The S&P 500 is a set of the largest 500 companies currently trading. Suppose there are 10, 000 stocks currently trading, and there have been 50, 000 stocks which have ever traded over the last 50 years (some of these have gone bankrupt and stopped trading). We wish to evaluate the profitability of various 'buy and hold' strategies using these 50 years of data (roughly 12, 500 trading days). Since it is not easy to get stock data, we will confine our analysis to today's S&P 500 stocks, for which the data is readily available. (a) A stock is profitable if it went up on more than 50% of the days. Of your S&P stocks, the most profitable went up on 52% of the days (Ein = 0.48). (i) Since we picked the best among 500, using the Hoeffding bound, IP[IEin -Eoutl > 0.02] :: 2 x 500 x e-2x125ooxo.o22 � 0.045. There is a greater than 95% chance this stock is profitable. Where did we go wrong? (ii) Give a better estimate for the probability that this stock is profitable. [Hint: What should the correct M be in the Hoeffding bound?] (b) We wish to evaluate the profitability of 'buy and hold' for general stock trading. We notice that all of our 500 S&P stocks went up on at least 51% of the days. (i) We conclude that buying and holding a stocks is a good strategy for general stock trading. Where did we go wrong? (ii) Can we say anything about the performance of buy and hold trading? Problem 5.5 You think that the stock market exhibits reversal, so if the price of a stock sharply drops you expect it to rise shortly thereafter. If it sharply rises, you expect it to drop shortly thereafter. To test this hypothesis, you build a trading strategy that buys when the stocks go down and sells in the opposite case. You collect historical data on the current S&P 500 stocks, and your hypothesis gave a good annual return of 12%. (a) When you trade using this system, do you expect it to perform at this level? Why or why not? (b) How can you test your strategy so that its performance in sample is more reflective of what you should expect in reality? Problem 5.6 One often hears \"Extrapolation is harder than interpolation.\" Give a possible explanation for this phenomenon using the principles in this chapter. [Hint: training distribution versus testing distribution.} 180 Epilogue This book set the stage for a deeper exploration into Learning From Data by developing the foundations . It is possible to learn from data, and you have all the basic tools to do so. The linear model coupled with the right features and an appropriate nonlinear transform, together with the right amount of regulariza tion, pretty much puts you into the thick of the game, and you will be in good stead as long as you keep in mind the three basic principles: simple is better (Occam's razor), avoid data snooping and beware of sampling bias. Where to go from here? There are two main directions. One is to learn more sophisticated learning techniques, and the other is to explore different learning paradigms. Let us preview these two directions to give the reader a better understanding of the 'map' of learning from data. The linear model can be used as a building block for other popular tech­ niques. A cascade of linear models, mostly with soft thresholds , creates a neural network. A robust algorithm for linear models, based on quadratic programming, creates support vector machines. An efficient approach to non­ linear transformation in support vector machines creates kernel methods. A combination of different models in a principled way creates boosting and en­ semble learning. There are other successful models and techniques, and more to come for sure. In terms of other paradigms, we have briefly mentioned unsupervised learn­ ing and reinforcement learning. There is a wealth of techniques for these learn­ ing paradigms, including methods that mix labeled and unlabeled data. Active learning and online learning, which we also mentioned briefly, have their own techniques and theories. In addition, there is a school of thought that treats learning as a completely probabilistic paradigm using a Bayesian approach, and there are useful probabilistic techniques such as Gaussian processes. Last but not least, there is a school that treats learning as a branch of the theory of computational complexity, with emphasis on asymptotic results. Of course, the ultimate test of any engineering discipline is its impact in real life. There is no shortage of successful applications of learning from data. Some of the application domains have specialized techniques that are worth exploring, e.g., computational finance and recommender systems. Learning from data is a very dynamic field. Some of the hot techniques and theories at times become just fads, and others gain traction and become 181 EPILOGUE part of the field. What we have emphasized in this book are the necessary fundamentals that give any student of learning from data a solid foundation, and enable him or her to venture out and explore further techniques and theories, or perhaps to contribute their own. 182 Further Reading Learning From Data book forum (at AMLBook.com). Y. S. Abu-Mosta fa. The Vapnik-C hervonenkis dimension: Information versus complexity in learning. Neural Computation, 1(3):312317, 1989. Y. S. Abu-Mosta fa, X. Song, A. Nicholson, and M. Magdon-Ismail. The bin model. Technical Report CaltechCSTR:2004.002, California Institute of Technology, 2004. R. Ariew. Ockham 's Razor: A Historical and Philosophical Analysis of Ock­ ham 's Principle of Parsimony. University of Illinois Press, 1976. R. Bell, J. Bennett, Y. Koren, and C. Volinsky. The million dollar program­ ming prize. IEEE Spectrum, 46(5):2933, 2009. A. Blumer, A. Ehrenfeucht , D. Haussler, and M. K. Warmuth. Occam's razor. Information Processing Letters, 24(6):377380, 1987. A. Blumer, A. Ehrenfeucht , D. Haussler, and M. K. Warmuth. Learnability and the Vapnik-Chervonenkis dimension. Journal of the Association for Computing Machinery, 36( 4) :929965, 1989. S. Boyd and L. Vandenberghe. Convex Optimization. Cambridge University Press, 2004. P. Burman. A comparative study of ordinary cross-valida tion, v-fold cross­ validation and the repeated learning-testing methods. Biometrika, 76(3): 503 514, 1989. T. M. Cover. Geometrical and statistical properties of systems of linear in­ equalities with applications in pattern recognition. IEEE Transactions on Electronic Computers, 14(3):326 334, 1965. M. H. DeGroot and M. J. Schervish. Probability and Statistics. Addison Wesley, fourth edition, 2011. 183 FURTHER READING V. Fabian. Stochastic approximation methods. Czechoslovak Mathematical Journal, 10(1):123159, 1960. W. Feller. An Introduction to Probability Theory and Its Applications. Wiley, third edition, 1968. A. Frank and A. Asuncion. UCI machine learning repository, 2010. URL http://archive.ics.uci.edu/ml. J. H. Friedman. On bias, variance, 0 /1 loss, and the curse-of-dimensionality. Data Mining and Knowledge Discovery, 1(1):5577, 1997. S. I. Gallant. Perceptron-based learning algorithms . IEEE Transactions on Neural Networks, 1(2):179-191, 1990. Z. Ghahramani . Unsupervised learning. In Advanced Lectures in Machine Learning {MLSS '03 ), pages 72112, 2004. G. H. Golub and C. F. van Loan. Matrix computations. Johns Hopkins Uni­ versity Press, 1996. D. C. Hoaglin and R. E. Welsch. The hat matrix in regression and ANOVA. American Statistician, 32:17-22, 1978. W. Hoeffding. Probability inequalities for sums of bounded random variables. Journal of the American Statistical Association, 58(301):1330, 1963. R. C. Holte. Very simple classification rules perform well on most commonly used datasets. Machine Learning, 11(1):6391, 1993. R. A. Horn and C. R. Johnson. Matrix Analysis. Cambridge University Press, 1990. L. P. Kaelbling, M. L. Littman, and A. W. Moore. Reinforcement learning: A survey. Journal of Artificial Intelligence Research, 4:237285, 1996. A. I. Khuri. Advanced calculus with applications in statistics. Wiley­ Interscience, 2003. R. Kohavi. A study of cross-validation and bootstrap for accuracy estimation and model selection. In Proceedings of the 14th International Joint Con­ ference on Artificial intelligence (IJCAI '95), volume 2, pages 11371143, 1995. J. Langford. Tutorial on practical prediction theory for classification. Journal of Machine Learning Research, 6:273306, 2005. 184 FURTHER READING L. Li and H.-T. Lin. Optimizing 0 /1 loss for perceptrons by random coordinate descent. In Proceedings of the 2007 International Joint Conference on Neural Networks (IJCNN '07), pages 749 754, 2007. H.-T. Lin and L. Li. Support vector machinery for infinite ensemble learning. Journal of Machine Learning Research, 9(2):285-312, 2008. M. Magdon-Ismail and K. Mertsalov. A permutation approach to validation. Statistical Analysis and Data Mining, 3(6):361-380, 2010. M. Magdon-Ismail, A. Nicholson, and Y. S. Abu-Mostafa. Learning in the presence of noise. In S. Haykin and B. Kosko, editors, Intelligent Signal Processing. IEEE Press, 2001. M. Markatou, H. Tian, S. Biswas, and G. Hripcsak. Analysis of variance of cross-validation estimators of the generalization error. Journal of Machine Learning Research, 6:1127 1168, 2005. M. L. Minsky and S. Papert. Perceptro ns: An Introduction to Computat ional Geometry. MIT Press, expanded edition, 1988. T. Poggio and S. Smale. The mathematics of learning: Dealing with data. Notices of the American Mathematical Society, 50(5):537544, 2003. K. Popper. The logic of scientific discovery. Routledge , 2002. F. Rosenblatt. The perceptron: A probabilistic model for information storage and organization in the brain. Psychological Review, 65(6):386 408, 1958. F. Rosenblatt. Principles of Neurodynamics: Perceptrons and the Theory of Brain Mechanisms. Spartan, 1962. B. Settles. Active learning literature survey. Technical Report 1648, University of Wisconsin-Madison, 2010. J. Shawe-Ta ylor, P. L. Bartlett, R. C. Williamson, and M. Anthony. A frame­ work for structural risk minimisation. In Learning Theory: 9th Annual Conference on Learning Theory (COLT '96), pages 68 76, 1996. L. G. Valiant. A theory of the learnable. Communi cations of the ACM, 27 (11):11341142, 1984. V. N. Vapnik and A. Y. Chervonenk is. On the uniform convergence of relative frequencies of events to their probabilities. Theory of Probability and Its Applications, 16:264280, 1971. 185 V. N. Vapnik, E. Levin, and Y. L. Cun. Measuring the VO-dimension of a learning machine. Neural Computation, 6(5):851876, 1994. G.-X. Yuan, C.-H. Ho, and C.-J. Lin. Recent advances of large-scale linear classification. Proceedings of IEEE, 2012. T. Zhang. Solving large scale linear prediction problems using stochastic gra­ dient descent algorithms. In Machine Learning: Proceedings of the 21th International Conference (ICML '04), pages 919926, 2004. 186 Appendix Proof of the VC Bound In this Appendix, we present the formal proof of Theorem 2.5. It is a fairly elaborate proof, and you may skip it altogether and just take the theorem for granted, but you won't know what you are missing © ! Theorem A.1 (Vapnik, Chervonenkis , 1971). Jp> [sup IEin(h) Eout(h)I >El :S 4mH(2N)e-iE2N. hEH This inequality is called the VC Inequality, and it implies the VC bound of Theorem 2.5. The inequality is valid for any target function (deterministic or probabilistic) and any input distribution. The probability is over data sets of size N. Each data set is generated iid (independent and identically distributed), with each data point generated independently according to the joint distribution P(x, y). The event suphEH IEin(h) Eout(h)I >Eis equiva­ lent to the union over all h E 1-l of the events IEin(h)Eout(h)I > t; this union contains the event that involves gin Theorem 2.5. The use of the supremum (a technical version of the maximum) is necessary since 1-l can have a continuum of hypotheses. The main challenge to proving this theorem is that Eout ( h) is difficult to manipulate compared to Ein(h), because Eout(h) depends on the entire input space rather than just a finite set of points. The main insight needed to over­ come this difficulty is the observation that we can get rid of Eout ( h) altogether because the deviations between Ein and Eout can be essentially captured by deviations between two in-sample errors: Ein (the original in-sample error) and the in-sample error on a second independent data set (Lemma A.2). We have seen this idea many times before when we use a test or validation set to estimate Eout. This insight results in two main simplifications : 1. The supremum of the deviations over infinitely many h E 1-l can be reduced to considering only the dichotomies implementable by 1-l on the 187 APPENDIX two independent data sets. That is where the growth function mH(2N) enters the picture (Lemma A.3). 2. The deviation between two independent in-sample errors is 'easy' to an­ alyze compared to the deviation between Ein and Eout (Lemma A.4). The combination of Lemmas A.2, A.3 and A.4 proves Theorem A.l. A.1 Relating Generaliza tion Error to In-Sample Deviations Let's introduce a second data set 'D', which is independ ent of 'D, but sampled according to the same distribution P(x, y). This second data set is called a ghost data set because it doesn't really exist; it is a just a tool used in the analysis. We hope to bound the term JP>[IEin Eout I is large) by another term JP>[IEin E[n I is large), which is easier to analyze. The intuition behind the formal proof is as follows. For any single hypoth­ esis h, because 'D' is fresh, sampled independently from P(x, y), the Hoeffding Inequality guarantees that E[n(h) � Eout(h) with a high probability. That is, when IEin(h) Eout(h)I is large, with a high probability IEin(h) E[n(h)I is also large. Therefore, JP>[IEin(h) Eout(h)I is large) can be approximately bounded by JP>[IEin(h) E{n(h)I is large). We are trying to bound the probabil­ ity that Ein is far from Eout. Let E{n ( h) be the 'in-sample' error for hypothesis h on 'D'. Suppose that Ein is far from Eout with some probability (and similarly E{n is far from Eout, with that same prob­ ability, since Ein and E[n are identically distributed). When N is large, the proba­ bility is roughly Gaussian around Eout, as illustrated in the figure to the right. The red region represents the cases when Ein is far from Eout. In those cases, E{n is far from Ein about half the time, as illustrated by the green region. That is, JP>[IEin Eout I is large] can be approximately bounded by 2 JP> [IEin E{nl is large]. This argument provides some intuition that the deviations between Ein and Eout can be captured by the deviations between Ein and E[n. The argu­ ment can be carefully extended to multiple hypotheses. Lemma A.2. where the probability on the RHS is over 'D and 'D' jointly. 188 APPENDIX Proof. We can assume that IF [sup JEin(h) Eout(h)J >El > 0, otherwise hE1-l there is nothing to prove. JP> [sup JEin(h) E{n(h)J > �1 hE1-l > JP> [sup JEin(h) E{n(h)J > � and sup JEin(h) Eout(h)J >El (A.1) hE1-l hE1-l JP> [sup JEin(h) Eout(h)J >El X hE1-l JP> [sup JEin(h) E{n(li)J > �I sup JEin(h) Eout(h)J >El . hE1-l hE1-l Inequality (A.1) follows because JP>[B1] � JP>[B1 and 82] for any two events Bi, 82• Now, let's consider the last term: JP> [sup JEin(h) E{n(h)J > �I sup JEin(h) Eout(h)J >El . hE1-l hE1-l The event on which we are conditioning is a set of data sets with non-zero probability. Fix a data set V in this event. Let h* be any hypothesis for which JEin(h*) Eout(h*)J > E. One such hypothesis must exist given that V is in the event on which we are conditioning. The hypothesis h * does not depend on V', but it does depend on V. JP> [sup JEin(h) E{n(h)J > �I sup JEin(h) Eout(h)J >El hE1-l hE1-l > I!' [IE;n(h*) E{n(h*)J > � I ��� IE;n(h) Eout(h)I > El (A.2) > I!' [IE{u(h*) Eout(h*)J S � I ��� IE;n(h) Eout(h)J > El (A.3) > 1 -2e�t2 N. (A.4) 1. Inequality (A.2) follows because the event \"JEin(h*) E{n(h*)J > f' implies \"sup JEin(h) E{n(h)J > f'. hE1-l 2. Inequality (A.3) follows because the events \"JE{n(h*) Eout(h*)J ::; f' and \"JEin(h*) Eout(h*)J > E\" (which is given) imply\"JEin(h) E{n(h)J > t\" 2· 3. Inequality (A.4) follows because h* is fixed with respect to V' and so we can apply the Hoeffding Inequality to JP>[JE{n(h*) Eout(h*)J :'SH Notice that the Hoeffding Inequality applies to IF[JE{n(h*) Eout(h*)J ::; �] for any h*, as long as h* is fixed with respect to V'. Therefore, it also applies 189 APPENDIX to any weighted average of JP[IE{n(h*) Eout(h* )·I :S i] based on h*. Finally, since h * depends on a particular V, we take the weighted average over all V in the event \"sup IEin(h) Eout(h)I > E\" hEH on which we are conditioning, where the weight comes from the probability of the particula r V. Since the bound holds for every V in this event, it holds for the weighted av erage. II Note that we can assume e-� E2 N < -Jt, because otherwise the bound in Theorem A.1 is trivially true. In this case, 1 2e-�E2N > �'so the lemma implies A.2 JP [sup IEin(h) -Eout(h)I >El :S 2JP [sup IEin(h) -E{n(h)I > i] · hEH hEH Bounding Worst Case Deviation Using the Growth Function Now that we have related the generalization error to the deviations between in-sample errors, we can actually work with }{ restricted to two data sets of size N each, rather than the infinite}{. Specifically, we want to bound IF [sup IEin(h) -E{n(h)I > i], hEH where the probability is over the joint distribution of the data sets V and V'. One equivalent way of sampling two data sets V and V' is to first sample a data set S of size 2N, then randomly partition S into V and V'. This amounts to randomly sampling, without replacement, N examples from S for V, leaving the remaining for V'. Given the joint data set S, let be the probability of deviation between the two in-sample errors, where the probability is taken over the random partitions of S into V and V'. By the law of total probability (with I: denoting sum or integral as the case may be), IF [sup IEin(h) -E{n(h)I > i] hEH LIF[S] x JP [sup IEin(h) E{n(h)I > i Is] S hEH < s�p IP' [��� [E1n(h) E[0(h)[ > � IS l · 190 APPENDIX Let 1-l ( S) be the dichotomies that 1-l can implement on the points in S. By definition of the growth function, 1-l(S) cannot have more than mH (2N) di­ chotomies. Suppose it has M :: mH (2N) dichotomies, realized by h1, ... , hM. Thus, Then, sup IEin(h) -E[n(h)I = sup /Ein(h) -E[n(h)I. hEH hE{h1, ... ,hM} IP' r��� fEin(h) E{n (li)I > � Isl JP [ sup IEin(h) -E[n(h)I > �Is] hE{h1, ... ,hM} M < :L JP [IEin(hm) -E[n(hm)/ > �I SJ m=l < M X sup JP [IEin(h) -E[n(h)I > � j SJ, hEH (A.5) (A.6) where we use the union bound in (A.5), and overestimate each term by the supremum over all possible hypotheses to get (A.6). After using M :: mH(2N) and taking the sup operation over S, we have proved: Lemma A.3. JP [sup IEin(h) -E[11(h)I > �1 hEH < mH(2N) X sup sup JP [IEin(h) -E[n(h)/ >�I SJ, S hEH where the probability on the LHS is over D and D' jointly, and the probability on the RHS is over random partitions of S into two sets D and D'. The main achievement of Lemma A.3 is that we have pulled the supre­ mum over h E 1-l outside the probability, at the expense of the extra factor of mH ( 2N). A.3 Bounding the Deviation between In-Sample Errors We now address the purely combinatorial problem of bounding sup sup JP [IEin(h) E{11(h)I > � j SJ , S hEH which appears in Lemma A.3. We will prove the following lemma. Then, Theorem A.l can be proved by combining Lemmas A.2, A.3 and A.4 taking 1 2e-�E2N 2: � (the only case we need to consider). 191 APPENDIX Lemma A.4. For any h and any S, where the probability is over random partitions of S into two sets 'D and 'D'. Proof. To prove the result, we will use a result, which is also due to Hoeffding, for sampling without replacement : Lemma A.5 (Hoeffding, 1963). Let A= {a1, ... , a2N} be a set of values with an E [O, 1], and letµ= 2:��1 an be their mean. Let 'D = {z1, ... , ZN} be a sample of size N, sampled from A uniformly without replacement . Then We apply Lemma A.5 as follows. For the 2N examples in S, let an = 1 if h(xn) -=f. Yn and an = 0 otherwise. The {an} are the errors made by h on S. Now randomly partition S into 'D and 'D', i.e., sample N examples from S without replacement to get V, leaving the remaining N examples for 'D'. This results in a sample of size N of the {an} for 'D, sampled uniformly without replacement. Note that Ein(h) = � L an, and E{n(h) = � L a�. an EV a'nEV' Since we are sampling without replacement, S = 'D U 'D' and 'D n 'D' = 0, and so _ 1 Ein(h) + E{n(h) µ2N - 2 . nl It follows that IEin - µI> t {: IEin E{nl > 2t. By Lemma A.5, Substituting t = � gives the result. 192 II /C6/D3/D8/CP/D8/CX/D3/D2/AG· /AH /CT/DA /CT/D2 /D8 /B4/CX/D2 /D4/D6/D3/CQ/CP/CQ/CX/D0/CX/D8 /DD/B5 {···} /D7/CT/D8 |·| /CP/CQ/D7/D3/D0/D9/D8/CT /DA /CP/D0/D9/CT /D3/CU /CP /D2 /D9/D1 /CQ /CT/D6/B8 /D3/D6 /CP/D6/CS/CX/D2/CP/D0/CX/D8 /DD /B4/D2 /D9/D1 /CQ /CT/D6 /D3/CU /CT/D0/CT/B9/D1/CT/D2 /D8/D7/B5 /D3/CU /CP /D7/CT/D8/B8 /D3/D6 /CS/CT/D8/CT/D6/D1/CX/D2/CP/D2 /D8 /D3/CU /CP /D1/CP/D8/D6/CX/DC /⌊a∇d⌊l·/⌊a∇d⌊l2/D7/D5/D9/CP/D6/CT /D3/CU /D8/CW/CT /D2/D3/D6/D1/BN /D7/D9/D1 /D3/CU /D8/CW/CT /D7/D5/D9/CP/D6/CT/CS /D3/D1/D4 /D3/D2/CT/D2 /D8/D7 /D3/CU /CP/DA /CT /D8/D3/D6 ⌊·⌋ /AT/D3 /D3/D6/BN /D0/CP/D6/CV/CT/D7/D8 /CX/D2 /D8/CT/CV/CT/D6 /DB/CW/CX /CW /CX/D7 /D2/D3/D8 /D0/CP/D6/CV/CT/D6 /D8/CW/CP/D2 /D8/CW/CT /CP/D6/CV/D9/D1/CT/D2 /D8 [a, b] /D8/CW/CT /CX/D2 /D8/CT/D6/DA /CP/D0 /D3/CU /D6/CT/CP/D0 /D2 /D9/D1 /CQ /CT/D6/D7 /CU/D6/D3/D1a /D8/D3b /llbracket·/rrbracket /CT/DA /CP/D0/D9/CP/D8/CT/D7 /D8/D3 /BD /CX/CU /CP/D6/CV/D9/D1/CT/D2 /D8 /CX/D7 /D8/D6/D9/CT/B8 /CP/D2/CS /D8/D3 /BC /CX/CU /CX/D8 /CX/D7 /CU/CP/D0/D7/CT ∇ /CV/D6/CP/CS/CX/CT/D2 /D8 /D3/D4 /CT/D6/CP/D8/D3/D6/B8 /CT/BA/CV/BA/B8∇E/CX/D2 /B4/CV/D6/CP/CS/CX/CT/D2 /D8 /D3/CUE/CX/D2(w) /DB/CX/D8/CW /D6/CT/B9/D7/D4 /CT /D8 /D8/D3w /B5 (·)−1/CX/D2 /DA /CT/D6/D7/CT (·)†/D4/D7/CT/D9/CS/D3/B9/CX/D2 /DA /CT/D6/D7/CT (·) /D8/D8/D6/CP/D2/D7/D4 /D3/D7/CT /B4 /D3/D0/D9/D1/D2/D7 /CQ /CT /D3/D1/CT /D6/D3 /DB/D7 /CP/D2/CS /DA/CX /CT /DA /CT/D6/D7/CP/B5/parenleftig N k/parenrightig/D2 /D9/D1 /CQ /CT/D6 /D3/CU /DB /CP /DD/D7 /D8/D3 /CW/D3 /D3/D7/CT k /D3/CQ /CY/CT /D8/D7 /CU/D6/D3/D1N /CS/CX/D7/D8/CX/D2 /D8 /D3/CQ /CY/CT /D8/D7/B4/CT/D5/D9/CP/D0/D7N! (N−k) ! k! /DB/CW/CT/D6/CT /CO /AX/B3 /CX/D7 /D8/CW/CT /CU/CP /D8/D3/D6/CX/CP/D0/B5 A\\B /D8/CW/CT /D7/CT/D8A /DB/CX/D8/CW /D8/CW/CT /CT/D0/CT/D1/CT/D2 /D8/D7 /CU/D6/D3/D1 /D7/CT/D8B /D6/CT/D1/D3 /DA /CT/CS 0 /DE/CT/D6/D3 /DA /CT /D8/D3/D6/BN /CP /D3/D0/D9/D1/D2 /DA /CT /D8/D3/D6 /DB/CW/D3/D7/CT /D3/D1/D4 /D3/D2/CT/D2 /D8/D7 /CP/D6/CT /CP/D0/D0 /DE/CT/D6/D3/D7 {1}×Rdd /B9/CS/CX/D1/CT/D2/D7/CX/D3/D2/CP/D0 /BX/D9 /D0/CX/CS/CT/CP/D2 /D7/D4/CP /CT /DB/CX/D8/CW /CP/D2 /CP/CS/CS/CT/CS /CO/DE/CT/D6/D3/D8/CW /D3 /D3/D6/B9/CS/CX/D2/CP/D8/CT/B3 /AS/DC/CT/CS /D8/D3 /BD ǫ /D8/D3/D0/CT/D6/CP/D2 /CT /CX/D2 /CP/D4/D4/D6/D3 /DC/CX/D1/CP/D8/CX/D2/CV /CP /D8/CP/D6/CV/CT/D8 δ /CQ /D3/D9/D2/CS /D3/D2 /D8/CW/CT /D4/D6/D3/CQ/CP/CQ/CX/D0/CX/D8 /DD /D3/CU /CT/DC /CT/CT/CS/CX/D2/CV ǫ /B4/D8/CW/CT /CP/D4/D4/D6/D3 /DC/CX/D1/CP/D8/CX/D3/D2/D8/D3/D0/CT/D6/CP/D2 /CT/B5 η /D0/CT/CP/D6/D2/CX/D2/CV /D6/CP/D8/CT /B4/D7/D8/CT/D4 /D7/CX/DE/CT /CX/D2 /CX/D8/CT/D6/CP/D8/CX/DA /CT /D0/CT/CP/D6/D2/CX/D2/CV/B8 /CT/BA/CV/BA/B8 /CX/D2 /D7/D8/D3 /CW/CP/D7/B9/D8/CX /CV/D6/CP/CS/CX/CT/D2 /D8 /CS/CT/D7 /CT/D2 /D8/B5 λ /D6/CT/CV/D9/D0/CP/D6/CX/DE/CP/D8/CX/D3/D2 /D4/CP/D6/CP/D1/CT/D8/CT/D6 λC /D6/CT/CV/D9/D0/CP/D6/CX/DE/CP/D8/CX/D3/D2 /D4/CP/D6/CP/D1/CT/D8/CT/D6 /D3/D6/D6/CT/D7/D4 /D3/D2/CS/CX/D2/CV /D8/D3 /DB /CT/CX/CV/CW /D8 /CQ/D9/CS/CV/CT/D8 C Ω /D4 /CT/D2/CP/D0/D8 /DD /CU/D3/D6 /D1/D3 /CS/CT/D0 /D3/D1/D4/D0/CT/DC/CX/D8 /DD/BN /CT/CX/D8/CW/CT/D6 /CP /CQ /D3/D9/D2/CS /D3/D2 /CV/CT/D2/CT/D6/CP/D0/B9/CX/DE/CP/D8/CX/D3/D2 /CT/D6/D6/D3/D6/B8 /D3/D6 /CP /D6/CT/CV/D9/D0/CP/D6/CX/DE/CP/D8/CX/D3/D2 /D8/CT/D6/D1 θ /D0/D3/CV/CX/D7/D8/CX /CU/D9/D2 /D8/CX/D3/D2 θ(s) =es/(1 +es) Φ /CU/CT/CP/D8/D9/D6/CT /D8/D6/CP/D2/D7/CU/D3/D6/D1/B8 z= Φ(x) Φ/D5 Q /D8/CW/B9/D3/D6/CS/CT/D6 /D4 /D3/D0/DD/D2/D3/D1/CX/CP/D0 /D8/D6/CP/D2/D7/CU/D3/D6/D1/BD/BL/BF /C6/D3/D8 /CP /D8/CX/D3/D2 φ /CP /D3 /D3/D6/CS/CX/D2/CP/D8/CT /CX/D2 /D8/CW/CT /CU/CT/CP/D8/D9/D6/CT /D8/D6/CP/D2/D7/CU/D3/D6/D1 Φ /B8zi=φi(x) µ /D4/D6/D3/CQ/CP/CQ/CX/D0/CX/D8 /DD /D3/CU /CP /CQ/CX/D2/CP/D6/DD /D3/D9/D8 /D3/D1/CT ν /CU/D6/CP /D8/CX/D3/D2 /D3/CU /CP /CQ/CX/D2/CP/D6/DD /D3/D9/D8 /D3/D1/CT /CX/D2 /CP /D7/CP/D1/D4/D0/CT σ2/DA /CP/D6/CX/CP/D2 /CT /D3/CU /D2/D3/CX/D7/CT A /D0/CT/CP/D6/D2/CX/D2/CV /CP/D0/CV/D3/D6/CX/D8/CW/D1/CP/D6/CV/D1/CX/D2a(·) /D8/CW/CT /DA /CP/D0/D9/CT /D3/CUa /CP/D8 /DB/CW/CX /CW /D8/CW/CT /D1/CX/D2/CX/D1 /D9/D1 /D3/CU /D8/CW/CT /CP/D6/CV/D9/D1/CT/D2 /D8 /CX/D7/CP /CW/CX/CT/DA /CT/CS B /CP/D2 /CT/DA /CT/D2 /D8 /B4/CX/D2 /D4/D6/D3/CQ/CP/CQ/CX/D0/CX/D8 /DD/B5/B8 /D9/D7/D9/CP/D0/D0/DD /CO/CQ/CP/CS/B3 /CT/DA /CT/D2 /D8 b /D8/CW/CT /CQ/CX/CP/D7 /D8/CT/D6/D1 /CX/D2 /CP /D0/CX/D2/CT/CP/D6 /D3/D1 /CQ/CX/D2/CP/D8/CX/D3/D2 /D3/CU /CX/D2/D4/D9/D8/D7/B8 /CP/D0/D7/D3 /CP/D0/D0/CT/CS w0/CQ/CX/CP/D7 /D8/CW/CT /CQ/CX/CP/D7 /D8/CT/D6/D1 /CX/D2 /CQ/CX/CP/D7/B9/DA /CP/D6/CX/CP/D2 /CT /CS/CT /D3/D1/D4 /D3/D7/CX/D8/CX/D3/D2 B(N, k) /D1/CP/DC/CX/D1 /D9/D1 /D2 /D9/D1 /CQ /CT/D6 /D3/CU /CS/CX /CW/D3/D8/D3/D1/CX/CT/D7 /D3/D2N /D4 /D3/CX/D2 /D8/D7 /DB/CX/D8/CW /CP /CQ/D6/CT/CP/CZ/D4 /D3/CX/D2 /D8 k C /CQ /D3/D9/D2/CS /D3/D2 /D8/CW/CT /D7/CX/DE/CT /D3/CU /DB /CT/CX/CV/CW /D8/D7 /CX/D2 /D8/CW/CT /D7/D3/CU/D8 /D3/D6/CS/CT/D6 /D3/D2/D7/D8/D6/CP/CX/D2 /D8 d /CS/CX/D1/CT/D2/D7/CX/D3/D2/CP/D0/CX/D8 /DD /D3/CU /D8/CW/CT /CX/D2/D4/D9/D8 /D7/D4/CP /CTX=Rd/D3/D6X={1}×Rd ˜d /CS/CX/D1/CT/D2/D7/CX/D3/D2/CP/D0/CX/D8 /DD /D3/CU /D8/CW/CT /D8/D6/CP/D2/D7/CU/D3/D6/D1/CT/CS /D7/D4/CP /CTZ d/DA /B8d/DA (H) /CE /BV /CS/CX/D1/CT/D2/D7/CX/D3/D2 /D3/CU /CW /DD/D4 /D3/D8/CW/CT/D7/CX/D7 /D7/CT/D8H D /CS/CP/D8/CP /D7/CT/D8D= (x1, y1),···,(xN, yN) /BN /D8/CT /CW/D2/CX /CP/D0/D0/DD /D2/D3/D8 /CP /D7/CT/D8/B8/CQ/D9/D8 /CP /DA /CT /D8/D3/D6 /D3/CU /CT/D0/CT/D1/CT/D2 /D8/D7 (xn, yn) /BAD /CX/D7 /D3/CU/D8/CT/D2 /D8/CW/CT /D8/D6/CP/CX/D2/CX/D2/CV/D7/CT/D8/B8 /CQ/D9/D8 /D7/D3/D1/CT/D8/CX/D1/CT/D7 /D7/D4/D0/CX/D8 /CX/D2 /D8/D3 /D8/D6/CP/CX/D2/CX/D2/CV /CP/D2/CS /DA /CP/D0/CX/CS/CP/D8/CX/D3/D2/BB/D8/CT/D7/D8/D7/CT/D8/D7/BA D/D8/D6/CP/CX/D2 /D7/D9/CQ/D7/CT/D8 /D3/CUD /D9/D7/CT/CS /CU/D3/D6 /D8/D6/CP/CX/D2/CX/D2/CV /DB/CW/CT/D2 /CP /DA /CP/D0/CX/CS/CP/D8/CX/D3/D2 /D3/D6 /D8/CT/D7/D8 /D7/CT/D8/CX/D7 /D9/D7/CT/CS/BA D/DA /CP/D0 /DA /CP/D0/CX/CS/CP/D8/CX/D3/D2 /D7/CT/D8/BN /D7/D9/CQ/D7/CT/D8 /D3/CUD /D9/D7/CT/CS /CU/D3/D6 /DA /CP/D0/CX/CS/CP/D8/CX/D3/D2/BA E(h, f) /CT/D6/D6/D3/D6 /D1/CT/CP/D7/D9/D6/CT /CQ /CT/D8 /DB /CT/CT/D2 /CW /DD/D4 /D3/D8/CW/CT/D7/CX/D7 h /CP/D2/CS /D8/CP/D6/CV/CT/D8 /CU/D9/D2 /D8/CX/D3/D2 f ex/CT/DC/D4 /D3/D2/CT/D2 /D8 /D3/CUx /CX/D2 /D8/CW/CT /D2/CP/D8/D9/D6/CP/D0 /CQ/CP/D7/CTe= 2.71828···/CT(h(x), f(x)) /D4 /D3/CX/D2 /D8 /DB/CX/D7/CT /DA /CT/D6/D7/CX/D3/D2 /D3/CUE(h, f) /B8 /CT/BA/CV/BA/B8(h(x)−f(x))2/CTn /D0/CT/CP /DA /CT/B9/D3/D2/CT/B9/D3/D9/D8 /CT/D6/D6/D3/D6 /D3/D2 /CT/DC/CP/D1/D4/D0/CT n /DB/CW/CT/D2 /D8/CW/CX/D7n /D8/CW /CT/DC/CP/D1/D4/D0/CT /CX/D7/CT/DC /D0/D9/CS/CT/CS /CX/D2 /D8/D6/CP/CX/D2/CX/D2/CV /CJ /D6/D3/D7/D7 /DA /CP/D0/CX/CS/CP/D8/CX/D3/D2℄ E[·] /CT/DC/D4 /CT /D8/CT/CS /DA /CP/D0/D9/CT /D3/CU /CP/D6/CV/D9/D1/CT/D2 /D8 Ex[·] /CT/DC/D4 /CT /D8/CT/CS /DA /CP/D0/D9/CT /DB/CX/D8/CW /D6/CT/D7/D4 /CT /D8 /D8/D3x E[y|x] /CT/DC/D4 /CT /D8/CT/CS /DA /CP/D0/D9/CT /D3/CUy /CV/CX/DA /CT/D2x E/CP/D9/CV /CP/D9/CV/D1/CT/D2 /D8/CT/CS /CT/D6/D6/D3/D6 /B4/CX/D2/B9/D7/CP/D1/D4/D0/CT /CT/D6/D6/D3/D6 /D4/D0/D9/D7 /D6/CT/CV/D9/D0/CP/D6/CX/DE/CP/D8/CX/D3/D2 /D8/CT/D6/D1/B5 E/CX/D2 /B8E/CX/D2(h) /CX/D2/B9/D7/CP/D1/D4/D0/CT /CT/D6/D6/D3/D6 /B4/D8/D6/CP/CX/D2/CX/D2/CV /CT/D6/D6/D3/D6/B5 /CU/D3/D6 /CW /DD/D4 /D3/D8/CW/CT/D7/CX/D7 h E /DA /D6/D3/D7/D7 /DA /CP/D0/CX/CS/CP/D8/CX/D3/D2 /CT/D6/D6/D3/D6 E/D3/D9/D8 /B8E/D3/D9/D8(h) /D3/D9/D8/B9/D3/CU/B9/D7/CP/D1/D4/D0/CT /CT/D6/D6/D3/D6 /CU/D3/D6 /CW /DD/D4 /D3/D8/CW/CT/D7/CX/D7 h ED/D3/D9/D8 /D3/D9/D8/B9/D3/CU/B9/D7/CP/D1/D4/D0/CT /CT/D6/D6/D3/D6 /DB/CW/CT/D2D /CX/D7 /D9/D7/CT/CS /CU/D3/D6 /D8/D6/CP/CX/D2/CX/D2/CV ¯E/D3/D9/D8 /CT/DC/D4 /CT /D8/CT/CS /D3/D9/D8/B9/D3/CU/B9/D7/CP/D1/D4/D0/CT /CT/D6/D6/D3/D6 E/DA /CP/D0 /DA /CP/D0/CX/CS/CP/D8/CX/D3/D2 /CT/D6/D6/D3/D6 E/D8/CT/D7/D8 /D8/CT/D7/D8 /CT/D6/D6/D3/D6 f /D8/CP/D6/CV/CT/D8 /CU/D9/D2 /D8/CX/D3/D2/B8 f:X→Y g /AS/D2/CP/D0 /CW /DD/D4 /D3/D8/CW/CT/D7/CX/D7 g∈H /D7/CT/D0/CT /D8/CT/CS /CQ /DD /D8/CW/CT /D0/CT/CP/D6/D2/CX/D2/CV /CP/D0/CV/D3/D6/CX/D8/CW/D1/BN g:X→Y g(D)/AS/D2/CP/D0 /CW /DD/D4 /D3/D8/CW/CT/D7/CX/D7 /DB/CW/CT/D2 /D8/CW/CT /D8/D6/CP/CX/D2/CX/D2/CV /D7/CT/D8 /CX/D7D ¯g /CP /DA /CT/D6/CP/CV/CT /AS/D2/CP/D0 /CW /DD/D4 /D3/D8/CW/CT/D7/CX/D7 /CJ/CQ/CX/CP/D7/B9/DA /CP/D6/CX/CP/D2 /CT /CP/D2/CP/D0/DD/D7/CX/D7℄/BD/BL/BG /C6/D3/D8 /CP /D8/CX/D3/D2 g /AS/D2/CP/D0 /CW /DD/D4 /D3/D8/CW/CT/D7/CX/D7 /DB/CW/CT/D2 /D8/D6/CP/CX/D2/CT/CS /D9/D7/CX/D2/CVD /D1/CX/D2/D9/D7 /D7/D3/D1/CT /D4 /D3/CX/D2 /D8/D7 g /CV/D6/CP/CS/CX/CT/D2 /D8/B8 /CT/BA/CV/BA/B8g=∇E/CX/D2 h /CP /CW /DD/D4 /D3/D8/CW/CT/D7/CX/D7 h∈H /BNh:X→Y ˜h /CP /CW /DD/D4 /D3/D8/CW/CT/D7/CX/D7 /CX/D2 /D8/D6/CP/D2/D7/CU/D3/D6/D1/CT/CS /D7/D4/CP /CTZ H /CW /DD/D4 /D3/D8/CW/CT/D7/CX/D7 /D7/CT/D8 HΦ /CW /DD/D4 /D3/D8/CW/CT/D7/CX/D7 /D7/CT/D8 /D8/CW/CP/D8 /D3/D6/D6/CT/D7/D4 /D3/D2/CS/D7 /D8/D3 /D4 /CT/D6 /CT/D4/D8/D6/D3/D2/D7 /CX/D2Φ /B9/D8/D6/CP/D2/D7/CU/D3/D6/D1/CT/CS /D7/D4/CP /CT H(C) /D6/CT/D7/D8/D6/CX /D8/CT/CS /CW /DD/D4 /D3/D8/CW/CT/D7/CX/D7 /D7/CT/D8 /CQ /DD /DB /CT/CX/CV/CW /D8 /CQ/D9/CS/CV/CT/D8 C /CJ/D7/D3/CU/D8 /D3/D6/CS/CT/D6 /D3/D2/D7/D8/D6/CP/CX/D2 /D8℄ H(x1, . . . ,xN) /CS/CX /CW/D3/D8/D3/D1/CX/CT/D7 /B4/D4/CP/D8/D8/CT/D6/D2/D7 /D3/CU±1 /B5 /CV/CT/D2/CT/D6/CP/D8/CT/CS /CQ /DDH /D3/D2 /D8/CW/CT /D4 /D3/CX/D2 /D8/D7 x1,···,xN H /CC/CW/CT /CW/CP/D8 /D1/CP/D8/D6/CX/DC /CJ/D0/CX/D2/CT/CP/D6 /D6/CT/CV/D6/CT/D7/D7/CX/D3/D2℄ I /CX/CS/CT/D2 /D8/CX/D8 /DD /D1/CP/D8/D6/CX/DC/BN /D7/D5/D9/CP/D6/CT /D1/CP/D8/D6/CX/DC /DB/CW/D3/D7/CT /CS/CX/CP/CV/D3/D2/CP/D0 /CT/D0/CT/D1/CT/D2 /D8/D7 /CP/D6/CT 1 /CP/D2/CS /D3/AR/B9/CS/CX/CP/CV/D3/D2/CP/D0 /CT/D0/CT/D1/CT/D2 /D8/D7 /CP/D6/CT0 K /D7/CX/DE/CT /D3/CU /DA /CP/D0/CX/CS/CP/D8/CX/D3/D2 /D7/CT/D8 Lq q /D8/CW/B9/D3/D6/CS/CT/D6 /C4/CT/CV/CT/D2/CS/D6/CT /D4 /D3/D0/DD/D2/D3/D1/CX/CP/D0 ln /D0/D3/CV/CP/D6/CX/D8/CW/D1 /CX/D2 /CQ/CP/D7/CTe log2 /D0/D3/CV/CP/D6/CX/D8/CW/D1 /CX/D2 /CQ/CP/D7/CT2 M /D2 /D9/D1 /CQ /CT/D6 /D3/CU /CW /DD/D4 /D3/D8/CW/CT/D7/CT/D7 mH(N) /D8/CW/CT /CV/D6/D3 /DB/D8/CW /CU/D9/D2 /D8/CX/D3/D2/BN /D1/CP/DC/CX/D1 /D9/D1 /D2 /D9/D1 /CQ /CT/D6 /D3/CU /CS/CX /CW/D3/D8/D3/D1/CX/CT/D7 /CV/CT/D2/B9/CT/D6/CP/D8/CT/CS /CQ /DDH /D3/D2 /CP/D2 /DDN /D4 /D3/CX/D2 /D8/D7 max(·,·) /D1/CP/DC/CX/D1 /D9/D1 /D3/CU /D8/CW/CT /D8 /DB /D3 /CP/D6/CV/D9/D1/CT/D2 /D8/D7 N /D2 /D9/D1 /CQ /CT/D6 /D3/CU /CT/DC/CP/D1/D4/D0/CT/D7 /B4/D7/CX/DE/CT /D3/CUD /B5 o(·) /CP/CQ/D7/D3/D0/D9/D8/CT /DA /CP/D0/D9/CT /D3/CU /D8/CW/CX/D7 /D8/CT/D6/D1 /CX/D7 /CP/D7/DD/D1/D4/D8/D3/D8/CX /CP/D0/D0/DD /D2/CT/CV/D0/CX/CV/CX/CQ/D0/CT /D3/D1/B9/D4/CP/D6/CT/CS /D8/D3 /D8/CW/CT /CP/D6/CV/D9/D1/CT/D2 /D8 O(·) /CP/CQ/D7/D3/D0/D9/D8/CT /DA /CP/D0/D9/CT /D3/CU /D8/CW/CX/D7 /D8/CT/D6/D1 /CX/D7 /CP/D7/DD/D1/D4/D8/D3/D8/CX /CP/D0/D0/DD /D7/D1/CP/D0/D0/CT/D6 /D8/CW/CP/D2/CP /D3/D2/D7/D8/CP/D2 /D8 /D1 /D9/D0/D8/CX/D4/D0/CT /D3/CU /D8/CW/CT /CP/D6/CV/D9/D1/CT/D2 /D8 P(x) /B4/D1/CP/D6/CV/CX/D2/CP/D0/B5 /D4/D6/D3/CQ/CP/CQ/CX/D0/CX/D8 /DD /D3/D6 /D4/D6/D3/CQ/CP/CQ/CX/D0/CX/D8 /DD /CS/CT/D2/D7/CX/D8 /DD /D3/CUx P(y|x) /D3/D2/CS/CX/D8/CX/D3/D2/CP/D0 /D4/D6/D3/CQ/CP/CQ/CX/D0/CX/D8 /DD /D3/D6 /D4/D6/D3/CQ/CP/CQ/CX/D0/CX/D8 /DD /CS/CT/D2/D7/CX/D8 /DD /D3/CUy /CV/CX/DA /CT/D2x P(x, y) /CY/D3/CX/D2 /D8 /D4/D6/D3/CQ/CP/CQ/CX/D0/CX/D8 /DD /D3/D6 /D4/D6/D3/CQ/CP/CQ/CX/D0/CX/D8 /DD /CS/CT/D2/D7/CX/D8 /DD /D3/CUx /CP/D2/CSy P[·] /D4/D6/D3/CQ/CP/CQ/CX/D0/CX/D8 /DD /D3/CU /CP/D2 /CT/DA /CT/D2 /D8 Q /D3/D6/CS/CT/D6 /D3/CU /D4 /D3/D0/DD/D2/D3/D1/CX/CP/D0 /D8/D6/CP/D2/D7/CU/D3/D6/D1 Qf /D3/D1/D4/D0/CT/DC/CX/D8 /DD /D3/CUf /B4/D3/D6/CS/CT/D6 /D3/CU /D4 /D3/D0/DD/D2/D3/D1/CX/CP/D0 /CS/CT/AS/D2/CX/D2/CV f /B5 R /D8/CW/CT /D7/CT/D8 /D3/CU /D6/CT/CP/D0 /D2 /D9/D1 /CQ /CT/D6/D7 Rdd /B9/CS/CX/D1/CT/D2/D7/CX/D3/D2/CP/D0 /BX/D9 /D0/CX/CS/CT/CP/D2 /D7/D4/CP /CT s /D7/CX/CV/D2/CP/D0 s=w /D8x=/summationtext iwixi /B4i /CV/D3 /CT/D7 /CU/D6/D3/D1 /BC /D8/D3d /D3/D61 /D8/D3d/CS/CT/D4 /CT/D2/CS/CX/D2/CV /D3/D2 /DB/CW/CT/D8/CW/CT/D6 x /CW/CP/D7 /D8/CW/CTx0= 1 /D3 /D3/D6/CS/CX/D2/CP/D8/CT /D3/D6 /D2/D3/D8/B5/D7/CX/CV/D2(·) /D7/CX/CV/D2 /CU/D9/D2 /D8/CX/D3/D2/B8 /D6/CT/D8/D9/D6/D2/CX/D2/CV +1 /CU/D3/D6 /D4 /D3/D7/CX/D8/CX/DA /CT /CP/D2/CS−1 /CU/D3/D6 /D2/CT/CV/CP/D8/CX/DA /CT supa(.) /D7/D9/D4/D6/CT/D1 /D9/D1/BN /D7/D1/CP/D0/D0/CT/D7/D8 /DA /CP/D0/D9/CT /D8/CW/CP/D8 /CX/D7≥ /D8/CW/CT /CP/D6/CV/D9/D1/CT/D2 /D8 /CU/D3/D6 /CP/D0/D0a T /D2 /D9/D1 /CQ /CT/D6 /D3/CU /CX/D8/CT/D6/CP/D8/CX/D3/D2/D7/B8 /D2 /D9/D1 /CQ /CT/D6 /D3/CU /CT/D4 /D3 /CW/D7 t /CX/D8/CT/D6/CP/D8/CX/D3/D2 /D2 /D9/D1 /CQ /CT/D6 /D3/D6 /CT/D4 /D3 /CW /D2 /D9/D1 /CQ /CT/D6 tanh(·) /CW /DD/D4 /CT/D6/CQ /D3/D0/CX /D8/CP/D2/CV/CT/D2 /D8 /CU/D9/D2 /D8/CX/D3/D2/BN tanh(s) = (es−e−s)/(es+e−s)/D8/D6/CP /CT(·) /D8/D6/CP /CT /D3/CU /D7/D5/D9/CP/D6/CT /D1/CP/D8/D6/CX/DC /B4/D7/D9/D1 /D3/CU /CS/CX/CP/CV/D3/D2/CP/D0 /CT/D0/CT/D1/CT/D2 /D8/D7/B5 V /D2 /D9/D1 /CQ /CT/D6 /D3/CU /D7/D9/CQ/D7/CT/D8/D7 /CX/D2V /B9/CU/D3/D0/CS /D6/D3/D7/D7 /DA /CP/D0/CX/CS/CP/D8/CX/D3/D2 /B4V×K=N /B5 v /CS/CX/D6/CT /D8/CX/D3/D2 /CX/D2 /CV/D6/CP/CS/CX/CT/D2 /D8 /CS/CT/D7 /CT/D2 /D8 /B4/D2/D3/D8 /D2/CT /CT/D7/D7/CP/D6/CX/D0/DD /CP /D9/D2/CX/D8 /DA /CT /D8/D3/D6/B5/BD/BL/BH /C6/D3/D8 /CP /D8/CX/D3/D2 ˆv /D9/D2/CX/D8 /DA /CT /D8/D3/D6 /DA /CT/D6/D7/CX/D3/D2 /D3/CUv /CJ/CV/D6/CP/CS/CX/CT/D2 /D8 /CS/CT/D7 /CT/D2 /D8℄/DA/CP /D6 /D8/CW/CT /DA /CP/D6/CX/CP/D2 /CT /D8/CT/D6/D1 /CX/D2 /CQ/CX/CP/D7/B9/DA /CP/D6/CX/CP/D2 /CT /CS/CT /D3/D1/D4 /D3/D7/CX/D8/CX/D3/D2 w /DB /CT/CX/CV/CW /D8 /DA /CT /D8/D3/D6 /B4 /D3/D0/D9/D1/D2 /DA /CT /D8/D3/D6/B5 ˜w /DB /CT/CX/CV/CW /D8 /DA /CT /D8/D3/D6 /CX/D2 /D8/D6/CP/D2/D7/CU/D3/D6/D1/CT/CS /D7/D4/CP /CTZ ˆw /D7/CT/D0/CT /D8/CT/CS /DB /CT/CX/CV/CW /D8 /DA /CT /D8/D3/D6 /CJ/D4 /D3 /CZ /CT/D8 /CP/D0/CV/D3/D6/CX/D8/CW/D1℄ w∗/DB /CT/CX/CV/CW /D8 /DA /CT /D8/D3/D6 /D8/CW/CP/D8 /D7/CT/D4/CP/D6/CP/D8/CT/D7 /D8/CW/CT /CS/CP/D8/CP w/D0/CX/D2 /D7/D3/D0/D9/D8/CX/D3/D2 /DB /CT/CX/CV/CW /D8 /DA /CT /D8/D3/D6 /D8/D3 /D0/CX/D2/CT/CP/D6 /D6/CT/CV/D6/CT/D7/D7/CX/D3/D2 w/D6/CT/CV /D6/CT/CV/D9/D0/CP/D6/CX/DE/CT/CS /D7/D3/D0/D9/D8/CX/D3/D2 /D8/D3 /D0/CX/D2/CT/CP/D6 /D6/CT/CV/D6/CT/D7/D7/CX/D3/D2 /DB/CX/D8/CW /DB /CT/CX/CV/CW /D8 /CS/CT /CP /DD w/C8/C4/BT /D7/D3/D0/D9/D8/CX/D3/D2 /DB /CT/CX/CV/CW /D8 /DA /CT /D8/D3/D6 /D3/CU /D4 /CT/D6 /CT/D4/D8/D6/D3/D2 /D0/CT/CP/D6/D2/CX/D2/CV /CP/D0/CV/D3/D6/CX/D8/CW/D1 w0 /CP/CS/CS/CT/CS /D3 /D3/D6/CS/CX/D2/CP/D8/CT /CX/D2 /DB /CT/CX/CV/CW /D8 /DA /CT /D8/D3/D6 w /D8/D3 /D6/CT/D4/D6/CT/D7/CT/D2 /D8 /CQ/CX/CP/D7b x /D8/CW/CT /CX/D2/D4/D9/D8x∈X /BA /C7/CU/D8/CT/D2 /CP /D3/D0/D9/D1/D2 /DA /CT /D8/D3/D6 x∈Rd/D3/D6x∈ {1}×Rd/BAx /CX/D7 /D9/D7/CT/CS /CX/CU /CX/D2/D4/D9/D8 /CX/D7 /D7 /CP/D0/CP/D6/BA x0 /CP/CS/CS/CT/CS /D3 /D3/D6/CS/CX/D2/CP/D8/CT /D8/D3x /B8 /AS/DC/CT/CS /CP/D8x0= 1 /D8/D3 /CP/CQ/D7/D3/D6/CQ /D8/CW/CT /CQ/CX/CP/D7/D8/CT/D6/D1 /CX/D2 /D0/CX/D2/CT/CP/D6 /CT/DC/D4/D6/CT/D7/D7/CX/D3/D2/D7 X /CX/D2/D4/D9/D8 /D7/D4/CP /CT /DB/CW/D3/D7/CT /CT/D0/CT/D1/CT/D2 /D8/D7 /CP/D6/CTx∈X X /D1/CP/D8/D6/CX/DC /DB/CW/D3/D7/CT /D6/D3 /DB/D7 /CP/D6/CT /D8/CW/CT /CS/CP/D8/CP /CX/D2/D4/D9/D8/D7 xn /CJ/D0/CX/D2/CT/CP/D6 /D6/CT/CV/D6/CT/D7/D7/CX/D3/D2℄ XOR /CT/DC /D0/D9/D7/CX/DA /CT /C7/CA /CU/D9/D2 /D8/CX/D3/D2 /B4/D6/CT/D8/D9/D6/D2/D7 /BD /CX/CU /D8/CW/CT /D2 /D9/D1 /CQ /CT/D6 /D3/CU /BD/B3/D7 /CX/D2 /CX/D8/D7/CX/D2/D4/D9/D8 /CX/D7 /D3 /CS/CS/B5 y /D8/CW/CT /D3/D9/D8/D4/D9/D8 y∈Y y /D3/D0/D9/D1/D2 /DA /CT /D8/D3/D6 /DB/CW/D3/D7/CT /D3/D1/D4 /D3/D2/CT/D2 /D8/D7 /CP/D6/CT /D8/CW/CT /CS/CP/D8/CP /D7/CT/D8 /D3/D9/D8/D4/D9/D8/D7 yn /CJ/D0/CX/D2/CT/CP/D6 /D6/CT/CV/D6/CT/D7/D7/CX/D3/D2℄ ˆy /CT/D7/D8/CX/D1/CP/D8/CT /D3/CUy /CJ/D0/CX/D2/CT/CP/D6 /D6/CT/CV/D6/CT/D7/D7/CX/D3/D2℄ Y /D3/D9/D8/D4/D9/D8 /D7/D4/CP /CT /DB/CW/D3/D7/CT /CT/D0/CT/D1/CT/D2 /D8/D7 /CP/D6/CTy∈Y Z /D8/D6/CP/D2/D7/CU/D3/D6/D1/CT/CS /CX/D2/D4/D9/D8 /D7/D4/CP /CT /DB/CW/D3/D7/CT /CT/D0/CT/D1/CT/D2 /D8/D7 /CP/D6/CTz= Φ(x) Z /D1/CP/D8/D6/CX/DC /DB/CW/D3/D7/CT /D6/D3 /DB/D7 /CP/D6/CT /D8/CW/CT /D8/D6/CP/D2/D7/CU/D3/D6/D1/CT/CS /CX/D2/D4/D9/D8/D7 zn= Φ(xn)/CJ/D0/CX/D2/CT/CP/D6 /D6/CT/CV/D6/CT/D7/D7/CX/D3/D2℄/BD/BL/BI /C1/D2/CS/CT/DC/CP /D8/CX/DA /CT /D0/CT/CP/D6/D2/CX/D2/CV/B8 /BD/BK/BD/CS/CT/AS/D2/CX/D8/CX/D3/D2/B8 /BD/BE/BT /CS/CP/D0/CX/D2/CT/B8 /BF/BH/B8 /BD/BD/BC/CP/D4/D4/D6/D3 /DC/CX/D1/CP/D8/CX/D3/D2/B8 /BE/BJ/DA /CT/D6/D7/D9/D7 /CV/CT/D2/CT/D6/CP/D0/CX/DE/CP/D8/CX/D3/D2/B8 /BI/BE/AL/BI/BK/B8 /BD/BC/BI/CP/D6/D8/CX/AS /CX/CP/D0 /CX/D2 /D8/CT/D0/D0/CX/CV/CT/D2 /CT/B8 /BH/CP/D9/CV/D1/CT/D2 /D8/CT/CS /CT/D6/D6/D3/D6/B8 /BD/BF/BE/B8 /BD/BH/BJ/CP/DC/CX/D3/D1 /D3/CU /D2/D3/D2/B9/CU/CP/D0/D7/CX/AS/CP/CQ/CX/D0/CX/D8 /DD /B8 /BD/BJ/BK B(N, k)/CS/CT/AS/D2/CX/D8/CX/D3/D2/B8 /BG/BI/D0/D3 /DB /CT/D6 /CQ /D3/D9/D2/CS/B8 /BI/BL/D9/D4/D4 /CT/D6 /CQ /D3/D9/D2/CS/B8 /BG/BK/CQ/CP /CZ/CV/CP/D1/D1/D3/D2/B8 /BD/BE/BU/CP /DD /CT/D7 /D3/D4/D8/CX/D1/CP/D0 /CS/CT /CX/D7/CX/D3/D2 /D8/CW/CT/D3/D6/DD /B8 /BD/BC/BU/CP /DD /CT/D7 /D8/CW/CT/D3/D6/CT/D1/B8 /BF/BF/BU/CP /DD /CT/D7/CX/CP/D2 /D0/CT/CP/D6/D2/CX/D2/CV/B8 /BD/BK/BD/CQ/CX/CP/D7/B9/DA /CP/D6/CX/CP/D2 /CT/B8 /BI/BE/AL/BI/BI/CP /DA /CT/D6/CP/CV/CT /CU/D9/D2 /D8/CX/D3/D2/B8 /BI/BF/CS/CT/D4 /CT/D2/CS/CT/D2 /CT /D3/D2N, d /B8 /BD/BH/BK/CT/DC/CP/D1/D4/D0/CT/B8 /BI/BH/CX/D1/D4/CP /D8 /D3/CU /D2/D3/CX/D7/CT/B8 /BD/BE/BH/D0/CX/D2/CT/CP/D6 /D1/D3 /CS/CT/D0/D7/B8 /BD/BH/BK/AL/BD/BH/BL/D0/CX/D2/CT/CP/D6 /D6/CT/CV/D6/CT/D7/D7/CX/D3/D2/B8 /BD/BD/BG/D2/D3/CX/D7/DD /D8/CP/D6/CV/CT/D8/B8 /BJ/BG/CQ/CX/D2 /D1/D3 /CS/CT/D0/B8 /BD/BK/D1 /D9/D0/D8/CX/D4/D0/CT /CQ/CX/D2/D7/B8 /BE/BE/D6/CT/D0/CP/D8/CX/D3/D2/D7/CW/CX/D4 /D8/D3 /D0/CT/CP/D6/D2/CX/D2/CV/B8 /BE/BC/CQ/CX/D2/D3/D1/CX/CP/D0 /CS/CX/D7/D8/D6/CX/CQ/D9/D8/CX/D3/D2/B8 /BF/BI/CQ /D3 /D3/D7/D8/CX/D2/CV/B8 /BD/BK/BD/CQ/D6/CT/CP/CZ /D4 /D3/CX/D2 /D8/CS/CT/AS/D2/CX/D8/CX/D3/D2/B8 /BG/BH/BV/CW/CT/CQ /DD/D7/CW/CT/DA /CX/D2/CT/D5/D9/CP/D0/CX/D8 /DD /B8 /BF/BI/BV/CW/CT/D6/D2/D3/AR /CQ /D3/D9/D2/CS/B8 /BF/BJ /D0/CP/D7/D7/CX/AS /CP/D8/CX/D3/D2/CU/D3/D6 /D6/CT/CV/D6/CT/D7/D7/CX/D3/D2/B8 /BD/BD/BF/D0/CX/D2/CT/CP/D6 /D4/D6/D3/CV/D6/CP/D1/D1/CX/D2/CV /CP/D0/CV/D3/D6/CX/D8/CW/D1/B8 /BD/BD/BC /D0/CP/D7/D7/CX/AS /CP/D8/CX/D3/D2 /CT/D6/D6/D3/D6 /CQ /D3/D9/D2/CS /CQ /DD /D6/D3/D7/D7/B9/CT/D2 /D8/D6/D3/D4 /DD /CT/D6/D6/D3/D6/B8 /BL/BJ/CQ /D3/D9/D2/CS /CQ /DD /D7/D5/D9/CP/D6/CT/CS /CT/D6/D6/D3/D6/B8 /BL/BJ /D0/D9/D7/D8/CT/D6/CX/D2/CV/B8 /BD/BF /D3/CX/D2 /D0/CP/D7/D7/CX/AS /CP/D8/CX/D3/D2/B8 /BL/B8 /BD/BF /D3/D1 /CQ/CX/D2/CP/D8/D3/D6/CX/CP/D0 /D3/D4/D8/CX/D1/CX/DE/CP/D8/CX/D3/D2/B8 /BK/BC /D3/D1/D4/D0/CT/DC/CX/D8 /DD/D3/CUH /B8 /BE/BI/D3/CUf /B8 /BE/BJ /D3/D1/D4/D9/D8/CP/D8/CX/D3/D2/CP/D0 /D3/D1/D4/D0/CT/DC/CX/D8 /DD /B8 /BD/BK/BD /D3/D1/D4/D9/D8/CP/D8/CX/D3/D2/CP/D0 /AS/D2/CP/D2 /CT/B8 /BD/BK/BD /D3/D1/D4/D9/D8/CT/D6 /DA/CX/D7/CX/D3/D2/B8 /BD /D3/D2 /DA /CT/DC /CU/D9/D2 /D8/CX/D3/D2/B8 /BL/BF /D3/D2 /DA /CT/DC /D7/CT/D8/B8 /BG/BG /D3/D7/D8/B8 /BE/BK /D3/D7/D8 /D1/CP/D8/D6/CX/DC/B8 /BE/BL/B8 /BD/BD/BH /D6/CT/CS/CX/D8 /CP/D4/D4/D6/D3 /DA /CP/D0/B8 /BF/B8 /BK/BE/B8 /BL/BI /D6/D3/D7/D7 /DA /CP/D0/CX/CS/CP/D8/CX/D3/D2/B8 /BD/BG/BH/AL/BD/BH/BC V /B9/CU/D3/D0/CS/B8 /BD/BH/BC /CW/D3 /D3/D7/CX/D2/CV λ /B8 /BD/BG/BL/CS/CX/CV/CX/D8/D7 /CS/CP/D8/CP/B8 /BD/BH/BD/CT/AR/CT /D8/CX/DA /CT /D2 /D9/D1 /CQ /CT/D6 /D3/CU /CT/DC/CP/D1/D4/D0/CT/D7/B8 /BD/BI/BF/CT/DC/CP /D8 /D3/D1/D4/D9/D8/CP/D8/CX/D3/D2/B8 /BD/BG/BL/D0/CT/CP /DA /CT/B9/D3/D2/CT/B9/D3/D9/D8/B8 /BD/BG/BI/D0/CX/D2/CT/CP/D6 /D1/D3 /CS/CT/D0/B8 /BD/BG/BL/D0/CX/D2/CT/CP/D6 /D1/D3 /CS/CT/D0/B8 /CP/D2/CP/D0/DD/D8/CX /B8 /BD/BI/BG/D1/D3 /CS/CT/D0 /D7/CT/D0/CT /D8/CX/D3/D2/B8 /BD/BG/BK/D6/CT/CV/D9/D0/CP/D6/CX/DE/CT/CS/B8 /BD/BI/BH/D7/D9/D1/D1/CP/D6/DD /B8 /BD/BG/BJ/D9/D2 /CQ/CX/CP/D7/CT/CS/B8 /BD/BG/BJ/DA /CP/D6/CX/CP/D2 /CT/B8 /BD/BI/BE /D6/D3/D7/D7/B9/CT/D2 /D8/D6/D3/D4 /DD /B8 /BL/BE/CS/CP/D8/CP /D3/D2 /D8/CP/D1/CX/D2/CP/D8/CX/D3/D2/B8 /BD/BG/BH/B8 /BD/BH/BD/B8 /BD/BJ/BI/CS/CP/D8/CP /D1/CX/D2/CX/D2/CV/B8 /BD/BH/CS/CP/D8/CP /D4 /D3/CX/D2 /D8/B8 /BF/CS/CP/D8/CP /D7/CT/D8/B8 /BF/CV/CW/D3/D7/D8/B8 /BD/BK/BK/D7/D4/CP /CT /D3/CU/B8 /BH/BG/CS/CP/D8/CP /D7/D2/D3 /D3/D4/CX/D2/CV/B8 /BD/BJ/BF/AL/BD/BJ/BJ/B8 /BD/BK/BD/BD/BL/BJ /C1/D2/CS/CT/DC/AS/D2/CP/D2 /CX/CP/D0 /D8/D6/CP/CS/CX/D2/CV/B8 /BD/BJ/BG/D2/D3/D2/D0/CX/D2/CT/CP/D6 /D8/D6/CP/D2/D7/CU/D3/D6/D1/B8 /BD/BC/BF/D2/D3/D6/D1/CP/D0/CX/DE/CP/D8/CX/D3/D2 /CQ/CX/CP/D7/B8 /BD/BJ/BG/DA /CT/D6/D7/D9/D7 /D7/CP/D1/D4/D0/CX/D2/CV /CQ/CX/CP/D7/B8 /BD/BJ/BJ/CS/CT /CX/D7/CX/D3/D2 /D7/D8/D9/D1/D4/B8 /BD/BC/BI/CS/CT/D7/CX/CV/D2/DA /CT/D6/D7/D9/D7 /D0/CT/CP/D6/D2/CX/D2/CV/B8 /BL/CS/CT/D8/CT/D6/D1/CX/D2/CX/D7/D8/CX /D2/D3/CX/D7/CT/B8 /BD/BE/BG /B8 /BD/BE/BK/CT/AR/CT /D8 /D3/D2 /D0/CT/CP/D6/D2/CX/D2/CV/B8 /BD/BH/BD/D6/CT/CV/D9/D0/CP/D6/CX/DE/CP/D8/CX/D3/D2/B8 /BD/BF/BI/D7/CX/D1/CX/D0/CP/D6/CX/D8 /DD /D8/D3 /D7/D8/D3 /CW/CP/D7/D8/CX /D2/D3/CX/D7/CT/B8 /BD/BF/BI/BW/CT/DB /CT/DD /B8 /BD/BJ/BD/CS/CX /CW/D3/D8/D3/D1 /DD /B8 /BG/BE/D1/CP/DC/CX/D1 /D9/D1 /D2 /D9/D1 /CQ /CT/D6/B8 /BG/BI/D4 /CT/D6 /CT/D4/D8/D6/D3/D2/B8 /BG/BF/D8/CP/CQ/D0/CT/B8 /BG/BJ/CS/CX/AR/CT/D6/CT/D2 /D8/CX/CP/CQ/D0/CT/B8 /BK/BH/D8 /DB/CX /CT/B9/B8 /BL/BF/B8 /BL/BH/CT/AR/CT /D8/CX/DA /CT /D2 /D9/D1 /CQ /CT/D6 /D3/CU /CW /DD/D4 /D3/D8/CW/CT/D7/CT/D7/B8 /BG/BD /B8 /BH/BF/CT/AR/CT /D8/CX/DA /CT /D2 /D9/D1 /CQ /CT/D6 /D3/CU /D4/CP/D6/CP/D1/CT/D8/CT/D6/D7/B8 /BH/BE/B8 /BD/BF/BJ /B8/BD/BH/BL/BX/CX/D2/D7/D8/CT/CX/D2/B8 /BD/BI/BJ/CT/D2/D7/CT/D1 /CQ/D0/CT /D0/CT/CP/D6/D2/CX/D2/CV/B8 /BD/BK/BD/CT/D2 /D8/D6/D3/D4 /DD /B8 /BD/BI/BK/CT/D6/D6/D3/D6 /D1/CT/CP/D7/D9/D6/CT/B8 /BE/BK/AL/BF/BC L1 /DA /CT/D6/D7/D9/D7 L2 /B8 /BF/BK /D0/CP/D7/D7/CX/AS /CP/D8/CX/D3/D2/B8 /BE/BK /D6/D3/D7/D7/B9/CT/D2 /D8/D6/D3/D4 /DD /B8 /BL/BE/AS/D2/CV/CT/D6/D4/D6/CX/D2 /D8 /CT/DC/CP/D1/D4/D0/CT/B8 /BE/BK/D0/D3/CV/CX/D7/D8/CX /D6/CT/CV/D6/CT/D7/D7/CX/D3/D2/B8 /BL/BD/CT/DC/CP/D1/D4/D0/CT/B8 /BF/CU/CP/D0/D7/CT /CP /CT/D4/D8/B8 /BE/BL/B8 /BD/BD/BH/CU/CP/D0/D7/CT /D6/CT/CY/CT /D8/B8 /BE/BL/B8 /BD/BD/BH/CU/CP/D0/D7/CX/AS/CP/CQ/CX/D0/CX/D8 /DD /B8 /BD/BJ/BK/CU/CT/CP/D7/CX/CQ/CX/D0/CX/D8 /DD /D3/CU /D0/CT/CP/D6/D2/CX/D2/CV/BU/D3 /D3/D0/CT/CP/D2 /CT/DC/CP/D1/D4/D0/CT/B8 /BD/BI/D4/D6/D3/CQ/CP/CQ/CX/D0/CX/D7/D8/CX /B8 /BD/BK/D8 /DB /D3 /D1/CP/CX/D2 /D5/D9/CT/D7/D8/CX/D3/D2/D7/B8 /BE/BI/DA/CX/D7/D9/CP/D0 /CT/DC/CP/D1/D4/D0/CT/B8 /BD/BH/CU/CT/CP/D8/D9/D6/CT /D7/CT/D0/CT /D8/CX/D3/D2/B8 /BD/BH/BD/CU/CT/CP/D8/D9/D6/CT /D7/D4/CP /CT/B8 /BD/BC/BC/CU/CT/CP/D8/D9/D6/CT/D7/B8 /BK/BD/D2/D3/D2/D0/CX/D2/CT/CP/D6 /D8/D6/CP/D2/D7/CU/D3/D6/D1/B8 /BL/BL/CU/CT/CP/D8/D9/D6/CT /D8/D6/CP/D2/D7/CU/D3/D6/D1/B8 /BD/BC/BC /B8 /BD/BD/BD/B8 /BD/BD/BI/AL/BD/BD/BJ/AS/D2/CP/D0 /CT/DC/CP/D1/B8 /BF/BL/AS/D2/CP/D2 /CX/CP/D0 /CU/D3/D6/CT /CP/D7/D8/CX/D2/CV/B8 /BD/AS/D2/CV/CT/D6/D4/D6/CX/D2 /D8 /DA /CT/D6/CX/AS /CP/D8/CX/D3/D2/B8 /BE/BK/B8 /BD/BD/BH /CU/D3 /D3/D8/CQ/CP/D0/D0 /D7 /CP/D1/B8 /BD/BJ/BC/BZ/CP/D9/D7/D7/CX/CP/D2 /D4/D6/D3 /CT/D7/D7/CT/D7/B8 /BD/BK/BD/CV/CT/D2/CT/D6/CP/D0/CX/DE/CP/D8/CX/D3/D2/B8 /BF/BL/AL/BH/BL/CE /BV /CQ /D3/D9/D2/CS/B8 /BH/BC/AL/BH/BL/CE /BV /CS/CX/D1/CT/D2/D7/CX/D3/D2/B8 /BH/BC/CV/CT/D2/CT/D6/CP/D0/CX/DE/CP/D8/CX/D3/D2 /CQ /D3/D9/D2/CS/CS/CT/AS/D2/CX/D8/CX/D3/D2/B8 /BG/BC/BW/CT/DA/D6/D3 /DD /CT/B8 /BJ/BF/C8 /CP/D6/D6/D3/D2/CS/D3 /CP/D2/CS /CE /CP/D2 /CS/CT/D2 /BU/D6/D3 /CT/CZ/B8 /BJ/BF/CA/CP/CS/CT/D1/CP /CW/CT/D6 /D4 /CT/D2/CP/D0/D8 /DD /B8 /BJ/BF/D6/CT/D0/CP/D8/CX/DA /CT /CT/D6/D6/D3/D6/B8 /BJ/BG/CE /BV/B8 /D7/CT /CT /CE /BV /CV/CT/D2/CT/D6/CP/D0/CX/DE/CP/D8/CX/D3/D2 /CQ /D3/D9/D2/CS/CV/CT/D2/CT/D6/CP/D0/CX/DE/CP/D8/CX/D3/D2 /CT/D6/D6/D3/D6/CS/CT/AS/D2/CX/D8/CX/D3/D2/B8 /BG/BC/CV/D0/D3/CQ/CP/D0 /D1/CX/D2/CX/D1 /D9/D1/B8 /BL/BF/CV/D6/CP/CS/CX/CT/D2 /D8 /CS/CT/D7 /CT/D2 /D8/B8 /BL/BE/AL/BL/BL/CP/D0/CV/D3/D6/CX/D8/CW/D1/B8 /BL/BH/CQ/CP/D8 /CW/B8 /BL/BJ/CX/D2/CX/D8/CX/CP/D0/CX/DE/CP/D8/CX/D3/D2 /CP/D2/CS /D8/CT/D6/D1/CX/D2/CP/D8/CX/D3/D2/B8 /BL/BH/D7/D8/D3 /CW/CP/D7/D8/CX /B8 /BL/BJ/CV/D6/D3 /DB/D8/CW /CU/D9/D2 /D8/CX/D3/D2/B8 /BG/BD/AL/BH/BC/BE/B9/CS/CX/D1/CT/D2/D7/CX/D3/D2/CP/D0 /D4 /CT/D6 /CT/D4/D8/D6/D3/D2/B8 /BG/BF/CQ /D3/D9/D2/CS/B8 /BG/BI/AL/BG/BL /D3/D2 /DA /CT/DC /D7/CT/D8/B8 /BG/BG/CS/CT/AS/D2/CX/D8/CX/D3/D2/B8 /BG/BE/CX/D2 /CE /BV /D4/D6/D3 /D3/CU/B8 /BD/BL/BC/D4 /D3/D0/DD/D2/D3/D1/CX/CP/D0 /CQ /D3/D9/D2/CS/B8 /BH/BC/D4 /D3/D7/CX/D8/CX/DA /CT /CX/D2 /D8/CT/D6/DA /CP/D0/B8 /BG/BG/D4 /D3/D7/CX/D8/CX/DA /CT /D6/CP /DD /B8 /BG/BF/D8 /DB /D3/B9/CS/CX/D1/CT/D2/D7/CX/D3/D2/CP/D0 /D4 /CT/D6 /CT/D4/D8/D6/D3/D2/B8 /BG/BF/CW/CP/D2/CS/DB/D6/CX/D8/D8/CT/D2 /CS/CX/CV/CX/D8 /D6/CT /D3/CV/D2/CX/D8/CX/D3/D2/B8 /BG/B8 /BD/BD/B8 /BK/BD/AL/BK/BE/B8 /BD/BC/BI/AL/BD/BC/BJ/B8 /BD/BH/BD/CW/CP/D8 /D1/CP/D8/D6/CX/DC/B8 /BK/BJ /B8 /BD/BD/BE/C0/CT/D7/D7/CX/CP/D2 /D1/CP/D8/D6/CX/DC/B8 /BD/BD/BI/C0/D3 /CT/AR/CS/CX/D2/CV /CQ /D3/D9/D2/CS/B8 /D7/CT /CT /C0/D3 /CT/AR/CS/CX/D2/CV /C1/D2/CT/D5/D9/CP/D0/B9/CX/D8 /DD/C0/D3 /CT/AR/CS/CX/D2/CV /C1/D2/CT/D5/D9/CP/D0/CX/D8 /DD /B8 /BD/BL /B8 /BD/BL/AL/BE/BJ/CP/D2/CS /CQ/CX/D2/D3/D1/CX/CP/D0 /CS/CX/D7/D8/D6/CX/CQ/D9/D8/CX/D3/D2/B8 /BF/BI/D9/D2/CX/CU/D3/D6/D1 /DA /CT/D6/D7/CX/D3/D2/B8 /BE/BG/DB/CX/D8/CW/D3/D9/D8 /D6/CT/D4/D0/CP /CT/D1/CT/D2 /D8/B8 /BD/BL/BE/CW /DD/D4 /D3/D8/CW/CT/D7/CX/D7 /D7/CT/D8/B8 /BF /D3/D1/D4 /D3/D7/CX/D8/CX/D3/D2/B8 /BJ/BE /D3/D2 /CT/D2 /D8/D6/CX /D7/D4/CW/CT/D6/CT/D7/B8 /BI/BL /D3/D2 /DA /CT/DC /D7/CT/D8/B8 /BG/BG/D1/D3/D2/D3/D8/D3/D2/CX /B8 /BJ/BD/D4 /D3/D0/DD/D2/D3/D1/CX/CP/D0/B8 /BD/BE/BC/D4 /D3/D7/CX/D8/CX/DA /CT /CX/D2 /D8/CT/D6/DA /CP/D0/B8 /BG/BG/BD/BL/BK /C1/D2/CS/CT/DC/D4 /D3/D7/CX/D8/CX/DA /CT /D6/CP /DD /B8 /BG/BF/D4 /D3/D7/CX/D8/CX/DA /CT /D6/CT /D8/CP/D2/CV/D0/CT/D7/B8 /BI/BL/D4 /D3/D7/CX/D8/CX/DA /CT/B9/D2/CT/CV/CP/D8/CX/DA /CT /CX/D2 /D8/CT/D6/DA /CP/D0/B8 /BI/BL/D4 /D3/D7/CX/D8/CX/DA /CT/B9/D2/CT/CV/CP/D8/CX/DA /CT /D6/CP /DD /B8 /BI/BL/D6/CT/D7/D8/D6/CX /D8/CT/CS /D8/D3 /CX/D2/D4/D9/D8/D7/B8 /BG/BE/CX/D2/B9/D7/CP/D1/D4/D0/CT /CT/D6/D6/D3/D6/B8 /BE/BD/CX/D2/D4/D9/D8 /D7/D4/CP /CT/B8 /BF/CX/D8/CT/D6/CP/D8/CX/DA /CT /D0/CT/CP/D6/D2/CX/D2/CV/B8 /BJ/CZ /CT/D6/D2/CT/D0 /D1/CT/D8/CW/D3 /CS/D7/B8 /BD/BK/BD/C4/CP/CV/D6/CP/D2/CV/CT /D1 /D9/D0/D8/CX/D4/D0/CX/CT/D6/B8 /BD/BF/BD/B8 /BD/BH/BJ/D0/CP/D7/D7/D3/B8 /BD/BI/BD/D0/CP /DB /D3/CU /D0/CP/D6/CV/CT /D2 /D9/D1 /CQ /CT/D6/D7/B8 /BF/BI/B8 /BF/BJ/D0/CT/CP/D6/D2/CX/D2/CV /D6/CX/D8/CT/D6/CX/CP/B8 /BE/BI/B8 /BJ/BK/CU/CT/CP/D7/CX/CQ/CX/D0/CX/D8 /DD /B8 /BD/BH/AL/BD/BK/B8 /BE/BG/AL/BE/BI/D0/CT/CP/D6/D2/CX/D2/CV /CP/D0/CV/D3/D6/CX/D8/CW/D1/B8 /BF/D0/CT/CP/D6/D2/CX/D2/CV /D9/D6/DA /CT/B8 /BI/BI/AL/BI/BK/B8 /BD/BG/BC/B8 /BD/BG/BJ/D0/CX/D2/CT/CP/D6 /D6/CT/CV/D6/CT/D7/D7/CX/D3/D2/B8 /BK/BK/D0/CT/CP/D6/D2/CX/D2/CV /D1/D3 /CS/CT/D0/CS/CT/AS/D2/CX/D8/CX/D3/D2/B8 /BH/D0/CT/CP/D6/D2/CX/D2/CV /D4/D6/D3/CQ/D0/CT/D1/D7/D9/D1/D1/CP/D6/DD /AS/CV/D9/D6/CT/B8 /BF/BC/D0/CT/CP/D6/D2/CX/D2/CV /D6/CP/D8/CT/B8 /BL/BG/B8 /BL/BH/D0/CT/CP /DA /CT/B9/D3/D2/CT/B9/D3/D9/D8/B8 /BD/BG/BI/C4/CT/CV/CT/D2/CS/D6/CT /D4 /D3/D0/DD/D2/D3/D1/CX/CP/D0/D7/B8 /BD/BE/BF/B8 /BD/BE/BK/AL/BD/BE/BL/B8 /BD/BH/BG/B8/BD/BH/BH/D0/CX/CZ /CT/D0/CX/CW/D3 /D3 /CS/B8 /BL/BD/D0/CX/D2/CT/CP/D6 /D0/CP/D7/D7/CX/AS /CP/D8/CX/D3/D2/B8 /BJ/BJ/D0/CX/D2/CT/CP/D6 /D1/D3 /CS/CT/D0/B8 /BJ/BJ/CQ/CX/CP/D7/B9/DA /CP/D6/CX/CP/D2 /CT/B8 /BD/BH/BK/AL/BD/BH/BL/CQ/D9/CX/D0/CS/CX/D2/CV /CQ/D0/D3 /CZ/B8 /BD/BK/BD /D6/D3/D7/D7 /DA /CP/D0/CX/CS/CP/D8/CX/D3/D2/B8 /CP/D2/CP/D0/DD/D8/CX /B8 /BD/BI/BG/D3/D4/D8/CX/D1/CP/D0 /DB /CT/CX/CV/CW /D8 /CS/CT /CP /DD /B8 /BD/BI/BD/D3 /DA /CT/D6/D0/D3 /D3/CZ /CT/CS /D6/CT/D7/D3/D9/D6 /CT/B8 /BD/BC/BJ/D7/D9/D1/D1/CP/D6/DD /B8 /BL/BI/D0/CX/D2/CT/CP/D6 /D4/D6/D3/CV/D6/CP/D1/D1/CX/D2/CV/B8 /BD/BD/BC/B8 /BD/BD/BD/D0/CX/D2/CT/CP/D6 /D6/CT/CV/D6/CT/D7/D7/CX/D3/D2/B8 /BK/BE/AL/BK/BK/B8 /BD/BD/BD/CP/D0/CV/D3/D6/CX/D8/CW/D1/B8 /BK/BI/CQ/CX/CP/D7 /CP/D2/CS /DA /CP/D6/CX/CP/D2 /CT/B8 /BD/BD/BG/CU/D3/D6 /D0/CP/D7/D7/CX/AS /CP/D8/CX/D3/D2/B8 /BL/BI/AL/BL/BJ/B8 /BD/BC/BL/AL/BD/BD/BC/D0/CT/CP/D6/D2/CX/D2/CV /D9/D6/DA /CT/B8 /BK/BK/D3/D4/D8/CX/D1/CP/D0 /CW /DD/D4 /D3/D8/CW/CT/D7/CX/D7/B8 /BD/BD/BD/D3/D9/D8 /D3/CU /D7/CP/D1/D4/D0/CT/B8 /BK/BJ/AL/BK/BK/D3/D9/D8/B9/D3/CU/B9/D7/CP/D1/D4/D0/CT /CT/D6/D6/D3/D6/B8 /BD/BD/BE/D4/D6/D3 /CY/CT /D8/CX/D3/D2 /D1/CP/D8/D6/CX/DC/B8 /BK/BI/B8 /BD/BD/BF/D6/CP/D2/CZ /CS/CT/AS /CX/CT/D2 /D8/B8 /BD/BD/BG /D9/D7/CX/D2/CV /D0/CP/D7/D7/CX/AS /CP/D8/CX/D3/D2 /CP/D0/CV/D3/D6/CX/D8/CW/D1/B8 /BD/BD/BF/D0/CX/D2/CT/CP/D6/D0/DD /D7/CT/D4/CP/D6/CP/CQ/D0/CT/B8 /BI/B8 /BJ/BK/CT/DC/CP/D1/D4/D0/CT/B8 /BI/D0/D3 /CP/D0 /D1/CX/D2/CX/D1 /D9/D1/B8 /BL/BF/D0/D3/CV/CX/D7/D8/CX /CU/D9/D2 /D8/CX/D3/D2/B8 /BK/BL/D0/D3/CV/CX/D7/D8/CX /D6/CT/CV/D6/CT/D7/D7/CX/D3/D2/B8 /BK/BK/AL/BL/BL/CP/D0/CV/D3/D6/CX/D8/CW/D1/B8 /BL/BH /D6/D3/D7/D7/B9/CT/D2 /D8/D6/D3/D4 /DD /CT/D6/D6/D3/D6/B8 /BL/BE/CT/D6/D6/D3/D6 /D1/CT/CP/D7/D9/D6/CT/B8 /BL/BD/AL/BL/BE/CU/D3/D6 /D0/CP/D7/D7/CX/AS /CP/D8/CX/D3/D2/B8 /BL/BI/AL/BL/BJ/B8 /BD/BD/BH/CW/CP/D6/CS /D8/CW/D6/CT/D7/CW/D3/D0/CS/B8 /BD/BD/BH/CX/D2/CX/D8/CX/CP/D0/CX/DE/CP/D8/CX/D3/D2/B8 /BL/BH/D3/D4/D8/CX/D1/CP/D0 /CS/CT /CX/D7/CX/D3/D2 /D8/CW/CT/D3/D6/DD /B8 /BD/BD/BH/D8/CT/D6/D1/CX/D2/CP/D8/CX/D3/D2/B8 /BL/BI/D0/D3/D7/D7 /D1/CP/D8/D6/CX/DC/B8 /BF/BK/D1/CP /CW/CX/D2/CT /D0/CT/CP/D6/D2/CX/D2/CV/B8 /DA/CX/CX/B8 /BD/BG/D1/CP/DC/CX/D1 /D9/D1 /D0/CX/CZ /CT/D0/CX/CW/D3 /D3 /CS/B8 /BL/BD/D1/CT/CS/CX /CP/D0 /CS/CX/CP/CV/D2/D3/D7/CX/D7/B8 /BD/D1/CX/D2/CX/D1 /D9/D1 /CS/CT/D7 /D6/CX/D4/D8/CX/D3/D2 /D0/CT/D2/CV/D8/CW/B8 /BD/BI/BK/D1/D3 /CS/CT/D0 /D7/CT/D0/CT /D8/CX/D3/D2/B8 /BD/BG/BD/AL/BD/BG/BH /CW/D3 /D3/D7/CX/D2/CV λ /B8 /BD/BF/BG/B8 /BD/BG/BL /D6/D3/D7/D7 /DA /CP/D0/CX/CS/CP/D8/CX/D3/D2/B8 /BD/BG/BK/CT/DC/D4 /CT/D6/CX/D1/CT/D2 /D8/B8 /BD/BG/BG/D7/D9/D1/D1/CP/D6/DD /B8 /BD/BG/BF/D1/D3/D2/D3/D8/D3/D2/CX /CU/D9/D2 /D8/CX/D3/D2/D7/B8 /BJ/BD/CE /BV /CS/CX/D1/CT/D2/D7/CX/D3/D2/B8 /BJ/BD/D1/D3 /DA/CX/CT /D6/CP/D8/CX/D2/CV/B8 /BD/AL/BF/D1 /D9/D0/D8/CX /D0/CP/D7/D7/B8 /BK/BD/C6/CT/D8/AT/CX/DC/B8 /BD/D2/CT/D9/D6/CP/D0 /D2/CT/D8 /DB /D3/D6/CZ/B8 /BD/BK/BD/C6/CT/DB/D8/D3/D2/B3/D7 /D1/CT/D8/CW/D3 /CS/B8 /BD/BD/BI/D2/D3/CX/D7/CT/CS/CT/D8/CT/D6/D1/CX/D2/CX/D7/D8/CX /B8 /BD/BE/BG/D7/D8/D3 /CW/CP/D7/D8/CX /B8 /BD/BE/BG/D2/D3/D2/B9/CU/CP/D0/D7/CX/AS/CP/CQ/CX/D0/CX/D8 /DD /B8 /BD/BJ/BK/CP/DC/CX/D3/D1/B8 /BD/BJ/BC/D4/CX /CZ/CX/D2/CV /AS/D2/CP/D2 /CX/CP/D0 /D8/D6/CP/CS/CT/D6/D7/B8 /BD/BJ/BC/D2/D3/D2/B9/D7/CT/D4/CP/D6/CP/CQ/D0/CT /CS/CP/D8/CP/B8 /BJ/BL/AL/BK/BD/D2/D3/D2/D0/CX/D2/CT/CP/D6 /D6/CT/CV/D6/CT/D7/D7/CX/D3/D2/B8 /BD/BC/BG/D2/D3/D2/D0/CX/D2/CT/CP/D6 /D8/D6/CP/D2/D7/CU/D3/D6/D1/CP/D8/CX/D3/D2/B8 /BL/BL/D2/D3/D6/D1/CP/D0/CX/DE/CP/D8/CX/D3/D2/B8 /BD/BJ/BH/C6/C8/B9/CW/CP/D6/CS/B8 /BK/BC/D3/CQ /CY/CT /D8/CX/DA /CT/B8 /BE/BK/C7 /CP/D1/B3/D7 /D6/CP/DE/D3/D6/B8 /BD/BI/BJ/AL/BD/BJ/BD/B8 /BD/BK/BD/D3/AR /D8/D6/CP/CX/D2/CX/D2/CV /D7/CT/D8 /CT/D6/D6/D3/D6/B8 /BF/BJ Ω /B8 /BH/BK/BD/BL/BL /C1/D2/CS/CT/DC/D3/D2/D0/CX/D2/CT /D0/CT/CP/D6/D2/CX/D2/CV/B8 /BL/BK/B8 /BD/BK/BD/CS/CT/AS/D2/CX/D8/CX/D3/D2/B8 /BD/BE/D3/D6/CS/CX/D2/CP/D6/DD /D0/CT/CP/D7/D8 /D7/D5/D9/CP/D6/CT/D7/B8 /BK/BI/D3/D9/D8/B9/D3/CU/B9/D7/CP/D1/D4/D0/CT /CT/D6/D6/D3/D6/B8 /BE/BD/D3/D9/D8/D0/CX/CT/D6/D7/B8 /BJ/BL/D3/D9/D8/D4/D9/D8 /D7/D4/CP /CT/B8 /BF/D3 /DA /CT/D6/AS/D8/D8/CX/D2/CV/B8 /BD/BD/BL/AL/BD/BI/BH /B8 /BD/BJ/BD/CS/CT/AS/D2/CX/D8/CX/D3/D2/B8 /BD/BD/BL/CT/DC/D4 /CT/D6/CX/D1/CT/D2 /D8/B8 /BD/BE/BF/B8 /BD/BH/BH/D0/CT/CP/D6/D2/CX/D2/CV /D9/D6/DA /CT/D7/B8 /BD/BE/BE/D4/CP/D8/D8/CT/D6/D2 /D6/CT /D3/CV/D2/CX/D8/CX/D3/D2/B8 /BL/D4 /CT/D2/CP/D0/D8 /DD/CW /DD/D4 /D3/D8/CW/CT/D7/CX/D7 /D3/D1/D4/D0/CT/DC/CX/D8 /DD /B8 /BD/BE/BI/B8 /BD/BF/BF/D1/D3 /CS/CT/D0 /D3/D1/D4/D0/CT/DC/CX/D8 /DD /B8 /BH/BK/D4 /CT/D6 /CT/D4/D8/D6/D3/D2/B8 /BH/AL/BK/B8 /BJ/BK/AL/BK/BE/CS/CT/AS/D2/CX/D8/CX/D3/D2/B8 /BH/CT/DC/D4 /CT/D6/CX/D1/CT/D2 /D8/B8 /BF/BG/D0/CT/CP/D6/D2/CX/D2/CV /CP/D0/CV/D3/D6/CX/D8/CW/D1 /B4/C8/C4/BT/B5/B8 /BJ mH(N) /B8 /BJ/BC/C8/C4/BT /D3/D2 /DA /CT/D6/CV/CT/D2 /CT/B8 /BF/BF/D4 /D3 /CZ /CT/D8 /CP/D0/CV/D3/D6/CX/D8/CW/D1/B8 /BK/BC/D4 /CT/D6 /CT/D4/D8/D6/D3/D2 /D0/CT/CP/D6/D2/CX/D2/CV /CP/D0/CV/D3/D6/CX/D8/CW/D1/B8 /BJ/B8 /BJ/BJ/B8 /BJ/BK/B8/BL/BK/B8 /BD/BC/BL/AL/BD/BD/BC/CP/D2/CS /CB/BZ/BW/B8 /BL/BK /D3/D2 /DA /CT/D6/CV/CT/D2 /CT/B8 /BF/BF/AS/CV/D9/D6/CT/B8 /BJ/B8 /BK/BF/C8/C4/BT/B8 /D7/CT /CT /D4 /CT/D6 /CT/D4/D8/D6/D3/D2 /D0/CT/CP/D6/D2/CX/D2/CV /CP/D0/CV/D3/D6/CX/D8/CW/D1/D4 /D3 /CZ /CT/D8 /CP/D0/CV/D3/D6/CX/D8/CW/D1/B8 /BK/BC /B8 /BL/BJ/B8 /BD/BC/BL/AS/CV/D9/D6/CT/B8 /BK/BF/D4 /D3/D0/D0/B8 /BD/BL/CC /D6/D9/D1/CP/D2 /DA /CT/D6/D7/D9/D7 /BW/CT/DB /CT/DD /B8 /BD/BJ/BD/D4 /D3/D0/DD/D2/D3/D1/CX/CP/D0 /D8/D6/CP/D2/D7/CU/D3/D6/D1/B8 /BD/BC/BG/D4 /D3/D0/DD/D2/D3/D1/CX/CP/D0/D7/B8 /BD/BE/BC/D4 /D3/D7/CX/D8/CX/DA /CT /CX/D2 /D8/CT/D6/DA /CP/D0/B8 /BG/BG/D4 /D3/D7/CX/D8/CX/DA /CT /D6/CP /DD /B8 /BG/BF/D4 /D3/D7/D8/CP/D0 /D7 /CP/D1/B8 /BD/BJ/BC/D4/D6/CT/CS/CX /D8/CX/D3/D2 /D3/CU /CW/CT/CP/D6/D8 /CP/D8/D8/CP /CZ/D7/B8 /BK/BL/D4/D6/D3/CQ/CP/CQ/CX/D0/CX/D8 /DD/D0/D3/CV/CX/D7/D8/CX /D6/CT/CV/D6/CT/D7/D7/CX/D3/D2/B8 /BK/BL/D9/D2/CX/D3/D2 /CQ /D3/D9/D2/CS/B8 /BE/BG/B8 /BG/BD/D4/D6/D3 /CY/CT /D8/CX/D3/D2 /D1/CP/D8/D6/CX/DC/B8 /BD/BD/BF/D4/D7/CT/D9/CS/D3/B9/CX/D2 /DA /CT/D6/D7/CT/B8 /BK/BH/D2 /D9/D1/CT/D6/CX /CP/D0 /D7/D8/CP/CQ/CX/D0/CX/D8 /DD /B8 /BK/BI/D4/D9/CQ/D0/CX /CP/D8/CX/D3/D2 /CQ/CX/CP/D7/B8 /BD/BJ/BF/D5/D9/CP/CS/D6/CP/D8/CX /D4/D6/D3/CV/D6/CP/D1/D1/CX/D2/CV/B8 /BD/BK/BD/D6/CP/D2/CS/D3/D1 /D7/CP/D1/D4/D0/CT/B8 /BD/BL /D6/CT /D3/D1/D1/CT/D2/CS/CT/D6 /D7/DD/D7/D8/CT/D1/D7/B8 /BD/B8 /BD/BH/B8 /BD/BK/BD/D6/CT/CV/D6/CT/D7/D7/CX/D3/D2/B8 /BJ/BJ/B8 /BK/BE/D0/D3/CV/CX/D7/D8/CX /B8 /BK/BL/D6/CT/CV/D9/D0/CP/D6/CX/DE/CP/D8/CX/D3/D2/B8 /BD/BE/BI/AL/BD/BF/BJ /B8 /BD/BK/BD E/CX/D2 /DA /CT/D6/D7/D9/D7 λ /B8 /BD/BH/BI/CP/D9/CV/D1/CT/D2 /D8/CT/CS /CT/D6/D6/D3/D6/B8 /BD/BF/BE /CW/D3 /D3/D7/CX/D2/CV λ /B8 /BD/BF/BG/B8 /BD/BG/BL/CX/D2/D4/D9/D8 /D2/D3/CX/D7/CT/B8 /BD/BI/BC/D0/CP/D7/D7/D3/B8 /BD/BI/BD/D0/CX/D2/CT/CP/D6 /D1/D3 /CS/CT/D0/B8 /BD/BF/BF/D6/CX/CS/CV/CT /D6/CT/CV/D6/CT/D7/D7/CX/D3/D2/B8 /BD/BF/BE/D7/D3/CU/D8 /D3/D6/CS/CT/D6 /D3/D2/D7/D8/D6/CP/CX/D2 /D8/B8 /BD/BE/BK/CC/CX/CZ/CW/D3/D2/D3 /DA/B8 /BD/BF/BD/B8 /BD/BI/BC/CE /BV /CS/CX/D1/CT/D2/D7/CX/D3/D2/B8 /BD/BF/BJ/DB /CT/CX/CV/CW /D8 /CS/CT /CP /DD /B8 /BD/BF/BE/D6/CT/CV/D9/D0/CP/D6/CX/DE/CP/D8/CX/D3/D2 /D4/CP/D6/CP/D1/CT/D8/CT/D6/B8 λ /B8 /BD/BF/BF/D6/CT/CX/D2/CU/D3/D6 /CT/D1/CT/D2 /D8 /D0/CT/CP/D6/D2/CX/D2/CV/B8 /BD/BE/B8 /BD/BK/BD/D6/CX/CS/CV/CT /D6/CT/CV/D6/CT/D7/D7/CX/D3/D2/B8 /BD/BF/BE/D6/CX/D7/CZ/B8 /BE/BK/D6/CX/D7/CZ /D1/CP/D8/D6/CX/DC/B8 /BF/BK/B8 /D7/CT /CT /CP/D0/D7/D3 /D3/D7/D8 /D1/CP/D8/D6/CX/DC/D7/CP/D1/D4/D0/CT /D3/D1/D4/D0/CT/DC/CX/D8 /DD /B8 /BH/BI/AL/BH/BJ/D7/CP/D1/D4/D0/CX/D2/CV /CQ/CX/CP/D7/B8 /BD/BJ/BD/AL/BD/BJ/BF/B8 /BD/BK/BD/DA /CT/D6/D7/D9/D7 /CS/CP/D8/CP /D7/D2/D3 /D3/D4/CX/D2/CV/B8 /BD/BJ/BJ/CB/CP/D9/CT/D6/B3/D7 /C4/CT/D1/D1/CP/B8 /BG/BK/D7/CT/CP/D6 /CW /CT/D2/CV/CX/D2/CT/D7/B8 /BD/D7/CT/D0/CT /D8/CX/D3/D2 /CQ/CX/CP/D7/B8 /BD/BJ/BF/CB/BZ/BW/B8 /D7/CT /CT /D7/D8/D3 /CW/CP/D7/D8/CX /CV/D6/CP/CS/CX/CT/D2 /D8 /CS/CT/D7 /CT/D2 /D8/D7/CW/CP/D8/D8/CT/D6/B8 /BG/BE/D7/CX/CV/D1/D3/CX/CS/B8 /BL/BC/D7/CX/D2/CV/D9/D0/CP/D6 /DA /CP/D0/D9/CT /CS/CT /D3/D1/D4 /D3/D7/CX/D8/CX/D3/D2/B8 /BD/BD/BG/D7/D3/CU/D8 /D3/D6/CS/CT/D6 /D3/D2/D7/D8/D6/CP/CX/D2 /D8/B8 /BD/BH/BJ/D7/D3/CU/D8 /D8/CW/D6/CT/D7/CW/D3/D0/CS/B8 /BL/BC/D7/D4/CP/D1/B8 /BG/B8 /BI/D7/D5/D9/CP/D6/CT/CS /CT/D6/D6/D3/D6/B8 /BI/BD/B8 /BI/BI/B8 /BK/BG/B8 /BD/BG/BC/CB/CA/C5/B8 /D7/CT /CT /D7/D8/D6/D9 /D8/D9/D6/CP/D0 /D6/CX/D7/CZ /D1/CX/D2/CX/D1/CX/DE/CP/D8/CX/D3/D2/D7/D8/CP/D8/CX/D7/D8/CX /D7/B8 /BD/BG/D7/D8/D3 /CW/CP/D7/D8/CX /CV/D6/CP/CS/CX/CT/D2 /D8 /CS/CT/D7 /CT/D2 /D8/B8 /BL/BJ/AL/BL/BL/B8 /BD/BD/BC/D7/D8/D3 /CW/CP/D7/D8/CX /D2/D3/CX/D7/CT/B8 /BD/BE/BG/D7/D8/D6/CT/CP/D1/CX/D2/CV /CS/CP/D8/CP/B8 /BD/BE/D7/D8/D6/D9 /D8/D9/D6/CP/D0 /D6/CX/D7/CZ /D1/CX/D2/CX/D1/CX/DE/CP/D8/CX/D3/D2/B8 /BD/BJ/BK/D7/D9/D4 /CT/D6/D7/D8/CX/D8/CX/D3/D2/B8 /BD/BD/BL/D7/D9/D4 /CT/D6/DA/CX/D7/CT/CS /D0/CT/CP/D6/D2/CX/D2/CV/CS/CT/AS/D2/CX/D8/CX/D3/D2/B8 /BD/BD/D7/D9/D4/D4 /D3/D6/D8 /DA /CT /D8/D3/D6 /D1/CP /CW/CX/D2/CT/D7/B8 /BD/BK/BD/D7/D9/D4/D6/CT/D1 /D9/D1/B8 /BD/BK/BJ/CB/CE/BW/B8 /D7/CT /CT /D7/CX/D2/CV/D9/D0/CP/D6 /DA /CP/D0/D9/CT /CS/CT /D3/D1/D4 /D3/D7/CX/D8/CX/D3/D2 tanh /B8 /BL/BC/BE/BC/BC /C1/D2/CS/CT/DC/D8/CP/D6/CV/CT/D8 /CS/CX/D7/D8/D6/CX/CQ/D9/D8/CX/D3/D2/B8 /BF/BD/D8/CP/D6/CV/CT/D8 /CU/D9/D2 /D8/CX/D3/D2/B8 /BF/D2/D3/CX/D7/DD /B8 /BF/BC/AL/BF/BE/B8 /BK/BF/B8 /BK/BJ/D8/CT/D7/D8 /D7/CT/D8/B8 /BH/BL/CC/CX/CZ/CW/D3/D2/D3 /DA /D6/CT/CV/D9/D0/CP/D6/CX/DE/CT/D6/B8 /BD/BF/BD/CC/CX/CZ/CW/D3/D2/D3 /DA /D7/D1/D3 /D3/D8/CW/D2/CT/D7/D7 /D4 /CT/D2/CP/D0/D8 /DD /B8 /BD/BI/BE/D8/D6/CP/CX/D2/CX/D2/CV /CT/DC/CP/D1/D4/D0/CT/D7/B8 /BG/CC /D6/D9/D1/CP/D2/B8 /BD/BJ/BD/D9/D2/CS/CT/D6/AS/D8/D8/CX/D2/CV/B8 /BD/BF/BH/D9/D2/CX/D3/D2 /CQ /D3/D9/D2/CS/B8 /BE/BG/B8 /BG/BD/D9/D2/D0/CP/CQ /CT/D0/CT/CS /CS/CP/D8/CP/B8 /BD/BF/B8 /BD/BK/BD/D9/D2/D7/D9/D4 /CT/D6/DA/CX/D7/CT/CS /D0/CT/CP/D6/D2/CX/D2/CV/B8 /BD/BF/B8 /BD/BK/BD/D0/CT/CP/D6/D2/CX/D2/CV /CP /D0/CP/D2/CV/D9/CP/CV/CT/B8 /BD/BF/DA /CP/D0/CX/CS/CP/D8/CX/D3/D2/B8 /BD/BF/BJ/AL/BD/BG/BD /D6/D3/D7/D7 /DA /CP/D0/CX/CS/CP/D8/CX/D3/D2/B8 /BD/BG/BH/D1/D3 /CS/CT/D0 /D7/CT/D0/CT /D8/CX/D3/D2/B8 /BD/BG/BD/D7/D9/D1/D1/CP/D6/DD /B8 /BD/BG/BD/DA /CP/D0/CX/CS/CP/D8/CX/D3/D2 /D7/CT/D8/B8 /BD/BF/BK/DA /CP/D0/CX/CS/CP/D8/CX/D3/D2 /CT/D6/D6/D3/D6/B8 /BD/BF/BK/CT/DC/D4 /CT /D8/CP/D8/CX/D3/D2/B8 /BD/BF/BK/D3/D4/D8/CX/D1/CX/D7/D8/CX /CQ/CX/CP/D7/B8 /BD/BG/BE/DA /CP/D6/CX/CP/D2 /CT/B8 /BD/BF/BL/DA /CP/D0/CX/CS/CP/D8/CX/D3/D2 /D7/CT/D8/CE /BV /CQ /D3/D9/D2/CS/B8 /BD/BF/BL/B8 /BD/BI/BF/CE /CP/D4/D2/CX/CZ/B9/BV/CW/CT/D6/DA /D3/D2/CT/D2/CZ/CX/D7/B8 /D7/CT /CT /CE /BV/CE /BV /CS/CX/D1/CT/D2/D7/CX/D3/D2/B8 /BH/BC d /B9/CS/CX/D1/CT/D2/D7/CX/D3/D2/CP/D0 /D4 /CT/D6 /CT/D4/D8/D6/D3/D2/B8 /BH/BE/CP/D2/CS /D2 /D9/D1 /CQ /CT/D6 /D3/CU /D4/CP/D6/CP/D1/CT/D8/CT/D6/D7/B8 /BJ/BE/CS/CT/AS/D2/CX/D8/CX/D3/D2/B8 /BH/BC/CT/AR/CT /D8/CX/DA /CT/B8 /BD/BF/BJ/CX/D2 /D8/CT/D6/D7/CT /D8/CX/D3/D2 /D3/CU /CW /DD/D4 /D3/D8/CW/CT/D7/CX/D7 /D7/CT/D8/D7/B8 /BJ/BD/D1/D3/D2/D3/D8/D3/D2/CX /CU/D9/D2 /D8/CX/D3/D2/D7/B8 /BJ/BD/D3/CU /D3/D1/D4 /D3/D7/CX/D8/CX/D3/D2/B8 /BJ/BE/D9/D2/CX/D3/D2 /D3/CU /CW /DD/D4 /D3/D8/CW/CT/D7/CX/D7 /D7/CT/D8/D7/B8 /BJ/BD/CE /BV /CV/CT/D2/CT/D6/CP/D0/CX/DE/CP/D8/CX/D3/D2 /CQ /D3/D9/D2/CS/B8 /BH/BF/B8 /BJ/BK/B8 /BK/BJ/B8 /BD/BC/BE/CS/CT/AS/D2/CX/D8/CX/D3/D2/B8 /BH/BF/D4/D6/D3 /D3/CU/B8 /BD/BK/BJ/D7/CZ /CT/D8 /CW /D3/CU /D4/D6/D3 /D3/CU/B8 /BH/BF/CE /BV /C1/D2/CT/D5/D9/CP/D0/CX/D8 /DD /B8 /BD/BK/BJ/DA /CT/D2/CS/CX/D2/CV /D1/CP /CW/CX/D2/CT/D7/B8 /BL/DA/CX/D6/D8/D9/CP/D0 /CT/DC/CP/D1/D4/D0/CT/D7/B8 /BD/BH/BJ/DB /CT/CX/CV/CW /D8 /CS/CT /CP /DD /B8 /BD/BF/BE /D6/D3/D7/D7 /DA /CP/D0/CX/CS/CP/D8/CX/D3/D2 /CT/D6/D6/D3/D6/B8 /BD/BG/BL/CT/DC/CP/D1/D4/D0/CT/B8 /BD/BE/BI/CV/D6/CP/CS/CX/CT/D2 /D8 /CS/CT/D7 /CT/D2 /D8/B8 /BD/BH/BI/CX/D2 /DA /CP/D6/CX/CP/D2 /CT /D9/D2/CS/CT/D6 /D0/CX/D2/CT/CP/D6 /D8/D6/CP/D2/D7/CU/D3/D6/D1/B8 /BD/BI/BE /D0/CX/D2/CT/CP/D6 /D1/D3 /CS/CT/D0/B8 /BD/BF/BF/D2/CT/CV/CP/D8/CX/DA /CT λ /B8 /BD/BH/BI/D3/D4/D8/CX/D1/CP/D0 λ /B8 /BD/BI/BD/DA/CX/D6/D8/D9/CP/D0 /CT/DC/CP/D1/D4/D0/CT/D7/B8 /BD/BH/BJ Z /D7/D4/CP /CT/B8 /BL/BL/AL/BD/BC/BE/BE/BC/BD"
}