{
  "title": "Introduction to Statistical Learning Gareth James, Daniela Witten, Trevor Hastie, & Robert Tibshirani",
  "source": "Libros/Introduction to Statistical Learning Gareth James, Daniela Witten, Trevor Hastie, & Robert Tibshirani.pdf",
  "content": "1James · Witten · Hastie · Tibshirani Springer Texts in Statistics Gareth James · Daniela Witten · Trevor Hastie · Robert Tibshirani An Introduction to Statistical Learning with Applications in RSpringer Texts in Statistics An Introduction to Statistical LearningGareth James Daniela WittenTrevor HastieRobert Tibshirani StatisticsAn Introduction to Statistical Learning with Applications in RAn Introduction to Statistical Learning provides an accessible overview of the ﬁ eld of statistical learning, an essential toolse t for making sense of the vast and complex data sets that have emerged in ﬁ elds ranging from biology to ﬁ nance to marketing to astrophysics in the past twenty years. Th is book presents some of the most important modeling and prediction techniques, along with relevant applications. Topics include linear regression, classiﬁ cation, resampling methods, shrinkage approaches, tree-based methods, support vector machines, clustering, and more. Color graphics and real-world examples are used to illustrate the methods presented. Since the goal of this textbook is to facilitate the use of these statistical learning techniques by practitioners in sci-ence, industry, and other ﬁ elds, each chapter contains a tutorial on implementing the analyses and methods presented in R, an extremely popular open source statistical soft ware platform. Two of the authors co-wrote Th e Elements of Statistical Learning (Hastie, Tibshirani and Friedman, 2nd edition 2009), a popular reference book for statistics and machine learning researchers. An Introduction to Statistical Learning covers many of the same topics, but at a level accessible to a much broader audience. Th is book is targeted at statisticians and non-statisticians alike who wish to use cutting-edge statistical learn- ing techniques to analyze their data. Th e text assumes only a previous course in linear regression and no knowledge of matrix algebra. Gareth James is a professor of statistics at University of Southern California. He has published an extensive body of methodological work in the domain of statistical learn- ing with particular emphasis on high-dimensional and functional data. Th e conceptual framework for this book grew out of his MBA elective courses in this area. Daniela Witten is an assistant professor of biostatistics at University of Washington. Her research focuses largely on high-dimensional statistical machine learning. She has contributed to the translation of statistical learning techniques to the ﬁ eld of genomics, through collaborations and as a member of the Institute of Medicine committee that led to the report Evolution of Translational Omics . Trevor Hastie and Robert Tibshirani are professors of statistics at Stanford University, and are co-authors of the successful textbook Elements of Statistical Learning. Hastie and Tibshirani developed generalized additive models and wrote a popular book of that title. Hastie co-developed much of the statistical modeling soft ware and environment in R/S-PLUS and invented principal curves and surfaces. Tibshirani proposed the lasso and is co-author of the very successful An Introduction to the Bootstrap . 9 781461 471370ISBN 978-1-4614-7137-0STS Springer Texts in Statistics 103 Series Editors: G. Casella S. Fienberg I. Olkin For further volumes: http://www.springer.com/series/417 Gareth James •Daniela Witten •Trevor Hastie Robert Tibshirani An Introduction to Statistical Learning with Applications in R 123 Gareth James Department of Information and Operations Management University of Southern California Los Angeles, CA, USA Trevor Hastie Department of Statistics Stanford University Stanford, CA, USADaniela Witten Department of Biostatistics University of Washington Seattle, WA, USA Robert Tibshirani Department of Statistics Stanford University Stanford, CA, USA ISSN 1431-875X ISBN 978-1-4614-7137-0 ISBN 978-1-4614-7138-7 (eBook) DOI 10.1007/978-1-4614-7138-7 Springer New York Heidelberg Dordrecht London Library of Congress Control Number: 2013936251 © Springer Science+Business Media New York 2013 This work is subject to copyright. All rights are rese rved by the Publisher, whether the whole or part of the material is concerned, speciﬁcally the rights o f translation, reprinting, reuse of illustrations, recitation, broadcasting, reproduc tion on microﬁlms or in any other physical way, and transmission or information storage and retrieval, electronic adaptation, computer software, or by similar or dissim- ilar methodology now known or hereafter developed. Ex empted from this legal reservation are brief excerpts in connection with reviews or scholarly anal ysis or material supplied speciﬁcally for the pur- pose of being entered and executed on a computer system, for exclusive use by the purchaser of the work. Duplication of this publication or parts ther eof is permitted only under the provisions of the Copyright Law of the Publisher’s location, in its current version, and permission for use must always be obtained from Springer. Perm issions for use may be obtained t hrough RightsLink at the Copyright Clearance Center. Violations are liable to pro secution under the respective Copyright Law. The use of general descriptive names, registered names, trademarks, service marks, etc. in this publi- cation does not imply, even in the absence of a speciﬁc statement, that such names are exempt from the relevant protective laws and regula tions and therefore fre e for general use. While the advice and information in this book are b elieved to be true and accurate at the date of publication, neither the authors nor the editors nor the publisher can accept any legal responsibility for any errors or omissions that may be made. The publisher makes no warranty, express or implied, with respect to the material contained herein. Printed on acid-free paper Springer is part of Springer Science+ Business Media (www.springer.com) To our parents: Alison and Michael James Chiara Nappi and Edward Witten Valerie and Patrick Hastie Vera and Sami Tibshirani and to our families: Michael, Daniel, and Catherine Ari Samantha, Timothy, and Lynda Charlie, Ryan, Julie, and Cheryl Preface Statistical learning refers to a set of tools for modeling and understanding complex datasets. It is a recently dev eloped area in statistics and blends with parallel developments in computer science and, in particular, machine learning. The ﬁeld encompasses many methods such as the lasso and sparse regression, classiﬁcation and regression trees, and boosting and support vector machines. With the explosion of “Big Data” problems, statistical learning has be- come a very hot ﬁeld in many scientiﬁc areas as well as marketing, ﬁnance, and other business disciplines. People with statistical learning skills are in high demand. One of the ﬁrst books in this area— The Elements of Statistical Learning (ESL) (Hastie, Tibshirani, and Friedman)—was published in 2001, with a second edition in 2009. ESL has become a popular text not only in statis- tics but also in related ﬁelds. One of the reasons for ESL’s popularity is its relatively accessible style. But ESL is intended for individuals with ad- vanced training in the mathematical sciences. An Introduction to Statistical Learning (ISL) arose from the perceived need for a broader and less tech- nical treatment of these topics. In this new book, we cover many of the same topics as ESL, but we concentrate more on the applications of the methods and less on the mathematical details. We have created labs illus- trating how to implement each of the statistical learning methods using the popular statistical software package R. These labs provide the reader with valuable hands-on experience. This book is appropriate for advanced undergraduates or master’s stu- dents in statistics or related quantitative ﬁelds or for individuals in other vii viii Preface disciplines who wish to use statistical learning tools to analyze their data. It can be used as a textbook for a course spanning one or two semesters. We would like to thank several readers for valuable comments on prelim- inary drafts of this book: Pallavi Basu, Alexandra Chouldechova, Patrick Danaher, Will Fithian, Luella Fu, Sam Gross, Max Grazier G’Sell, Court- ney Paulson, Xinghao Qiao, Elisa Sheng, Noah Simon, Kean Ming Tan, and Xin Lu Tan. It’s tough to make predictions, especially about the future. -Yogi Berra Los Angeles, USA Gareth James Seattle, USA Daniela Witten Palo Alto, USA Trevor Hastie Palo Alto, USA Robert Tibshirani Contents Preface vii 1 Introduction 1 2 Statistical Learning 15 2 . 1 W h a tI sS t a t i s t i c a lL e a r n i n g ?................. 1 5 2.1.1 Why Estimate f?.................... 1 7 2.1.2 How Do We Estimate f? ............... 2 1 2.1.3 The Trade-Oﬀ Betw een Prediction Accuracy and Model Interpretability . . . . . . . . . . . . . . 24 2.1.4 Supervised Versus Unsupervised Learning . . . . . . 26 2.1.5 Regression Versus Classiﬁcation Problems . . . . . . 28 2 . 2 A s s e s s i n gM o d e lA c c u r a c y................... 2 9 2 . 2 . 1 M e a s u r i n gt h eQ u a l i t yo fF i t ............. 2 9 2 . 2 . 2 T h eB i a s - V a r i a n c eT r a d e - O ﬀ ............. 3 3 2 . 2 . 3 T h eC l a s s i ﬁ c a t i o nS e t t i n g............... 3 7 2 . 3 L a b :I n t r o d u c t i o nt oR..................... 4 2 2 . 3 . 1 B a s i cC o m m a n d s.................... 4 2 2 . 3 . 2 G r a p h i c s ........................ 4 5 2 . 3 . 3 I n d e x i n gD a t a ..................... 4 7 2 . 3 . 4 L o a d i n gD a t a...................... 4 8 2.3.5 Additional Graphical and Numerical Summaries . . 49 2 . 4 E x e r c i s e s ............................ 5 2 ix xC o n t e n t s 3 Linear Regression 59 3 . 1 S i m p l eL i n e a rR e g r e s s i o n ................... 6 1 3 . 1 . 1 E s t i m a t i n gt h eC o e ﬃ c i e n t s .............. 6 1 3.1.2 Assessing the Accuracy of the Coeﬃcient E s t i m a t e s........................ 6 3 3 . 1 . 3 A s s e s s i n gt h eA c c u r a c yo ft h eM o d e l......... 6 8 3 . 2 M u l t i p l eL i n e a rR e g r e s s i o n .................. 7 1 3.2.1 Estimating the Regression Coeﬃcients . . . . . . . . 72 3.2.2 Some Important Questions . . . . . . . . . . . . . . 75 3.3 Other Considerations in the Regression Model . . . . . . . . 82 3 . 3 . 1 Q u a l i t a t i v eP r e d i c t o r s................. 8 2 3 . 3 . 2 E x t e n s i o n so ft h eL i n e a rM o d e l............ 8 6 3 . 3 . 3 P o t e n t i a lP r o b l e m s................... 9 2 3 . 4 T h eM a r k e t i n gP l a n ...................... 1 0 2 3.5 Comparison of Linear Regression with K-Nearest N e i g h b o r s............................ 1 0 4 3 . 6 L a b :L i n e a rR e g r e s s i o n..................... 1 0 9 3 . 6 . 1 L i b r a r i e s......................... 1 0 9 3 . 6 . 2 S i m p l eL i n e a rR e g r e s s i o n ............... 1 1 0 3 . 6 . 3 M u l t i p l eL i n e a rR e g r e s s i o n .............. 1 1 3 3 . 6 . 4 I n t e r a c t i o nT e r m s ................... 1 1 5 3.6.5 Non-linear Transformations of the Predictors . . . . 115 3 . 6 . 6 Q u a l i t a t i v eP r e d i c t o r s................. 1 1 7 3 . 6 . 7 W r i t i n gF u n c t i o n s ................... 1 1 9 3 . 7 E x e r c i s e s ............................ 1 2 0 4 Classiﬁcation 127 4 . 1 A nO v e r v i e wo fC l a s s i ﬁ c a t i o n................. 1 2 8 4 . 2 W h yN o tL i n e a rR e g r e s s i o n ? ................. 1 2 9 4 . 3 L o g i s t i cR e g r e s s i o n....................... 1 3 0 4 . 3 . 1 T h eL o g i s t i cM o d e l................... 1 3 1 4.3.2 Estimating the Regression Coeﬃcients . . . . . . . . 133 4 . 3 . 3 M a k i n gP r e d i c t i o n s................... 1 3 4 4 . 3 . 4 M u l t i p l eL o g i s t i cR e g r e s s i o n.............. 1 3 5 4.3.5 Logistic Regression for >2R e s p o n s eC l a s s e s..... 1 3 7 4 . 4 L i n e a rD i s c r i m i n a n tA n a l y s i s ................. 1 3 8 4.4.1 Using Bayes’ Theorem for Classiﬁcation . . . . . . . 138 4.4.2 Linear Discriminant Analysis for p=1........ 1 3 9 4.4.3 Linear Discriminant Analysis for p>1........ 1 4 2 4 . 4 . 4 Q u a d r a t i cD i s c r i m i n a n tA n a l y s i s........... 1 4 9 4.5 A Comparison of Classiﬁcation Methods . . . . . . . . . . . 151 4.6 Lab: Logistic Regression, LDA, QDA, and KNN . . . . . . 154 4 . 6 . 1 T h eS t o c kM a r k e tD a t a................ 1 5 4 4 . 6 . 2 L o g i s t i cR e g r e s s i o n................... 1 5 6 4 . 6 . 3 L i n e a rD i s c r i m i n a n tA n a l y s i s............. 1 6 1 Contents xi 4 . 6 . 4 Q u a d r a t i cD i s c r i m i n a n tA n a l y s i s........... 1 6 2 4.6.5K- N e a r e s tN e i g h b o r s.................. 1 6 3 4.6.6 An Application to Caravan Insurance Data . . . . . 164 4 . 7 E x e r c i s e s ............................ 1 6 8 5 Resampling Methods 175 5 . 1 C r o s s - V a l i d a t i o n ........................ 1 7 6 5 . 1 . 1 T h eV a l i d a t i o nS e tA p p r o a c h............. 1 7 6 5.1.2 Leave-One-Out Cross-Validation . . . . . . . . . . . 178 5.1.3k- F o l dC r o s s - V a l i d a t i o n................ 1 8 1 5.1.4 Bias-Variance Trade-Oﬀ for k-Fold C r o s s - V a l i d a t i o n .................... 1 8 3 5.1.5 Cross-Validation on Classiﬁcation Problems . . . . . 184 5 . 2 T h eB o o t s t r a p ......................... 1 8 7 5 . 3 L a b :C r o s s - V a l i d a t i o na n dt h eB o o t s t r a p........... 1 9 0 5 . 3 . 1 T h eV a l i d a t i o nS e tA p p r o a c h............. 1 9 1 5.3.2 Leave-One-Out Cross-Validation . . . . . . . . . . . 192 5.3.3k- F o l dC r o s s - V a l i d a t i o n................ 1 9 3 5 . 3 . 4 T h eB o o t s t r a p ..................... 1 9 4 5 . 4 E x e r c i s e s ............................ 1 9 7 6 Linear Model Selection and Regularization 203 6.1 Subset Selection . . . . . . . . . . . . . . . . . . . . . . . . 205 6.1.1 Best Subset Selection . . . . . . . . . . . . . . . . . 205 6 . 1 . 2 S t e p w i s eS e l e c t i o n ................... 2 0 7 6 . 1 . 3 C h o o s i n gt h eO p t i m a lM o d e l............. 2 1 0 6 . 2 S h r i n k a g eM e t h o d s....................... 2 1 4 6 . 2 . 1 R i d g eR e g r e s s i o n.................... 2 1 5 6 . 2 . 2 T h eL a s s o........................ 2 1 9 6 . 2 . 3 S e l e c t i n gt h eT u n i n gP a r a m e t e r............ 2 2 7 6 . 3 D i m e n s i o nR e d u c t i o nM e t h o d s ................ 2 2 8 6.3.1 Principal Components Regression . . . . . . . . . . . 230 6.3.2 Partial Least Squares . . . . . . . . . . . . . . . . . 237 6 . 4 C o n s i d e r a t i o n si nH i g hD i m e n s i o n s.............. 2 3 8 6 . 4 . 1 H i g h - D i m e n s i o n a lD a t a ................ 2 3 8 6.4.2 What Goes Wrong in High Dimensions? . . . . . . . 239 6 . 4 . 3 R e g r e s s i o ni nH i g hD i m e n s i o n s............ 2 4 1 6.4.4 Interpreting Results in High Dimensions . . . . . . . 243 6.5 Lab 1: Subset Selection Methods . . . . . . . . . . . . . . . 244 6.5.1 Best Subset Selection . . . . . . . . . . . . . . . . . 244 6.5.2 Forward and Backward Stepwise Selection . . . . . . 247 6.5.3 Choosing Among Models Using the Validation S e tA p p r o a c ha n dC r o s s - V a l i d a t i o n.......... 2 4 8 xii Contents 6.6 Lab 2: Ridge Regression and the Lasso . . . . . . . . . . . . 251 6 . 6 . 1 R i d g eR e g r e s s i o n.................... 2 5 1 6 . 6 . 2 T h eL a s s o........................ 2 5 5 6 . 7 L a b3 :P C Ra n dP L SR e g r e s s i o n............... 2 5 6 6.7.1 Principal Components Regression . . . . . . . . . . . 256 6.7.2 Partial Least Squares . . . . . . . . . . . . . . . . . 258 6 . 8 E x e r c i s e s ............................ 2 5 9 7 Moving Beyond Linearity 265 7 . 1 P o l y n o m i a lR e g r e s s i o n..................... 2 6 6 7 . 2 S t e pF u n c t i o n s ......................... 2 6 8 7 . 3 B a s i sF u n c t i o n s......................... 2 7 0 7 . 4 R e g r e s s i o nS p l i n e s ....................... 2 7 1 7.4.1 Piecewise Polynomials . . . . . . . . . . . . . . . . . 271 7 . 4 . 2 C o n s t r a i n t sa n dS p l i n e s ................ 2 7 1 7 . 4 . 3 T h eS p l i n eB a s i sR e p r e s e n t a t i o n ........... 2 7 3 7.4.4 Choosing the Number and Locations o ft h eK n o t s ...................... 2 7 4 7.4.5 Comparison to Polynomial Regression . . . . . . . . 276 7 . 5 S m o o t h i n gS p l i n e s ....................... 2 7 7 7.5.1 An Overview of Smoothing Splines . . . . . . . . . . 277 7.5.2 Choosing the Smoothing Parameter λ........ 2 7 8 7 . 6 L o c a lR e g r e s s i o n........................ 2 8 0 7 . 7 G e n e r a l i z e dA d d i t i v eM o d e l s ................. 2 8 2 7.7.1 GAMs for Regression Problems . . . . . . . . . . . . 283 7.7.2 GAMs for Classiﬁcation Problems . . . . . . . . . . 286 7 . 8 L a b :N o n - l i n e a rM o d e l i n g................... 2 8 7 7.8.1 Polynomial Regression and Step Functions . . . . . 288 7 . 8 . 2 S p l i n e s.......................... 2 9 3 7 . 8 . 3 G A M s.......................... 2 9 4 7 . 9 E x e r c i s e s ............................ 2 9 7 8 Tree-Based Methods 303 8 . 1 T h eB a s i c so fD e c i s i o nT r e e s ................. 3 0 3 8 . 1 . 1 R e g r e s s i o nT r e e s.................... 3 0 4 8 . 1 . 2 C l a s s i ﬁ c a t i o nT r e e s................... 3 1 1 8 . 1 . 3 T r e e sV e r s u sL i n e a rM o d e l s.............. 3 1 4 8.1.4 Advantages and Disadvantages of Trees . . . . . . . 315 8.2 Bagging, Random Forests, Boosting . . . . . . . . . . . . . 316 8.2.1 Bagging . . . . . . . . . . . . . . . . . . . . . . . . . 316 8 . 2 . 2 R a n d o mF o r e s t s .................... 3 2 0 8 . 2 . 3 B o o s t i n g......................... 3 2 1 8 . 3 L a b :D e c i s i o nT r e e s....................... 3 2 4 8 . 3 . 1 F i t t i n gC l a s s i ﬁ c a t i o nT r e e s .............. 3 2 4 8 . 3 . 2 F i t t i n gR e g r e s s i o nT r e e s................ 3 2 7 Contents xiii 8.3.3 Bagging and Random Forests . . . . . . . . . . . . . 328 8 . 3 . 4 B o o s t i n g......................... 3 3 0 8 . 4 E x e r c i s e s ............................ 3 3 2 9 Support Vector Machines 337 9 . 1 M a x i m a lM a r g i nC l a s s i ﬁ e r................... 3 3 8 9 . 1 . 1 W h a tI saH y p e r p l a n e ? ................ 3 3 8 9.1.2 Classiﬁcation Using a Separating Hyperplane . . . . 339 9 . 1 . 3 T h eM a x i m a lM a r g i nC l a s s i ﬁ e r............ 3 4 1 9.1.4 Construction of the Maximal Margin Classiﬁer . . . 342 9 . 1 . 5 T h eN o n - s e p a r a b l eC a s e................ 3 4 3 9.2 Support Vector Classiﬁers . . . . . . . . . . . . . . . . . . . 344 9.2.1 Overview of the Support Vector Classiﬁer . . . . . . 344 9.2.2 Details of the Support Vector Classiﬁer . . . . . . . 345 9.3 Support Vector Machines . . . . . . . . . . . . . . . . . . . 349 9.3.1 Classiﬁcation with Non-linear Decision Boundaries . . . . . . . . . . . . . . . . . . . . . . . 349 9.3.2 The Support Vector Machine . . . . . . . . . . . . . 350 9.3.3 An Application to the Heart Disease Data . . . . . . 354 9 . 4 S V M sw i t hM o r et h a nT w oC l a s s e s.............. 3 5 5 9 . 4 . 1 O n e - V e r s u s - O n eC l a s s i ﬁ c a t i o n............. 3 5 5 9 . 4 . 2 O n e - V e r s u s - A l lC l a s s i ﬁ c a t i o n............. 3 5 6 9 . 5 R e l a t i o n s h i pt oL o g i s t i cR e g r e s s i o n.............. 3 5 6 9.6 Lab: Support Vector Machines . . . . . . . . . . . . . . . . 359 9.6.1 Support Vector Classiﬁer . . . . . . . . . . . . . . . 359 9.6.2 Support Vector Machine . . . . . . . . . . . . . . . . 363 9 . 6 . 3 R O CC u r v e s ...................... 3 6 5 9 . 6 . 4 S V Mw i t hM u l t i p l eC l a s s e s.............. 3 6 6 9.6.5 Application to Gene Expression Data . . . . . . . . 366 9 . 7 E x e r c i s e s ............................ 3 6 8 10 Unsupervised Learning 373 10.1 The Challenge of Unsupervised Learning . . . . . . . . . . . 373 1 0 . 2P r i n c i p a lC o m p o n e n t sA n a l y s i s................ 3 7 4 10.2.1 What Are Principal Components? . . . . . . . . . . 375 10.2.2 Another Interpretation of Principal Components . . 379 1 0 . 2 . 3M o r eo nP C A...................... 3 8 0 10.2.4 Other Uses for Principal Components . . . . . . . . 385 1 0 . 3C l u s t e r i n gM e t h o d s....................... 3 8 5 10.3.1K- M e a n sC l u s t e r i n g.................. 3 8 6 1 0 . 3 . 2H i e r a r c h i c a lC l u s t e r i n g................. 3 9 0 1 0 . 3 . 3P r a c t i c a lI s s u e si nC l u s t e r i n g............. 3 9 9 1 0 . 4L a b1 :P r i n c i p a lC o m p o n e n t sA n a l y s i s............ 4 0 1 xiv Contents 1 0 . 5L a b2 :C l u s t e r i n g........................ 4 0 4 10.5.1K- M e a n sC l u s t e r i n g.................. 4 0 4 1 0 . 5 . 2H i e r a r c h i c a lC l u s t e r i n g................. 4 0 6 1 0 . 6L a b3 :N C I 6 0D a t aE x a m p l e ................. 4 0 7 1 0 . 6 . 1P C Ao nt h eN C I 6 0D a t a ............... 4 0 8 10.6.2 Clustering the Observations of the NCI60 Data . . . 410 1 0 . 7E x e r c i s e s ............................ 4 1 3 Index 419 1 Introduction An Overview of Statistical Learning Statistical learning referstoavastsetoftoolsfor understanding data .T h e se tools can be classiﬁed as supervised orunsupervised . Broadly speaking, supervised statistical learning involves building a statistical model for pre- dicting, or estimating, an outputb a s e do no n eo rm o r e inputs.P r o b l e m so f thisnatureoccurinﬁeldsasdiverseasbusiness,medicine,astrophysics,and public policy. With unsupervised statistical learning, there are inputs but no supervising output; nevertheless we can learn relationships and struc- ture from such data. To provide an illustration of some applications of statistical learning, we brieﬂy discuss three real-world data sets that are considered in this book. Wage Data In this application (which we refer to as the Wagedata set throughout this book), we examine a number of factors that relate to wages for a group of males from the Atlantic region of the United States. In particular, we wish to understand the association between an employee’s ageand education ,a s well as the calendar year,o nh i s wage. Consider, for example, the left-hand panel of Figure 1.1, which displays wageversus agefor each of the individu- als in the data set. There is evidence that wageincreases with agebut then decreases again after approximately age 60. The blue line, which provides an estimate of the average wagefor a given age, makes this trend clearer. G. James et al., An Introduction to Statistical Learning: with Applications in R , Springer Texts in Statistics 103, DOI 10.1007/978-1-4614-7138-7 1, ©Springer Science+Business Media New York 20131 2 1. Introduction AgeWage Ye a rWage 20 40 60 8050 100 200 300 50 100 200 300 50 100 200 300 2003 2006 2009 12345 Education LevelWage FIGURE 1.1. Wagedata, which contains income survey information for males from the central Atlantic region of the United States. Left: wageas a function of age. On average, wageincreases with ageuntil about 60years of age, at which point it begins to decline. Center: wageas a function of year.T h e r ei sas l o w but steady increase of approximately $10,000in the average wagebetween 2003 and2009.Right:Boxplots displaying wageas a function of education ,w i t h1 indicating the lowest level (no high school diploma) and 5the highest level (an advanced graduate degree). On average, wageincreases with the level of education. G i v e nane m p l o y e e ’ s age, we canuse this curveto predicthiswage. However, it is also clear from Figure 1.1 that there is a signiﬁcant amount of vari- ability associated with this average value, and so agealone is unlikely to provide an accurate prediction of a particular man’s wage. We also have information regarding each employee’s education level and theyearin which the wagewas earned. The center and right-hand panels of Figure 1.1, which display wageas a function of both yearand education ,i n - dicate that both of these factors are associated with wage. Wages increase by approximately $10 ,000, in a roughly linear (or straight-line) fashion, between 2003 and 2009, though this rise is very slight relative to the vari- ability in the data. Wages are also typically greater for individuals with higher education levels: men with the lowest education level (1) tend to have substantially lower wages than those with the highest education level (5). Clearly, the most accurate prediction of a given man’s wagewill be obtained by combining his age,h i s education ,a n dt h e year. In Chapter 3, we discuss linear regression, which can be used to predict wagefrom this data set. Ideally, we should predict wagein a way that accounts for the non-linear relationship between wageand age. In Chapter 7, we discuss a class of approaches for addressing this problem. Stock Market Data The Wagedatainvolvespredictinga continuous orquantitative outputvalue. This is often referred to as a regression problem. However, in certain cases wemayinsteadwishtopredictanon-numericalvalue—thatis,a categorical 1. Introduction 3 Yesterday Today’s DirectionPercentage change in S&PTwo Days PreviousPercentage change in S&P Down Up Today’s DirectionDown Up Today’s DirectionDown Up−4 −2 0 2 4 6 −4 −2 0 2 4 6 −4 −2 0 2 4 6Three Days PreviousPercentage change in S&P FIGURE 1.2. Left:Boxplots of the previous day’s percentage change in the S&P index for the days for which the market increased or decreased, obtained from the Smarket data.Center and Right: Same as left panel, but the percentage changes for 2 and 3 days previous are shown. orqualitative output. For example, in Chapter 4 we examine a stock mar- ket data set that contains the daily movements in the Standard & Poor’s 500 (S&P) stock index over a 5-year period between 2001 and 2005. We refer to this as the Smarketdata. The goal is to predict whether the index willincrease ordecrease on a given day using the past 5 days’ percentage changes in the index. Here the statistical learning problem does not in- volve predicting a numerical value. Instead it involves predicting whether a given day’s stock market performance will fall into the Upbucket or the Downbucket. This is known as a classiﬁcation problem. A model that could accurately predict the direction in which the market will move would be very useful! The left-hand panel of Figure 1.2 displays two boxplots of the previous day’s percentage changes in the stock index: one for the 648 days for which the market increased on the subsequent day, and one for the 602 days for which the market decreased. The two plots look almost identical, suggest- ing that there is no simple strategy for using yesterday’s movement in the S&P to predict today’s returns. The remaining panels, which display box- plots for the percentage changes 2 and 3 days previous to today, similarly indicate little association between past and present returns. Of course, this lack of pattern is to be expected: in the presence of strong correlations be- tween successive days’ returns, one could adopt a simple trading strategy to generate proﬁts from the market. Nevertheless, in Chapter 4, we explore these datausingseveraldiﬀerent statisticallearningmethods. Interestingly, there are hints of some weak trends in the data that suggest that, at least for this 5-year period, it is possible to correctly predict the direction of movement in the market approximately 60% of the time (Figure 1.3). 4 1. Introduction Down Up0.46 0.48 0.50 0.52 Today’s DirectionPredicted Probability FIGURE 1.3. We ﬁt a quadratic discriminant analysis model to the subset of the Smarket data corresponding to the 2001–2004 time period, and predicted the probability of a stock market decrease using the 2005 data. On average, the predicted probability of decrease is higher for the days in which the market does decrease. Based on these results, we are able to correctly predict the direction of movement in the market 60% of the time. Gene Expression Data The previous two applications illustrate data sets with both input and output variables. However, another important class of problems involves situations in which we only observe input variables, with no corresponding output. For example, in a marketing setting, we might have demographic informationforanumberofcurrentorpotentialcustomers.Wemaywishto understand which types of customers are similar to each other by grouping individuals according to their observed characteristics. This is known as a clustering problem. Unlike in the previous examples, here we are not trying to predict an output variable. We devote Chapter 10 to a discussion of statistical learning methods for problems in which no natural output variable is available. We consider theNCI60data set, which consists of 6 ,830 gene expression measurements for each of 64 cancer cell lines. Instead of predicting a particular output variable, we are interested in determining whether there are groups, or clusters, among the cell lines based on their gene expression measurements. This is a diﬃcult question to address, in part because there are thousands of gene expression measurements per cell line, making it hard to visualize the data. The left-hand panel of Figure 1.4 addresses this problem by represent- ing each of the 64 cell lines using just two numbers, Z1andZ2.T h e s e are the ﬁrst two principal components of the data, which summarize the 6,830 expression measurements for each cell line down to two numbers or dimensions . While it is likely that this dimension reduction has resulted in 1. Introduction 5 −40 −20 0 20 40 60−60 −40 −20 0 20 −60 −40 −20 0 20 Z1−40 −20 0 20 40 60 Z1Z2 Z2 FIGURE 1.4. Left:Representation of the NCI60gene expression data set in a two-dimensional space, Z1andZ2. Each point corresponds to one of the 64 cell lines. There appear to be four groups of cell lines, which we have represented using diﬀerent colors. Right:Same as left panel except that we have represented each of the 14diﬀerent types of cancer using a diﬀerent colored symbol. Cell lines corresponding to the same cancer type tend to be nearby in the two-dimensional space. some loss of information, it is now possible to visually examine the data for evidence of clustering. Deciding on th e number of clusters is often a diﬃ- cult problem. But the left-hand panel of Figure 1.4 suggests at least four groups of cell lines, which we have represented using separate colors. We can now examine the cell lines within ea ch cluster for similarities in their types of cancer, in order to better understand the relationship between gene expression levels and cancer. In this particular data set, it turns out that the cell lines correspond to 14 diﬀerent types of cancer. (However, this information was not used to create the left-hand panel of Figure 1.4.) The right-hand panel of Fig- ure 1.4 is identical to the left-hand p anel, except that the 14 cancer types are shown using distinct colored symb ols. There is clear evidence that cell lines with the same cancer type tend to be located near each other in this two-dimensional representation. In addition, even though the cancer infor- mationwasnot usedtoproducethe left-handpanel,the clusteringobtained does bear some resemblance to some of the actual cancer types observed in the right-hand panel. This provides some independent veriﬁcation of the accuracy of our clu stering analysis. A Brief History of Statistical Learning Though the term statistical learning is fairly new, many of the concepts that underlie the ﬁeld were developed long ago. At the beginning of the nineteenth century, Legendre and Gauss published papers on the method 6 1. Introduction of least squares , which implemented the earliest form of what is now known aslinear regression . Theapproachwasﬁrstsuccessfullyappliedtoproblems in astronomy. Linear regression is used for predicting quantitative values, such as an individual’s salary.In order to predict qualitative values, such as whether a patient survives or dies, or whether the stock market increases or decreases, Fisher proposed linear discriminant analysis in 1936. In the 1940s,variousauthorsputforthanalternativeapproach, logistic regression . In the early 1970s, Nelder and Wedderburn coined the term generalized linear models for an entire class of statistical learning methods that include both linear and logistic regression as special cases. By the end of the 1970s, many more techniques for learning from data were available. However, they were almost exclusively linearmethods, be- cause ﬁtting non-linear relationships was computationally infeasible at the time. By the 1980s, computing technology had ﬁnally improved suﬃciently thatnon-linearmethodswerenolongercomputationallyprohibitive.Inmid 1980s Breiman, Friedman, Olshen and Stone introduced classiﬁcation and regression trees , and were among the ﬁrst to demonstrate the power of a detailed practical implementation of a method, including cross-validation for modelselection. Hastie andTibshiranicoined the term generalized addi- tive models in 1986 for a class of non-linear extensions to generalized linear models, and also provided a practical software implementation. Since that time, inspired by the advent of machine learning and other disciplines, statistical learning has emerged as a new subﬁeld in statistics, focused on supervised and unsupervise d modeling and prediction. In recent years, progress in statistical learning has been marked by the increasing availability of powerful and relatively user-friendly software, such as the popular and freely available Rsystem. This has the potential to continue the transformation of the ﬁeld from a set of techniques used and developed by statisticians and computer scientists to an essential toolkit for a much broader community. This Book The Elements of Statistical Learning (ESL) by Hastie, Tibshirani, and Friedman was ﬁrst published in 2001. Since that time, it has become an important reference on the fundamentals of statistical machine learning. Its success derives from its comprehen sive and detailed treatment of many important topics in statistical learning, as well as the fact that (relative to many upper-level statistics textbo oks) it is accessible to a wide audience. However, the greatest factor behin d the success of ESL has been its topical nature. At the time of its publication, interest in the ﬁeld of statistical 1. Introduction 7 learning was starting to explode. ESL provided one of the ﬁrst accessible and comprehensive introductions to the topic. Since ESL was ﬁrst published, the ﬁeld of statistical learning has con- tinued to ﬂourish. The ﬁeld’s expansion has taken two forms. The most obvious growth has involved the development of new and improved statis- tical learning approaches aimed at answ ering a range of scientiﬁc questions across a number of ﬁelds. However, t he ﬁeld of statistical learning has also expanded its audience. In the 1990s, increases in computational power generated a surge of interest in the ﬁeld from non-statisticians who were eager to use cutting-edge statistical tools to analyze their data. Unfortu- nately, the highly technical nature of these approaches meant that the user community remained primarily restrict ed to experts in statistics, computer science, and related ﬁelds with the training (and time) to understand and implement them. In recent years, new and improved software packages have signiﬁcantly eased the implementation burden for many statistical learning methods. At the same time, there has been grow ing recognition across a number of ﬁelds, from business to health care to g enetics to the social sciences and beyond, that statistical learning is a powerful tool with important practical applications.Asaresult,theﬁeldhasmovedfromoneofprimarilyacademic interest to a mainstream discipline, with an enormous potential audience. This trend will surely continue with the increasing availability of enormous quantities of data and the software to analyze it. The purpose of An Introduction to Statistical Learning (ISL) is to facili- tate the transitionof statisticallearning from an academicto a mainstream ﬁeld. ISL is not intended to replace ESL, which is a far more comprehen- sive text both in terms of the number of approaches considered and the depth to which they are explored. We consider ESL to be an important companion for professionals (with graduate degrees in statistics, machine learning, or related ﬁelds) who need to understand the technical details behind statistical learning approaches. However, the community of users of statistical learning techniques has expanded to include individuals with a wider range of interests and backgrounds. Therefore, we believe that there is now a place for a less technical and more accessible version of ESL. In teaching these topics over the years, we have discovered that they are of interest to master’s and PhD students in ﬁelds as disparate as business administration, biology, and computer science, as well as to quantitatively- oriented upper-division undergraduates. It is important for this diverse group to be able to understand the models, intuitions, and strengths and weaknesses of the various approaches. But for this audience, many of the technical details behind statistical learning methods, such as optimiza- tion algorithms and theoretical properties, are not of primary interest. We believe that these students do not need a deep understanding of these aspectsinordertobecomeinformedus ersofthevariousmethodologies,and 8 1. Introduction in order to contribute to their chosen ﬁelds through the use of statistical learning tools. ISLR is based on the following four premises. 1.Many statistical learning methods are relevant and useful in a wide range of academic and non-academic disciplines, beyond just the sta- tistical sciences. We believe that many contempo rarystatisticallearn- ing procedures should, and will, become as widely available and used as is currently the case for classi cal methods such as linear regres- sion. As a result, rather than attempting to consider every possible approach (an impossible task), we have concentrated on presenting the methods that we believe are most widely applicable. 2.Statistical learning should not be viewed as a series of black boxes. No single approach will perform well in all possible applications. With- out understanding all of the cogs inside the box, or the interaction between those cogs, it is impossible to select the best box. Hence, we have attempted to carefully describe the model, intuition, assump- tions, and trade-oﬀs behind each of the methods that we consider. 3.While it is important to know what job is performed by each cog, it is not necessary to have the skills to construct the machine inside the box!Thus, we have minimized discussion of technical details related to ﬁtting procedures and theoretical properties. We assume that the reader is comfortable with basic mathematical concepts, but we do not assume a graduate degree in the m athematical sciences. For in- stance, we have almost completely avoided the use of matrix algebra, and it is possible to understand the entire book without a detailed knowledge of matrices and vectors. 4.We presume that the reader is interested in applying statistical learn- ing methods to real-world problems. In order to facilitate this, as well as to motivate the techniques discussed, we have devoted a section within each chapter to Rcomputer labs. In each lab, we walk the reader through a realistic application of the methods considered in that chapter. When we have taught this material in our courses, we have allocated roughly one-third of classroom time to working through the labs, and we have found them to be extremely useful. Many of the less computationally-oriented students who were ini- tially intimidated by R’s command level interface got the hang of things over the course of the quarter or semester. We have used R because it is freely available and is powerful enough to implement all of the methods discussed in the book. It also has optional packages that can be downloaded to implement literally thousands of addi- tional methods. Most importantly, Ris the language of choice for academic statisticians, and new approaches often become available in 1. Introduction 9 Ryears before they are implemented in commercial packages. How- ever, the labs in ISL are self-contained, and can be skipped if the reader wishes to use a diﬀerent software package or does not wish to apply the methods discussed to real-world problems. Who Should Read This Book? This book is intended for anyone who is interested in using modern statis- tical methods for modeling and prediction from data. This group includes scientists, engineers, data analysts, or quants, but also less technical indi- viduals with degrees in non-quantitative ﬁelds such as the social sciences or business. We expect that the reader w ill have had at least one elementary course in statistics. Background in linear regression is also useful, though not required, since we review the key concepts behind linear regression in Chapter 3. The mathematical level of this book is modest, and a detailed knowledge of matrix operations is not required. This book provides an in- troduction to the statistical programming language R. Previous exposure to a programming language, such as MATLABorPython, is useful but not required. We have successfully taught material at this level to master’s and PhD students in business, computer science, biology, earth sciences, psychology, and many other areas of the physical and social sciences. This book could also be appropriate for advanced undergraduates who have already taken a course on linear regression. In the context of a more mathematically rigorous course in which ESL serves as the primary textbook, ISL could be used as a supplementary text for teaching computational aspects of the various approaches. Notation and Simple Matrix Algebra Choosing notation for a textbook is always a diﬃcult task. For the most part we adopt the same notational conventions as ESL. We will use nto represent the number of distinct data points, or observa- tions, in our sample. We will let pdenote the number of variables that are available for use in making predictions. For example, the Wagedata set con- sists of 12 variablesfor 3 ,000people, so wehave n=3,000observationsand p= 12 variables (such as year,age,wage, and more). Note that throughout this book, we indicate variable names using colored font: Variable Name . In some examples, pmight be quite large, such as on the order of thou- sands or even millions; this situation arises quite often, for example, in the analysis of modern biological data or web-based advertising data. 10 1. Introduction In general, we will let xijrepresent the value of the jth variable for the ith observation, where i=1,2,...,nandj=1,2,...,p. Throughout this book,iwill be used to index the samples or observations (from 1 to n)a n d jwill be used to index the variables (from 1 to p). We let Xdenote a n×p matrix whose ( i,j)th element is xij.T h a ti s , X=⎛ ⎜⎜⎜⎝x11x12... x 1p x21x22... x 2p ............ xn1xn2... x np⎞ ⎟⎟⎟⎠. For readers who are unfamiliar with matrices, it is useful to visualize Xas a spreadsheet of numbers with nrows and pcolumns. At times we will be interested in the rows of X, which we write as x1,x2,...,x n.H e r exiis a vector of length p, containing the pvariable measurements for the ith observation. That is, xi=⎛ ⎜⎜⎜⎝xi1 xi2 ... xip⎞ ⎟⎟⎟⎠. (1.1) (Vectors are by default represented as columns.) For example, for the Wage data,xiis a vector of length 12, consisting of year,age,wage, and other values for the ith individual. At other times we will instead be interested in the columns of X, which we write as x1,x2,...,xp. Each is a vector of lengthn.T h a ti s , xj=⎛ ⎜⎜⎜⎝x1j x2j ... xnj⎞ ⎟⎟⎟⎠. For example, for the Wagedata,x1contains the n=3,000 values for year. Using this notation, the matrix Xcan be written as X=/parenleftbigx1x2···xp/parenrightbig , or X=⎛ ⎜⎜⎜⎝xT 1 xT 2 ... xT n⎞ ⎟⎟⎟⎠. 1. Introduction 11 TheTnotationdenotesthe transpose ofamatrixorvector.So,forexample, XT=⎛ ⎜⎜⎜⎝x11x21... x n1 x12x22... x n2 ......... x1px2p... x np⎞ ⎟⎟⎟⎠, while xT i=/parenleftbigxi1xi2···xip/parenrightbig . We useyito denote the ith observation of the variable on which we wish to make predictions, such as wage. Hence, we write the set of all n observations in vector form as y=⎛ ⎜⎜⎜⎝y1 y2 ... yn⎞ ⎟⎟⎟⎠. Then our observed data consists of {(x1,y1),(x2,y2),...,(xn,yn)},w h e r e eachxiis a vector of length p.( I fp=1 ,t h e n xiis simply a scalar.) In this text, a vector of length nwill always be denoted in lower case bold; e.g. a=⎛ ⎜⎜⎜⎝a1 a2 ... an⎞ ⎟⎟⎟⎠. However, vectors that are not of length n(such as feature vectors of length p, as in (1.1)) will be denoted in lower case normal font , e.g.a. Scalars will also be denoted in lower case normal font , e.g.a. In the rare cases in which these two uses for lower case normal font lead to ambiguity, we will clarify which use is intended. Matrices will be denoted using bold capitals ,s u c h asA. Random variables will be denoted using capital normal font , e.g.A, regardless of their dimensions. Occasionally we will want to indicate the dimension of a particular ob- ject. To indicate that an object is a scalar, we will use the notation a∈R. To indicate that it is a vector of length k, we will use a∈Rk(ora∈Rn if it is of length n). We will indicate that an object is a r×smatrix using A∈Rr×s. We have avoided using matrix algebra whenever possible. However, in a few instances it becomes too cumber some to avoid it entirely. In these rare instances it is important to understand the concept of multiplying two matrices. Suppose that A∈Rr×dandB∈Rd×s. Then the product 12 1. Introduction ofAandBis denoted AB.T h e(i,j)th element of ABis computed by multiplying each element of the ith row of Aby the corresponding element of thejth column of B.T h a ti s ,( AB)ij=/summationtextd k=1aikbkj. As an example, consider A=/parenleftbigg12 34/parenrightbigg andB=/parenleftbigg56 78/parenrightbigg . Then AB=/parenleftbigg 12 34/parenrightbigg/parenleftbigg 56 78/parenrightbigg =/parenleftbigg 1×5+2×71×6+2×8 3×5+4×73×6+4×8/parenrightbigg =/parenleftbigg 19 22 43 50/parenrightbigg . Note that this operation produces an r×smatrix. It is only possible to compute ABif the number of columns of Ais the same as the number of rows ofB. Organization of This Book Chapter 2 introduces the basic terminology and concepts behind statisti- cal learning. This chapter also presents the K-nearest neighbor classiﬁer, a very simple method that works surprisingly well on many problems. Chap- ters 3 and 4 cover classical linear met hods for regression and classiﬁcation. In particular, Chapter 3 reviews linear regression , the fundamental start- ing point for all regression methods. In Chapter 4 we discuss two of the most important classical classiﬁcation methods, logistic regression andlin- ear discriminant analysis . A central problem in all statistical learning situations involves choosing the best method for a given application. Hence, in Chapter 5 we intro- ducecross-validation and thebootstrap , which can be used to estimate the accuracy of a number of diﬀerent methods in order to choose the best one. Much of the recent research in statist ical learning has concentrated on non-linear methods. However, linear methods often have advantages over their non-linearcompetitorsin terms of interpretabilityand sometimes also accuracy. Hence, in Chapter 6 we cons ider a host of linear methods, both classical and more modern, which oﬀer potential improvements over stan- dard linear regression. These include stepwise selection ,ridge regression , principal components regression ,partial least squares ,a n dt h e lasso. The remaining chapters move into the world of non-linear statistical learning. We ﬁrst introduce in Chapter 7 a number of non-linear methods that workwell for problems with a single input variable. We then show how these methods can be used to ﬁt non-linear additivemodels for which there is more than one input. In Chapter 8, we investigate tree-based methods, including bagging,boosting,a n drandom forests .Support vector machines , a set of approaches for performing both linear and non-linear classiﬁcation, 1. Introduction 13 are discussed in Chapter 9. Finally, in Chapter 10, we consider a setting in which we have input variables but no output variable. In particular, we presentprincipal components analysis ,K-means clustering ,a n dhierarchi- cal clustering . At the end of each chapter, we present one or more Rlab sections in which we systematically work through applications of the various meth- ods discussed in that chapter. These labs demonstrate the strengths and weaknesses of the various approaches, and also provide a useful reference for the syntax required to implement the various methods. The reader may choose to work through the labs at his or her own pace, or the labs may be the focus of group sessions as part of a classroom environment. Within each Rlab, we present the results that we obtained when we performed the lab at the time of writing this book. However, new versions of Rare continuously released, and over time, the packages called in the labs will be updated. Therefore, in the future, it is possible that the results shown in the lab sections may no longer correspond precisely to the results obtained by the reader who performs the labs. As necessary, we will post updates to the labs on the book website. We use the symbol to denote sections or exercises that contain more challenging concepts. These can be easily skipped by readers who do not wish to delve as deeply into the material, or who lack the mathematical background. Data Sets Used in Labs and Exercises In this textbook, we illustrate statistical learning methods using applica- tions from marketing, ﬁnance, biology, and other areas. The ISLRpackage available on the book website contains a number of data sets that are required in order to perform the lab s and exercises associated with this book. One other data set is contained in the MASSlibrary, and yet another is part of the base Rdistribution. Table 1.1 contains a summary of the data sets required to perform the labs and exercises. A couple of these data sets are also available as text ﬁles on the book website, for use in Chapter 2. Book Website T h ew e b s i t ef o rt h i sb o o ki sl o c a t e da t www.StatLearning.com 14 1. Introduction Name Description Auto Gas mileage, horsepower, and other information for cars. Boston Housing values and other information about Boston suburbs. Caravan Information about individuals oﬀered caravan insurance. Carseats Information about car seat sales in 400 stores. College Demographic characteristics, tuition, and more for USA colleges. Default Customer default records for a credit card company. Hitters Records and salaries for baseball players. Khan Gene expression measurements for four cancer types. NCI60 Gene expression measurements for 64 cancer cell lines. OJ Sales information for Citrus Hill and Minute Maid orange juice. Portfolio Past values of ﬁnancial assets, for use in portfolio allocation. Smarket Daily percentage returns for S&P 500 over a 5-year period. USArrests Crime statistics per 100,000 residents in 50 states of USA. Wage Income survey data for males in central Atlantic region of USA. Weekly 1,089 weekly stock market returns for 21 years. TABLE 1.1. A list of data sets needed to perform the labs and exercises in this textbook. All data sets are available in the ISLRlibrary, with the exception of Boston(part of MASS)a n d USArrests (part of the base Rdistribution) . It contains a number of resources, including the Rpackage associated with this book, and some additional data sets. Acknowledgements A few of the plots in this book were taken from ESL: Figures 6.7, 8.3, and 10.12. All other plots are new to this book. 2 Statistical Learning 2.1 What Is Statistical Learning? In order to motivate our study of statistical learning, we begin with a simple example. Suppose that we are statistical consultants hired by a clienttoprovideadviceonhowtoimprovesalesofaparticularproduct.The Advertising data set consists of the salesof that product in 200 diﬀerent markets, along with advertising budgets for the product in each of those markets for three diﬀerent media: TV,radio,a n d newspaper . The data are displayed in Figure 2.1. It is not possible for our client to directly increase sales of the product. On the other hand, they can control the advertising expenditure in each of the three medi a. Therefore, if we determine that there is an association between advert ising and sales, then we can instruct our client to adjust advertising budgets, thereby indirectly increasing sales. In other words, our goal is to develop an accurate model that can be used to predict sales on the basis of the three media budgets. In this setting, the advertising budgets are input variables while salesinput variable is anoutput variable . The input variables are typically denoted using the output variablesymbolX, with a subscript to distinguish them. So X1might be the TV budget,X2the radiobudget, and X3the newspaper budget. The inputs go by diﬀerent names, such as predictors ,independent variables ,features,predictor independent variable featureor sometimes just variables . The output variable—in this case, sales—is variableoften called the response ordependent variable , and is typically denoted response dependent variableusing the symbol Y. Throughout this book, we will use all of these terms interchangeably. G. James et al., An Introduction to Statistical Learning: with Applications in R , Springer Texts in Statistics 103, DOI 10.1007/978-1-4614-7138-7 2, ©Springer Science+Business Media New York 201315 16 2. Statistical Learning 0 50 100 200 30051 0 1 5 2 0 2 5 TVSales 0 1 02 03 04 05 051 0 1 5 2 0 2 5 RadioSales 02 0 4 0 6 0 8 0 1 0 051 0 1 5 2 0 2 5 NewspaperSales FIGURE 2.1. The Advertising data set. The plot displays sales, in thousands of units, as a function of TV,radio,a n d newspaper budgets, in thousands of dollars, for 200diﬀerent markets. In each plot we show the simple least squares ﬁt of salesto that variable, as described in Chapter 3. In other words, each blue line represents a simple model that can be used to predict salesusing TV,radio, and newspaper , respectively. More generally, suppose that we observe a quantitative response Yandp diﬀerent predictors, X1,X2,...,X p. We assume that there is some relationship between YandX=(X1,X2,...,X p), which can be written in the very general form Y=f(X)+/epsilon1. (2.1) Herefissomeﬁxedbut unknownfunction of X1,...,X p,and/epsilon1isarandom error term , which is independent of Xand has mean zero. In this formula-error termtion,frepresents the systematic information that Xprovides about Y.systematicAs another example, consider the left-hand panel of Figure 2.2, a plot of incomeversus years of education for 30 individuals in the Incomedata set. The plot suggests that one might be able to predict incomeusing years of education . However, the function fthat connects the input variable to the output variable is in general unknown. In this situation one must estimate fb a s e do nt h eo b s e r v e dp o i n t s .S i n c e Incomeis a simulated data set, fis known and is shown by the blue curvein the right-handpanel ofFigure 2.2. The vertical lines repr esent the error terms /epsilon1. We note that some of the 30 observations lie above the blue curve and some lie below it; overall, the errors have approximately mean zero. In general, the function fmay involve more than one input variable. In Figure 2.3 we plot incomeas a function of years of education and seniority .H e r efis a two-dimensional surface that must be estimated based on the observed data. 2.1 What Is Statistical Learning? 17 10 12 14 16 18 20 2220 30 40 50 60 70 80 Y ears of EducationIncome 10 12 14 16 18 20 2220 30 40 50 60 70 80 Years of EducationIncome FIGURE 2.2. The Incomedata set. Left:The red dots are the observed values ofincome(in tens of thousands of dollars) and years of education for30indi- viduals.Right:The blue curve represents the true underlying relationship between incomeand years of education , which is generally unknown (but is known in this case because the data were simulated). The black lines represent the error associated with each observation. Note that some errors are positive (if an ob- servation lies above the blue curve) and some are negative (if an observation lies below the curve). Overall, these errors have approximately mean zero. In essence, statistical learning ref ers to a set of approaches for estimating f. In this chapter we outline some of the key theoretical concepts that arise in estimating f, as well as tools for evaluating the estimates obtained. 2.1.1 Why Estimate f? There are two main reasons that we may wish to estimate f:prediction andinference . We discuss each in turn. Prediction In many situations, a set of inputs Xare readily available, but the output Ycannot be easily obtained. In this se tting, since the error term averages to zero, we can predict Yusing ˆY=ˆf(X), (2.2) whereˆfrepresents our estimate for f,a n dˆYrepresents the resulting pre- diction for Y. In this setting, ˆfis often treated as a black box , in the sense that one is not typically concerned with the exact form of ˆf, provided that it yields accurate predictions for Y. 18 2. Statistical Learning Y ears of Education SeniorityIncome FIGURE 2.3. The plot displays incomeas a function of years of education and seniority in the Incomedata set. The blue surface represents the true un- derlying relationship between incomeand years of education and seniority , which is known since the data are simulated. The red dots indicate the observed values of these quantities for 30individuals. As an example, suppose that X1,...,X pare characteristicsof a patient’s blood sample that can be easily measured in a lab, and Yis a variable encoding the patient’s risk for a seve re adverse reaction to a particular drug. It is natural to seek to predict YusingX, since we can then avoid giving the drug in question to patients who are at high risk of an adverse reaction—that is, patients for whom the estimate of Yis high. The accuracy of ˆYas a prediction for Ydepends on two quantities, which we will call the reducible error and theirreducible error . In general,reducible error irreducible errorˆfwill not be a perfect estimate for f, and this inaccuracy will introduce some error. This error is reducible because we can potentially improve the accuracyof ˆfbyusingthemostappropriatestatisticallearningtechniqueto estimate f. However, even if it were possibl e to form a perfect estimate for f, so that our estimated response took the form ˆY=f(X), our prediction would still have some error in it! This is because Yis also a function of /epsilon1, which, by deﬁnition, cannot be predicted using X. Therefore, variability associated with /epsilon1also aﬀects the accuracyof ou r predictions. This is known as theirreducible error, because no matter how well we estimate f,w e cannot reduce the error introduced by /epsilon1. Why is the irreducible error larger than zero? The quantity /epsilon1may con- tain unmeasured variables that are useful in predicting Y: since we don’t measure them, fcannot use them for its prediction. The quantity /epsilon1may also contain unmeasurable variation. For example, the risk of an adverse reaction might vary for a given patient on a given day, depending on 2.1 What Is Statistical Learning? 19 manufacturing variation in the drug its elf or the patient’s general feeling of well-being on that day. Consider a given estimate ˆfand a set of predictors X, which yields the prediction ˆY=ˆf(X). Assume for a moment that both ˆfandXare ﬁxed. Then, it is easy to show that E(Y−ˆY)2=E[f(X)+/epsilon1−ˆf(X)]2 =[f(X)−ˆf(X)]2 /bracehtipupleft/bracehtipdownright/bracehtipdownleft/bracehtipupright Reducible+V a r (/epsilon1)/bracehtipupleft/bracehtipdownright/bracehtipdownleft/bracehtipupright Irreducible, (2.3) whereE(Y−ˆY)2represents the average, or expected value , of the squaredexpected value diﬀerence between the predicted and actual value of Y,a n dV a r ( /epsilon1)r e p r e - sents the variance associated with the error term /epsilon1.varianceThe focus of this book is on techniques for estimating fwith the aim of minimizing the reducible error. It is important to keep in mind that the irreducible error will always provide an upper bound on the accuracy of our prediction for Y. This bound is almost always unknown in practice. Inference We are often interested in understanding the way that Yis aﬀected as X1,...,X pchange. In this situation we wish to estimate f, but our goal is not necessarily to ma ke predictions for Y. We instead want to understand the relationship between XandY, or more speciﬁcally, to understand how Ychanges as a function of X1,...,X p.N o wˆfcannot be treated as a black box, because we need to know its exact form. In this setting, one may be interested in answering the following questions: •Which predictors are associated with the response? It is often the case that only a small fraction of the available predictors are substantially associated with Y. Identifying the few important predictors among a large set of possible variables can be extremely useful, depending on the application. •What is the relationship between the response and each predictor? Some predictors may have a positive relationship with Y, in the sense that increasing the predictor is a ssociated with increasing values of Y. Other predictors may have the opposite relationship. Depending on the complexity of f, the relationship between the response and a givenpredictor mayalso depend on the values ofthe otherpredictors. •Can the relationship between Yand each predictor be adequately sum- marized using a linear equation, or is the relationship more compli- cated?Historically,mostmethods forestimating fhave taken a linear form.Insomesituations,suchanassumptionisreasonableorevende- sirable. But often the true relationship is more complicated, in which case a linear model may not provid e an accurate representation of the relationship between the input and output variables. 20 2. Statistical Learning Inthisbook,wewillseeanumberofexamplesthatfallintotheprediction setting, the inference setting, or a combination of the two. For instance, consider a company that is interested in conducting a direct-marketing campaign. The goal is to identify individuals who will respond positively to a mailing, based on observations of demographic vari- ables measured on each individual. In this case, the demographic variables serve as predictors, and response to t he marketing campaign (either pos- itive or negative) serves as the out come. The company is not interested in obtaining a deep understanding of the relationships between each in- dividual predictor and the response; instead, the company simply wants an accurate model to predict the response using the predictors. This is an example of modeling for prediction. In contrast, consider the Advertising data illustrated in Figure 2.1. One may be interested in answering questions such as: –Which media contribute to sales? –Which media generate the biggest boost in sales? or –How much increase in sales is associated with a given increase in TV advertising? This situation falls into the inference paradigm. Another example involves modeling the brand of a product that a customer might purchase based on variables such as price, store location, discount levels, competition price, and so forth. In this situation one might really be most interested in how each of the individual variables aﬀects the probability of purchase. For instance, what eﬀect will changing the price of a product have on sales? This is an example of modeling for inference. Finally, some modeling could be conducted both for prediction and infer- ence. For example, in a real estate se tting, one may seek to relate values of homes to inputs such as crime rate, zoning, distance from a river, air qual- ity, schools, income level of community, size of houses, and so forth. In this case one might be interested in how the individual input variables aﬀect the prices—that is, how much extra will a house be worth if it has a view of the river? This is an inference problem. Alternatively, one may simply be interested in predicting the value of a home given its characteristics: is this house under- or over-valued? This is a prediction problem. Depending on whether our ultimate goal is prediction, inference, or a combination of the two, diﬀerent methods for estimating fmay be appro- priate. For example, linear models allow for relatively simple and inter-linear modelpretable inference, but may not yield a s accurate predictions as some other approaches. In contrast, some of the highly non-linear approaches that we discuss in the laterchaptersofthis book can potentially providequite accu- rate predictions for Y, but this comes at the expense of a less interpretable model for which inference is more challenging. 2.1 What Is Statistical Learning? 21 2.1.2 How Do We Estimate f? Throughout this book, we explore many linear and non-linear approaches for estimating f. However, these methods gener ally share certain charac- teristics. We provide an overview of these shared characteristics in this section. We will always assume that we have observed a set of ndiﬀerent data points. For example in Figure 2.2 we observed n=3 0d a t ap o i n t s . These observations are called the training data because we will use thesetraining dataobservations to train, or teach, our method how to estimate f.L e txij represent the value of the jth predictor, or input, for observation i,w h e r e i=1,2,...,nandj=1,2,...,p. Correspondingly, let yirepresent the response variable for the ith observation. Then our training data consist of {(x1,y1),(x2,y2),...,(xn,yn)}wherexi=(xi1,xi2,...,x ip)T. Our goal is to apply a statistical learning method to the training data in order to estimate the unknown function f. In other words, we want to ﬁnd a function ˆfsuch that Y≈ˆf(X) for any observation ( X,Y). Broadly speaking, most statistical learning methods for this task can be character- ized as either parametric ornon-parametric . We now brieﬂy discuss theseparametric non- parametrictwo types of approaches. Parametric Methods Parametric methods involve a two-step model-based approach. 1. First, we make an assumption about the functional form, or shape, off. For example, one very simple assumption is that fis linear in X: f(X)=β0+β1X1+β2X2+...+βpXp. (2.4) This is a linear model , which will be discussed extensively in Chap- ter 3. Once we have assumed that fis linear, the problem of estimat- ingfis greatly simpliﬁed. Instead of having to estimate an entirely arbitrary p-dimensional function f(X), one only needs to estimate thep+1 coeﬃcients β0,β1,...,β p. 2. After a model has been selected, we need a procedure that uses the training data to ﬁtortrainthe model. In the case of the linear modelﬁt train (2.4), we need to estimate the parameters β0,β1,...,β p.T h a ti s ,w e want to ﬁnd values of these parameters such that Y≈β0+β1X1+β2X2+...+βpXp. The most common approach to ﬁtting the model (2.4) is referred to as(ordinary) least squares , which we discuss in Chapter 3. How-least squaresever, least squares is one of many possible ways way to ﬁt the linear model. In Chapter 6, we discuss other approaches for estimating the parameters in (2.4). The model-based approach just described is referred to as parametric ; it reduces the problem of estimating fdown to one of estimating a set of 22 2. Statistical Learning Y ears of Education SeniorityIncome FIGURE 2.4. A linear model ﬁt by least squares to the Incomedata from Fig- ure 2.3. The observations are shown in red, and the yellow plane indicates the least squares ﬁt to the data. parameters. Assuming a parametric form for fsimpliﬁes the problem of estimating fbecause it is generally much ea sier to estimate a set of pa- rameters, such as β0,β1,...,β pin the linear model (2.4), than it is to ﬁt an entirely arbitrary function f. The potential disadvantage of a paramet- ric approach is that the model we choose will usually not match the true unknown form of f. If the chosen model is too far from the true f,t h e n our estimate will be poor. We can try to address this problem by choos- ingﬂexiblemodels that can ﬁt many diﬀerent possible functional formsﬂexibleforf. But in general, ﬁtting a more ﬂexible model requires estimating a greater number of parameters. Thes e more complex models can lead to a phenomenon known as overﬁtting the data, which essentially means theyoverﬁttingfollow the errors, or noise, too closely. These issues are discussed through-noiseout this book. Figure 2.4 shows an example of the parametric approach applied to the Incomedata from Figure 2.3. We have ﬁt a linear model of the form income≈β0+β1×education +β2×seniority . Since we have assumed a linear relationship between the response and the two predictors, the entire ﬁtting problem reduces to estimating β0,β1,a n d β2, which we do using leastsquares linear regression.Comparing Figure 2.3 to Figure 2.4, we can see that the linear ﬁt given in Figure 2.4 is not quite right: the true fhas some curvature that is not captured in the linear ﬁt. However, the linear ﬁt still appears to do a reasonable job of capturing the positive relationshipbetween years of education and income,a sw e l la st h e 2.1 What Is Statistical Learning? 23 Years of Education SeniorityIncome FIGURE 2.5. A smooth thin-plate spline ﬁt to the Incomedata from Figure 2.3 is shown in yellow; the observations are displayed in red. Splines are discussed in Chapter 7. slightly less positive relationship between seniority and income.I tm a yb e that with such a small number of observations, this is the best we can do. Non-parametric Methods Non-parametricmethods do not make explicit assumptions about the func- tional form of f. Instead they seek an estimate of fthat gets as close to the data points as possible without being too rough or wiggly. Such approaches can have a major advantage over parametric approaches: by avoiding the assumption of a particular functional form for f, they have the potential to accurately ﬁt a wider range of possible shapes for f.A n yp a r a m e t r i c approach brings with it the possibility that the functional form used to estimate fis very diﬀerent from the true f, in which case the resulting model will not ﬁt the data well. In contrast, non-parametric approaches completely avoid this danger, since essentially no assumption about the form offis made. But non-parametric approaches do suﬀer from a major disadvantage: since they do not reduce the problem of estimating fto a small number of parameters, a very large number of observations (far more than is typically needed for a parametric approach) is required in order to obtain an accurate estimate for f. An example of a non-parametric approach to ﬁtting the Incomedata is s h o w ni nF i g u r e2 . 5 .A thin-plate spline is used to estimate f. This ap-thin-plate spline proach does not impose any pre-speciﬁed model on f. It instead attempts to produce an estimate for fthat is as close as possible to the observed data, subject to the ﬁt—that is, the yellow surface in Figure 2.5—being 24 2. Statistical Learning Years of Education SeniorityIncome FIGURE 2.6. A rough thin-plate spline ﬁt to the Incomedata from Figure 2.3. This ﬁt makes zero errors on the training data. smooth. In this case, the non-parametric ﬁt has produced a remarkably ac- curateestimateof the true fshownin Figure2.3.In ordertoﬁt athin-plate spline, the data analyst must select a level of smoothness. Figure 2.6 shows the same thin-plate spline ﬁt using a lower level of smoothness, allowing for a rougher ﬁt. The resulting estimate ﬁts the observed data perfectly! However, the spline ﬁt shown in Figure 2.6 is far more variable than the true function f, from Figure 2.3. This is an example of overﬁtting the data, which we discussed previously. It is an undesirable situation because the ﬁt obtained will not yield accurate estimates of the response on new observations that were not part of the original training data set. We dis- cuss methods for choosing the correctamount of smoothness in Chapter 5. Splines are discussed in Chapter 7. As we have seen, there are advantages and disadvantages to parametric and non-parametricmethods for statisticallearning.We exploreboth types of methods throughout this book. 2.1.3 The Trade-Oﬀ Between Prediction Accuracy and Model Interpretability Of the many methods that we examine in this book, some are less ﬂexible, or more restrictive, in the sense th at they can produce just a relatively small range of shapes to estimate f. For example, linear regression is a relatively inﬂexible approach, because it can only generate linear functions such as the lines shown in Figure 2.1 or the plane shown in Figure 2.3. 2.1 What Is Statistical Learning? 25 FlexibilityInterpretability Low HighHigh LowSubset Selection Lasso Least Squares Generalized Additive Models Trees Bagging, Boosting Support Vector Machines FIGURE 2.7. A representation of the tradeoﬀ between ﬂexibility and inter- pretability, using diﬀerent statistical learning methods. In general, as the ﬂexibil- ity of a method increases, its interpretability decreases. Other methods, such as the thin plate splines shown in Figures 2.5 and 2.6, are considerably more ﬂexible because they can generate a much wider range of possible shapes to estimate f. One might reasonably ask the following question: why would we ever choose to use a more restrictive method instead of a very ﬂexible approach? There are several reasons that we might prefer a more restrictive model. If we are mainly interested in inferen ce, then restrictive models are much more interpretable. For instance, when inference is the goal, the linear model may be a good choice since it will be quite easy to understand the relationship between YandX1,X2,...,X p. In contrast, very ﬂexible approaches, such as the splines discussed in Chapter 7 and displayed in Figures 2.5 and 2.6, and the boosting methods discussed in Chapter 8, can lead to such complicated estimates of fthat it is diﬃcult to understand how any individual predictor is associated with the response. Figure 2.7 provides an illustration of the trade-oﬀbetween ﬂexibility and interpretability for some of the methods that we cover in this book. Least squares linear regression, discussed in Chapter 3, is relatively inﬂexible but is quite interpretable. The lasso, discussed in Chapter 6, relies upon thelassolinear model (2.4) but uses an alternative ﬁtting procedure for estimating the coeﬃcients β0,β1,...,β p. The new procedure is more restrictive in es- timating the coeﬃcients, and sets a number of them to exactly zero. Hence in this sense the lasso is a less ﬂexible approach than linear regression. It is also more interpretable than linear regression, because in the ﬁnal model the response variable will only be related to a small subset of the predictors—namely, those wit h nonzero coeﬃcient estimates. Generalized 26 2. Statistical Learning additive models (GAMs), discussed in Chapter 7, instead extend the lin-generalized additive modelear model (2.4) to allow for certain non-linear relationships. Consequently, GAMs are more ﬂexible than linear regression. They are also somewhat less interpretable than linear regression, because the relationship between each predictor and the response is now modeled using a curve. Finally, fully non-linear methods such as bagging,boosting,a n dsupport vector machinesbagging boostingwith non-linear kernels, discussed in Chapters 8 and 9, are highly ﬂexible support vector machineapproaches that are harder to interpret. We have established that when inference is the goal, there are clear ad- vantages to using simple and relatively inﬂexible statistical learning meth- ods. In some settings, however, we are only interested in prediction, and the interpretability of the predictive model is simply not of interest. For instance, if we seek to develop an algorithm to predict the price of a stock, our sole requirement for the algorithm is that it predict accurately— interpretability is not a concern. In this setting, we might expect that it will be best to use the most ﬂexible model available. Surprisingly, this is not always the case! We will often obtain more accurate predictions using a less ﬂexible method. This phenomenon, which may seem counterintuitive at ﬁrst glance, has to do with the potential for overﬁtting in highly ﬂexible methods. We saw an example of overﬁtting in Figure 2.6. We will discuss this very important concept further in Section 2.2 and throughout this book. 2.1.4 Supervised Versus Unsupervised Learning Most statisticallearning problems fall into oneof two categories: supervisedsupervisedorunsupervised . The examples that we have discussed so far in this chap-unsupervisedter all fall into the supervised learning domain. For each observation of the predictor measurement(s) xi,i=1,...,nthere is an associated response measurement yi. We wish to ﬁt a model that relates the response to the predictors, with the aim of accurately predicting the response for future observations (prediction) or better understanding the relationship between the responseand the predictors(infere nce). Many classicalstatisticallearn- ing methods such as linear regressionand logistic regression (Chapter 4), aslogistic regression well as more modern approaches such as GAM, boosting, and support vec- tor machines, operatein the supervised learningdomain. The vast majority of this book is devoted to this setting. In contrast, unsupervised learnin g describes the somewhat more chal- lenging situation in which for every observation i=1,...,n,w eo b s e r v e a vector of measurements xibut no associated response yi.I ti sn o tp o s - sible to ﬁt a linear regression model, since there is no response variable to predict. In this setting, we are in some sense working blind; the sit- uation is referred to as unsupervised b e c a u s ew el a c kar e s p o n s ev a r i - able that can supervise our analysis. What sort of statistical analysis is 2.1 What Is Statistical Learning? 27 02468 1 0 1 224 6 8 10 12 02462468 FIGURE 2.8. A clustering data set involving three groups. Each group is shown using a diﬀerent colored symbol. Left:The three groups are well-separated. In this setting, a clustering approach should successfully identify the three groups. Right:There is some overlap among the groups. Now the clustering task is more challenging. possible?Wecanseektounderstandtherelationshipsbetweenthe variables or between the observations. One statistical learning tool that we may use in this setting is cluster analysis , or clustering. The goal of cluster analysiscluster analysis is to ascertain, on the basis of x1,...,x n, whether the observations fall into relatively distinct groups. For example, in a market segmentation study we might observe multiple characteristics (variables) for potential customers, such as zip code, family income, and shopping habits. We might believe that the customers fall into diﬀerent groups, such as big spenders versus low spenders. If the information about each customer’s spending patterns were available, then a supervised analysis would be possible. However, this information is not available—that is, we do not know whether each poten- tial customer is a big spender or not. In this setting, we can try to cluster the customers on the basis of the variables measured, in order to identify distinct groups of potential customers. Identifying such groups can be of interest because it might be that th e groups diﬀer with respect to some property of interest, such as spending habits. Figure 2.8 provides a simple illustration of the clustering problem. We have plotted 150 observations with measurements on two variables, X1 andX2. Each observation corresponds to one of three distinct groups. For illustrative purposes, we have plotted the members of each group using diﬀerent colors and symbols. However , in practice the group memberships are unknown, and the goal is to determine the group to which each ob- servation belongs. In the left-hand panel of Figure 2.8, this is a relatively easytask because the groupsarewell-separated.In contrast,the right-hand panel illustrates a more challenging problem in which there is some overlap 28 2. Statistical Learning between the groups. A clustering method could not be expected to assign all of the overlapping points to their correct group (blue, green, or orange). In the examples shown in Figure 2.8, there are only two variables, and so one can simply visually inspect the scatterplots of the observations in order to identify clusters. However, in practice, we often encounter data sets that contain many more than two variables. In this case, we cannot easily plot the observation s. For instance, if there are pvariables in our data set, then p(p−1)/2 distinct scatterplots can be made, and visual inspection is simply not a viable way to identify clusters. For this reason, automated clustering methods are imp ortant. We discuss clustering and other unsupervised learning approaches in Chapter 10. Many problems fall naturally into the supervised or unsupervised learn- ing paradigms. However, sometimes the question of whether an analysis should be considered supervised or uns upervised is less clear-cut. For in- stance, suppose that we have a set of nobservations. For mof the observa- tions, where m<n, we have both predictor measurements and a response measurement. For the remaining n−mobservations, we have predictor measurements but no response measur ement. Such a scenario can arise if the predictors can be measured relatively cheaply but the corresponding responses are much more expensive to collect. We refer to this setting as asemi-supervised learning problem. In this setting, we wish to use a sta-semi- supervised learningtistical learning method that can incorporate the mobservations for which response measurements are available as well as the n−mobservations for which they are not. Although this is an interesting topic, it is beyond the scope of this book. 2.1.5 Regression Versus Classiﬁcation Problems Variables can be characterized as either quantitative orqualitative (alsoquantitative qualitativeknown as categorical ). Quantitative variables take on numerical values. categoricalExamples include a person’s age, height, or income, the value of a house, and the price of a stock. In contrast, qualitative variables take on val- ues in one of Kdiﬀerent classes, or categories. Examples of qualitativeclassvariables include a person’s gender (male or female), the brand of prod- uct purchased (brand A, B, or C), whether a person defaults on a debt (yes or no), or a cancer diagnosis (Acute Myelogenous Leukemia, Acute Lymphoblastic Leukemia, or No Leukemia). We tend to refer to problems with a quantitative response as regression problems, while those involv-regressioning a qualitative response are often referred to as classiﬁcation problems.classiﬁcationHowever, the distinction is not always that crisp. Least squares linear re- gression (Chapter 3) is used with a qua ntitative response, whereas logistic regression (Chapter 4) is typically used with a qualitative (two-class, or binary) response. As such it is often used as a classiﬁcation method. Butbinarysince it estimates class probabilities, it can be thought of as a regression 2.2 Assessing Model Accuracy 29 method as well. Some statistical methods, such as K-nearest neighbors (Chapters 2 and 4) and boosting (Chapter 8), can be used in the case of either quantitative or qualitative responses. We tend to select statistical learn ing methods on the basis of whether the response is quantitative or qualitative; i.e. we might use linear regres- sion when quantitative and logistic regression when qualitative. However, whether the predictors are qualitative or quantitative is generally consid- ered less important. Most of the statistical learning methods discussed in this book can be applied regardless of the predictor variable type, provided that any qualitative predictors are properly codedbefore the analysis is performed. This is discussed in Chapter 3. 2.2 Assessing Model Accuracy One of the key aims of this book is to introduce the reader to a wide range of statistical learning m ethods that extend far beyond the standard linear regression approach. Why is it necessary to introduce so many diﬀerent statisticallearningapproaches,ratherthanjustasingle bestmethod? There is no free lunch in statistics: no one method dominates all others over all possible data sets. On a particular data set, one speciﬁc method may work best, but some other method may work better on a similar but diﬀerent data set. Hence it is an important task to decide for any given set of data which method produces the best resul ts. Selecting the best approach can be one of the most challenging parts of performing statistical learning in practice. In this section, we discuss some of the most important concepts that arise in selecting a statis tical learning procedure for a speciﬁc data set. As the book progresses, we will explai n how the concepts presented here can be applied in practice. 2.2.1 Measuring the Quality of Fit In order to evaluate the performance of a statistical learning method on a given data set, we need some way to m easure how well its predictions actually match the observed data. That is, we need to quantify the extent to which the predicted response value for a given observation is close to the true response value for that observation. In the regression setting, the most commonly-used measure is the mean squared error (MSE), given bymean squared error MSE=1 nn/summationdisplay i=1(yi−ˆf(xi))2, (2.5) 30 2. Statistical Learning whereˆf(xi) is the prediction that ˆfgives for the ith observation.The MSE will be small if the predicted responses are very close to the true responses, and will be large if for some of the observations, the predicted and true responses diﬀer substantially. The MSE in (2.5) is computed using the training data that was used to ﬁt the model, and so should more accurately be referred to as the training MSE. But in general, we do not really care how well the method workstraining MSE on the training data. Rather, we are interested in the accuracy of the pre- dictions that we obtain when we apply our method to previously unseen test data. Why is this what we care about? Suppose that we are interestedtest datain developing an algorithm to predict a stock’s price based on previous stock returns. We can train the method using stock returns from the past 6months.Butwedon’treallycarehowwellourmethodpredictslastweek’s stock price. We instead care about how w ell it will predict tomorrow’sprice or next month’s price. On a similar note, suppose that we have clinical measurements (e.g. weight, blood pressure, height, age, family history of disease)foranumberofpatients,aswellasinformationaboutwhethereach patient has diabetes. We can use these patients to train a statistical learn- ing method to predict risk of diabetes based on clinical measurements. In practice, we want this method to accurately predict diabetes risk for future patients based on their clinical measurem ents. We are not very interested in whether or not the method accurately predicts diabetes risk for patients used to train the model, since we already know which of those patients have diabetes. To stateit moremathematically,supposethatweﬁt our statisticallearn- ing method on our training observations {(x1,y1),(x2,y2),...,(xn,yn)}, andweobtaintheestimate ˆf.Wecanthencompute ˆf(x1),ˆf(x2),...,ˆf(xn). If these are approximately equal to y1,y2,...,y n, then the training MSE given by (2.5) is small. However, we are really not interested in whether ˆf(xi)≈yi; instead, we want to know whether ˆf(x0) is approximately equal toy0,where(x0,y0)i sapreviously unseen test observation not used to train the statistical learning method . We want to choose the method that gives thelowest test MSE ,asopposedtothe lowesttrainingMSE.Inotherwords,test MSEif we had a large number of test observations, we could compute Ave(ˆf(x0)−y0)2, (2.6) the average squared prediction error for these test observations ( x0,y0). We’d like to select the model for which the average of this quantity—the test MSE—is as small as possible. How can we go about trying to select a method that minimizes the test MSE? In some settings, we may have a test data set available—that is, we may have access to a set of observations that were not used to train the statistical learning method. We can then simply evaluate (2.6) on the test observations, and select the learning method for which the test MSE is 2.2 Assessing Model Accuracy 31 0 2 04 06 08 0 1 0 02468 1 0 1 2 XY 2 5 10 200.0 0.5 1.0 1.5 2.0 2.5 FlexibilityMean Squared Error FIGURE 2.9. Left:Data simulated from f, shown in black. Three estimates of fare shown: the linear regression line (orange curve), and two smoothing spline ﬁts (blue and green curves). Right:Training MSE (grey curve), test MSE (red curve), and minimum possible test MSE over all methods (dashed line). Squares represent the training and test MSEs for the three ﬁts shown in the left-hand panel. smallest. But what if no test observations are available? In that case, one mightimaginesimplyselectingastatisticallearningmethod thatminimizes the training MSE (2.5). This seems like it might be a sensible approach, since the training MSE and the test MSE appear to be closely related. Unfortunately, there is a fundamental problem with this strategy: there is no guarantee that the method with the lowest training MSE will also have the lowest test MSE. Roughly speaking, the problem is that many statistical methods speciﬁcally esti mate coeﬃcients so as to minimize the training set MSE. For these methods, the training set MSE can be quite small, but the test MSE is often much larger. Figure 2.9 illustrates this phenomenon on a simple example. In the left- hand panel of Figure 2.9, we have generated observations from (2.1) with the truefgivenbythe blackcurve.The orange,blue andgreencurvesillus- trate three possible estimates for fobtained using methods with increasing levels of ﬂexibility. The orange line is the linear regression ﬁt, which is rela- tively inﬂexible. The blue and green curves were produced using smoothing splines, discussed in Chapter 7, with diﬀerent levels of smoothness. It issmoothing spline clear that as the level of ﬂexibility increases, the curves ﬁt the observed data more closely. The green curve is the most ﬂexible and matches the data very well; however, we observe that it ﬁts the true f(shown in black) poorly because it is too wiggly. By adjusting the level of ﬂexibility of the smoothing spline ﬁt, we can produce many diﬀerent ﬁts to this data. 32 2. Statistical Learning We now move on to the right-hand panel of Figure 2.9. The grey curve displays the average training MSE as a function of ﬂexibility, or more for- mally the degrees of freedom , for a number of smoothing splines. The de-degrees of freedom grees of freedom is a quantity that summarizes the ﬂexibility of a curve; it is discussed more fully in Chapter 7. The orange, blue and green squares indicate the MSEs associated with th e corresponding curves in the left- hand panel. A more restricted and hence smoother curve has fewer degrees of freedom than a wiggly curve—note that in Figure 2.9, linear regression is at the most restrictive end, with two degrees of freedom. The training MSE declines monotonically as ﬂexibility increases. In this example the truefis non-linear, and so the orange linear ﬁt is not ﬂexible enough to estimate fwell. The green curve has the lowest training MSE of all three methods, since it corresponds to the most ﬂexible of the three curves ﬁt in the left-hand panel. In this example, we know the true function f, and so we can also com- pute the test MSE over a very large test set, as a function of ﬂexibility. (Of course, in general fis unknown, so this will not be possible.) The test MSE is displayed using the red curve in the right-hand panel of Figure 2.9. As with the training MSE, the test MSE initially declines as the level of ﬂex- ibility increases. However, at some point the test MSE levels oﬀ and then starts to increase again. Consequently, the orange and green curves both have high test MSE. The blue curve minimizes the test MSE, which should not be surprisinggiven that visuallyit appearsto estimate fthe best in the left-hand panel of Figure 2.9. The horizontal dashed line indicates Var( /epsilon1), the irreducible error in (2.3), which corresponds to the lowest achievable test MSE among all possible methods. Hence, the smoothing spline repre- sented by the blue curve is close to optimal. In the right-hand panel of Figure 2.9, as the ﬂexibility of the statistical learning method increases, we observe a monotone decrease in the training MSE and a U-shape in the test MSE. This is a fundamental property of statistical learning that holds regardless of the particular data set at hand and regardless of the statistical method being used. As model ﬂexibility increases, training MSE will decrease, but the test MSE may not. When a given method yields a small training MSE but a large test MSE, we are saidtobe overﬁtting thedata.Thishappensbecaus eourstatisticallearning procedure is working too hard to ﬁnd patterns in the training data, and may be picking up some patterns that are just caused by random chance rather than by true properties of the unknown function f.W h e nw eo v e r ﬁ t the training data, the test MSE will be very large because the supposed patterns that the method found in the training data simply don’t exist in the test data. Note that regardless of whether or not overﬁtting has occurred, we almost always expect the training MSE to be smaller than the test MSE because most statistical learning methods either directly or indirectly seek to minimize the train ing MSE. Overﬁtting refers speciﬁcally to the case in which a less ﬂexible model would have yielded a smaller test MSE. 2.2 Assessing Model Accuracy 33 0 2 04 06 08 0 1 0 02468 1 0 1 2 XY 2 5 10 200.0 0.5 1.0 1.5 2.0 2.5 FlexibilityMean Squared Error FIGURE 2.10. Details are as in Figure 2.9, using a diﬀerent true fthat is much closer to linear. In this setting, linear regression provides a very good ﬁt to the data. Figure 2.10 provides another example in which the true fis approxi- mately linear. Again we observe that the training MSE decreases mono- tonically as the model ﬂexibility increases, and that there is a U-shape in the test MSE. However, because the tr uth is close to linear, the test MSE only decreases slightly before increasing again, so that the orange least squares ﬁt is substantially better than the highly ﬂexible green curve. Fi- nally, Figure 2.11 displays an example in which fis highly non-linear. The training and test MSE curves still exhibit the same general patterns, but now there is a rapid decrease in both curves before the test MSE starts to increase slowly. In practice, one can usually compute the training MSE with relative ease,but estimatingtestMSEis considerablymorediﬃcult becauseusually no test data are available. As the previous three examples illustrate, the ﬂexibility level corresponding to the model with the minimal test MSE can vary considerably among data sets. Throughout this book, we discuss a varietyofapproachesthatcanbeusedinpracticetoestimatethis minimum point. One important method is cross-validation (Chapter 5), which is across- validation method for estimating test MSE using the training data. 2.2.2 The Bias-Variance Trade-Oﬀ The U-shape observed in the test MSE curves (Figures 2.9–2.11) turns out to be the result oftwo competing properties ofstatistical learningmethods. Though the mathematical proof is beyond the scope of this book, it is possible to show that the expected test MSE, for a given value x0,c a n 34 2. Statistical Learning 0 2 04 06 08 0 1 0 0−10 0 10 20 XY 2 5 10 200 5 10 15 20 FlexibilityMean Squared Error FIGURE 2.11. Details are as in Figure 2.9, using a diﬀerent fthat is far from linear. In this setting, linear regression provides a very poor ﬁt to the data. always be decomposed into the sum of three fundamental quantities: the variance ofˆf(x0), the squared biasofˆf(x0) and the variance of the errorvariance bias terms/epsilon1.T h a ti s , E/parenleftBig y0−ˆf(x0)/parenrightBig2 =V a r (ˆf(x0))+[Bias( ˆf(x0))]2+V ar(/epsilon1).(2.7) Herethenotation E/parenleftBig y0−ˆf(x0)/parenrightBig2 deﬁnesthe expectedtest MSE ,andrefersexpected test MSE to the average test MSE that we would obtain if we repeatedly estimated fusing a large number of training sets, and tested each at x0.T h eo v e r a l l expected test MSE can be computed by averaging E/parenleftBig y0−ˆf(x0)/parenrightBig2 over all possible values of x0in the test set. Equation 2.7 tells us that in order to minimize the expected test error, we need to selecta statistical learning method that simultaneously achieves low variance andlow bias. Note that variance is inherently a nonnegative quantity, and squared bias is also nonnegative. Hence, we see that the expected test MSE can never lie below Var( /epsilon1), the irreducible error from (2.3). What do we mean by the variance andbiasof a statistical learning method? Variance refers to the amount by which ˆfwould change if we estimated it using a diﬀerent training data set. Since the training data are used to ﬁt the statistical learning method, diﬀerent training data sets will result in a diﬀerent ˆf. But ideally the estimate for fshould not vary too much between training sets. However, if a method has high variance then small changes in the training data can result in large changes in ˆf.I n general,moreﬂexiblestatisticalmethodshavehighervariance.Considerthe 2.2 Assessing Model Accuracy 35 green and orange curves in Figure 2.9. The ﬂexible green curve is following the observations very closely. It has high variance because changing any one of these data points may cause the estimate ˆfto change considerably. In contrast, the orange least squares line is relatively inﬂexible and has low variance, because moving any single observation will likely cause only a small shift in the position of the line. On the other hand, biasrefers to the error that is introduced by approxi- matingareal-lifeproblem,which maybe extremelycomplicated,byamuch simpler model. For example, linear reg ressionassumes that there is a linear relationship between YandX1,X2,...,X p. It is unlikely that any real-life problem truly has such a simple linear relationship, and so performing lin- ear regression will undoubtedly result in some bias in the estimate of f.I n Figure 2.11, the true fis substantially non-linear, so no matter how many training observations we are given, it will not be possible to produce an accurate estimate using linear regression. In other words, linear regression results in high bias in this example. However, in Figure 2.10 the true fis very close to linear, and so given enough data, it should be possible for linear regression to produce an accurate estimate. Genera lly, more ﬂexible methods result in less bias. As a general rule, as we use more ﬂexible methods, the variance will increase and the bias will decrease. The relative rate of change of these two quantities determines whether th e test MSE increases or decreases. As we increase the ﬂexibility of a class of methods, the bias tends to initially decrease faster than the variance inc reases. Consequently, the expected test MSE declines. However, at some point increasing ﬂexibility has little impact on the bias but starts to signiﬁ cantly increase th e variance. When this happens the test MSE increases. Note that we observed this pattern of decreasing test MSE followed by increasing test MSE in the right-hand panels of Figures 2.9–2.11. The three plots in Figure 2.12 illustrate Equation 2.7 for the examples in Figures 2.9–2.11. In each case the blue solid curve represents the squared bias, for diﬀerent levels of ﬂexibility, while the orange curve corresponds to the variance. The horizontal dashed line represents Var( /epsilon1), the irreducible error. Finally, the red curve, corresponding to the test set MSE, is the sum of these three quantities. In all three c ases, the variance increases and the bias decreases as the method’s ﬂexibility increases. However, the ﬂexibility level correspondingto the optimal test MSE diﬀers considerablyamong the three data sets, because the squared bias and variance change at diﬀerent rates in each of the data sets. In the left-hand panel of Figure 2.12, the bias initially decreases rapidly, resulting in an initial sharp decrease in the expected test MSE. On the other hand, in the center panel of Figure 2.12 the truefis close to linear, so there is onl y a small decrease in bias as ﬂex- ibility increases, and the test MSE only declines slightly before increasing rapidly as the variance increases. Finally, in the right-hand panel of Fig- ure 2.12, as ﬂexibility increases, there is a dramatic decline in bias because 36 2. Statistical Learning 2 51 0 2 00.0 0.5 1.0 1.5 2.0 2.5 Flexibility2 5 10 200.0 0.5 1.0 1.5 2.0 2.5 Flexibility2 5 10 200 5 10 15 20 FlexibilityMSE Bias Var FIGURE 2.12. Squared bias (blue curve), variance (orange curve), Var (/epsilon1) (dashed line), and test MSE (red curve) for the three data sets in Figures 2.9–2.11. The vertical dotted line indicates the ﬂexibility level corresponding to the smallest test MSE. the true fis very non-linear. There is also very little increase in variance as ﬂexibility increases. Consequently, the test MSE declines substantially before experiencing a small increase as model ﬂexibility increases. The relationshipbetween bias, varia nce,and test setMSE given in Equa- tion 2.7 and displayed in Figure 2.12 is referred to as the bias-variance trade-oﬀ. Good test set performance of a statistical learning method re-bias-variance trade-oﬀ quires low variance as well as low squared bias. This is referred to as a trade-oﬀ because it is easy to obtai n a method with extremely low bias but high variance (for instance, by drawing a curve that passes through every single training observation) or a method with very low variance but high bias (by ﬁtting a horizontal line to the data). The challenge lies in ﬁnding a method for which both the variance and the squared bias are low. This trade-oﬀ is one of the most important recurring themes in this book. In a real-life situation in which fis unobserved, it is generally not pos- sible to explicitly compute the test MSE, bias, or variance for a statistical learning method. Nevertheless, one s hould always keep the bias-variance trade-oﬀ in mind. In this book we explore methods that are extremely ﬂexible and hence can essentially eliminate bias. However, this does not guarantee that they will outperform a much simpler method such as linear regression. To take an extreme example, suppose that the true fis linear. In this situation linear regression will have no bias, making it very hard for a more ﬂexible method to compete. In contrast, if the true fis highly non-linear and we have an ample number of training observations, then we may do better using a highly ﬂexible approach, as in Figure 2.11. In Chapter 5 we discuss cross-validation, which is a way to estimate the test MSE using the training data. 2.2 Assessing Model Accuracy 37 2.2.3 The Classiﬁcation Setting Thus far, our discussion of model accuracy has been focused on the regres- sion setting. But many of the concepts that we have encountered, such as the bias-variance trade-oﬀ, transfer over to the classiﬁcation setting with only some modiﬁcations due to the fact that yiis no longer numer- ical. Suppose that we seek to estimate fon the basis of training obser- vations{(x1,y1),...,(xn,yn)}, where now y1,...,y nare qualitative. The most common approach for quantifying the accuracy of our estimate ˆfis the training error rate ,theproportionofmistakesthataremadeifweapplyerror rateour estimate ˆfto the training observations: 1 nn/summationdisplay i=1I(yi/negationslash=ˆyi). (2.8) Here ˆyiis the predicted class label for the ith observation using ˆf.A n d I(yi/negationslash=ˆyi)i sanindicator variable that equals1if yi/negationslash=ˆyiandzeroif yi=ˆyi.indicator variable IfI(yi/negationslash=ˆyi) = 0 then the ith observation was classiﬁed correctly by our classiﬁcation method; otherwise it was misclassiﬁed. Hence Equation 2.8 computes the fraction of inc orrect classiﬁcations. Equation 2.8 is referred to as the training error rate because it is com-training error puted based on the data that was used to train our classiﬁer. As in the regressionsetting, we are most interested in the errorrates that result from applying our classiﬁer to test observations that were not used in training. Thetest error rate associated with a set of test observations of the formtest error(x0,y0)i sg i v e nb y Ave(I(y0/negationslash=ˆy0)), (2.9) where ˆy0is the predicted class label that results from applying the classiﬁer to the test observation with predictor x0.Agoodclassiﬁer is one for which the test error (2.9) is smallest. The Bayes Classiﬁer It is possible to show (though the proof is outside of the scope of this book) that the test error rate given in (2.9) is minimized, on average, by a very simple classiﬁer that assigns each observation to the most likely class, given its predictor values . In other words, we should simply assign a test observation with predictor vector x0to the class jfor which Pr(Y=j|X=x0) (2.10) is largest. Note that (2.10) is a conditional probability : it is the probabilityconditional probability thatY=j, given the observed predictor vector x0. This very simple clas- siﬁer is called the Bayes classiﬁer . In a two-class problem where there areBayes classiﬁer only two possible response values, say class 1orclass 2, the Bayes classiﬁer 38 2. Statistical Learning o o o oo oo o o oo oo oo oo oo oo oooo o oo o oo oo oo o oo oo o oo o ooo o ooooo ooo o o oo oo oo oo ooo oo o oo o oo ooo ooooo o oo oooo ooo oo oo oo oo o oo o oo oo o oooo o o oooo oo oo o oo o oooo oo oo oo oo o oo o oo oooo o oo ooo ooo o oooo o oooo o o ooo ooo ooo ooo oo oo o oo oo oooo oo FIGURE 2.13. A simulated data set consisting of 100observations in each of two groups, indicated in blue and in orange. The purple dashed line represents the Bayes decision boundary. The orange background grid indicates the region in which a test observation will be assigned to the orange class, and the blue background grid indicates the region in which a test observation will be assigned to the blue class. corresponds to predicting class one if Pr( Y=1|X=x0)>0.5, and class two otherwise. Figure 2.13 provides an example using a simulated data set in a two- dimensional space consisting of predictors X1andX2. The orange and blue circles correspondto training observationsthat belong to two diﬀerent classes. For each value of X1andX2, there is a diﬀerent probability of the response being orange or blue. Since this is simulated data, we know how the data were generated and we can calculate the conditional probabilities for each value of X1andX2. The orange shaded region reﬂects the set of points for which Pr( Y=o r a n g e |X) is greater than 50%, while the blue shaded region indicates the set of points for which the probability is below 50%. The purple dashed line represents the points where the probability is exactly 50%. This is called the Bayes decision boundary .T h eB a y e sBayes decision boundaryclassiﬁer’s prediction is determined by the Bayes decision boundary; an observation that falls on the orange side of the boundary will be assigned to the orange class, and similarly an observation on the blue side of the boundary will be assigned to the blue class. The Bayes classiﬁer produces the low est possible test error rate, called theBayes error rate . Since the Bayes classiﬁer will always choose the classBayes error rate for which (2.10)is largest,the errorrate at X=x0will be 1−maxjPr(Y= j|X=x0). In general, the overall Bayes error rate is given by 1−E/parenleftbigg max jPr(Y=j|X)/parenrightbigg , (2.11) 2.2 Assessing Model Accuracy 39 where the expectation averages the probability over all possible values of X. For our simulated data, the Bayes error rate is 0 .1304.It is greater than zero, because the classes overlap in the true population so max jPr(Y= j|X=x0)<1 for some values of x0. The Bayes error rate is analogous to the irreducible error, discussed earlier. K-Nearest Neighbors In theory we would always like to predict qualitative responses using the Bayes classiﬁer. But for real data, we do not know the conditional distri- bution of YgivenX, and so computing the Bayes classiﬁer is impossi- ble. Therefore, the Bayes classiﬁer s erves as an unattainable gold standard against which to compare other methods. Many approaches attempt to estimate the conditional distribution of YgivenX, and then classify a given observation to the class with highest estimated probability. One such method is the K-nearest neighbors (KNN) classiﬁer. Given a positive in-K-nearest neighbors tegerKand a test observation x0, the KNN classiﬁer ﬁrst identiﬁes the Kpoints in the training data that are closest to x0, represented by N0. It then estimates the conditional probability for class jas the fraction of points in N0whose response values equal j: Pr(Y=j|X=x0)=1 K/summationdisplay i∈N 0I(yi=j). (2.12) Finally, KNN applies Bayes rule and classiﬁes the test observation x0to the class with the largest probability. Figure 2.14 provides an illustrative example of the KNN approach. In the left-hand panel, we have plotted a small training data set consisting of six blue and six orange observations. Our goal is to make a prediction for the point labeled by the black cross. Suppose that we choose K=3 .T h e n KNN will ﬁrst identify the three observations that are closest to the cross. This neighborhood is shown as a circle. It consists of two blue points and one orange point, resulting in estimated probabilities of 2 /3 for the blue class and 1 /3 for the orange class. Hence KNN will predict that the black cross belongs to the blue class. In the right-hand panel of Figure 2.14 we have applied the KNN approachwith K= 3 at all of the possible values for X1andX2, and have drawn in the corresponding KNN decision boundary. Despite the fact that it is a very simple approach, KNN can often pro- duce classiﬁers that are surprisingly close to the optimal Bayes classiﬁer. Figure 2.15 displays the KNN decision boundary, using K= 10, when ap- plied to the larger simulated data set from Figure 2.13. Notice that even though the true distribution is not known by the KNN classiﬁer, the KNN decision boundaryis veryclose to thatof the Bayesclassiﬁer.The testerror rate using KNN is 0 .1363, which is close to the Bayes error rate of 0 .1304. 40 2. Statistical Learning oo ooo o o oo oo o oo ooo o o oo oo o FIGURE 2.14. The KNN approach, using K=3, is illustrated in a simple situation with six blue observations and six orange observations. Left:a test ob- servation at which a predicted class label is desired is shown as a black cross. The three closest points to the test observation are identiﬁed, and it is predicted that the test observation belongs to the most commonly-occurring class, in this case blue.Right:The KNN decision boundary for this example is shown in black. The blue grid indicates the region in which a test observation will be assigned to the blue class, and the orange grid indicates the region in which it will be assigned to t h eo r a n g ec l a s s . The choice of Khas a drastic eﬀect on the KNN classiﬁer obtained. Figure 2.16 displays two KNN ﬁts to the simulated data from Figure 2.13, usingK=1a n d K= 100. When K= 1, the decision boundary is overly ﬂexible and ﬁnds patterns in the data that don’t correspond to the Bayes decision boundary. This corresponds to a classiﬁer that has low bias but very high variance. As Kgrows, the method becomes less ﬂexible and produces a decision boundary that is close to linear. This corresponds to a low-variance but high-bias classiﬁer. On this simulated data set, neither K=1n o r K= 100 give good predictions: they have test error rates of 0.1695 and 0 .1925, respectively. Just as in the regression setting, there is not a strong relationship be- tween the training error rate and the test error rate. With K=1 ,t h e KNN training error rate is 0, but the test error rate may be quite high. In general, as we use more ﬂexible classiﬁcation methods, the training error rate will decline but the test error rate may not. In Figure 2.17, we have plotted the KNN test and training errors as a function of 1 /K.A s1/Kin- creases, the method becomes more ﬂexib le. As in the regressionsetting, the trainingerrorrateconsistentlydeclinesastheﬂexibilityincreases.However, the test error exhibits a characteristic U-shape, declining at ﬁrst (with a minimum at approximately K= 10) before increasing again when the method becomes excessively ﬂexible and overﬁts. 2.2 Assessing Model Accuracy 41 o o o oo oo o o oo oo oo oo oo oo oooo o oo o oo oo oo o oo oo o oo o ooo o ooooo ooo o o oo oo oo oo ooo oo o oo o oo ooo ooooo o oo oooo ooo oo oo oo oo o oo o oo oo o oooo o o oooo oo oo o oo o oooo oo oo oo oo o oo o oo oooo o oo ooo ooo o oooo o oooo o o ooo ooo ooo ooo oo oo o oo oo oooo ooKNN: K=10 FIGURE 2.15. The black curve indicates the KNN decision boundary on the data from Figure 2.13, using K=1 0. The Bayes decision boundary is shown as a purple dashed line. The KNN and Bayes decision boundaries are very similar. o o o oo oo o o oo oo oo oo oo oo oooo o oo o oo oo oo o oo oo o oo o ooo o ooooo ooo o o oo oo oo oo ooo oo o oo o oo ooo ooooo o oo oooo ooo oo oo oo oo o oo o oo oo o oooo o o oooo oo oo o oo o oooo oo oo oo oo o oo o oo oooo o oo ooo ooo o oooo o oooo o o ooo ooo ooo ooo oo oo o oo oo oooo oo o o o oo oo o o oo oo oo oo oo oo oooo o oo o oo oo oo o oo oo o oo o ooo o ooooo ooo o o oo oo oo oo ooo oo o oo o oo ooo ooooo o oo oooo ooo oo oo oo oo o oo o oo oo o oooo o o oooo oo oo o oo o oooo oo oo oo oo o oo o oo oooo o oo ooo ooo o oooo o oooo o o ooo ooo ooo ooo oo oo o oo oo oooo ooKNN: K=1 KNN: K=100 FIGURE 2.16. A comparison of the KNN decision boundaries (solid black curves) obtained using K=1andK= 100on the data from Figure 2.13. With K=1, the decision boundary is overly ﬂexible, while with K= 100it is not suﬃciently ﬂexible. The Bayes decision boundary is shown as a purple dashed line. 42 2. Statistical Learning 0.01 0.02 0.05 0.10 0.20 0.50 1.000.00 0.05 0.10 0.15 0.20 1/KError Rate Training Errors Test Errors FIGURE 2.17. The KNN training error rate (blue, 200 observations) and test error rate (orange, 5,000 observations) on the data from Figure 2.13, as the level of ﬂexibility (assessed using 1/K) increases, or equivalently as the number of neighbors Kdecreases. The black dashed line indicates the Bayes error rate. The jumpiness of the curves is due to the small size of the training data set. In both the regression and classiﬁcation settings, choosing the correct levelofﬂexibilityiscriticaltothesuccessofanystatisticallearningmethod. The bias-variance tradeoﬀ, and the resulting U-shape in the test error, can make this a diﬃcult task. In Chapter 5, we return to this topic and discuss various methods for estimating test error rates and thereby choosing the optimal level of ﬂexibility for a given statistical learning method. 2.3 Lab: Introduction to R In this lab, we will introduce some simple Rcommands. The best way to learnanewlanguageistotryoutthecommands. Rcanbe downloadedfrom http://cran.r-project.org/ 2.3.1 Basic Commands Rusesfunctions to perform operations. To run a function called funcname ,functionwe type funcname(input1, input2) , where the inputs (or arguments )input1argument 2.3 Lab: Introduction to R 43 and input2tellRhow to run the function. A function can have any number of inputs. For example, to create a vector of numbers, we use the function c()(forconcatenate ). Any numbers inside the parentheses are joined to-c()gether. The following command instructs Rto join together the numbers 1, 3, 2, and 5, and to save them as a vectornamed x.W h e nw et y p e x,i tvectorgives us back the vector. > x <- c(1,3,2,5) >x [1] 1 3 2 5 Note that the >is not part of the command; rather, it is printed by Rto indicate that it is ready for another command to be entered. We can also save things using =rather than <-: > x = c(1,6,2) >x [1] 1 6 2 > y = c(1,4,3) Hitting the uparrow multiple times will display the previous commands, which can then be edited. This is use ful since one often wishes to repeat a similar command. In addition, typing ?funcname will always cause Rto open anew help ﬁle windowwith additionalinformationabout the function funcname . We can tell Rto add two sets of numbers together. It will then add the ﬁrst number from xto the ﬁrst number from y, and so on. However, xand yshould be the same length. We ca n check their length using the length()length()function. > length(x) [1] 3 > length(y) [1] 3 >x + y [1] 2 10 5 The ls()function allows us to look at a list of all of the objects, suchls()as data and functions, that we have saved so far. The rm()function can berm()used to delete any that we don’t want. >l s ( ) [1] \"x\" \"y\" > rm(x,y) >l s ( ) character (0) It’s also possible to remove all objects at once: > rm(list=ls()) 44 2. Statistical Learning The matrix() function can be used to create a matrix of numbers. Beforematrix()we use the matrix() function, we can learn more about it: > ?matrix The help ﬁle reveals that the matrix() function takes a number of inputs, but for now we focus on the ﬁrst three: the data (the entries in the matrix), the number of rows, and the number of columns. First, we create a simple matrix. > x=matrix(data=c(1,2,3,4), nrow=2, ncol=2) >x [,1] [,2] [1,] 1 3 [2,] 2 4 Note that we could just as well omit typing data=,nrow=,a n d ncol=in the matrix() command above: that is, we could just type > x=matrix(c(1,2,3,4) ,2,2) and this wouldhave the same eﬀect. However,it cansometimes be usefulto specify the names of the arguments passed in, since otherwise Rwill assume that the function arguments are passed into the function in the same order that is given in the function’s help ﬁle. As this example illustrates, by default Rcreates matrices by successively ﬁlling in columns. Alternatively, thebyrow=TRUE option can be used to populate the matrix in order of the rows. > matrix(c(1,2,3,4),2,2,byrow=TRUE) [,1] [,2] [1,] 1 2 [2,] 3 4 Notice that in the above command we did not assign the matrix to a value such as x. In this case the matrix is printed to the screen but is not saved for future calculations. The sqrt()function returns the square root of eachsqrt()element of a vector or matrix. The command x^2raises each element of x to the power 2; any powers are possible, including fractional or negative powers. > sqrt(x) [,1] [,2] [1,] 1.00 1.73 [2,] 1.41 2.00 >x ^ 2 [,1] [,2] [1,] 1 9 [2,] 4 16 The rnorm() function generates a vector of random normal variables,rnorm()with ﬁrst argument nthe sample size. Each time we call this function, we will get a diﬀerent answer. Here we create two correlated sets of numbers, xand y, and use the cor()function to compute the correlation betweencor()them. 2.3 Lab: Introduction to R 45 > x=rnorm(50) > y=x+rnorm(50,mean=50,sd=.1) > cor(x,y) [1] 0.995 By default, rnorm()creates standard normal random variables with a mean of 0 and a standard deviation of 1. However, the mean and standard devi- ation can be altered using the meanand sdarguments, as illustrated above. Sometimes we want our code to reproduce the exact same set of random numbers; we can use the set.seed() function to do this. The set.seed()set.seed()function takes an (arbitrary) integer argument. > set.seed(1303) > rnorm(50) [1] -1.1440 1.3421 2.1854 0.5364 0.0632 0.5022 - 0.0004 ... We use set.seed() throughout the labs whenever we perform calculations involving random quantities. In general this should allow the user to re- produce our results. However, it should be noted that as new versions of Rbecome available it is possible that some small discrepancies may form between the book and the output from R. The mean()and var()functions can be used to compute the mean andmean() var()variance of a vector of numbers. Applying sqrt()to the output of var() will give the standard deviation. Or we can simply use the sd()function.sd() > set.seed(3) > y=rnorm(100) > mean(y) [1] 0.0110 > var(y) [1] 0.7329 > sqrt(var(y)) [1] 0.8561 > sd(y) [1] 0.8561 2.3.2 Graphics The plot()function is the primary way to plot data in R. For instance,plot()plot(x,y) produces a scatterplot of the numbers in xversus the numbers iny. There are many additional options that can be passed in to the plot() function. For example, passing in the argument xlabwill result in a label on thex-axis. To ﬁnd out more information about the plot()function, type ?plot. > x=rnorm(100) > y=rnorm(100) > plot(x,y) > plot(x,y,xlab=\"this is the x-axis\",ylab=\"this is the y-axis\", main=\"Plot of X vs Y\") 46 2. Statistical Learning We will often want to save the output of an Rplot. The command that we use to do this will depend on the ﬁle type that we would like to create. For instance, to create a pdf, we use the pdf()function, and to create a jpeg,pdf()we use the jpeg()function.jpeg() > pdf(\"Figure.pdf\") > plot(x,y,col=\"green\") > dev.off() null device 1 The function dev.off() indicates to Rthat we are done creating the plot.dev.off()Alternatively, we can simply copy the plot window and paste it into an appropriate ﬁle type, such as a Word document. The function seq()can be used to create a sequence of numbers. Forseq()instance, seq(a,b) makes a vector of integers between aand b.T h e r ea r e many other options: for instance, seq(0,1,length=10) makes a sequence of 10numbers that are equally spaced between 0and 1. Typing 3:11is a shorthand for seq(3,11) for integer arguments. > x=seq(1,10) >x [ 1 ]123456789 1 0 > x=1:10 >x [ 1 ]123456789 1 0 > x=seq(-pi,pi,length=50) We will now create some more sophisticated plots. The contour() func-contour()tion produces a contour plot in order to represent three-dimensional data;contour plotit is like a topographical map. It takes three arguments: 1. A vector of the xvalues (the ﬁrst dimension), 2. A vector of the yvalues (the second dimension), and 3. A matrix whose elements correspond to the zvalue (the third dimen- sion) for each pair of ( x,y) coordinates. As with the plot()function, there are many other inputs that can be used to ﬁne-tune the output of the contour() function. To learn more about these, take a look at the help ﬁle by typing ?contour . >y = x > f=outer(x,y,function(x,y)cos(y)/(1+x^2)) > contour(x,y,f) > contour(x,y,f,nlevels=45,add=T) > fa=(f-t(f))/2 > contour(x,y,fa,nlevels =15) The image()function works the same way as contour() , except that itimage()produces a color-coded plot whose colors depend on the zvalue. This is 2.3 Lab: Introduction to R 47 known as a heatmap, and is sometimes used to plot temperature in weatherheatmapforecasts.Alternatively, persp()canbeusedtoproduceathree-dimensionalpersp()plot. The arguments thetaand phicontrol the angles at which the plot is viewed. > image(x,y,fa) > persp(x,y,fa) > persp(x,y,fa,theta=30) > persp(x,y,fa,theta=30,phi=20) > persp(x,y,fa,theta=30,phi=70) > persp(x,y,fa,theta=30,phi=40) 2.3.3 Indexing Data We often wish to examine part of a set of data. Suppose that our data is stored in the matrix A. > A=matrix(1:16,4,4) >A [,1] [,2] [,3] [,4] [1,] 1 5 9 13 [2,] 2 6 10 14 [3,] 3 7 11 15 [4,] 4 8 12 16 Then, typing >A [ 2 , 3 ] [1] 10 will select the element corresponding to the second row and the third col- umn. The ﬁrst number after the open-bracket symbol [always refers to the row, and the second number always refers to the column. We can also select multiple rows and columns at a time, by providing vectors as the indices. > A[c(1,3),c(2,4)] [,1] [,2] [1,] 5 13 [2,] 7 15 > A[1:3,2:4] [,1] [,2] [,3] [1,] 5 9 13 [2,] 6 10 14 [3,] 7 11 15 > A[1:2,] [,1] [,2] [,3] [,4] [1,] 1 5 9 13 [2,] 2 6 10 14 > A[,1:2] [,1] [,2] [1,] 1 5 [2,] 2 6 48 2. Statistical Learning [3,] 3 7 [4,] 4 8 The last two examples include either no index for the columns or no index for the rows. These indicate that Rshould include all columns or all rows, respectively. Rtreats a single row or column of a matrix as a vector. >A [ 1 , ] [1] 1 5 9 13 The use of a negative sign -in the index tells Rto keep all rows or columns except those indicated in the index. > A[-c(1,3) ,] [,1] [,2] [,3] [,4] [1,] 2 6 10 14 [2,] 4 8 12 16 > A[-c(1,3),-c(1,3,4)] [1] 6 8 The dim()function outputs the number of rows followed by the number ofdim()columns of a given matrix. > dim(A) [1] 4 4 2.3.4 Loading Data For most analyses, the ﬁrst step involves importing a data set into R.T h e read.table() function is one of the primary ways to do this. The help ﬁleread.table()contains details about how to use this function. We can use the function write.table() to export data.write. table() Before attempting to load a data set, we must make sure that Rknows to search for the data in the proper directory. For example on a Windows system one could select the directory using the Change dir ...option under theFilemenu. However, the details of how to do this depend on the op- erating system (e.g. Windows, Mac, Unix) that is being used, and so we do not give further details here. We begin by loading in the Autodata set. This data is part of the ISLRlibrary (we discuss libraries in Chapter 3) but to illustrate the read.table() function we load it now from a text ﬁle. The following command will load the Auto.data ﬁle into Rand store it as an object called Auto, in a format referred to as a data frame .( T h et e x tﬁ l edata framecan be obtained from this book’s website.) Once the data has been loaded, the fix()function can be used to view it in a spreadsheet like window. However, the window must be closed before further Rcommands can be entered. > Auto=read.table(\"Auto.data\") > fix(Auto) 2.3 Lab: Introduction to R 49 Note that Auto.data is simply a text ﬁle, which you could alternatively open on your computer using a standard text editor. It is often a good idea to view a data set using a text editor or other software such as Excel before loading it into R. This particular data set has no t been loaded correctly, because Rhas assumed that the variable names are part of the data and so has included them in the ﬁrst row. The data set also includes a number of missing observations, indicated by a question mark ?. Missing values are a common occurrence in real data sets. Using the option header=T (orheader=TRUE )i n theread.table() function tells Rthat the ﬁrst line of the ﬁle contains the variable names, and using the option na.strings tells Rthat any time it sees a particular character or set of c haracters (such as a question mark), it should be treated as a missing element of the data matrix. > Auto=read.table(\"Auto.data\",header=T,na.strings =\"?\") > fix(Auto) Excel is a common-format data storageprogram. An easy way to load such data into Ris to save it as a csv (comma separated value) ﬁle and then use theread.csv() function to load it in. > Auto=read.csv(\"Auto.csv\",header=T,na.strings =\"?\") > fix(Auto) > dim(Auto) [1] 397 9 > Auto[1:4,] The dim()function tells us that the data has 397 observations,or rows,anddim()nine variables, or columns. There are various ways to deal with the missing data. In this case, only ﬁve of the rows contain missing observations, and so we choose to use the na.omit() function to simply remove these rows.na.omit() > Auto=na.omit(Auto) > dim(Auto) [1] 392 9 Once the data are loaded correctly, we can use names() to check thenames()variable names. > names(Auto) [1] \"mpg\" \"cylinders \" \" displacement\" \" horsepower \" [5] \"weight\" \" acceleration\" \" year\" \"origin\" [9] \"name\" 2.3.5 Additional Graphical and Numerical Summaries We can use the plot()function to produce scatterplots of the quantitativescatterplotvariables. However, simply typing the variable names will produce an error message, because Rdoes not know to look in the Autodata set for those variables. 50 2. Statistical Learning > plot(cylinders , mpg) Error in plot(cylinders , mpg) : object ’cylinders ’ not found To refer to a variable, we must type the data set and the variable name joined with a $symbol. Alternatively, we can use the attach() function inattach()order to tell Rto make the variables in this data frame available by name. > plot(Auto$cylinders , Auto$mpg) > attach(Auto) > plot(cylinders , mpg) The cylinders variable is stored as a numeric vector, so Rhas treated it as quantitative. However, since there are only a small number of possible values for cylinders , one may prefer to treat it as a qualitative variable. The as.factor() function converts quantitative variables into qualitativeas.factor()variables. > cylinders =as.factor(cylinders ) If the variable plotted on the x-axis is categorial, then boxplots willboxplotautomatically be produced by the plot()function. As usual, a number of options can be speciﬁed in order to customize the plots. > plot(cylinders , mpg) > plot(cylinders , mpg, col=\"red\") > plot(cylinders , mpg, col=\"red\", varwidth=T) > plot(cylinders , mpg, col=\"red\", varwidth=T,horizontal =T) > plot(cylinders , mpg, col=\"red\", varwidth=T, xlab=\"cylinders \", ylab=\"MPG\") The hist()function can be used to plot a histogram .N o t et h a t col=2hist() histogramhas the same eﬀect as col=\"red\" . > hist(mpg) > hist(mpg,col=2) > hist(mpg,col=2,breaks=15) The pairs()function creates a scatterplot matrix i.e. a scatterplot for everyscatterplot matrix pair of variables for any given data set. We can also produce scatterplots for just a subset of the variables. > pairs(Auto) > pairs( ∼mpg + displacement + horsepower + weight + acceleration , Auto) In conjunction with the plot()function, identify() provides a usefulidentify()interactive method for identifying the value for a particular variable for points on a plot. We pass in three arguments to identify() :t h ex-axis variable, the y-axis variable, and the variable whose values we would like to see printed for each point. Then clicking on a given point in the plot will cause Rto print the value of the variable of interest. Right-clicking on the plot will exit the identify() function (control-click on a Mac). The numbers printed under the identify() function correspond to the rows for the selected points. 2.3 Lab: Introduction to R 51 > plot(horsepower ,mpg) > identify(horsepower ,mpg,name) The summary() function produces a numerical summary of each variable insummary()a particular data set. > summary(Auto) mpg cylinders displacement Min. : 9.00 Min. :3.000 Min. : 68.0 1st Qu.:17.00 1st Qu.:4.000 1st Qu.:105.0 Median :22.75 Median :4.000 Median :151.0 Mean :23.45 Mean :5.472 Mean :194.4 3rd Qu.:29.00 3rd Qu.:8.000 3rd Qu.:275.8 Max. :46.60 Max. :8.000 Max. :455.0 horsepower weight acceleration Min. : 46.0 Min. :1613 Min. : 8.00 1st Qu.: 75.0 1st Qu.:2225 1st Qu.:13.78 Median : 93.5 Median :2804 Median :15.50 Mean :104.5 Mean :2978 Mean :15.54 3rd Qu.:126.0 3rd Qu.:3615 3rd Qu.:17.02 Max. :230.0 Max. :5140 Max. :24.80 year origin name Min. :70.00 Min. :1.000 amc matador : 5 1st Qu.:73.00 1st Qu.:1.000 ford pinto : 5 Median :76.00 Median :1.000 toyota corolla : 5 Mean :75.98 Mean :1.577 amc gremlin : 4 3rd Qu.:79.00 3rd Qu.:2.000 amc hornet : 4 Max. :82.00 Max. :3.000 chevrolet chevette: 4 (Other) :365 For qualitative variables such as name,Rwill list the number of observations that fall in each category. We can also produce a summary of just a single variable. > summary(mpg) Min. 1st Qu. Median Mean 3rd Qu. Max. 9.00 17.00 22.75 23.45 29.00 46.60 Once we have ﬁnished using R,w et y p e q()i no r d e rt os h u ti td o w n ,o rq()quit. When exiting R, we have the option to save the current workspace soworkspacethat all objects (such as data sets) that we have created in this Rsession will be available next time. Before exiting R, we may want to save a record of all of the commands that we typed in the most recent session; this can be accomplished using the savehistory() f u n c t i o n .N e x tt i m ew ee n t e r R,savehistory( )we can load that history using the loadhistory() function.loadhistory( ) 52 2. Statistical Learning 2.4 Exercises Conceptual 1. Foreachofparts(a)through(d),indicatewhetherwewouldgenerally expect the performance of a ﬂexible statistical learning method to be better or worse than an inﬂexible method. Justify your answer. (a) The sample size nis extremely large, and the number of predic- torspis small. (b) The number of predictors pis extremely large, and the number of observations nis small. (c) The relationship between the predictors and response is highly non-linear. (d) The variance of the error terms, i.e. σ2=V a r (/epsilon1), is extremely high. 2. Explain whether each scenario is a classiﬁcation or regression prob- lem, and indicate whether we are most interested in inference or pre- diction. Finally, provide nandp. (a) We collect a set of data on the top 500 ﬁrms in the US. For each ﬁrm we record proﬁt, number of employees, industry and the CEO salary. We are interested in understanding which factors aﬀect CEO salary. (b) We are considering launching a new product and wish to know whether it will be a successor afailure. We collect data on 20 similar products that were previously launched. For each prod- uct we have recorded whether it was a success or failure, price charged for the product, marketing budget, competition price, and ten other variables. (c) We are interestingin predicting the % change in the US dollarin relationto the weeklychangesin the worldstockmarkets.Hence we collect weekly data for all of 2012. For each week we record the % change in the dollar, the % change in the US market, the % change in the British market, and the % change in the German market. 3. We now revisit the bias-variance decomposition. (a) Provide a sketch of typical (squared) bias, variance, training er- ror, test error, and Bayes (or irreducible) error curves, on a sin- gle plot, as we go from less ﬂexible statistical learning methods towards more ﬂexible approaches. The x-axis should represent 2.4 Exercises 53 the amount of ﬂexibility in the method, and the y-axis should represent the values for each curve. There should be ﬁve curves. Make sure to label each one. (b) Explain why each of the ﬁve curves has the shape displayed in part (a). 4. You will now think of some real-life applications for statistical learn- ing. (a) Describe threereal-lifeapplicationsinwhich classiﬁcation might be useful. Describe the response, as well as the predictors. Is the goal of each application inference or prediction? Explain your answer. (b) Describe three real-life applications in which regression might be useful. Describe the response, as well as the predictors. Is the goal of each application inference or prediction? Explain your answer. (c) Describe three real-life applications in which cluster analysis might be useful. 5. What are the advantages and disadvantages of a very ﬂexible (versus a less ﬂexible) approach for regression or classiﬁcation? Under what circumstances might a more ﬂexible approach be preferred to a less ﬂexible approach? When might a less ﬂexible approach be preferred? 6. Describe the diﬀerences between a p arametric and a non-parametric statistical learning approach. What are the advantages of a para- metric approach to regression or classiﬁcation (as opposed to a non- parametric approach)? What are its disadvantages? 7. The table below provides a training data set containing six observa- tions, three predictors, and one qualitative response variable. Obs.X1X2X3Y 1 030 R e d 2 200 R e d 3 013 R e d 4 012 G r e e n 5−1 0 1 Green 6 111 R e d Suppose we wish to use this data set to make a prediction for Ywhen X1=X2=X3= 0 using K-nearest neighbors. (a) Compute the Euclidean distanc e between each observation and the test point, X1=X2=X3=0 . 54 2. Statistical Learning (b) What is our prediction with K=1 ?W h y ? (c) What is our prediction with K=3 ?W h y ? (d) If the Bayes decision boundary in this problem is highly non- linear, then would we expect the bestvalue for Kto be large or small? Why? Applied 8. This exercise relates to the Collegedata set, which can be found in theﬁle College.csv . Itcontainsanumberofvariablesfor777diﬀerent universities and colleges in the US. The variables are •Private: Public/private indicator •Apps: Number of applications received •Accept: Number of applicants accepted •Enroll: Number of new students enrolled •Top10perc : New students from top 10% of high school class •Top25perc : New students from top 25% of high school class •F.Undergrad : Number of full-time undergraduates •P.Undergrad : Number of part-time undergraduates •Outstate : Out-of-state tuition •Room.Board : Room and board costs •Books: Estimated book costs •Personal : Estimated personal spending •PhD: Percent of faculty with Ph.D.’s •Terminal : Percent of faculty with terminal degree •S.F.Ratio : Student/faculty ratio •perc.alumni : Percent of alumni who donate •Expend: Instructional expenditure per student •Grad.Rate : Graduation rate Before reading the data into R, it can be viewed in Excel or a text editor. (a) Use the read.csv() function to read the data into R.C a l lt h e loaded data college. Make sure that you have the directory set to the correct location for the data. (b) Look at the data using the fix()function. You should notice thattheﬁrstcolumnisjustthenameofeachuniversity.Wedon’t really want Rto treat this as data. However, it may be handy to have these names for later. T ry the following commands: 2.4 Exercises 55 > rownames(college)=college[,1] > fix(college) You should see that there is now a row.names column with the name of each university recorded. This means that Rhas given each row a name corresponding to the appropriate university. R will not try to perform calculations on the row names. However, we still need to eliminate the ﬁrst column in the data where the names are stored. Try > college=college[,-1] > fix(college) Now you should see that the ﬁrst data column is Private.N o t e that another column labeled row.names now appears before the Privatecolumn. However, this is not a data column but rather t h en a m et h a t Ris giving to each row. (c) i. Usethe summary() functiontoproduceanumericalsummary of the variables in the data set. ii. Use the pairs()function to produce a scatterplot matrix of the ﬁrst ten columns or variables of the data. Recall that you can reference the ﬁrst ten columns of a matrix Ausing A[,1:10] . iii. Use the plot()function to produce side-by-side boxplots of Outstate versus Private. iv. Create a new qualitative variable, called Elite,b ybinning theTop10perc variable. We are going to divide universities into two groups based on whether or not the proportion of students coming from the top 10% of their high school classes exceeds 50%. > Elite=rep(\"No\",nrow(college)) > Elite[college$Top10perc >50]=\"Yes\" > Elite=as.factor(Elite) > college=data.frame( college , Elite) Use the summary() function to see how many elite univer- sities there are. Now use the plot()function to produce side-by-side boxplots of Outstate versus Elite. v. Use the hist()function to produce some histograms with diﬀering numbers of bins for a few of the quantitative vari- ables.Youmayﬁndthe command par(mfrow=c(2,2)) useful: it will divide the print window into four regions so that four plots can be made simultaneously. Modifying the arguments to this function will divide the screen in other ways. vi. Continue exploring the data, and provide a brief summary of what you discover. 56 2. Statistical Learning 9. This exercise involves the Autodata set studied in the lab. Make sure that the missing values have been removed from the data. (a) Which of the predictors are quantitative, and which are quali- tative? (b) What is the rangeof each quantitative predictor? You can an- swer this using the range()function.range() (c) What is the mean and standard deviation of each quantitative predictor? (d) Now remove the 10th through 85th observations. What is the range, mean, and standard deviation of each predictor in the subset of the data that remains? (e) Using the full data set, investigate the predictors graphically, usingscatterplotsorothertoolsofyourchoice.Createsomeplots highlighting the relationships among the predictors. Comment on your ﬁndings. (f) Suppose that we wish to predict gas mileage ( mpg) on the basis of the other variables. Do your plots suggest that any of the other variables might be useful in predicting mpg? Justify your answer. 10. This exercise involves the Bostonhousing data set. (a) To begin, load in the Bostondata set. The Bostondata set is part of the MASSlibraryinR. > library(MASS) Now the data set is contained in the object Boston. > Boston Read about the data set: > ?Boston How many rows are in this data set? How many columns? What do the rows and columns represent? (b) Make some pairwise scatterplots of the predictors (columns) in this data set. Describe your ﬁndings. (c) Are any of the predictors associated with per capita crime rate? If so, explain the relationship. (d) Do any of the suburbs of Boston appear to have particularly high crime rates? Tax rates? Pupil-teacher ratios? Comment on the range of each predictor. (e) How many of the suburbs in this data set bound the Charles river? 2.4 Exercises 57 (f) What is the median pupil-teacher ratio among the towns in this data set? (g) Which suburb of Boston has lowest median value of owner- occupied homes? What are the values of the other predictors for that suburb, and how do those values compare to the overall ranges for those predictors? Comment on your ﬁndings. (h) In this data set, how many of the suburbs average more than seven rooms per dwelling? More than eight rooms per dwelling? Comment on the suburbs that average more than eight rooms per dwelling. 3 Linear Regression This chapter is about linear regression , a very simple approach for supervised learning. In particular, linear regression is a useful tool for pre- dicting a quantitative response. L inear regression has been around for a long time and is the topic of innumerable textbooks. Though it may seem somewhat dull compared to some of the more modern statistical learning approaches described in later chapters of this book, linear regression is still a useful and widely used statistical l earning method. Moreover, it serves as a good jumping-oﬀ point for newer approaches: as we will see in later chapters, many fancy statistical learning approaches can be seen as gener- alizations or extensions of linear regression. Consequently, the importance of having a good understanding of linear regression before studying more complex learning methods cannot be ove rstated. In this chapter, we review some of the key ideas underlying the linear regression model, as well as the least squares approach that is most commonly used to ﬁt this model. Recall the Advertising data from Chapter 2. Figure 2.1 displays sales (in thousands of units) for a particular product as a function of advertis- ing budgets (in thousands of dollars) for TV,radio,a n d newspaper media. Suppose that in our role as statistical consultants we are asked to suggest, on the basis of this data, a marketing plan for next year that will result in high product sales. What information would be useful in order to provide such a recommendation? Here are a few important questions that we might seek to address: 1.Is there a relationship between advertising budget and sales? Our ﬁrst goal should be to determine whether the data provide G. James et al., An Introduction to Statistical Learning: with Applications in R , Springer Texts in Statistics 103, DOI 10.1007/978-1-4614-7138-7 3, ©Springer Science+Business Media New York 201359 60 3. Linear Regression evidence of an associationbetween ad vertising expenditure and sales. If the evidence is weak, then one might argue that no money should be spent on advertising! 2.How strong is the relationship between advertising budget and sales? Assuming that there is a relationship between advertising and sales, we would like to know the strength of this relationship. In other words, given a certain advertising budget, can we predict sales with a high level of accuracy? This wou ld be a strong relationship. Or is a prediction of sales based on advertising expenditure only slightly better than a random guess? This would be a weak relationship. 3.Which media contribute to sales? Do all three media—TV, radio, and newspaper—contribute to sales, ordojustoneortwoofthemediacont ribute?Toanswerthisquestion, we must ﬁnd a way to separate out the individual eﬀects of each medium when we have spent money on all three media. 4.How accurately can we estimate the eﬀect of each medium on sales? For every dollar spent on advertising in a particular medium, by what amount will sales increase? How accurately can we predict this amount of increase? 5.How accurately can we predict future sales? Foranygivenleveloftelevision,radio,ornewspaperadvertising,what isourpredictionforsales,andwhatis theaccuracyofthisprediction? 6.Is the relationship linear? Ifthereisapproximatelyastraight-linerelationshipbetweenadvertis- ing expenditure in the various media and sales, then linear regression is an appropriate tool. If not, then it may still be possible to trans- form the predictor or the respons e so that linear regression can be used. 7.Is there synergy among the advertising media? Perhaps spending $50 ,000 on television advertising and $50 ,000 on radio advertising results in more sales than allocating $100 ,000 to either television or radio individually. In marketing, this is known as asynergyeﬀect, while in statistics it is called an interaction eﬀect.synergy interaction It turns out that linear regression can be used to answer each of these questions. We will ﬁrst discuss all of these questions in a general context, and then return to them in this s peciﬁc context in Section 3.4. 3.1 Simple Linear Regression 61 3.1 Simple Linear Regression Simple linear regression lives up to its name: it is a very straightforwardsimple linear regression approach for predicting a quantitative response Yon the basis of a sin- gle predictor variable X. It assumes that there is approximately a linear relationship between XandY. Mathematically, we can write this linear relationship as Y≈β0+β1X. (3.1) You might read “ ≈”a s“is approximately modeled as” . We will sometimes describe (3.1) by saying that we are regressing YonX(orYontoX). For example, Xmay represent TVadvertising and Ymay represent sales. Then we can regress salesonto TVby ﬁtting the model sales≈β0+β1×TV. In Equation 3.1, β0andβ1are two unknown constants that represent theintercept andslopeterms in the linear model. Together, β0andβ1areintercept slopeknown as the model coeﬃcients orparameters . O n c ew eh a v eu s e do u r coeﬃcient parametertraining data to produce estimates ˆβ0andˆβ1for the model coeﬃcients, we can predict future sales on the basis of a particular value of TV advertising by computing ˆy=ˆβ0+ˆβ1x, (3.2) where ˆyindicates a prediction of Yon the basis of X=x.H e r ew eu s ea hatsymbol, ˆ , to denote the estimated value for an unknown parameter or coeﬃcient, or to denote the predicted value of the response. 3.1.1 Estimating the Coeﬃcients In practice, β0andβ1are unknown. So before we can use (3.1) to make predictions, we must use data t o estimate the coeﬃcients. Let (x1,y1),(x2,y2),...,(xn,yn) represent nobservation pairs, each of which consists of a measurement ofXand a measurement of Y.I nt h e Advertising example, this data set consists of the TV advertising budget and product sales in n= 200 diﬀerent markets. (Recall that the data are displayed in Figure 2.1.) Our goal is to obtain coeﬃcient estimates ˆβ0andˆβ1such that the linear model (3.1) ﬁts the available data well—that is, so that yi≈ˆβ0+ˆβ1xifori= 1,...,n. In other words, we want to ﬁnd an intercept ˆβ0anda slope ˆβ1such that the resulting line is as close as possible to the n= 200 data points. There are a number of ways of measuring closeness . However, by far the most common approach involves minimizing the least squares criterion,least squaresand we take that approach in this chapter. Alternative approaches will be considered in Chapter 6. 62 3. Linear Regression 0 50 100 150 200 250 30051 0 1 5 2 0 2 5 TVSales FIGURE 3.1. For the Advertising data, the least squares ﬁt for the regression ofsalesonto TVis shown. The ﬁt is found by minimizing the sum of squared errors. Each grey line segment represents an error, and the ﬁt makes a compro- mise by averaging their squares. In this case a linear ﬁt captures the essence of the relationship, although it is somewhat deﬁcient in the left of the plot. Let ˆyi=ˆβ0+ˆβ1xibe the prediction for Ybased on the ith value of X. Thenei=yi−ˆyirepresents the ithresidual—this is the diﬀerence betweenresidualtheith observedresponsevalue and the ith response value that is predicted by our linear model. We deﬁne the residual sum of squares (RSS) asresidual sum of squaresRSS =e2 1+e2 2+···+e2 n, or equivalently as RSS = (y1−ˆβ0−ˆβ1x1)2+(y2−ˆβ0−ˆβ1x2)2+...+(yn−ˆβ0−ˆβ1xn)2.(3.3) The least squares approach chooses ˆβ0andˆβ1to minimize the RSS. Using some calculus, one can show that the minimizers are ˆβ1=/summationtextn i=1(xi−¯x)(yi−¯y)/summationtextn i=1(xi−¯x)2, ˆβ0=¯y−ˆβ1¯x,(3.4) where ¯y≡1 n/summationtextn i=1yiand ¯x≡1 n/summationtextn i=1xiare the sample means. In other words, (3.4) deﬁnes the least squares coeﬃcient estimates for simple linear regression. Figure 3.1 displays the simple linear regression ﬁt to the Advertising data, where ˆβ0=7.03 andˆβ1=0.0475. In other words, according to 3.1 Simple Linear Regression 63 β0β1 2.15 2.2 2.3 2.5 3 3 3 3 567890.03 0.04 0.05 0.06RSS β1 β0 FIGURE 3.2. Contour and three-dimensional plots of the RSS on the Advertising data, using salesas the response and TVas the predictor. The red dots correspond to the least squares estimates ˆβ0andˆβ1, given by (3.4). this approximation, an additional $1 ,000 spent on TV advertising is asso- ciated with selling approximately 47 .5 additional units of the product. In Figure 3.2, we have computed RSS for a number of values of β0andβ1, using the advertising data with salesas the response and TVas the predic- tor. In each plot, the red dot represen ts the pair of least squares estimates (ˆβ0,ˆβ1) given by (3.4). These values clearly minimize the RSS. 3.1.2 Assessing the Accuracy of the Coeﬃcient Estimates Recall from (2.1) that we assume that the truerelationship between Xand Ytakes the form Y=f(X)+/epsilon1for some unknown function f,w h e r e/epsilon1 is a mean-zero ra ndom error term. If fis to be approximated by a linear function, then we can write this relationship as Y=β0+β1X+/epsilon1. (3.5) Hereβ0isthe interceptterm—thatis, theexpected valueof YwhenX=0 , andβ1is the slope—the average increase in Yassociated with a one-unit increase in X. The error term is a catch-all for what we miss with this simple model: the true relationship is probably not linear, there may be other variables that cause variation in Y, and there may be measurement error. We typically assume that the error term is independent of X. The model given by (3.5) deﬁnes the population regression line ,w h i c hpopulation regression lineis the best linear approximation to the true relationship between Xand Y.1The least squares regressioncoeﬃcien t estimates (3.4) c haracterize the least squares line (3.2). The left-hand panel of Figure 3.3 displays theseleast squares line 1The assumption of linearity is often a useful working model. However, despite what many textbooks might tell us, we seldom believe that the true relationship is linear. 64 3. Linear Regression XY −2 −1 0 1 2 X−2 −1 0 1 2−10 −5 0 5 10 Y −10 −5 0 5 10 FIGURE 3.3. A simulated data set. Left:The red line represents the true rela- tionship, f(X)=2+3 X, which is known as the population regression line. The blue line is the least squares line; it is the least squares estimate for f(X)based on the observed data, shown in black. Right:The population regression line is again shown in red, and the least squares line in dark blue. In light blue, ten least squares lines are shown, each computed on the basis of a separate random set of observations. Each least squares line is diﬀerent, but on average, the least squares lines are quite close to the population regression line. two lines in a simple simulated example. We created 100 random Xs, and generated 100 corresponding Ys from the model Y=2+3X+/epsilon1, (3.6) where/epsilon1was generated from a normal dis tribution with mean zero. The red line in the left-hand panel of Figure 3.3 displays the truerelationship, f(X)=2+3 X, while the blue line is the least squares estimate based on the observed data. The true relationship is generally not known for real data, but the least squares line can always be computed using the coeﬃcient estimates given in (3.4). In other words, in real applications, we have access to a set of observations from which we can compute the least squares line; however, the population regression line is unobserved. In the right-hand panel of Figure 3.3 we have generated ten diﬀerent data sets from the model given by (3.6) and plotted the corresponding ten least squares lines. Notice that diﬀerent d ata sets generated from the same true model result in slightly diﬀerent least squares lines, but the unobserved population regression line does not change. At ﬁrst glance, the diﬀerence between the population regression line and the least squares line may seem subtle and confusing. We only have one data set, and so what does it mean that two diﬀerent lines describe the relationship between the predictor and the response? Fundamentally, the 3.1 Simple Linear Regression 65 concept of these two lines is a natural extension of the standard statistical approachofusinginformationfromasampletoestimatecharacteristicsofa large population. For example, suppose that we are interested in knowing the population mean μof some random variable Y. Unfortunately, μis unknown, but we do have access to nobservations from Y,w h i c hw ec a n write as y1,...,y n, and which we can use to estimate μ. A reasonable estimate is ˆ μ=¯y,w h e r e¯y=1 n/summationtextn i=1yii st h es a m p l em e a n .T h es a m p l e mean and the population mean are diﬀerent, but in general the sample mean will provide a good estimate of the population mean. In the same way, the unknown coeﬃcients β0andβ1in linear regression deﬁne the population regression line. We seek to estimate these unknown coeﬃcients usingˆβ0andˆβ1given in (3.4). These coeﬃci ent estimates deﬁne the least squares line. The analogy between linear regression and estimation of the mean of a random variable is an apt one based on the concept of bias.I fw eu s et h ebiassample mean ˆ μto estimate μ, this estimate is unbiased, in the sense thatunbiasedon average,we expect ˆ μto equalμ. What exactly does this mean? It means that on the basis of one particular set of observations y1,...,y n,ˆμmight overestimate μ, and on the basis of another set of observations, ˆ μmight underestimate μ. But if we could average a huge number of estimates of μobtained from a huge number of sets of observations, then this average wouldexactlyequalμ.Hence,anunbiasedestimatordoesnot systematically over- or under-estimate the true parameter. The property of unbiasedness holds for the least squares coeﬃcient estimates given by (3.4) as well: if we estimate β0andβ1on the basis of a particular data set, then our estimates won’t be exactly equal to β0andβ1. But if we could average the estimates obtained over a huge n umber of data sets, then the average of these estimates would be spot on! In fact, we can see from the right- hand panel of Figure 3.3 that the average of many least squares lines, each estimated from a separate data set, is pretty close to the true population regression line. We continue the analogy with the estimation of the population mean μof a random variable Y. A natural question is as follows: how accurate is the sample mean ˆ μas an estimate of μ? We have established that the average of ˆ μ’s over many data sets will be very close to μ, but that a single estimate ˆ μmay be a substantial underestimate or overestimate of μ. How far oﬀ will that single estimate of ˆ μbe? In general, we answer this question by computing the standard error of ˆμ, written as SE(ˆ μ). We havestandard error the well-known formula Var(ˆμ)=S E (ˆμ)2=σ2 n, (3.7) 66 3. Linear Regression whereσis the standard deviation of each of the realizations yiofY.2 Roughly speaking, the standard error tells us the averageamount that this estimate ˆ μdiﬀers from the actual value of μ. Equation 3.7 also tells us how this deviation shrinks with n—the more observations we have, the smaller the standard error of ˆ μ. In a similar vein, we can wonder how close ˆβ0 andˆβ1are to the true values β0andβ1. To compute the standard errors associated with ˆβ0andˆβ1, we use the following formulas: SE(ˆβ0)2=σ2/bracketleftbigg1 n+¯x2 /summationtextn i=1(xi−¯x)2/bracketrightbigg ,SE(ˆβ1)2=σ2 /summationtextn i=1(xi−¯x)2,(3.8) whereσ2=V a r (/epsilon1). For these formulas to be strictly valid, we need to as- sume that the errors /epsilon1ifor each observation are uncorrelated with common variance σ2. This is clearly not true in Figure 3.1, but the formula still turns out to be a good approximation. Notice in the formula that SE( ˆβ1)i s smaller when the xiare more spread out; intuitively we have more leverage to estimate a slope when this is the case. We also see that SE( ˆβ0)w o u l db e the same as SE(ˆ μ)i f¯xwere zero (in which case ˆβ0would be equal to ¯ y). In general, σ2is not known, but can be estimated from the data. This esti- mate is known as the residual standard error , and is given by the formularesidual standard errorRSE =/radicalbig RSS/(n−2). Strictly speaking, when σ2is estimated from the data we should write /hatwiderSE(ˆβ1) to indicate that an estimate has been made, but for simplicity of notation we will drop this extra “hat”. Standard errors can be used to compute conﬁdence intervals .A9 5 %conﬁdence interval conﬁdence interval is deﬁned as a range of values such that with 95% probability,therangewillcontainthetrueunknownvalueoftheparameter. The range is deﬁned in terms of lower and upper limits computed from the sample of data. For linear regression, the 95% conﬁdence interval for β1 approximately takes the form ˆβ1±2·SE(ˆβ1). (3.9) That is, there is approximately a 95% chance that the interval /bracketleftBig ˆβ1−2·SE(ˆβ1),ˆβ1+2·SE(ˆβ1)/bracketrightBig (3.10) will contain the true value of β1.3Similarly, a conﬁdence interval for β0 approximately takes the form ˆβ0±2·SE(ˆβ0). (3.11) 2This formula holds provided that the nobservations are uncorrelated. 3Approximately for several reasons. Equation 3.10 relies on the assumption that the errors are Gaussian. Also, the factor of 2 in front of the SE( ˆβ1) term will vary slightly depending on the number of observations nin the linear regression. To be precise, rather than the number 2, (3.10) should contain the 97.5% quantile of a t-distribution with n−2 degrees of freedom. Details of how to compute the 95% conﬁdence interval precisely inRwill be provided later in this chapter. 3.1 Simple Linear Regression 67 In the case of the advertising data, the 95% conﬁdence interval for β0 is [6.130,7.935] and the 95% conﬁdence interval for β1is [0.042,0.053]. Therefore,wecanconcludethatintheabsenceofanyadvertising,saleswill, on average, fall somewhere between 6 ,130 and 7 ,940 units. Furthermore, for each $1 ,000 increase in television advertising, there will be an average increase in sales of between 42 and 53 units. Standard errors can also be used to perform hypothesis tests on thehypothesis test coeﬃcients. The most common hypot hesis test involves testing the null hypothesis ofnull hypothesis H0: There is no relationship between XandY (3.12) versus the alternative hypothesisalternative hypothesis Ha: There is some relationship between XandY.(3.13) Mathematically, this corresponds to testing H0:β1=0 versus Ha:β1/negationslash=0, since ifβ1= 0 then the model (3.5) reduces to Y=β0+/epsilon1,a n dXis not associated with Y. To test the null hypothesis, we need to determine whether ˆβ1, our estimate for β1, is suﬃciently far from zero that we can be conﬁdent that β1is non-zero. How far is far enough? This of course depends on the accuracy of ˆβ1—that is, it depends on SE( ˆβ1). If SE(ˆβ1)i s small, then even relatively small values of ˆβ1may provide strong evidence thatβ1/negationslash= 0, and hence that there is a relationship between XandY.I n contrast, if SE( ˆβ1) is large,then ˆβ1must be large in absolute value in order for us to reject the null hypothesis. In practice, we compute a t-statistic ,t-statisticgiven by t=ˆβ1−0 SE(ˆβ1), (3.14) which measures the number of standard deviations that ˆβ1is away from 0. If there really is no relationship between XandY, then we expect that (3.14) will have a t-distribution with n−2 degrees of freedom. The t- distribution has abell shape and forvalues of ngreaterthan approximately 30 it is quite similar to the normal distribution. Consequently, it is a simple matter to compute the probability of observing any value equal to |t|or larger, assuming β1= 0. We call this probability the p-value. Roughlyp-valuespeaking, we interpret the p-value as follows: a small p-value indicates that it isunlikely toobservesuch asubstant ialassociationbetweenthe predictor and the response due to chance, in the absence of any real association between the predictor and the respon se. Hence, if we see a small p-value, 68 3. Linear Regression then we can infer that there is an associ ationbetween the predictor and the response. We reject the null hypothesis —that is, we declare a relationship to exist between XandY—if the p-value is small enough. Typical p-value cutoﬀs for rejecting the null hypothesis are 5 or 1%. When n= 30, these correspond to t-statistics (3.14) of around 2 and 2.75, respectively. Coeﬃcient Std. error t-statistic p-value Intercept 7.0325 0.4578 15.36 <0.0001 TV 0.0475 0.0027 17.67 <0.0001 TABLE 3.1. For the Advertising data, coeﬃcients of the least squares model for the regression of number of units sold on TV advertising budget. An increase of$1,000in the TV advertising budget is associated with an increase in sales by around 50 units (Recall that the salesvariable is in thousands of units, and the TVvariable is in thousands of dollars). Table 3.1 provides details of the least squares model for the regression of number of units sold on TV advertising budget for the Advertising data. Notice that the coeﬃcients for ˆβ0andˆβ1are very large relative to their standard errors, so the t-statistics are also large; the probabilities of seeing such values if H0is true are virtually zero. Hence we can conclude that β0/negationslash=0a n d β1/negationslash=0 .4 3.1.3 Assessing the Accuracy of the Model Once we have rejected the null hypothesis (3.12) in favor of the alternative hypothesis (3.13), it is natural to want to quantify the extent to which the model ﬁts the data . The quality ofa linear regressionﬁt is typically assessed using two related quantities: the residual standard error (RSE) and the R2 R2 statistic. Table 3.2 displays the RSE, the R2statistic, and the F-statistic (to be described in Section 3.2.2) for the linear regression of number of units sold on TV advertising budget. Residual Standard Error Recall from the model (3.5) that asso ciated with each observation is an error term /epsilon1. Due to the presence of these error terms, even if we knew the true regression line (i.e. even if β0andβ1were known), we would not be able to perfectly predict YfromX. The RSE is an estimate of the standard 4In Table 3.1, a small p-value for the intercept indicates that we can reject the null hypothesis that β0= 0, and a small p-value for TVindicates that we can reject the null hypothesis that β1= 0. Rejecting the latter null hypothesis allows us to conclude that there is a relationship between TVandsales. Rejecting the former allows us to conclude that in the absence of TVexpenditure, salesare non-zero. 3.1 Simple Linear Regression 69 Quantity Value Residual standard error 3.26 R20.612 F-statistic 312.1 TABLE 3.2. For the Advertising data, more information about the least squares model for the regression of number of units sold on TV advertising budget. deviationof /epsilon1.Roughlyspeaking,itistheaverageamountthattheresponse will deviate from the true regression line. It is computed using the formula RSE =/radicalbigg 1 n−2RSS =/radicaltp/radicalvertex/radicalvertex/radicalbt1 n−2n/summationdisplay i=1(yi−ˆyi)2. (3.15) Note that RSS was deﬁned in Section 3.1.1, and is given by the formula RSS =n/summationdisplay i=1(yi−ˆyi)2. (3.16) In the case of the advertising data, we see from the linear regression output in Table 3.2 that the RSE is 3 .26. In other words, actual sales in each market deviate from the true regression line by approximately 3 ,260 units, on average. Another way to think about this is that even if the model were correct and the true va lues of the unknown coeﬃcients β0 andβ1were known exactly, any prediction of sales on the basis of TV advertising would still be oﬀ by about 3 ,260 units on average. Of course, whether or not 3 ,260 units is an acceptable prediction error depends on the problem context. In the advertising data set, the mean value of salesover all markets is approximately 14 ,000 units, and so the percentage error is 3,260/14,0 0 0=2 3% . The RSE is considered a measure of the lack of ﬁt of the model (3.5) to the data. If the predictions obtained using the model are very close to the true outcome values—that is, if ˆ yi≈yifori=1,...,n—then (3.15) will be small, and we can conclude that the model ﬁts the data very well. On the other hand, if ˆ yiis very far from yifor one or more observations, then the RSE may be quite large, indicating that the model doesn’t ﬁt the data well. R2Statistic The RSE provides an absolute measure of lack of ﬁt of the model (3.5) to the data. But since it is measured in the units of Y, it is not always clear whatconstitutes a good RSE. The R2statistic providesan alternative measure of ﬁt. It takesthe form of a proportion —the proportionofvariance explained—and so it always takes on a value between 0 and 1, and is independent of the scale of Y. 70 3. Linear Regression To calculate R2,w eu s et h ef o r m u l a R2=TSS−RSS TSS=1−RSS TSS(3.17) where TSS =/summationtext(yi−¯y)2is thetotal sum of squares , and RSS is deﬁnedtotal sum of squares in (3.16). TSS measures the total variance in the response Y,a n dc a nb e thought of as the amount of variability inherent in the response before the regressionisperformed.Incontrast,RSSmeasurestheamountofvariability that is left unexplained after performing the regression. Hence, TSS −RSS measures the amount of variability in the response that is explained (or removed) by performing the regression, and R2measures the proportion of variability in Ythat can be explained using X.A nR2statistic that is close to 1 indicates that a large proportion of the variability in the response has been explained by the regression. A number near 0 indicates that the regressiondidnotexplainmuchofthevariabilityintheresponse;thismight occur because the linear model is wrong, or the inherent error σ2is high, or both. In Table 3.2, the R2was 0.61, and so just under two-thirds of the variability in salesis explained by a linear regression on TV. TheR2statistic (3.17) has an interpretational advantage over the RSE (3.15), since unlike the RSE, it alwayslies between 0 and 1. However,it can still be challenging to determine what is a goodR2value, and in general, this will depend on the application. For instance, in certain problems in physics, we may know that the data truly comes from a linear model with a small residual error.In this case, we would expect to see an R2value that isextremelycloseto1,andasubstantiallysmaller R2valuemightindicatea serious problem with the experiment i n which the data were generated. On the other hand, in typical applications in biology, psychology, marketing, and other domains, the linear model (3.5) is at best an extremely rough approximation to the data, and residual errors due to other unmeasured factors are often very large. In this setting, we would expect only a very small proportion of the variance in the response to be explained by the predictor, and an R2value well below 0 .1 might be more realistic! TheR2statistic is a measure of the linear relationship between Xand Y. Recall that correlation , deﬁned ascorrelation Cor(X,Y)=/summationtextn i=1(xi−x)(yi−y)/radicalbig/summationtextn i=1(xi−x)2/radicalbig/summationtextn i=1(yi−y)2,(3.18) is also a measure of the linear relationship between XandY.5This sug- gests that we might be able to use r=C o r (X,Y) instead of R2in order to assess the ﬁt of the linear model. In fact, it can be shown that in the simple linear regression setting, R2=r2. In other words, the squared correlation 5We note that in fact, the right-hand side of (3.18) is the sample correlation; thus, it would be more correct to write /hatwiderCor(X, Y); however, we omit the “hat” for ease of notation. 3.2 Multiple Linear Regression 71 and the R2statistic are identical. However, in the next section we will discuss the multiple linear regression problem, in which we use several pre- dictors simultaneously to predict th e response. The concept of correlation between the predictors and the response does not extend automatically to this setting, since correlation quanti ﬁes the association between a single pair of variables rather than between a larger number of variables. We will see that R2ﬁlls this role. 3.2 Multiple Linear Regression Simplelinearregressionisausefulapproachforpredictingaresponseonthe basis of a single predictor variable. However,in practice we often havemore thanonepredictor.Forexample,inthe Advertising data,wehaveexamined the relationship between sales and TV advertising. We also have data for the amount of money spent advertising on the radio and in newspapers, and we may want to know whether either of these two media is associated with sales. How can we extend our analysis of the advertising data in order to accommodate these two additional predictors? One option is to run three separate simple linear regressions, each of which uses a diﬀerent advertising medium as a predictor. For instance, we can ﬁt a simple linear regression to predict sales on the basis of the amount spent on radio advertisements. Results are shown in Table 3.3 (top table). We ﬁnd that a $1 ,000 increase in spending on radio advertising is associated with an increase in sales by around 203 units. Table 3.3 (bottom table) contains the least squarescoeﬃc ients for a simple linear regressionof sales onto newspaper advertising budget. A $1 ,000 increase in newspaper advertising budget is associated with an increase in sales by approximately 55 units. However,theapproachofﬁttingaseparatesimplelinearregressionmodel foreachpredictorisnotentirelysatisfactory.Firstofall,itisunclearhowto make a single prediction of sales given levels of the three advertising media budgets, since each of the budgets is associated with a separate regression equation. Second, each of the three regr ession equations ignores the other two media in forming estimates for the regression coeﬃcients. We will see shortly that if the media budgets are correlated with each other in the 200 markets that constitute our data set, then this can lead to very misleading estimates of the individual media eﬀects on sales. Instead of ﬁtting a separate simple linear regression model for each pre- dictor, a better approach is to extend the simple linear regression model (3.5) so that it can directly accommodate multiple predictors. We can do this by giving each predictor a separate slope coeﬃcient in a single model. In general, suppose that we have pdistinct predictors. Then the multiple linear regression model takes the form Y=β0+β1X1+β2X2+···+βpXp+/epsilon1, (3.19) 72 3. Linear Regression Simple regression of salesonradio Coeﬃcient Std. error t-statistic p-value Intercept 9.312 0.563 16.54 <0.0001 radio 0.203 0.020 9.92 <0.0001 Simple regression of salesonnewspaper Coeﬃcient Std. error t-statistic p-value Intercept 12.351 0.621 19.88 <0.0001 newspaper 0.055 0.017 3.30 <0.0001 TABLE 3.3. More simple linear regression models for the Advertising data. Co- eﬃcients of the simple linear regression model for number of units sold on Top: radio advertising budget and Bottom: newspaper advertising budget. A $1,000in- crease in spending on radio advertising is associated with an average increase in sales by around 203 units, while the same increase in spending on newspaper ad- vertising is associated with an average increase in sales by around 55 units (Note that the salesvariable is in thousands of units, and the radioand newspaper variables are in thousands of dollars). whereXjrepresents the jth predictor and βjquantiﬁes the association between that variable and the response. We interpret βjas theaverage eﬀect on Yof a one unit increase in Xj,holding all other predictors ﬁxed . In the advertising example, (3.19) becomes sales=β0+β1×TV+β2×radio+β3×newspaper +/epsilon1.(3.20) 3.2.1 Estimating the Regression Coeﬃcients As was the case in the simple linear reg ression setting, the regression coef- ﬁcientsβ0,β1,...,β pin (3.19) are unknown, and must be estimated. Given estimates ˆβ0,ˆβ1,...,ˆβp, we can make predictions using the formula ˆy=ˆβ0+ˆβ1x1+ˆβ2x2+···+ˆβpxp. (3.21) Theparametersareestimatedusingthesameleastsquaresapproachthat we saw in the context of simple linear regression. We choose β0,β1,...,β p to minimize the sum of squared residuals RSS =n/summationdisplay i=1(yi−ˆyi)2 =n/summationdisplay i=1(yi−ˆβ0−ˆβ1xi1−ˆβ2xi2−···−ˆβpxip)2.(3.22) 3.2 Multiple Linear Regression 73 X1X2Y FIGURE 3.4. In a three-dimensional setting, with two predictors and one re- sponse, the least squares regression line becomes a plane. The plane is chosen to minimize the sum of the squared vertical distances between each observation (shown in red) and the plane. The values ˆβ0,ˆβ1,...,ˆβpthatminimize(3.22)arethe multiple leastsquares regression coeﬃcient e stimates. Unlike the simple linear regression estimates given in (3.4), the multipl e regression coeﬃcient estimates have somewhat complicated forms that are most easily represented using ma- trix algebra. For this reason, we do not provide them here. Any statistical software package can be used to comput e these coeﬃcient estimates, and later in this chapter we will show how this can be done in R. Figure 3.4 illustrates an example of the least squares ﬁt to a toy data set with p=2 predictors. Table 3.4 displays the multiple regre ssioncoeﬃcient est imates when TV, radio, and newspaper advertising budgets are used to predict product sales usingthe Advertising data.We interprettheseres ultsasfollows:foragiven amount of TV and newspaper advertising, spending an additional $1 ,000 on radio advertising leads to an increase in sales by approximately 189 units.ComparingthesecoeﬃcientestimatestothosedisplayedinTables3.1 and 3.3, we notice that the multiple regression coeﬃcient estimates for TVand radioare pretty similar to the simple linear regression coeﬃcient estimates. However, while the newspaper regression coeﬃci ent estimate in Table 3.3 was signiﬁcantly non-zero, the coeﬃcient estimate for newspaper in the multiple regression model is close to zero, and the corresponding p-value is no longer signiﬁcant, with a value around 0 .86. This illustrates 74 3. Linear Regression Coeﬃcient Std. error t-statistic p-value Intercept 2.939 0.3119 9.42 <0.0001 TV 0.046 0.0014 32.81 <0.0001 radio 0.189 0.0086 21.89 <0.0001 newspaper −0.001 0.0059 −0.18 0 .8599 TABLE 3.4. For the Advertising data, least squares coeﬃcient estimates of the multiple linear regression of number of units sold on radio, TV, and newspaper advertising budgets. that the simple and multiple regressi on coeﬃcients can be quite diﬀerent. This diﬀerence stems from the fact that in the simple regression case, the slope term represents the average eﬀect of a $1 ,000 increase in newspaper advertising, ignoring other predictors such as TVand radio. In contrast, in the multiple regression setting, the coeﬃcient for newspaper represents the average eﬀect of increasing newspaper spending by $1 ,000 while holding TV and radioﬁxed. Does it make sense for the multiple regression to suggest no relationship between salesand newspaper while the simple linear regression implies the opposite? In fact it does. Consider the correlation matrix for the three predictor variables and response variable, displayed in Table 3.5. Notice that the correlation between radioand newspaper is 0.35. This reveals a tendency to spend more on newspaper advertising in markets where more is spent on radio advertising. Now suppose that the multiple regression is correct and newspaper adve rtising has no direct impact on sales, but radio advertising does increase sales. Then in markets where we spend more on radio our sales will tend to be higher, and as our correlation matrix shows, we also tend to spend more on n ewspaper advertising in those same markets. Hence, in a simple linear regression which only examines sales versus newspaper , we will observethat higher values of newspaper tend to be associated with higher values of sales, even though newspaper advertising does not actually aﬀect sales. So newspaper sales are a surrogate for radio advertising; newspaper gets “credit” for the eﬀect of radioonsales. This slightly counterintuitive result is very common in many real life situations. Consider an absurd example to illustrate the point. Running a regression of shark attacks versus i ce cream sales for data collected at a given beach community over a period of time would show a positive relationship, similar to that seen between salesand newspaper .O fc o u r s e no one (yet) has suggested that ice creams should be banned at beaches to reduce shark attacks. In reality, higher temperatures cause more people to visit the beach, which in turn results in more ice cream sales and more shark attacks. A multiple regression of attacks versus ice cream sales and temperature reveals that, as intuition implies, the former predictor is no longer signiﬁcant after adjusting for temperature. 3.2 Multiple Linear Regression 75 TV radio newspaper sales TV 1.0000 0.0548 0.0567 0.7822 radio 1.0000 0.3541 0.5762 newspaper 1.0000 0.2283 sales 1.0000 TABLE 3.5. Correlation matrix for TV,radio,newspaper ,a n d salesfor the Advertising data. 3.2.2 Some Important Questions When we perform multiple linear regre ssion, we usually are interested in answering a few important questions. 1.Is at least one of the predictors X1,X2,...,X puseful in predicting the response? 2.Do all the predictors help to explain Y, or is only a subset of the predictors useful? 3.How well does the model ﬁt the data? 4.Given a set of predictor values, what response value should we predict, and how accurate is our prediction? We now address each of these questions in turn. One: Is There a Relationship Betw een the Response and Predictors? Recall that in the simple linear regression setting, in order to determine whether there is a relationship between the response and the predictor we can simply check whether β1= 0. In the multiple regression setting with p predictors, we need to ask whether all o f the regressioncoeﬃcients arezero, i.e. whether β1=β2=···=βp= 0. As in the simple linear regression setting, we use a hypothesis test to answer this question. We test the null hypothesis, H0:β1=β2=···=βp=0 versus the alternative Ha:a t l e a s t o n e βjis non-zero. This hypothesis test is performed by computing the F-statistic ,F-statistic F=(TSS−RSS)/p RSS/(n−p−1), (3.23) 76 3. Linear Regression Quantity Value Residual standard error 1.69 R20.897 F-statistic 570 TABLE 3.6. More information about the least squares model for the regression of number of units sold on TV, newspaper, and radio advertising budgets in the Advertising data. Other information about this model was displayed in Table 3.4. where, as with simple linear regression, TSS =/summationtext(yi−¯y)2and RSS =/summationtext(yi−ˆyi)2. If the linear model assumption s are correct, one can show that E{RSS/(n−p−1)}=σ2 and that, provided H0is true, E{(TSS−RSS)/p}=σ2. Hence, when there is no relationship b etween the response and predictors, one would expect the F-statistic to take on a value close to 1. On the other hand, if Hais true, then E{(TSS−RSS)/p}>σ2, so we expect Fto be greater than 1. The F-statistic for the multiple linear regression model obtained by re- gressing salesonto radio,TV,a n d newspaper is shown in Table 3.6. In this example the F-statistic is 570. Since this is far larger than 1, it provides compelling evidence against the null hypothesis H0. In other words, the large F-statistic suggests that at least one of the advertising media must be related to sales. However, what if the F-statistic had been closer to 1? How large does the F-statistic need to be before we can reject H0and conclude that there is a relationship? It turns out that the answer depends on the values of nandp.W h e nnis large, an F-statistic that is just a little larger than 1 might still provide evidence against H0. In contrast, a larger F-statistic is needed to reject H0ifnis small. When H0is true and the errors /epsilon1ihave a normal distribution, the F-statistic follows an F-distribution.6For any given value of nandp, any statistical software package can be used to compute the p-value associated with the F-statistic using this distribution. Based on this p-value, we can determine whether or not to reject H0. For the advertising data, the p-value associated with the F-statistic in Table 3.6 is essentially zero, so we have extremely strong evidence that at least one of the med ia is associated with increased sales. In (3.23) we are testing H0that all the coeﬃcients are zero. Sometimes we want to test that a particular subset of qof the coeﬃcients are zero. This corresponds to a null hypothesis H0:βp−q+1=βp−q+2=...=βp=0, 6Eveniftheerrorsarenotnormally-distributed,theF-statisticapproximatelyfollows an F-distribution provided that the sample size nis large. 3.2 Multiple Linear Regression 77 where for convenience we have put the variables chosen for omission at the end of the list. In this case we ﬁt a second model that uses all the variables exceptthose last q. Suppose that the residual sum of squares for that model is RSS 0. Then the appropriate F-statistic is F=(RSS0−RSS)/q RSS/(n−p−1). (3.24) Notice that in Table 3.4, for each individual predictor a t-statistic and a p-value were reported. These provide information about whether each individual predictor is related to the response, after adjusting for the other predictors. It turns out that each of these are exactly equivalent7to the F-test that omits that single variable from the model, leaving all the others in—i.e.q=1 in (3.24). So it reports the partial eﬀect of adding that variable to the model. For instance, as we discussed earlier, these p-values indicate that TVand radioare related to sales, but that there is no evidence that newspaper is associated with sales, in the presence of these two. Given these individual p-values for each variable, why do we need to look at the overall F-statistic? After all, it seems likely that if any one of the p-values for the individual variables is very small, then at least one of the predictors is related to the response . However,this logic is ﬂawed, especially when the number of predictors pis large. For instance, consider an example in which p= 100 and H0:β1=β2= ...=βp= 0 is true, so no variable is truly associated with the response. In this situation, about 5% of the p-values associated with each variable (of the type shown in Table 3.4) will be below 0 .05 by chance. In other words, we expect to see approximately ﬁve smallp-values even in the absence of any true association between the predi ctors and the response. In fact, we are almost guaranteed that we will observe at least one p-value below 0 .05 by chance! Hence, if we use the individual t-statistics and associated p- values in order to decide whether or not there is any association between the variables and the response, there is a very high chance that we will incorrectly conclude that there is a rela tionship. However, the F-statistic does not suﬀer from this problem because it adjusts for the number of predictors. Hence, if H0is true, there is only a 5% chance that the F- statistic will result in a p-value below 0 .05, regardless of the number of predictors or the number of observations. The approach of using an F-statistic to test for any association between the predictors and the response works when pis relatively small, and cer- tainly small compared to n. However, sometimes we have a very large num- ber of variables. If p>nthen there are more coeﬃcients βjto estimate than observations from which to estimate them. In this case we cannot even ﬁt the multiple linear regression model using least squares, so the 7The square of each t-statistic is the corresponding F-statistic. 78 3. Linear Regression F-statistic cannot be used, and neither can most of the other concepts that we have seen so far in this chapter. When pis large,some of the approaches discussed in the next section, such as forward selection , can be used. This high-dimensional setting is discussed in greater detail in Chapter 6.high- dimensional Two: Deciding on Important Variables As discussed in the previous section, the ﬁrst step in a multiple regression analysis is to compute the F-statistic and to examine the associated p- value. If we conclude on the basis of that p-value that at least one of the predictors is related to the response, then it is natural to wonder whichare the guilty ones! We could look at the individual p-values as in Table 3.4, but as discussed, if pis large we are likely to make some false discoveries. It is possible that all of the predictor s are associated with the response, but it is more often the case that the response is only related to a subset of thepredictors.Thetaskofdetermining whichpredictorsareassociatedwith the response, in order to ﬁt a single model involving only those predictors, is referredto as variable selection . The variableselection problem is studiedvariable selection extensively in Chapter 6, and so here we will provide only a brief outline of some classical approaches. Ideally, we would like to perform variable selection by trying out a lot of diﬀerent models, each containing a diﬀerent subset of the predictors. For instance, if p= 2, then we can consider four models: (1) a model contain- ing no variables, (2) a model containing X1only, (3) a model containing X2only, and (4) a model containing both X1andX2.W ec a nt h e ns e - lect thebestmodel out of all of the models that we have considered. How do we determine which model is best? Various statistics can be used to judge the quality of a model. These include Mallow’s Cp,Akaike informa-Mallow’s Cption criterion (AIC),Bayesian information criterion (BIC), and adjustedAkaike information criterion Bayesian information criterionR2. These are discussed in more detai l in Chapter 6. We can also deter- adjusted R2mine which model is best by plotting various model outputs, such as the residuals, in order to search for patterns. Unfortunately, there are a total of 2pmodels that contain subsets of p variables. This means that even for moderate p, trying out every possible subsetofthe predictorsisinfeasible.Forinstance,wesawthatif p=2 ,t h e n there are 22= 4 models to consider. But if p= 30, then we must consider 230=1,073,741,824models!Thisisnotpractical.Therefore,unless pisvery small, we cannot consider all 2pmodels, and instead we need an automated and eﬃcient approach to choose a smaller set of models to consider. There are three classical approaches for this task: •Forward selection . We begin with the null model —a model that con-forward selection null modeltains an intercept but no predictors. We then ﬁt psimple linear re- gressions and add to the null model the variable that results in the lowest RSS. We then add to that model the variable that results 3.2 Multiple Linear Regression 79 in the lowest RSS for the new two-variable model. This approach is continued until some stopping rule is satisﬁed. •Backward selection . We start with all variables in the model, andbackward selection remove the variable with the largest p-value—that is, the variable that is the least statistically signiﬁcant. The new ( p−1)-variable modelis ﬁt,andthe variablewith the largestp-value is removed.This procedure continues until a stopping rule is reached. For instance, we may stop when all remaining variables have a p-value below some threshold. •Mixed selection . This is a combination of forward and backward se-mixed selection lection. We start with no variables in the model, and as with forward selection, we add the variable that provides the best ﬁt. We con- tinue to add variables one-by-one. Of course, as we noted with the Advertising example, the p-values for variables can become larger as new predictors are added to the model. Hence, if at any point the p-value for one of the variables in the model rises above a certain threshold, then we remove that variable from the model. We con- tinue to perform these forward and backward steps until all variables in the model have a suﬃciently low p-value, and all variables outside the model would have a large p-value if added to the model. Backward selection cannot be used if p>n, while forward selection can always be used. Forward selection is a greedy approach, and might include variables early that later become redundant. Mixed selection can remedy this. Three: Model Fit Two of the most common numerical measures of model ﬁt are the RSE and R2, the fraction of variance explained. These quantities are computed and interpreted in the same fashion as for simple linear regression. Recall that in simple regression, R2is the squareof the correlationof the response and the variable. In multiple linear regression, it turns out that it equals Cor( Y,ˆY)2, the square of the correlation between the response and the ﬁtted linear model; in fact one property of the ﬁtted linear model is that it maximizes this correlation among all possible linear models. AnR2value close to 1 indicates that the model explains a large portion of the variance in the responsevariable. As an example, we saw in Table 3.6 that for the Advertising data, the model that uses all three advertisingme- dia to predict saleshas anR2of0.8972.Onthe otherhand, the model that uses only TVand radioto predict saleshas anR2value of 0 .89719.In other words, there is a smallincrease in R2if we include newspaper advertising in the model that already contains TV and radio advertising, even though we saw earlierthat the p-value for newspaper advertisingin Table 3.4 is not 80 3. Linear Regression signiﬁcant. It turns out that R2will always increase when more variables are added to the model, even if those v ariables are only weakly associated with the response. This is due to the fact that adding another variable to the least squares equations must allow us to ﬁt the training data (though not necessarily the testing data) more accurately. Thus, the R2statistic, which is also computed on the training data, must increase. The fact that adding newspaper advertising to the model containing only TV and radio advertising leads to just a tiny increase in R2provides additional evidence that newspaper can be dropped from the model. Essentially, newspaper pro- vides no real improvement in the model ﬁt to the training samples, and its inclusion will likely lead to poor results on independent test samples due to overﬁtting. In contrast,the modelcontainingonly TVasa predictorhadan R2of0.61 (Table 3.2). Adding radioto the model leads to a substantial improvement inR2. This implies that a model that uses TV and radio expenditures to predict sales is substantially better than one that uses only TV advertis- ing. We could further quantify this improvement by looking at the p-value for the radiocoeﬃcient in a model that contains only TVand radioas predictors. The model that contains only TVand radioas predictors has an RSE of 1.681, and the model that also contains newspaper as a predictor has an RSE of 1.686 (Table 3.6). In contrast, the model that contains only TV has an RSE of 3 .26 (Table 3.2). This corroborates our previous conclusion that a model that uses TV and radio expenditures to predict sales is much more accurate (on the training data) than one that only uses TV spending. Furthermore, given that TV and radio expenditures are used as predictors, there is no point in also using newspaper spending as a predictor in the model. The observant reader may w onder how RSE can increase when newspaper is added to the model given that RSS must decrease. In general RSE is deﬁned as RSE =/radicalbigg1 n−p−1RSS, (3.25) which simpliﬁes to (3.15) for a simple linear regression. Thus, models with more variables can have higher RSE if the decrease in RSS is small relative to the increase in p. In addition to looking at the RSE and R2statistics just discussed, it can be useful to plot the data. Graphical s ummaries can reveal problems with a model that are not visible from numerical statistics. For example, Fig- ure 3.5 displays a three-dimensional plot of TVand radioversus sales.W e see that some observations lie above and some observations lie below the least squares regression plane. Notice that there is a clear pattern of nega- tive residuals, followed by positive residuals, followed by negative residuals. In particular, the linear model seems to overestimate salesfor instances in which most of the advertising money was spent exclusively on either 3.2 Multiple Linear Regression 81 Sales RadioTV FIGURE 3.5. For the Advertising data, a linear regression ﬁt to salesusing TVand radioas predictors. From the pattern of the residuals, we can see that there is a pronounced non-linear relationship in the data. TVorradio. It underestimates salesfor instances where the budget was split between the twomedia. This pronounced non-linearpattern cannot be modeled accurately using linear regression. It suggests a synergyorinter- actioneﬀect between the advertising media, whereby combining the media together results in a bigger boost to sales than using any single medium. In Section 3.3.2, we will discuss extending the linear model to accommodate such synergistic eﬀects through the use of interaction terms. Four: Predictions Once we have ﬁt the multiple regression model, it is straightforward to apply (3.21) in order to predict the response Yon the basis of a set of values for the predictors X1,X2,...,X p. However, there are three sorts of uncertainty associated with this prediction. 1. Thecoeﬃcientestimates ˆβ0,ˆβ1,...,ˆβpareestimatesfor β0,β1,...,β p. That is, the least squares plane ˆY=ˆβ0+ˆβ1X1+···+ˆβpXp is only an estimate for the true population regression plane f(X)=β0+β1X1+···+βpXp. The inaccuracy in the coeﬃcient estimates is related to the reducible errorfrom Chapter 2. We can compute a conﬁdence interval in order to determine how close ˆYwill be to f(X). 82 3. Linear Regression 2. Of course, in practice assuming a linear model for f(X) is almost always an approximationof reality, so there is an additional source of potentiallyreducible errorwhich wecall model bias .S ow h e nw eu s ea linear model, we are in fact estimating the best linear approximation to the true surface. However, here we will ignore this discrepancy, and operate as if the linear model were correct. 3. Even if we knew f(X)—that is, even if we knew the true values forβ0,β1,...,β p—the response value cannot be predicted perfectly because of the random error /epsilon1in the model (3.21). In Chapter 2, we referred to this as the irreducible error . How much will Yvary from ˆY?W eu s e prediction intervals to answer this question. Prediction intervals are always wider than conﬁdence intervals, because they incorporate both the error in the estimate for f(X) (the reducible error) and the uncertainty as to how much an individual point will diﬀer from the population regression plane (the irreducible error). We use a conﬁdence interval to quantify the uncertainty surroundingconﬁdence interval theaverage salesover a large number of cities. For example, given that $100,000isspenton TVadvertisingand$20 ,000isspenton radioadvertising in each city, the 95% conﬁdence interval is [10 ,985,11,528]. We interpret this to meanthat 95% ofintervalsofthis formwill containthe true value of f(X).8On the other hand, a prediction interval c a nbeu s e dt oq u a n t i f yt h eprediction interval uncertainty surrounding salesfor aparticular city. Given that $100 ,000 is spenton TVadvertisingand$20 ,000isspenton radioadvertisinginthatcity the 95% prediction interval is [7 ,930,14,580]. We interpret this to mean that 95% of intervals of this form will contain the true value of Yfor this city.Note thatbothintervalsarecenteredat11 ,256,butthattheprediction interval is substantially wider than the conﬁdence interval, reﬂecting the increased uncertainty about salesfor a given city in comparison to the average salesover many locations. 3.3 Other Considerations in the Regression Model 3.3.1 Qualitative Predictors In our discussion so far, we have assumed that all variables in our linear regression model are quantitative . But in practice, this is not necessarily the case; often some predictors are qualitative . 8In other words, if we collect a large number of data sets like the Advertising data set, and we construct a conﬁdence interval for the average saleson the basis of each data set (given $100 ,000 in TVand $20 ,000 in radioadvertising), then 95% of these conﬁdence intervals will contain the true value of average sales. 3.3 Other Considerations in the Regression Model 83 For example, the Creditdata set displayed in Figure 3.6 records balance (average credit card debt for a numb er of individuals) as well as several quantitative predictors: age,cards(number of credit cards), education (years of education), income(in thousands of dollars), limit(credit limit), and rating(credit rating). Each panel of Figure 3.6 is a scatterplot for a pair of variables whose identities are given by the corresponding row and column labels. Forexample, the scatterplotdirectly to the right ofthe word “Balance” depicts balanceversus age, while the plot directly to the right of “Age” corresponds to ageversus cards. In addition to these quantitative variables, we also have four qualitative variables: gender,student(student status), status(marital status), and ethnicity (Caucasian, African Amer- ican or Asian). Balance Age Cards Education Income Limit20 40 60 80 100 5 10 15 20 2000 8000 14000 0 500 150020 40 60 80 100 246851 0 1 5 2 0 50 100 1502000 8000 14000 0 500 1500 2 4 6 8 50 100 150 200 600 1000 200 600 1000Rating FIGURE 3.6. The Creditdata set contains information about balance,age, cards,education ,income,limit,a n d ratingfor a number of potential cus- tomers. 84 3. Linear Regression Coeﬃcient Std. error t-statistic p-value Intercept 509.80 33.13 15.389 <0.0001 gender[Female] 19.73 46.05 0.429 0.6690 TABLE 3.7. Least squares coeﬃcient estimates associated with the regression of balance onto genderin the Creditdata set. The linear model is given in (3.27). That is, gender is encoded as a dummy variable, as in (3.26). Predictors with Only Two Levels Suppose that we wish to investigate diﬀerences in credit card balance be- tween males and females, ignoring the other variables for the moment. If a qualitative predictor (also known as a factor)o n l yh a st w o levels, or possi-factor level ble values, then incorporating it into a regression model is very simple. We simply create an indicator or dummy variable that takes on two possibledummy variable numerical values. For example, based on the gendervariable, we can create a new variable that takes the form xi=/braceleftBigg 1i fith person is female 0i fith person is male ,(3.26) and use this variable as a predictor in the regression equation. This results in the model yi=β0+β1xi+/epsilon1i=/braceleftBigg β0+β1+/epsilon1iifith person is female β0+/epsilon1i ifith person is male .(3.27) Nowβ0can be interpreted as the average credit cardbala nce among males, β0+β1as the average credit card balance among females, and β1as the average diﬀerence in credit card balance between females and males. Table 3.7 displays the coeﬃcient estimates and other information asso- ciated with the model (3.27). The av erage credit card debt for males is estimated to be $509 .80, whereas females ar e estimated to carry $19 .73 in additional debt for a total of $509 .80 + $19 .73 = $529 .53. However, we notice that the p-value for the dummy variable is very high. This indicates that there is no statistical evidence of a diﬀerence in average credit card balance between the genders. Thedecisiontocodefemalesas1andmalesas0in(3.27)isarbitrary,and has no eﬀect on the regression ﬁt, but does alter the interpretation of the coeﬃcients. If we had coded males as 1 and females as 0, then the estimates forβ0andβ1wouldhavebeen529 .53and−19.73,respectively,leadingonce again to a prediction of credit card debt of $529 .53−$19.73 = $509 .80 for males and a prediction of $529 .53 for females. Alternatively, instead of a 0/1 coding scheme, we could create a dummy variable 3.3 Other Considerations in the Regression Model 85 xi=/braceleftBigg 1i f ith person is female −1i fith person is male and use this variable in the regression equation. This results in the model yi=β0+β1xi+/epsilon1i=/braceleftBigg β0+β1+/epsilon1iifith person is female β0−β1+/epsilon1iifith person is male. Nowβ0can be interpreted as the overall average credit card balance (ig- noring the gender eﬀect), and β1is the amount that females are above the average and males are below the average. In this example, the estimate for β0would be $519 .665, halfway between the male and female averages of $509.80 and $529 .53. The estimate for β1would be $9 .865, which is half of $19.73,the averagediﬀerencebetween females and males.It is importantto note that the ﬁnal predictions for the credit balances of males and females will be identical regardless of the coding scheme used. The only diﬀerence is in the way that the coeﬃcients are interpreted. Qualitative Predictors with More than Two Levels When a qualitative predictor has more than two levels, a single dummy variablecannotrepresentallpossiblevalues.Inthis situation,wecancreate additional dummy variables. For example, for the ethnicity variable we create two dummy variables. The ﬁrst could be xi1=/braceleftBigg 1i fith person is Asian 0i fith person is not Asian ,(3.28) and the second could be xi2=/braceleftBigg 1i fith person is Caucasian 0i fith person is not Caucasian .(3.29) Then both of these variables can be u sed in the regression equation, in order to obtain the model yi=β0+β1xi1+β2xi2+/epsilon1i=⎧ ⎪⎨ ⎪⎩β0+β1+/epsilon1iifith person is Asian β0+β2+/epsilon1iifith person is Caucasian β0+/epsilon1iifith person is African American . (3.30) Nowβ0can be interpreted as the average credit card balance for African Americans, β1can be interpreted as the diﬀer ence in the average balance between the Asian and African American categories, and β2can be inter- preted as the diﬀerence in the average balance between the Caucasian and 86 3. Linear Regression Coeﬃcient Std. error t-statistic p-value Intercept 531.00 46.32 11.464 <0.0001 ethnicity[Asian] −18.69 65.02 −0.287 0.7740 ethnicity[Caucasian] −12.50 56.68 −0.221 0.8260 TABLE 3.8. Least squares coeﬃcient estimates associated with the regression ofbalance onto ethnicity in the Creditdata set. The linear model is given in (3.30). That is, ethnicity is encoded via two dummy variables (3.28) and (3.29). African American categories. Ther e will always be one fewer dummy vari- able than the number of levels. The level with no dummy variable—African American in this example—is known as the baseline.baselineFrom Table 3.8, we see that the estimated balance for the baseline, African American, is $531 .00. It is estimated that the Asian category will have $18 .69 less debt than the African American category, and that the Caucasian category will have $12 .50 less debt than the African American category.However,the p-valuesassociatedwith the coeﬃcientestimates for the two dummy variables are very large, suggesting no statistical evidence of a real diﬀerence in credit card bala nce between the ethnicities. Once again, the level selected as the baseline category is arbitrary, and the ﬁnal predictions for each group will be the same regardless of this choice. How- ever, the coeﬃcients and their p-values do depend on the choice of dummy variable coding. Rather than rely on the individual coeﬃcients, we can use an F-test to test H0:β1=β2= 0; this does not depend on the coding. This F-test has a p-value of 0 .96, indicating that we cannot reject the null hypothesis that there is no relationship between balanceand ethnicity . Using this dummy variable approach presents no diﬃculties when in- corporating both quantitative and qualitative predictors. For example, to regress balanceon both a quantitative variable such as incomeand a qual- itative variable such as student, we must simply create a dummy variable forstudentand then ﬁt a multiple regression model using incomeand the dummy variable as predictors for credit card balance. There are many diﬀerent ways of coding qualitative variables besides the dummy variable approach taken here. All of these approaches lead to equivalent model ﬁts, but the coeﬃcients are diﬀerent and have diﬀerent interpretations,andaredesignedtomeasureparticular contrasts .Thistopiccontrastis beyond the scope of the book, and so we will not pursue it further. 3.3.2 Extensions of the Linear Model The standard linear regression model (3.19) provides interpretable results and works quite well on many real-worl d problems. However, it makes sev- eral highly restrictive assumptions that are often violated in practice. Two of the most important assumptions state that the relationship between the predictors and response are additive andlinear. The additive assumptionadditive linear 3.3 Other Considerations in the Regression Model 87 means that the eﬀect of changes in a predictor Xjon the response Yis independent of the values of the other predictors. The linear assumption states that the change in the response Ydue to a one-unit change in Xjis constant, regardless of the value of Xj. In this book, we examine a number of sophisticatedmethods that relax these two assumptions.Here,we brieﬂy examine some common classical approachesfor extending the linear model. Removing the Additive Assumption In ourpreviousanalysisofthe Advertising data, we concluded that both TV and radioseem to be associated with sales. The linear models that formed the basis for this conclusion assumed that the eﬀect on salesof increasing one advertising medium is independent of the amount spent on the other media. For example, the linear model (3.20) states that the average eﬀect onsalesof a one-unit increase in TVis always β1, regardless of the amount spent on radio. However, this simple model may be incorrect. Suppose that spending money on radio advertising actually increases the eﬀectiveness of TV ad- vertising, so that the slope term for TVshould increase as radioincreases. In this situation, given a ﬁxed budget of $100 ,000, spending half on radio and half on TVmay increase salesmore than allocating the entire amount to either TVor to radio. In marketing, this is known as a synergyeﬀect, a n di ns t a t i s t i c si ti sr e f e r r e dt oa sa n interaction eﬀect. Figure 3.5 sug- gests that such an eﬀect may be present in the advertising data. Notice that when levels of either TVorradioare low, then the true salesare lower than predicted by the linear model. But when advertising is split between the two media, then the model tends to underestimate sales. Consider the standard linear regression model with two variables, Y=β0+β1X1+β2X2+/epsilon1. According to this model, if we increase X1by one unit, then Ywill increase by an average of β1units. Notice that the presence of X2does not alter this statement—that is, regardless of the value of X2, a one-unit increase inX1will lead to a β1-unit increase in Y. One way of extending this model to allow for interaction eﬀects is to include a third predictor, called an interaction term , which is constructed by computing the product of X1 andX2. This results in the model Y=β0+β1X1+β2X2+β3X1X2+/epsilon1. (3.31) How does inclusion of this interaction term relax the additive assumption? Notice that (3.31) can be rewritten as Y=β0+(β1+β3X2)X1+β2X2+/epsilon1 (3.32) =β0+˜β1X1+β2X2+/epsilon1 88 3. Linear Regression Coeﬃcient Std. error t-statistic p-value Intercept 6.7502 0.248 27.23 <0.0001 TV 0.0191 0.002 12.70 <0.0001 radio 0.0289 0.009 3.24 0.0014 TV×radio 0.0011 0.000 20.73 <0.0001 TABLE 3.9. For the Advertising data, least squares coeﬃcient estimates asso- ciated with the regression of salesonto TVand radio, with an interaction term, as in (3.33). where˜β1=β1+β3X2.S i n c e˜β1changes with X2, the eﬀect of X1onYis no longer constant: adjusting X2will change the impact of X1onY. For example, suppose that we are interested in studying the productiv- ity of a factory. We wish to predict the number of unitsproduced on the basis of the number of production linesand the total number of workers. It seems likely that the eﬀect of increasing the number of production lines will depend on the number of workers, since if no workers are available to operate the lines, then increasing the number of lines will not increase production. This suggests that it would be appropriate to include an inter- action term between linesand workersin a linear model to predict units. Suppose that when we ﬁt the model, we obtain units≈1.2+3.4×lines+0.22×workers+1.4×(lines×workers) =1.2+(3.4+1.4×workers)×lines+0.22×workers. In other words, adding an additional line will increase the number of units produced by 3 .4+1.4×workers. Hence the more workers we have, the stronger will be the eﬀect of lines. We now return to the Advertising example. A linear model that uses radio,TV, and an interaction between the two to predict salestakes the form sales=β0+β1×TV+β2×radio+β3×(radio×TV)+/epsilon1 =β0+(β1+β3×radio)×TV+β2×radio+/epsilon1.(3.33) We can interpret β3as the increase in the eﬀectiveness of TV advertising for a one unit increase in radio advertising (or vice-versa). The coeﬃcients that result from ﬁtting the model (3.33) are given in Table 3.9. The resultsin Table3.9stronglysuggestthat the model that includes the interaction term is superior to the model that contains only main eﬀects .main eﬀectThe p-value forthe interactionterm, TV×radio, is extremelylow,indicating that there is strong evidence for Ha:β3/negationslash= 0. In other words, it is clear that the true relationship is not additive. The R2for the model (3.33) is 96.8%, compared to only 89.7% for the model that predicts salesusing TVand radiowithout an interaction term. This means that (96 .8−89.7)/(100− 89.7) = 69% of the variability in salesthat remains after ﬁtting the ad- ditive model has been explained by the interaction term. The coeﬃcient 3.3 Other Considerations in the Regression Model 89 estimatesinTable3.9suggestthatanincreaseinTVadvertisingof$1 ,000is associatedwithincreasedsalesof( ˆβ1+ˆβ3×radio)×1,000 = 19+1 .1×radio units. And an increase in radio advertising of $1 ,000will be associatedwith an increase in sales of ( ˆβ2+ˆβ3×TV)×1,000 = 29+1 .1×TVunits. In this example, the p-values associated with TV,radio,a n dt h ei n t e r a c - tion term all are statistically signiﬁcant (Table 3.9), and so it is obvious that all three variables should be included in the model. However, it is sometimes the case that an interact ion term has a very small p-value, but the associated main eﬀects (in this case, TVand radio)d on o t .T h e hier- archical principle states that if we include an interaction in a model, wehierarchical principle should also include the main eﬀects, even if the p-values associated with their coeﬃcients are not signiﬁcant. In other words, if the interaction be- tweenX1andX2seems important, then we should include both X1and X2in the model even if their coeﬃcient estimates have large p-values. The rationale for this principle is that if X1×X2is related to the response, then whether or not the coeﬃcients of X1orX2are exactly zero is of lit- tle interest. Also X1×X2is typically correlated with X1andX2,a n ds o leaving them out tends to alter the meaning of the interaction. In the previous example, we considered an interaction between TVand radio, both of which are quantitative var iables. However, the concept of interactionsapplies just aswell to qualitativevariables,orto a combination of quantitative and qualitative variables. In fact, an interaction between a qualitative variable and a quantitative variable has a particularly nice interpretation.Considerthe CreditdatasetfromSection3.3.1,andsuppose that wewish topredict balanceusing the income(quantitative)and student (qualitative) variables. In the absen ce of an interaction term, the model takes the form balance i≈β0+β1×income i+/braceleftBigg β2ifith person is a student 0i f ith person is not a student =β1×income i+/braceleftBigg β0+β2ifith person is a student β0 ifith person is not a student . (3.34) Notice that this amounts to ﬁtting two parallel lines to the data, one for students and one for non-students. The lines for students and non-students have diﬀerent intercepts, β0+β2versusβ0, but the same slope, β1.T h i s is illustrated in the left-hand panel of Figure 3.7. The fact that the lines are parallel means that the average eﬀect on balanceof a one-unit increase inincomedoes not depend on whether or not the individual is a student. This represents a potentially serious limitation of the model, since in fact a change in incomemay have a very diﬀerent eﬀect on the credit card balance of a student versus a non-student. This limitation can be addressed by adding an interaction variable, cre- ated by multiplying incomewith the dummy variable for student.O u r 90 3. Linear Regression IncomeBalance 0 50 100 150 Income0 50 100 150200 600 1000 1400 Balance 200 600 1000 1400student non−student FIGURE 3.7. For the Creditdata, the least squares lines are shown for pre- diction of balance from incomefor students and non-students. Left:The model (3.34) was ﬁt. There is no interaction between incomeand student.Right:The model (3.35) was ﬁt. There is an interaction term between incomeand student. model now becomes balance i≈β0+β1×income i+/braceleftBigg β2+β3×income iif student 0 if not student =/braceleftBigg (β0+β2)+(β1+β3)×income iif student β0+β1×income i if not student (3.35) Once again, we have two diﬀerent regression lines for the students and the non-students. But now those regression lines have diﬀerent intercepts, β0+β2versusβ0,aswellasdiﬀerentslopes, β1+β3versusβ1.Thisallowsfor the possibility that changes in income may aﬀect the credit card balances of students and non-students diﬀerently. The right-handpanel ofFigure 3.7 shows the estimated relationships between incomeand balancefor students and non-students in the model (3.35). We note that the slope for students is lower than the slope for non-students. This suggests that increases in income are associated with smaller inc reases in credit card balance among students as compared to non-students. Non-linear Relationships As discussed previously, the linear r egressionmodel (3.19) assumes a linear relationship between the response and predictors. But in some cases, the true relationship between the response and the predictors may be non- linear.Herewepresentaverysimplewa ytodirectlyextendthelinearmodel to accommodate non-linear relationships, using polynomial regression .I npolynomial regression later chapters, we will present more complex approaches for performing non-linear ﬁts in more general settings. Consider Figure 3.8, in which the mpg(gas mileage in miles per gallon) versus horsepower is shown for a number of cars in the Autodata set. The 3.3 Other Considerations in the Regression Model 91 50 100 150 20010 20 30 40 50 HorsepowerMiles per gallonLinear Degree 2 Degree 5 FIGURE 3.8. The Autodata set. For a number of cars, mpgandhorsepower are shown. The linear regression ﬁt is shown in orange. The linear regression ﬁt for a model that includes horsepower2is shown as a blue curve. The linear regression ﬁt for a model that includes all polynomials of horsepower up to ﬁfth-degree is shown in green. orange line represents the linear regression ﬁt. There is a pronounced rela- tionship between mpgand horsepower , but it seems clear that this relation- ship is in fact non-linear: the data suggest a curved relationship. A simple approach for incorporating non-linear associations in a linear model is to include transformed versions of the pr edictors in the model. For example, the points in Figure 3.8 seem to have a quadratic shape, suggesting that aquadraticmodel of the form mpg=β0+β1×horsepower +β2×horsepower2+/epsilon1(3.36) may provide a better ﬁt. Equation 3.36 involves predicting mpgusing a non-linear function of horsepower .But it is still a linear model! That is, (3.36) is simply a multiple linear regression model with X1=horsepower andX2=horsepower2. So we canusestandardlinear regressionsoftwareto estimate β0,β1,a n dβ2in order to produce a non-linear ﬁt. The blue curve in Figure 3.8 shows the resulting quadratic ﬁt to the data. The quadratic ﬁt appears to be substantially better than the ﬁt obtained when just the linear term is included. The R2of the quadratic ﬁt is 0 .688, compared to 0.606 for the linear ﬁt, and the p-value in Table 3.10 for the quadratic term is highly signiﬁcant. If including horsepower2l e dt osu c hab i gi m p ro v e m e n ti nt h em od e l ,w h y notinclude horsepower3,horsepower4,orev en horsepower5?Thegreencurve 92 3. Linear Regression Coeﬃcient Std. error t-statistic p-value Intercept 56.9001 1.8004 31.6 <0.0001 horsepower −0.4662 0.0311 −15.0<0.0001 horsepower20.0012 0.0001 10.1 <0.0001 TABLE 3.10. For the Autodata set, least squares coeﬃcient estimates associated with the regression of mpgonto horsepower and horsepower2. in Figure 3.8 displays the ﬁt that results from including all polynomials up to ﬁfth degree in the model (3.36). T he resulting ﬁt seems unnecessarily wiggly—that is, it is unclear that including the additional terms really has led to a better ﬁt to the data. The approach that we have just described for extending the linear model to accommodate non-linear relationships is known as polynomial regres- sion, since we have included polynomial functions of the predictors in the regression model. We further explore this approach and other non-linear extensions of the linear model in Chapter 7. 3.3.3 Potential Problems When we ﬁt a linear regression model to a particular data set, many prob- lems may occur. Most common among these are the following: 1.Non-linearity of the response-predictor relationships. 2.Correlation of error terms. 3.Non-constant variance of error terms. 4.Outliers. 5.High-leverage points. 6.Collinearity. In practice, identifying and overco ming these problems is as much an art as a science. Many pages in countless books have been written on this topic. Since the linear regression model is not our primary focus here, we will provide only a brief summary of some key points. 1. Non-linearity of the Data The linear regression model assumes that there is a straight-line relation- ship between the predictors and the response. If the true relationship is far from linear, then virtually all of the conclusions that we draw from the ﬁt are suspect. In addition, the pred iction accuracy of the model can be signiﬁcantly reduced. Residual plots are a useful graphical tool for identifying non-linearity.residual plotGiven a simple linear regression model, we can plot the residuals, ei= yi−ˆyi, versus the predictor xi. In the case of a multiple regression model, 3.3 Other Considerations in the Regression Model 93 Fitted valuesResidualsResidual Plot for Linear Fit 323 330 334 5 1 01 52 02 53 0−15 −10 −5 0 5 10 15 20 15 20 25 30 35−15 −10 −5 0 5 10 15 Fitted valuesResidualsResidual Plot for Quadratic Fit 334323 155 FIGURE 3.9. Plots of residuals versus predicted (or ﬁtted) values for the Auto data set. In each plot, the red line is a smooth ﬁt to the residuals, intended to make it easier to identify a trend. Left:A linear regression of mpgonhorsepower .A strong pattern in the residuals indicates non-linearity in the data. Right:Al i n e a r regression of mpgonhorsepower and horsepower2. There is little pattern in the residuals. since there are multiple predictors, we instead plot the residuals versus the predicted (or ﬁtted)v a l u e sˆ yi. Ideally, the residual plot will show noﬁtteddiscernible pattern. The presence of a pattern may indicate a problem with some aspect of the linear model. The left panel of Figure 3.9 displays a residual plot from the linear regression of mpgonto horsepower on the Autodata set that was illustrated inFigure3.8.Theredlineisasmoothﬁttothe residuals,whichisdisplayed in order to make it easier to identify any trends. The residuals exhibit a clear U-shape, which provides a strong indication of non-linearity in the data. In contrast, the right-hand panel of Figure 3.9 displays the residual plot that results from the model (3.36), which contains a quadratic term. There appears to be little pattern in the residuals, suggesting that the quadratic term improves the ﬁt to the data. If the residual plot indicates that there are non-linear associations in the data, then a simple approach is to use non-linear transformations of the predictors, such as log X,√ X,a n dX2, in the regression model. In the later chapters of this book, we will discuss other more advanced non-linear approaches for addressing this issue. 2. Correlation of Error Terms An important assumption of the linear regression model is that the error terms,/epsilon11,/epsilon12,...,/epsilon1 n, are uncorrelated. What does this mean? For instance, if the errors are uncorrelated, then the fact that /epsilon1iis positive provides little or no information about the sign of /epsilon1i+1. The standard errors that are computed for the estimated regression coeﬃcients or the ﬁtted values 94 3. Linear Regression are based on the assumption of uncorrelated error terms. If in fact there is correlation among the error terms, then the estimated standard errors will tend to underestimate the true standard errors. As a result, conﬁ- dence and prediction intervals will be narrower than they should be. For example, a 95% conﬁdence interval may in reality have a much lower prob- ability than 0 .95 of containing the true value of the parameter. In addition, p-values associated with the model will be lower than they should be; this could cause us to erroneously conclude that a parameter is statistically signiﬁcant. In short, if the error terms are correlated, we may have an unwarranted sense of conﬁdence in our model. As an extreme example, suppose we accidentally doubled our data, lead- ing to observationsand errorterms iden ticalinpairs.If weignoredthis,our standard error calculations would be as if we had a sample of size 2 n,w h e n in fact we have only nsamples. Our estimated parameters would be the same for the 2 ns a m p l e sa sf o rt h e nsamples, but the conﬁdence intervals would be narrower by a factor of√ 2! Why might correlations among the error terms occur? Such correlations frequently occur in the context of time series data, which consists of ob-time seriesservations for which measurements are obtained at discrete points in time. In many cases, observations that are obtained at adjacent time points will have positively correlatederrors.In order to determine if this is the case for a given data set, we can plot the residuals from our model as a function of time. Ifthe errorsareuncorrelated,then there should be no discernible pat- tern. On the other hand, if the error terms are positively correlated, then we may see tracking in the residuals—that is, adjacent residuals may havetrackingsimilar values. Figure 3.10 provides an illustration. In the top panel, we see the residuals from a linear regression ﬁt to data generated with uncorre- lated errors. There is no evidence of a time-related trend in the residuals. In contrast, the residuals in the bottom panel are from a data set in which adjacent errors had a correlation of 0 .9. Now there is a clear pattern in the residuals—adjacent residuals tend to take on similar values. Finally, the center panel illustrates a more moderate case in which the residuals had a correlation of 0 .5. There is still evidence of tracking, but the pattern is less clear. Many methods have been developed to properly take account of corre- lations in the error terms in time series data. Correlation among the error terms can also occur outside of time se ries data. For instance, consider a study in which individuals’ heights are predicted from their weights. The assumption of uncorrelated errors could be violated if some of the individ- uals in the study are members of the same family, or eat the same diet, or have been exposed to the same envi ronmental factors. In general, the assumption of uncorrelated errors is ex tremely important for linear regres- sion as well as for other statistical methods, and good experimental design is crucial in order to mitigate the risk of such correlations. 3.3 Other Considerations in the Regression Model 95 100 80 60 40 20 0 100 80 60 40 20 0 100 80 60 40 20 0ρ=0.0Residual ρ=0.5Residual −3 −1 0 1 2 3 −4 −2 0 1 2 −1.5 −0.5 0.5 1.5ρ=0.9Residual Observation FIGURE 3.10. Plots of residuals from simulated time series data sets generated with diﬀering levels of correlation ρbetween error terms for adjacent time points. 3. Non-constant Variance of Error Terms Another important assumption of the linear regression model is that the error terms have a constant variance, Var( /epsilon1i)=σ2. The standard errors, conﬁdence intervals, and hypothesis tests associated with the linear model rely upon this assumption. Unfortunately, it is often the case that the variances of the error terms are non-constant. For instance, the varia nces of the error terms may increase with the value of the response. One can identify non-constant variances in the errors, or heteroscedasticity , from the presence of a funnel shape inheterosceda- sticity the residual plot. An example is shown in the left-hand panel of Figure 3.11, in which the magnitude of the residuals tends to increase with the ﬁtted values. When faced with this problem, one possible solution is to trans- form the response Yusing a concave function such as log Yor√ Y. Such a transformation results in a greater amount of shrinkage of the larger re- sponses, leading to a reduction in heteroscedasticity. The right-hand panel of Figure 3.11 displays the residual plot after transforming the response 96 3. Linear Regression Fitted valuesResidualsResponse Y 998 975845 10 15 20 25 30−10 −5 0 5 10 15 2.4 2.6 2.8 3.0 3.2 3.4−0.8 −0.6 −0.4 −0.2 0.0 0.2 0.4 Fitted valuesResidualsResponse log(Y) 437671605 FIGURE 3.11. Residual plots. In each plot, the red line is a smooth ﬁt to the residuals, intended to make it easier to identify a trend. The blue lines track the outer quantiles of the residuals, and emphasize patterns. Left:The funnel shape indicates heteroscedasticity. Right:The predictor has been log-transformed, and there is now no evidence of heteroscedasticity. using log Y. The residuals now appear to have constant variance, though there is some evidence of a slight non-linear relationship in the data. Sometimes we have a good idea of the variance of each response. For example, the ith response could be an average of niraw observations. If each of these raw observations is uncorrelated with variance σ2, then their average has variance σ2 i=σ2/ni. In this case a simple remedy is to ﬁt our model by weighted least squares , with weights proportional to the inverseweighted least squares variances—i.e. wi=niin this case. Most linear regression software allows for observation weights. 4. Outliers Anoutlieris a point for which yiis far from the value predicted by theoutliermodel.Outlierscanariseforavarietyo freasons,suchasinc orrectrecording of an observation during data collection. The red point (observation 20) in the left-hand panel of Figure 3.12 illustrates a typical outlier. The red solid line is the least squares regression ﬁt, while the blue dashed line is the least squares ﬁt after removal of the outlier.Inthiscase,removingtheoutlierhaslittleeﬀectontheleastsquares line: it leads to almost no change in the slope, and a miniscule reduction in the intercept. It is typical for an outlier that does not have an unusual predictor value to have little eﬀect on the least squares ﬁt. However, even if an outlier does not have much eﬀect on the least squares ﬁt, it can cause other problems. For instance, in this example, the RSE is 1 .09 when the outlier is included in the regression, but it is only 0 .77 when the outlier is removed. Since the RSE is used to compute all conﬁdence intervals and 3.3 Other Considerations in the Regression Model 97 −2 −1 0 1 2−4 −2 0 2 4 620 − 2 0246− 1 01234 Fitted ValuesResiduals20 − 2 02460246 Fitted ValuesStudentized Residuals20 XY FIGURE 3.12. Left:The least squares regression line is shown in red, and the regression line after removing the outlier is shown in blue. Center:The residual plot clearly identiﬁes the outlier. Right:The outlier has a studentized residual of 6; typically we expect values between −3and3. p-values, such a dramatic increase ca used by a single data point can have implications for the interpretation of the ﬁt. Similarly, inclusion of the outlier causes the R2to decline from 0 .892 to 0.805. Residual plots can be used to identify outliers. In this example, the out- lier is clearly visible in the residual plot illustrated in the center panel of Figure 3.12. But in practice, it can be d iﬃcult to decide how large a resid- ual needs to be before we consider the point to be an outlier. To address this problem, instead of plotting the residuals, we can plot the studentized residuals , computed by dividing each residual eiby its estimated standardstudentized residual error. Observations whose studentized residuals are greater than 3 in abso- lute value are possible outliers. In the right-hand panel of Figure 3.12, the outlier’s studentized residual exceed s 6, while all other observations have studentized residuals between −2a n d2 . If we believe that an outlier has occurred due to an error in data collec- tion or recording, then one solution is to simply remove the observation. However, care should be taken, since an outlier may instead indicate a deﬁciency with the model, such as a missing predictor. 5. High Leverage Points We just saw that outliers are observations for which the response yiis unusual given the predictor xi. In contrast, observations with high leveragehigh leveragehave an unusual value for xi. For example, observation 41 in the left-hand panel of Figure 3.13 has high leverage, in that the predictor value for this observation is large relative to the other observations. (Note that the data displayed in Figure 3.13 are the same as the data displayed in Figure 3.12, but with the addition of a single high leverage observation.) The red solid line is the least squares ﬁt to the data, while the blue dashed line is the ﬁt produced when observation 41 is removed. Comparing the left-hand panels of Figures 3.12 and 3.13,we observethat removing the high leverage observation has a much more substantial impact on the least squares line 98 3. Linear Regression − 2 − 1 0123405 1 02041 −2 −1 0 1 2−2 −1 0 1 2 0.00 0.05 0.10 0.15 0.20 0.25− 1 012345 LeverageStudentized Residuals20 41 XY X1X2 FIGURE 3.13. Left:Observation 41 is a high leverage point, while 20 is not. The red line is the ﬁt to all the data, and the blue line is the ﬁt with observation 41 removed. Center:The red observation is not unusual in terms of its X1value or itsX2value, but still falls outside the bulk of the data, and hence has high leverage. Right:Observation 41has a high leverage and a high residual. than removing the outlier. In fact, high leverage observations tend to have a sizable impact on the estimated regr ession line. It is cause for concern if the least squares line is heavily aﬀect ed by just a couple of observations, because any problems with these points may invalidate the entire ﬁt. For this reason, it is important to identify high leverage observations. In a simple linear regression,high leverageobservations are fairly easy to identify, since we can simply look for observations for which the predictor value is outside of the normal range of the observations. But in a multiple linear regressionwith many predictors , it is possible to have an observation that is well within the range of each individual predictor’s values, but that is unusual in terms of the full set of predictors. An example is shown in the center panel of Figure 3.13, for a data set with two predictors, X1and X2. Most of the observations’ predictor values fall within the blue dashed ellipse, but the red observation is well outside of this range. But neither its value for X1nor its value for X2is unusual. So if we examine just X1or justX2, we will fail to notice this high leveragepoint. This problem is more pronounced in multiple regression settings with more than two predictors, because then there is no simple way to plot all dimensions of the data simultaneously. In order to quantify an observation’s leverage, we compute the leverage statistic. A large value of this statistic indicates an observation with highleverage statistic leverage. For a simple linear regression, hi=1 n+(xi−¯x)2 /summationtextn i/prime=1(xi/prime−¯x)2. (3.37) Itisclearfromthisequationthat hiincreaseswiththedistanceof xifrom ¯x. There is a simple extension of hito the case of multiple predictors, though we do not provide the formula here. The leverage statistic hiis always between 1 /nand 1, and the average leverage for all the observations is always equal to ( p+1)/n. So if a given observation has a leverage statistic 3.3 Other Considerations in the Regression Model 99 LimitAge 2000 4000 6000 8000 1200030 40 50 60 70 80 2000 4000 6000 8000 12000200 400 600 800 LimitRating FIGURE 3.14. Scatterplots of the observations from the Creditdata set. Left: Ap l o to f ageversus limit. These two variables are not collinear. Right:Ap l o t ofratingversus limit. There is high collinearity. that greatly exceeds ( p+1)/n, then we may suspect that the corresponding point has high leverage. The right-hand panel of Figure 3.13 provides a plot of the studentized residuals versus hifor the data in the left-hand panel of Figure 3.13. Ob- servation 41 stands out as having a very high leverage statistic as well as a high studentized residual. In other words, it is an outlier as well as a high leverage observation. This is a particularly dangerous combination! This plot also reveals the reason that observation 20 had relatively little eﬀect on the least squares ﬁt in Figure 3.12: it has low leverage. 6. Collinearity Collinearity refers to the situation in which two or more predictor variablescollinearityare closely related to one another. The concept of collinearity is illustrated in Figure 3.14 using the Creditdata set. In the left-hand panel of Fig- ure 3.14, the two predictors limitand ageappear to have no obvious rela- tionship. In contrast, in the right-hand panel of Figure 3.14, the predictors limitand ratingare very highly correlated with each other, and we say that they are collinear. The presence of collinearity can pose problems in the regression context, since it can be diﬃcult to separate out the indi- vidual eﬀects of collinear variables on the response. In other words, since limitand ratingtend to increase or decrease t ogether,it can be diﬃcult to determine howeachoneseparatel yisassociatedwith the response, balance. Figure3.15illustratessomeofthediﬃcultiesthatcanresultfromcollinear- ity. The left-hand panel of Figure 3.15 is a contour plot of the RSS (3.22) associated with diﬀerent possible coe ﬃcient estimates for the regression ofbalanceonlimitand age. Each ellipse represents a set of coeﬃcients that correspond to the same RSS, with ellipses nearest to the center tak- ing on the lowest values of RSS. The black dots and associated dashed 100 3. Linear Regression 21.25 21.5 21.8 0.16 0.17 0.18 0.19−5 − 4 −3 −2 −1 0 21.5 21.8 −0.1 0.0 0.1 0.2012345 βLimit βLimitβAge βRating FIGURE 3.15. Contour plots for the RSS values as a function of the parameters βfor various regressions involving the Creditdata set. In each plot, the black dots represent the coeﬃcient values corresponding to the minimum RSS. Left: A contour plot of RSS for the regression of balance onto ageand limit.T h e minimum value is well deﬁned. Right:A contour plot of RSS for the regression ofbalance onto ratingand limit. Because of the collinearity, there are many pairs(βLimit,βRating)with a similar value for RSS. lines represent the coeﬃcient estimat es that result in the smallest possible RSS—in other words, these are the least squares estimates. The axes for limitand agehave been scaled so that the plot includes possible coeﬃ- cient estimates that are up to four standard errors on either side of the least squares estimates. Thus the plot includes all plausible values for the coeﬃcients. For example, we see that the true limitcoeﬃcient is almost certainly somewhere between 0 .15 and 0 .20. In contrast, the right-hand panel of Figure 3.15 displays contour plots of the RSS associated with possible coeﬃcient estimates for the regression ofbalanceonto limitand rating, which we know to be highly collinear. Now the contours run along a narrow valley; there is a broad range of values for the coeﬃcient estimates that result in equal values for RSS. Hence a small change in the data could cause the pair of coeﬃcient values that yield the smallest RSS—that is, the least squares estimates—to move anywhere along this valley. This results in a great deal of uncertainty in the coeﬃcientestimates. Not icethatthe scaleforthe limitcoeﬃcientnowruns from roughly −0.2t o0.2; this is an eight-fold increase over the plausible range of the limitcoeﬃcient in the regression with age. Interestingly, even though the limitand ratingcoeﬃcients now have much more individual uncertainty, they will almost certainly lie somewhere in this contour valley. For example, we would not expect the true value of the limitand rating coeﬃcients to be −0.1 and 1 respectively, even though such a value is plausible for each coeﬃcient individually. 3.3 Other Considerations in the Regression Model 101 Coeﬃcient Std. error t-statistic p-value Intercept −173.411 43.828 −3.957<0.0001 Model 1 age −2.292 0.672 −3.407 0 .0007 limit 0.173 0.005 34.496 <0.0001 Intercept −377.537 45.254 −8.343<0.0001 Model 2 rating 2.202 0.952 2.312 0.0213 limit 0.025 0.064 0.384 0.7012 TABLE 3.11. The results for two multiple regression models involving the Creditdata set are shown. Model 1 is a regression of balance onageandlimit, and Model 2 a regression of balance onratingand limit. The standard error ofˆβlimitincreases 12-fold in the second regression, due to collinearity. Since collinearity reduces the accuracy of the estimates of the regression coeﬃcients, it causes the standard error for ˆβjto grow. Recall that the t-statistic for each predictor is calculated by dividing ˆβjby its standard error. Consequently, collinearity results in a decline in the t-statistic. As a result, in the presence of collinearity,we may fail to reject H0:βj=0 .T h i s means that the powerof the hypothesis test—the probability of correctlypower detecting a non-zero coeﬃcient—is reduced by collinearity. Table 3.11comparesthe coeﬃcientest imates obtainedfrom two separate multiple regression models. The ﬁrst is a regression of balanceonageand limit, and the second is a regressionof balanceonratingand limit.I nt h e ﬁrst regression,both ageand limitare highly signiﬁcant with very small p- values. In the second, the collinearity between limitand ratinghas caused the standard error for the limitcoeﬃcient estimate t o increase by a factor of 12 and the p-value to increase to 0 .701. In other words, the importance of the limitvariable has been masked due to the presence of collinearity. To avoid such a situation, it is desirable to identify and address potential collinearity problems while ﬁtting the model. A simple way to detect collinearity is to look at the correlation matrix of the predictors. An element of this matrix that is large in absolute value indicates a pair of highly correlated variables, and therefore a collinearity problem in the data. Unfortunately, not all collinearity problems can be detected by inspection of the correlation matrix: it is possible for collinear- ity to exist between three or more variables even if no pair of variables has a particularly high correlation. We call this situation multicollinearity .multi- collinearity Instead of inspecting the correlation matrix, a better way to assess multi- collinearity is to compute the variance inﬂation factor (VIF). The VIF isvariance inﬂation factorthe ratio of the variance of ˆβjwhen ﬁtting the full model divided by the variance of ˆβjif ﬁt on its own. The smallest possible value for VIF is 1, which indicates the complete absence of collinearity. Typically in practice there is a small amount of collinearity among the predictors. As a rule of thumb, a VIF value that exceeds 5 or 10 indicates a proble matic amount of 102 3. Linear Regression collinearity. The VIF for each variable can be computed using the formula VIF(ˆβj)=1 1−R2 Xj|X−j, whereR2 Xj|X−jis theR2from a regression of Xjonto all of the other predictors. If R2 Xj|X−jis close to one, then collinearity is present, and so the VIF will be large. In the Creditdata, a regression of balanceonage,rating,a n d limit indicates that the predictors have VIF values of 1.01, 160.67, and 160.59. As we suspected, there is considerable collinearity in the data! When faced with the problem of collinearity, there are two simple solu- tions. The ﬁrst is to drop one of the problematic variables from the regres- sion. This can usually be done without much compromise to the regression ﬁt, since the presence of collinearity implies that the information that this variable provides about the response is redundant in the presence of the other variables. For instance, if we regress balance onto ageand limit, without the ratingpredictor, then the resulting VIF values are close to the minimum possible value of 1, and the R2drops from 0 .754 to 0 .75. So dropping ratingfrom the set of predictors has eﬀectively solved the collinearity problem without compromising the ﬁt. The second solution is to combine the collinear variables together into a single predictor. For in- stance, we might take the average of standardized versions of limitand ratingin order to create a new variable that measures credit worthiness . 3.4 The Marketing Plan We now brieﬂy return to the seven questions about the Advertising data that we set out to answer at the beginning of this chapter. 1.Is there a relationship between advertising sales and budget? This question can be answered by ﬁtting a multiple regression model ofsalesonto TV,radio,a n d newspaper , as in (3.20), and testing the hypothesis H0:βTV=βradio=βnewspaper = 0. In Section 3.2.2, we showed that the F-statistic ca n be used to determine whether or not we should reject this null hypothesis. In this case the p-value corresponding to the F-statistic in Table 3.6 is very low, indicating clear evidence of a relationship between advertising and sales. 2.How strong is the relationship? We discussed two measures of model accuracy in Section 3.1.3. First, the RSE estimates the standard deviation of the response from the populationregressionline.For the Advertising data,the RSE is1 ,681 3.4 The Marketing Plan 103 units while the mean value for the response is 14 ,022, indicating a percentage error of roughly 12%. Second, the R2statistic records the percentage of variability in the response that is explained by the predictors. The predictors explain almost 90% of the variance in sales. The RSE and R2statistics are displayed in Table 3.6. 3.Which media contribute to sales? To answer this question, we can exam ine the p-values associated with each predictor’s t-statistic (Section 3.1.2). In the multiple linear re- gression displayed in Table 3.4, the p-values for TVand radioare low, but the p-value for newspaper is not. This suggests that only TVand radioare related to sales. In Chapter 6 we explore this question in greater detail. 4.How large is the eﬀect of each medium on sales? We saw in Section 3.1.2 that the standard error of ˆβjcan be used to construct conﬁdence intervals for βj.F o rt h e Advertising data, the 95% conﬁdence intervals are as follows: (0 .043,0.049) for TV, (0.172,0.206)for radio,a n d(−0.013,0.011)for newspaper . The conﬁ- dence intervals for TVand radioare narrowand far from zero, provid- ing evidence that these media are related to sales.B u tt h ei n t e r v a l fornewspaper includes zero, indicating that the variable is not statis- tically signiﬁcant given the values of TVand radio. We saw in Section 3.3.3 that collinearity can result in very wide stan- dard errors. Could collinearity be the reason that the conﬁdence in- tervalassociatedwith newspaper is so wide? The VIF scoresare1 .005, 1.145, and 1 .145 for TV,radio,a n d newspaper , suggesting no evidence of collinearity. In order to assess the association of each medium individually on sales, we can perform three separat e simple linear regressions. Re- sults are shown in Tables 3.1 and 3.3. There is evidence of an ex- tremely strong association between TVand salesand between radio and sales. There is evidence of a mild association between newspaper and sales, when the values of TVand radioare ignored. 5.How accurately can we predict future sales? The response can be predicted usi ng (3.21). The accuracy associ- ated with this estimate depends on whether we wish to predict an individual response, Y=f(X)+/epsilon1, or the average response, f(X) (Section 3.2.2). If the former, we use a prediction interval, and if the latter, we use a conﬁdence interval. Prediction intervals will always be wider than conﬁdence intervals because they account for the un- certainty associated with /epsilon1, the irreducible error. 104 3. Linear Regression 6.Is the relationship linear? In Section 3.3.3, we saw that residual plots can be used in order to identify non-linearity. If the relationships are linear, then the residual plots should display no pattern. In the case of the Advertising data, we observe a non-linear eﬀect in Figure 3.5, though this eﬀect could also be observed in a residual plot. In Section 3.3.2, we discussed the inclusion of transformations of the predictors in the linear regression model in order to accommodate non-linear relationships. 7.Is there synergy among the advertising media? The standard linear regression model assumes an additive relation- ship between the predictors and the response. An additive model is easytointerpretbecausetheeﬀectof eachpredictorontheresponseis unrelated to the values of the other predictors. However, the additive assumption may be unrealistic for certain data sets. In Section 3.3.3, we showed how to include an interaction term in the regressionmodel in order to accommodate non-additive relationships. A small p-value associated with the interaction te rm indicates the presence of such relationships. Figure 3.5 suggested that the Advertising data may not be additive. Including an interaction term in the model results in a substantial increase in R2, from around 90% to almost 97%. 3.5 Comparison of Linear Regression withK-Nearest Neighbors As discussed in Chapter 2, linear regression is an example of a parametric approach because it assumes a linear functional form for f(X). Parametric methods have several advantages. They are often easy to ﬁt, because one need estimate only a small number of coeﬃcients. In the case of linear re- gression, the coeﬃcients have simple inte rpretations,and tests of statistical signiﬁcance can be easily performed. But parametric methods do have a disadvantage: by construction, they make strong assumptions about the form off(X). If the speciﬁed functional form is far from the truth, and prediction accuracy is our goal, then the parametric method will perform poorly. For instance, if we assume a linear relationship between XandY but the true relationship is far from linear, then the resulting model will provide a poor ﬁt to the data, and any conclusions drawn from it will be suspect. In contrast, non-parametric methods do not explicitly assume a para- metric form for f(X), and thereby provide an alternative and more ﬂexi- ble approach for performing regression. We discuss various non-parametric methods in this book. Here we consider one of the simplest and best-known non-parametricmethods, K-nearest neighbors regression (KNNregression).K-nearest neighbors regression 3.5 Comparison of Linear Regression with K-Nearest Neighbors 105 y y x1 x1x2x2 FIGURE 3.16. Plots of ˆf(X)using KNN regression on a two-dimensional data set with 64observations (orange dots). Left:K=1results in a rough step func- tion ﬁt.Right:K=9produces a much smoother ﬁt. The KNN regression method is closely related to the KNN classiﬁer dis- cussed in Chapter 2. Given a value for Kand a prediction point x0,K N N regression ﬁrst identiﬁes the Ktraining observations that are closest to x0, represented by N0.I tt h e ne s t i m a t e s f(x0) using the average of all the training responses in N0.I no t h e rw o r d s , ˆf(x0)=1 K/summationdisplay xi∈N 0yi. Figure 3.16 illustrates two KNN ﬁts on a data set with p= 2 predictors. The ﬁt with K= 1 is shown in the left-hand panel, while the right-hand panelcorrespondsto K= 9.Weseethatwhen K= 1,theKNNﬁtperfectly interpolates the training observations, and consequently takes the form of a step function. When K= 9, the KNN ﬁt still is a step function, but averagingovernine observationsresultsin much smallerregionsofconstant prediction, and consequently a smoother ﬁt. In general, the optimal value forKwill depend on the bias-variance tradeoﬀ , which we introduced in Chapter 2. A small value for Kprovides the most ﬂexible ﬁt, which will have low bias but high variance. This variance is due to the fact that the prediction in a given region is entirely dependent on just one observation. In contrast, larger values of Kprovide a smoother and less variable ﬁt; the prediction in a region is an average of several points, and so changing one observation has a smaller eﬀect. However,the smoothing may cause bias by masking some of the structure in f(X). In Chapter 5, we introduce several approaches for estimating test error rates. These methods can be used to identify the optimal value of Kin KNN regression. 106 3. Linear Regression Inwhatsetting willaparametricapproachsuchasleastsquareslinearre- gression outperform a non-parametric approach such as KNN regression? The answer is simple: the parametric approach will outperform the non- parametric approach if the parametric form that has been selected is close to the true form of f. Figure 3.17 provides an example with data generated from a one-dimensional linear regression model. The black solid lines rep- resentf(X), while the blue curves correspond to the KNN ﬁts using K=1 andK=9 .I nt h i sc a s e ,t h e K= 1 predictions are far too variable, while the smoother K= 9 ﬁt is much closer to f(X). However, since the true relationship is linear, it is hard for a non-parametric approach to compete with linear regression: a non-parametric approach incurs a cost in variance that is not oﬀset by a reduction in bias. The blue dashed line in the left- hand panel of Figure 3.18 represents the linear regression ﬁt to the same data. It is almost perfect. The right-hand panel of Figure 3.18 reveals that linear regression outperforms KNN for t his data. The green solid line, plot- ted as a function of 1 /K, represents the test set mean squared error (MSE) for KNN. The KNN errors are well above the black dashed line, which is the test MSE for linear regression. When the value of Kis large, then KNN performs only a little worse than least squares regression in terms of MSE. It performs far worse when Kis small. In practice, the true relationship between XandYis rarely exactly lin- ear. Figure 3.19 examines the relative performances of least squares regres- sion and KNN under increasing levels of non-linearity in the relationship between XandY. In the top row, the true relationship is nearly linear. In this case we see that the test MSE for linear regression is still superior to that of KNN for low values of K. However, for K≥4, KNN out- performs linear regression. The second row illustrates a more substantial deviation from linearity. In this situation, KNN substantially outperforms linear regressionfor all values of K. Note that as the extent of non-linearity increases, there is little change in the test set MSE for the non-parametric KNN method, but there is a large increase in the test set MSE of linear regression. Figures 3.18 and 3.19 display situations in which KNN performs slightly worsethanlinearregressionwhenther elationshipislinear,butmuchbetter than linear regression for non-linear situations. In a real life situation in which the truerelationship isunknown, one might drawthe conclusionthat KNN should be favored over linear regression because it will at worst be slightly inferior than linear regression if the true relationship is linear, and may give substantially better results if the true relationship is non-linear. But in reality, even when the true relat ionship is highly non-linear, KNN may still provide inferior results to linear regression. In particular, both Figures 3.18 and 3.19 illustrate settings with p= 1 predictor. But in higher dimensions, KNN often performs worse than linear regression. Figure 3.20 considers the same strongly non-linear situation as in the second row of Figure 3.19, except that we have added additional noise 3.5 Comparison of Linear Regression with K-Nearest Neighbors 107 −1.0 −0.5 0.0 0.5 1.0 −1.0 −0.5 0.0 0.5 1.01234 1234yy x x FIGURE 3.17. Plots of ˆf(X)using KNN regression on a one-dimensional data set with 100observations. The true relationship is given by the black solid line. Left:T h eb l u ec u r v ec o r r e s p o n d st o K=1and interpolates (i.e. passes directly through) the training data. Right:The blue curve corresponds to K=9,a n d represents a smoother ﬁt. −1.0 −0.5 0.0 0.5 1.01234 0.2 0.5 1.00.00 0.05 0.10 0.15Mean Squared Errory x 1/K FIGURE 3.18. The same data set shown in Figure 3.17 is investigated further. Left:The blue dashed line is the least squares ﬁt to the data. Since f(X)is in fact linear (displayed as the black line), the least squares regression line provides a very good estimate of f(X).Right:The dashed horizontal line represents the least squares test set MSE, while the green solid line corresponds to the MSE for KNN as a function of 1/K(on the log scale). Linear regression achieves a lower test MSE than does KNN regression, since f(X)is in fact linear. For KNN regression, the best results occur with a very large value of K, corresponding to a small value of 1/K. 108 3. Linear Regression −1.0 −0.5 0.0 0.5 1.0 0.2 0.5 1.0 Mean Squared Error −1.0 −0.5 0.0 0.5 1.0 0.2 0.5 1.00.5 1.0 1.5 2.0 2.5 3.0 3.5 0.00 0.02 0.04 0.06 0.081.0 1.5 2.0 2.5 3.0 3.5 0.00 0.05 0.10 0.15Mean Squared Erroryy xx 1/K1/K FIGURE 3.19. Top Left: In a setting with a slightly non-linear relationship between XandY(solid black line), the KNN ﬁts with K=1(blue) and K=9 (red) are displayed. Top Right: For the slightly non-linear data, the test set MSE for least squares regression (horizontal black) and KNNwith various values of 1/K(green) are displayed. Bottom Left and Bottom Right: As in the top panel, but with a strongly non-linear relationship between XandY. predictors that are not associ ated with the response. When p=1o rp=2 , KNN outperforms linear regression. But for p= 3 the results are mixed, and forp≥4 linear regression is superior to KNN. In fact, the increase in dimension has only causeda small deteriorationin the linearregressiontest set MSE, but it has caused more than a ten-fold increase in the MSE for KNN. Thisdecreaseinperformanceasthedimensionincreasesisacommon problem for KNN, and results from the fact that in higher dimensions there is eﬀectively a reduction in sa mple size. In this data set there are 100 training observations; when p= 1, this provides enough information to accuratelyestimate f(X).However,spreading100observationsover p=2 0 dimensions results in a phenomenon in which a given observation has no nearby neighbors —this is the so-called curse of dimensionality .T h a ti s ,curse of di- mensionality theKobservations that are nearest to a given test observation x0may be very far away from x0inp-dimensional space when pis large, leading to a 3.6 Lab: Linear Regression 1090.0 0.2 0.4 0.6 0.8 1.0p=1 p=2 p=3 p=4 p=10 0.2 0.5 1.0 0.2 0.5 1.0 0.2 0.5 1.0 0.2 0.5 1.0 0.2 0.5 1.0 0.2 0.5 1.00.0 0.2 0.4 0.6 0.8 1.0 0.0 0.2 0.4 0.6 0.8 1.0 0.0 0.2 0.4 0.6 0.8 1.0 0.0 0.2 0.4 0.6 0.8 1.0 0.0 0.2 0.4 0.6 0.8 1.0p=20Mean Squared Error 1/K FIGURE 3.20. Test MSE for linear regression (black dashed lines) and KNN (green curves) as the number of variables pincreases. The true function is non– linear in the ﬁrst variable, as in the lower panel in Figure 3.19, and does not depend on the additional variables. The performance of linear regression deteri- orates slowly in the presence of these additional noise variables, whereas KNN’s performance degrades much more quickly as pincreases. very poor prediction of f(x0) and hence a poor KNN ﬁt. As a general rule, parametric methods will tend to outperform non-parametric approaches when there is a small number of o bservations per predictor. Even in problems in which the dimension is small, we might prefer linear regression to KNN from an interpretability standpoint. If the test MSE of KNN is only slightly lower than that of linear regression, we might be willing to forego a little bit of prediction accuracy for the sake of a simple model that can be described in terms of just a few coeﬃcients, and for which p-values are available. 3.6 Lab: Linear Regression 3.6.1 Libraries The library() function is used to load libraries, or groups of functions andlibrary()data sets that are not included in the base Rdistribution. Basic functions that performleast squareslinear regressionand other simple analyses come standard with the base distribution, but more exotic functions require ad- ditional libraries. Here we load the MASSpackage, which is a very large collection of data sets and functions. We also load the ISLRpackage, which includes the data sets associated with this book. > library(MASS) > library(ISLR) If you receive an error message when l oading any of these libraries, it likely indicates that the corresponding library has not yet been installed onyoursystem.Somelibraries,suchas MASS,comewith Randdonotneedto be separately installed on your computer. However,other packages,such as 110 3. Linear Regression ISLR, must be downloadedthe ﬁrst time they are used. This can be done di- rectly from within R. For example, on a Windows system, select the Install packageoption under the Packages tab. After you select any mirror site, a list of available packages will appear. Simply select the package you wish to install and Rwill automatically download the package. Alternatively, this can be done at the Rcommand line via install.packages(\"ISLR\") . This in- stallation only needs to be done the ﬁrst time you use a package. However, the library() function must be called each time you wish to use a given package. 3.6.2 Simple Linear Regression The MASSlibrary contains the Bostondata set, which records medv(median house value) for 506 neighborhoods around Boston. We will seek to predict medvusing 13 predictors such as rm(average number of rooms per house), age(average age of houses), and lstat(percent of households with low socioeconomic status). > fix(Boston) > names(Boston) [1] \"crim\" \"zn\" \"indus\" \"chas\" \"nox\" \"rm\" \"age\" [8] \"dis\" \"rad\" \"tax\" \"ptratio\" \"black\" \"lstat\" \"medv\" To ﬁnd out more about the data set, we can type ?Boston. We will start by using the lm()function to ﬁt a simple linear regressionlm()model, with medvas the response and lstatas the predictor. The basic syntax is lm(y∼x,data),w h e r e yis the response, xis the predictor, and datais the data set in which these two variables are kept. > lm.fit=lm(medv ∼lstat) Error in eval( expr, envir , enclos) : Object \"medv\" not found The command causes an error because Rdoes not know where to ﬁnd the variables medvand lstat. The next line tells Rthat the variables are inBoston. If we attach Boston, the ﬁrst line works ﬁne because Rnow recognizes the variables. > lm.fit=lm(medv ∼lstat , data=Boston) > attach(Boston) > lm.fit=lm(medv ∼lstat) If we type lm.fit, some basic information about the model is output. For more detailed information, we use summary(lm.fit) . This gives us p- values and standard errors for the coeﬃcients, as well as the R2statistic and F-statistic for the model. >l m . f i t Call: lm(formula = medv ∼lstat) 3.6 Lab: Linear Regression 111 Coefficients: (Intercept ) lstat 34.55 -0.95 > summary(lm.fit) Call: lm(formula = medv ∼lstat) Residuals : Min 1Q Median 3Q Max -15.17 -3.99 -1.32 2.03 24.50 Coefficients: Estimate Std. Error t value Pr(>|t|) (Intercept ) 34.5538 0.5626 61.4 <2e-16 *** lstat -0.9500 0.0387 -24.5 <2e-16 *** --- Signif. codes: 0 *** 0.001 ** 0.01 * 0.05 . 0.1 1 Residual standard error: 6.22 on 504 degrees of freedom Multiple R-squared: 0.544, Adjusted R-squared: 0.543 F-statistic : 602 on 1 and 504 DF, p-value: <2e-16 We can use the names()function in order to ﬁnd out what other piecesnames()of information are stored in lm.fit. Although we can extract these quan- tities by name—e.g. lm.fit$coefficients —it is safer to use the extractor functions like coef()to access them.coef() > names(lm.fit) [1] \"coefficients\" \" residuals \" \"effects\" [4] \"rank\" \"fitted.values\" \"assign\" [7] \"qr\" \"df.residual\" \"xlevels\" [10] \"call\" \"terms\" \"model\" > coef(lm.fit) (Intercept ) lstat 34.55 -0.95 In order to obtain a conﬁdence interval for the coeﬃcient estimates, we can use the confint() command.confint() > confint(lm.fit) 2.5 % 97.5 % (Intercept ) 33.45 35.659 lstat -1.03 -0.874 The predict() function can be used to produce conﬁdence intervals andpredict()prediction intervals for the prediction of medvfor a given value of lstat. > predict(lm.fit,data.frame(lstat=(c(5,10 ,15))), interval =\"confidence \") fit lwr upr 1 29.80 29.01 30.60 2 25.05 24.47 25.63 3 20.30 19.73 20.87 112 3. Linear Regression > predict(lm.fit,data.frame(lstat=(c(5,10 ,15))), interval =\"prediction \") fit lwr upr 1 29.80 17.566 42.04 2 25.05 12.828 37.28 3 20.30 8.078 32.53 For instance, the 95% conﬁdence interval associated with a lstatvalue of 10 is (24 .47,25.63), and the 95% prediction interval is (12 .828,37.28). As expected, the conﬁdence and prediction intervals are centered around the same point (a predicted value of 25 .05 for medvwhen lstatequals 10), but the latter are substantially wider. We will now plot medvand lstatalong with the least squares regression line using the plot()and abline() functions.abline() > plot(lstat , medv) > abline(lm.fit) There is some evidence for non-linearity in the relationship between lstat and medv. We will explore this issue later in this lab. The abline() function can be used to draw any line, not just the least squares regression line. To draw a line with intercept aand slope b,w e type abline(a,b) . Below we experiment with some additional settings for plotting lines and points. The lwd=3command causes the width of the regression line to be increased by a factor of 3; this works for the plot() and lines()functionsalso.Wecanalsousethe pchoptiontocreatediﬀerent plotting symbols. > abline(lm.fit,lwd=3) > abline(lm.fit,lwd=3,col=\"red\") > plot(lstat ,medv ,col=\"red\") > plot(lstat ,medv ,pch =20) > plot(lstat ,medv ,pch =\"+\") > plot(1:20,1:20,pch=1:20) Next we examine some diagnostic plots, several of which were discussed in Section 3.3.3. Four diagnostic plots are automatically produced by ap- plying the plot()function directly to the output from lm(). In general, this command will produce one plot at a time, and hitting Enterwill generate the next plot. However,it is often convenientto view all fourplots together. We can achieve this by using the par()function, which tells Rto split thepar()display screen into separate panels so that multiple plots can be viewed si- multaneously. For example, par(mfrow=c(2,2)) divides the plotting region into a 2×2g r i do fp a n e l s . > par(mfrow=c(2,2)) > plot(lm.fit) Alternatively, we can compute the residuals from a linear regression ﬁt using the residuals() function. The function rstudent() will return theresiduals() rstudent()studentized residuals, and we can use this function to plot the residuals against the ﬁtted values. 3.6 Lab: Linear Regression 113 > plot(predict(lm.fit), residuals (lm.fit)) > plot(predict(lm.fit), rstudent(lm.fit)) On the basis of the residual plots, there is some evidence of non-linearity. Leverage statistics can be computed fo r any number of predictors using the hatvalues() function.hatvalues() > plot(hatvalues (lm.fit)) > which.max(hatvalues (lm.fit)) 375 The which.max() function identiﬁes the index of the largest element of awhich.max()vector. In this case, it tells us which o bservation has the largest leverage statistic. 3.6.3 Multiple Linear Regression In order to ﬁt a multiple linear regression model using least squares, we again use the lm()function. The syntax lm(y∼x1+x2+x3) is used to ﬁt a model with three predictors, x1,x2,a n d x3.T h e summary() function now outputs the regression coeﬃci ents for all the predictors. > lm.fit=lm(medv ∼lstat+age,data=Boston) > summary(lm.fit) Call: lm(formula = medv ∼lstat + age, data = Boston) Residuals : Min 1Q Median 3Q Max -15.98 -3.98 -1.28 1.97 23.16 Coefficients: Estimate Std. Error t value Pr(>|t|) (Intercept ) 33.2228 0.7308 45.46 <2e-16 *** lstat -1.0321 0.0482 -21.42 <2e-16 *** age 0.0345 0.0122 2.83 0.0049 ** --- Signif. codes: 0 *** 0.001 ** 0.01 * 0.05 . 0.1 1 Residual standard error: 6.17 on 503 degrees of freedom Multiple R-squared: 0.551, Adjusted R-squared: 0.549 F-statistic : 309 on 2 and 503 DF, p-value: <2e-16 The Bostondata set contains 13 variables, and so it would be cumbersome to have to type all of these in order to perform a regression using all of the predictors. Instead, we can use the following short-hand: > lm.fit=lm(medv ∼.,data=Boston) > summary(lm.fit) Call: lm(formula = medv ∼., data = Boston) 114 3. Linear Regression Residuals : Min 1Q Median 3Q Max -15.594 -2.730 -0.518 1.777 26.199 Coefficients: Estimate Std. Error t value Pr(>|t|) (Intercept ) 3.646e+01 5.103e+00 7.144 3.28e-12 *** crim -1.080e-01 3.286e-02 - 3.287 0.001087 ** zn 4.642e-02 1.373e-02 3.382 0.000778 *** indus 2.056e-02 6.150e-02 0.334 0.738288 chas 2.687e+00 8.616e-01 3.118 0.001925 ** nox -1.777e+01 3.820e+00 - 4.651 4.25e-06 *** rm 3.810e+00 4.179e-01 9.116 < 2e-16 *** age 6.922e-04 1.321e-02 0.052 0.958229 dis -1.476e+00 1.995e-01 - 7.398 6.01e-13 *** rad 3.060e-01 6.635e-02 4.613 5.07e-06 *** tax -1.233e-02 3.761e-03 - 3.280 0.001112 ** ptratio -9.527e-01 1.308e-01 - 7.283 1.31e-12 *** black 9.312e-03 2.686e-03 3.467 0.000573 *** lstat -5.248e-01 5.072e-02 -1 0.347 < 2e-16 *** --- Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 Residual standard error: 4.745 on 492 degrees of freedom Multiple R-Squared: 0.7406, Adjusted R-squared: 0.7338 F-statistic : 108.1 on 13 and 492 DF, p-value: < 2.2e-16 We can access the individual components of a summary object by name (type ?summary.lm to see what is available). Hence summary(lm.fit)$r.sq gives us the R2,a n d summary(lm.fit)$sigma gives us the RSE. The vif()vif()function, part of the carpackage,can be used to compute varianceinﬂation factors. Most VIF’s are low to moderate for this data. The carpackage is not part of the base Rinstallation so it must be downloaded the ﬁrst time you use it via the install.packages option in R. > library(car) > vif(lm.fit) crim zn indus chas nox rm age 1.79 2.30 3.99 1.07 4.39 1.93 3.10 dis rad tax ptratio black lstat 3.96 7.48 9.01 1.80 1.35 2.94 What if we would like to perform a regression using all of the variables but one? For example, in the above regression output, agehas a high p-value. So we may wish to run a regression excluding this predictor. The following syntax results in a regression using all predictors except age. > lm.fit1=lm(medv ∼.-age,data=Boston) > summary(lm.fit1) ... Alternatively, the update() function can be used.update() 3.6 Lab: Linear Regression 115 > lm.fit1=update(lm.fit, ∼.-age) 3.6.4 Interaction Terms It is easy to include interaction terms in a linear model using the lm()func- tion. The syntax lstat:black tells Rto include an interaction term between lstatand black.T h es y n t a x lstat*age simultaneously includes lstat,age, and the interaction term lstat×ageas predictors; it is a shorthand for lstat+age+lstat:age . > summary(lm(medv ∼lstat*age,data=Boston)) Call: lm(formula = medv ∼lstat * age, data = Boston) Residuals : Min 1Q Median 3Q Max -15.81 -4.04 -1.33 2.08 27.55 Coefficients: Estimate Std. Error t value Pr(>|t|) (Intercept ) 36.088536 1.469835 24.55 < 2e-16 *** lstat -1.392117 0.167456 -8.31 8.8e-16 *** age -0.000721 0.019879 -0.04 0.971 lstat:age 0.004156 0.001852 2.24 0.025 * --- Signif. codes: 0 ’***’ 0.001 ’**’ 0.01 ’*’ 0.05 ’.’ 0.1 ’ ’ 1 Residual standard error: 6.15 on 502 degrees of freedom Multiple R-squared: 0.556, Adjusted R-squared: 0.553 F-statistic : 209 on 3 and 502 DF, p-value: <2e-16 3.6.5 Non-linear Transformations of the Predictors The lm()function can also accommodate non-linear transformations of the predictors. For instance, given a predictor X, we can create a predictor X2 using I(X^2). The function I()is needed since the ^has a special meaningI()in a formula; wrapping as we do allows the standard usage in R,w h i c hi s to raise Xto the power 2. We now perform a regression of medvonto lstat and lstat2. > lm.fit2=lm(medv ∼lstat+I(lstat^2)) > summary(lm.fit2) Call: lm(formula = medv ∼lstat + I(lstat^2)) Residuals : Min 1Q Median 3Q Max -15.28 -3.83 -0.53 2.31 25.41 116 3. Linear Regression Coefficients: Estimate Std. Error t value Pr(>|t|) (Intercept ) 42.86201 0.87208 49.1 <2e-16 *** lstat -2.33282 0.12380 -18.8 <2e-16 *** I(lstat^2) 0.04355 0.00375 11.6 <2e-16 *** --- Signif. codes: 0 ’***’ 0.001 ’**’ 0.01 ’*’ 0.05 ’.’ 0.1 ’ ’ 1 Residual standard error: 5.52 on 503 degrees of freedom Multiple R-squared: 0.641, Adjusted R-squared: 0.639 F-statistic : 449 on 2 and 503 DF, p-value: <2e-16 The near-zero p-value associated with the quadratic term suggests that it leads to an improved model. We use the anova() function to furtheranova()quantify the extent to which the quadratic ﬁt is superior to the linear ﬁt. > lm.fit=lm(medv ∼lstat) > anova(lm.fit,lm.fit2) Analysis of Variance Table Model 1: medv ∼lstat Model 2: medv ∼lstat + I(lstat^2) Res.Df RSS Df Sum of Sq F Pr(>F) 1 504 19472 2 503 15347 1 4125 135 <2e-16 *** --- Signif. codes: 0 ’***’ 0.001 ’**’ 0.01 ’*’ 0.05 ’.’ 0.1 ’ ’ 1 Here Model 1 represents the linear submodel containing only one predictor, lstat,whileModel2correspondstothelargerquadraticmodelthathastwo predictors, lstatand lstat2.T h e anova()function performs a hypothesis test comparing the two models. The null hypothesis is that the two models ﬁt the data equally well, and the alternative hypothesis is that the full model is superior. Here the F-statistic is 135 and the associated p-value is virtually zero. This provides very clear evidence that the model containing the predictors lstatand lstat2is far superior to the model that only contains the predictor lstat. This is not surprising, since earlier we saw evidence for non-linearity in the relationship between medvand lstat.I fw e type > par(mfrow=c(2,2)) > plot(lm.fit2) then we see that when the lstat2term is included in the model, there is little discernible pattern in the residuals. In order to create a cubic ﬁt, we can include a predictor of the form I(X^3). However, this approach can star t to get cumbersome for higher- order polynomials. A better approach involves using the poly()functionpoly()to create the polynomial within lm(). For example, the following command produces a ﬁfth-order polynomial ﬁt: 3.6 Lab: Linear Regression 117 > lm.fit5=lm(medv ∼poly(lstat ,5)) > summary(lm.fit5) Call: lm(formula = medv ∼poly(lstat , 5)) Residuals : Min 1Q Median 3Q Max -13.543 -3.104 -0.705 2.084 27.115 Coefficients: Estimate Std. Error t value Pr(>|t|) (Intercept ) 22.533 0.232 97.20 < 2e-16 *** poly(lstat , 5)1 -152.460 5.215 - 29.24 < 2e-16 *** poly(lstat , 5)2 64.227 5.215 12.32 < 2e-16 *** poly(lstat , 5)3 -27.051 5.215 -5.19 3.1e-07 *** poly(lstat , 5)4 25.452 5.215 4.88 1.4e-06 *** poly(lstat , 5)5 -19.252 5.215 -3.69 0.00025 *** --- Signif. codes: 0 ’***’ 0.001 ’**’ 0.01 ’*’ 0.05 ’.’ 0.1 ’ ’ 1 Residual standard error: 5.21 on 500 degrees of freedom Multiple R-squared: 0.682, Adjusted R-squared: 0.679 F-statistic : 214 on 5 and 500 DF, p-value: <2e-16 This suggests that including additional polynomial terms, up to ﬁfth order, leads to an improvement in the model ﬁt! However, further investigation of the data reveals that no polynomial terms beyond ﬁfth order have signiﬁ- cant p-values in a regression ﬁt. Of course, we are in no way restricted to using polynomial transforma- tions of the predictors. Here we try a log transformation. > summary(lm(medv ∼log(rm),data=Boston)) ... 3.6.6 Qualitative Predictors We will now examine the Carseats data, which is part of the ISLRlibrary. We will attempt to predict Sales(child car seat sales) in 400 locations based on a number of predictors. > fix(Carseats) > names(Carseats) [1] \"Sales\" \"CompPrice \" \"Income\" \"Advertising \" [5] \"Population \" \"Price\" \"ShelveLoc \" \"Age\" [9] \"Education \" \"Urban\" \"US\" The Carseats data includes qualitative predictors such as Shelveloc ,a ni n - dicator of the quality of the shelving location—that is, the space within a store in which the car seat is displayed—at each location. The pre- dictor Shelveloc takes on three possible values, Bad,Medium,a n dGood. 118 3. Linear Regression Givenaqualitativevariablesuchas Shelveloc ,Rgeneratesdummyvariables automatically. Below we ﬁt a multiple regression model that includes some interaction terms. > lm.fit=lm(Sales ∼.+Income:Advertising +Price:Age,data=Carseats) > summary(lm.fit) Call: lm(formula = Sales ∼. + Income:Advertising + Price:Age, data = Carseats) Residuals : Min 1Q Median 3Q Max -2.921 -0.750 0.018 0.675 3.341 Coefficients: Estimate Std. Error t value Pr(>|t|) (Intercept ) 6.575565 1.008747 6.52 2.2e-10 *** CompPrice 0.092937 0.004118 22.57 < 2e-16 *** Income 0.010894 0.002604 4.18 3.6e-05 *** Advertising 0.070246 0.022609 3.11 0.00203 ** Population 0.000159 0.000368 0.43 0.66533 Price -0.100806 0.007440 -13.55 < 2e-16 *** ShelveLocGood 4.848676 0.152838 31.72 < 2e-16 *** ShelveLocMedium 1.953262 0.125768 15.53 < 2e-16 *** Age -0.057947 0.015951 -3.63 0.00032 *** Education -0.020852 0.019613 -1.06 0.28836 UrbanYes 0.140160 0.112402 1.25 0.21317 USYes -0.157557 0.148923 -1.06 0.29073 Income:Advertising 0.000751 0.000278 2.70 0.00729 ** Price:Age 0.000107 0.000133 0.80 0.42381 --- Signif. codes: 0 ’***’ 0.001 ’**’ 0.01 ’*’ 0.05 ’.’ 0.1 ’ ’ 1 Residual standard error: 1.01 on 386 degrees of freedom Multiple R-squared: 0.876, Adjusted R-squared: 0.872 F-statistic : 210 on 13 and 386 DF, p-value: <2e-16 The contrasts() function returns the coding that Ruses for the dummycontrasts()variables. > attach(Carseats) > contrasts (ShelveLoc ) Good Medium Bad 0 0 Good 1 0 Medium 0 1 Use ?contrasts to learn about other contrasts, and how to set them. Rhas created a ShelveLocGood dummy variable that takes on a value of 1 if the shelving location is good, a nd 0 otherwise. It has also created a ShelveLocMedium dummy variable that equals 1 if the shelving location is medium, and 0 otherwise. A bad shelving location corresponds to a zero for each of the two dummy variables. The fact that the coeﬃcient for 3.6 Lab: Linear Regression 119 ShelveLocGood in the regression output is positive indicates that a good shelving location is associated with high sales (relative to a bad location). And ShelveLocMedium has a smaller positive coeﬃcient, indicating that a medium shelving location leads to higher sales than a bad shelving location but lower sales than a good shelving location. 3.6.7 Writing Functions As we have seen, Rcomes with many useful functions, and still more func- tions are available by way of Rlibraries. However, we will often be inter- ested in performing an operation for which no function is available. In this setting, we may want to write our own function. For instance, below we provide a simple function that reads in the ISLRand MASSlibraries, called LoadLibraries() . Before we have created the function, Rreturns an error if we try to call it. > LoadLibraries Error: object ’LoadLibraries ’ not found > LoadLibraries() Error: could not find function \" LoadLibraries\" We now create the function. Note that the +symbols are printed by Rand should not be typed in. The {symbol informs Rthat multiple commands are about to be input. Hitting Enterafter typing {will cause Rto print the +symbol. We can then input as many commands as we wish, hitting Enter after each one. Finally the }symbol informs Rthat no further commands will be entered. > LoadLibraries= function (){ + library(ISLR) + library(MASS) + print(\"The libraries have been loaded.\") +} Now if we type in LoadLibraries ,Rwill tell us what is in the function. > LoadLibraries function (){ library(ISLR) library(MASS) print(\"The libraries have been loaded.\") } If we call the function, the libraries are loaded in and the print statement is output. > LoadLibraries() [1] \"The libraries have been loaded.\" 120 3. Linear Regression 3.7 Exercises Conceptual 1. Describe the null hypotheses to which the p-values given in Table 3.4 correspond. Explain what conclusions you can draw based on these p-values. Your explanation should be phrased in terms of sales,TV, radio,a n d newspaper , rather than in terms of the coeﬃcients of the linear model. 2. CarefullyexplainthediﬀerencesbetweentheKNNclassiﬁerandKNN regression methods. 3. Supposewehaveadatasetwith ﬁvepredictors, X1=GP A ,X2=I Q , X3=Gender(1forFemaleand0forMale), X4=Interactionbetween GPA and IQ, and X5= Interaction between GPA and Gender. The response is starting salary after graduation (in thousands of dollars). Suppose we use least squares to ﬁt the model, and get ˆβ0=5 0,ˆβ1= 20,ˆβ2=0.07,ˆβ3=3 5,ˆβ4=0.01,ˆβ5=−10. (a) Which answer is correct, and why? i. ForaﬁxedvalueofIQandGPA,malesearnmoreonaverage than females. ii. For a ﬁxed value of IQ and GPA, females earn more on average than males. iii. ForaﬁxedvalueofIQandGPA,malesearnmoreonaverage than females provided that the GPA is high enough. iv. For a ﬁxed value of IQ and GPA, females earn more on average than males provided that the GPA is high enough. (b) Predict the salary of a female with IQ of 110 and a GPA of 4 .0. (c) True or false: Since the coeﬃcient for the GPA/IQ interaction term is very small, there is very little evidence of an interaction eﬀect. Justify your answer. 4. I collect a set of data ( n= 100 observations) containing a single predictor and a quantitative response. I then ﬁt a linear regression model to the data, as well as a separate cubic regression, i.e. Y= β0+β1X+β2X2+β3X3+/epsilon1. (a) Suppose that the true relationship between X and Y is linear, i.e.Y=β0+β1X+/epsilon1. Consider the training residual sum of squares (RSS) for the linear regression, and also the training RSS for the cubic regression. Would we expect one to be lower than the other, would we expect them to be the same, or is there not enough information to tell? Justify your answer. 3.7 Exercises 121 (b) Answer (a) using test rather than training RSS. (c) SupposethatthetruerelationshipbetweenXandYisnotlinear, butwedon’tknowhowfaritisfromlinear.Considerthetraining RSS for the linear regression, and also the training RSS for the cubic regression. Would we expect one to be lower than the other, would we expect them to be the same, or is there not enough information to tell? Justify your answer. (d) Answer (c) using test rather than training RSS. 5. Consider the ﬁtted values that res ult from performing linear regres- sion without an intercept. In this setting, the ith ﬁtted value takes the form ˆyi=xiˆβ, where ˆβ=/parenleftBiggn/summationdisplay i=1xiyi/parenrightBigg //parenleftBiggn/summationdisplay i/prime=1x2 i/prime/parenrightBigg . (3.38) Show that we can write ˆyi=n/summationdisplay i/prime=1ai/primeyi/prime. What is ai/prime? Note: We interpret this result by saying that the ﬁtted values from linear regression are linear combinations of the response values. 6. Using (3.4), argue that in the case of simple linear regression, the least squares line always passes through the point (¯ x,¯y). 7. It is claimed in the text that in the case of simple linear regression ofYontoX,t h eR2statistic (3.17) is equal to the square of the correlation between XandY(3.18). Prove that this is the case. For simplicity, you may assume that ¯ x=¯y=0 . Applied 8. This question involves the use of simple linear regression on the Auto data set. (a) Use the lm()function to perform a simple linear regression with mpgas the response and horsepower as the predictor. Use the summary() function to print the results. Comment on the output. For example: 122 3. Linear Regression i. Is there a relationship between the predictor and the re- sponse? ii. How strong is the relationship between the predictor and the response? iii. Is the relationship between the predictor and the response positive or negative? iv. What is the predicted mpgassociated with a horsepower of 98? What are the associated 95% conﬁdence and prediction intervals? (b) Plot the response and the predictor. Use the abline() function to display the least squares regression line. (c) Use the plot()function to produce diagnostic plots of the least squares regression ﬁt. Comment on any problems you see with the ﬁt. 9. This question involves the use of multiple linear regression on the Autodata set. (a) Produce a scatterplot matrix which includes all of the variables in the data set. (b) Compute the matrix of correlati ons between the variables using the function cor(). You will need to exclude the namevariable,cor()which is qualitative. (c) Use the lm()function to perform a multiple linear regression with mpgas the response and all other variables except nameas t h ep r e d i c t o r s .U s et h e summary() function to print the results. Comment on the output. For instance: i. Is there a relationship between the predictors and the re- sponse? ii. Which predictors appear to have a statistically signiﬁcant relationship to the response? iii. What does the coeﬃcient for the yearvariable suggest? (d) Use the plot()function to produce diagnostic plots of the linear regression ﬁt. Comment on any problems you see with the ﬁt. Do the residual plots suggest any unusually large outliers? Does the leverage plot identify any observations with unusually high leverage? (e) Use the *and :symbols to ﬁt linear regression models with interaction eﬀects. Do any interac tions appear to be statistically signiﬁcant? (f) Try a few diﬀerent transformations of the variables, such as log(X),√ X,X2. Comment on your ﬁndings. 3.7 Exercises 123 10. This question should be answered using the Carseats data set. (a) Fit a multiple regression model to predict Salesusing Price, Urban,a n d US. (b) Provide an interpretation of each coeﬃcient in the model. Be careful—some of the variables in the model are qualitative! (c) Write out the model in equation form, being careful to handle the qualitative variables properly. (d) For which of the predictors can you reject the null hypothesis H0:βj=0 ? (e) On the basis of your response to the previous question, ﬁt a smaller model that only uses the predictors for which there is evidence of associat ion with the outcome. (f) How well do the models in (a) and (e) ﬁt the data? (g) Using the model from (e), obtain 95% conﬁdence intervals for the coeﬃcient(s). (h) Is there evidence of outliers or high leverage observations in the model from (e)? 11. In this problem we will investigate the t-statistic for the null hypoth- esisH0:β= 0 in simple linear regression without an intercept. To begin, we generate a predictor xand a response yas follows. > set.seed(1) > x=rnorm(100) > y=2*x+rnorm(100) (a) Perform a simple linear regression of yonto x,withoutan in- tercept. Report the coeﬃcient estimate ˆβ, the standard error of this coeﬃcient estimate, and the t-statistic and p-value associ- ated with the null hypothesis H0:β= 0. Comment on these results. (You can perform regre ssion without an intercept using the command lm(y∼x+0).) (b) Now perform a simple linear regression of xonto ywithout an intercept, and report the coeﬃci ent estimate, its standard error, and the corresponding t-statistic and p-values associated with the null hypothesis H0:β= 0. Comment on these results. (c) What is the relationship between the results obtained in (a) and (b)? (d) For the regression of YontoXwithout an intercept, the t- statistic for H0:β=0t a k e st h ef o r m ˆβ/SE(ˆβ), where ˆβis given by (3.38), and where SE(ˆβ)=/radicalBigg/summationtextn i=1(yi−xiˆβ)2 (n−1)/summationtextn i/prime=1x2 i/prime. 124 3. Linear Regression (These formulas are slightly diﬀerent from those given in Sec- tions 3.1.1 and 3.1.2, since here we are performing regression without an intercept.) Show alg ebraically, and conﬁrm numeri- cally in R, that the t-statistic can be written as (√n−1)/summationtextn i=1xiyi/radicalbig (/summationtextn i=1x2 i)(/summationtextn i/prime=1y2 i/prime)−(/summationtextn i/prime=1xi/primeyi/prime)2. (e) Using the results from (d), argue that the t-statistic for the re- gressionof yonto xisthesameasthet-statisticfortheregression ofxonto y. (f) In R, show that when regression is performed withan intercept, the t-statistic for H0:β1= 0 is the same for the regression of y onto xas it is for the regression of xonto y. 12. This problem involves simple linear regression without an intercept. (a) Recall that the coeﬃcient estimate ˆβf o rt h el i n e a rr e g r e s s i o no f YontoXwithout an intercept is given by (3.38). Under what circumstance is the coeﬃcient estimate for the regression of X ontoYthe same as the coeﬃcient est imate for the regression of YontoX? (b) Generate an example in Rwithn= 100 observations in which the coeﬃcientestimate forthe regressionof XontoYisdiﬀerent fromthe coeﬃcient estimate for the regression of YontoX. (c) Generate an example in Rwithn= 100 observations in which the coeﬃcient estimate for the regression of XontoYisthe same as the coeﬃcient estimate for the regression of YontoX. 13. In this exerciseyou will createsome simulated dataand will ﬁt simple linear regression models to it. Make sure to use set.seed(1) prior to starting part (a) to ensure consistent results. (a) Using the rnorm()function, create a vector, x, containing 100 observations drawn from a N(0,1) distribution. This represents af e a t u r e , X. (b) Using the rnorm()function, create a vector, eps, containing 100 observations drawn from a N(0,0.25) distribution i.e. a normal distribution with mean zero and variance 0 .25. (c) Using xand eps, generate a vector yaccording to the model Y=−1+0.5X+/epsilon1. (3.39) What is the length of the vector y? What are the values of β0 andβ1in this linear model? 3.7 Exercises 125 (d) Create a scatterplot displaying the relationship between xand y. Comment on what you observe. (e) Fit a least squares linear model to predict yusing x. Comment on the model obtained. How do ˆβ0andˆβ1compare to β0and β1? (f) Display the least squares line on the scatterplot obtained in (d). Draw the population regression line on the plot, in a diﬀerent color. Use the legend() command to create an appropriate leg- end. (g) Now ﬁt a polynomial regression model that predicts yusing x andx2. Is there evidence that the quadratic term improves the model ﬁt? Explain your answer. (h) Repeat (a)–(f) after modifyi ng the data generation process in such a way that there is lessnoise in the data. The model (3.39) should remain the same. You can do this by decreasing the vari- ance of the normal distribution u sed to generate the error term /epsilon1in (b). Describe your results. (i) Repeat (a)–(f) after modifyi ng the data generation process in such a way that there is morenoise in the data. The model (3.39) should remain the same. You can do this by increasing the variance of the normal distribution used to generate the error term /epsilon1in (b). Describe your results. (j) What are the conﬁdence intervals for β0andβ1based on the original data set, the noisier data set, and the less noisy data set? Comment on your results. 14. This problem focuses on the collinearity problem. (a) Perform the following commands in R: > set.seed(1) > x1=runif(100) > x2=0.5*x1+rnorm(100)/10 > y=2+2*x1+0.3*x2+rnorm(100) The last line correspondsto creating a linear model in which yis a function of x1and x2. Write out the form of the linear model. What are the regression coeﬃcients? (b) What is the correlation between x1and x2? Create a scatterplot displaying the relationship between the variables. (c) Using this data, ﬁt a least squares regression to predict yusing x1and x2. Describe the results obtained. What are ˆβ0,ˆβ1,a n d ˆβ2? How do these relate to the true β0,β1,a n dβ2?C a ny o u reject the null hypothesis H0:β1= 0? How about the null hypothesis H0:β2=0 ? 126 3. Linear Regression (d) Now ﬁt a least squares regression to predict yusing only x1. Comment on your results. Can you reject the null hypothesis H0:β1=0 ? (e) Now ﬁt a least squares regression to predict yusing only x2. Comment on your results. Can you reject the null hypothesis H0:β1=0 ? (f) Do theresultsobtainedin(c)–(e) contradicteachother?Explain your answer. (g) Now suppose we obtain one additional observation, which was unfortunately mismeasured. > x1=c(x1, 0.1) > x2=c(x2, 0.8) > y=c(y,6) Re-ﬁtthelinearmodelsfrom(c)to(e)usingthisnewdata.What eﬀect does this new observation have on the each of the models? In each model, is this observation an outlier? A high-leverage point? Both? Explain your answers. 15. This problem involves the Bostondata set, which we saw in the lab for this chapter. We will now try to predict per capita crime rate using the other variables in this data set. In other words, per capita crime rate is the response, and the other variables are the predictors. (a) For eachpredictor,ﬁt asimple linear regressionmodel to predict the response. Describe your results. In which of the models is there a statistically signiﬁcant a ssociationbetween the predictor and the response? Create some plots to back up your assertions. (b) Fit a multiple regression model to predict the response using all of the predictors. Describe you r results. For which predictors can we reject the null hypothesis H0:βj=0 ? (c) How do your results from (a) compare to your results from (b)? Create a plot displaying the uni variate regression coeﬃcients from (a) on the x-axis, and the multiple regression coeﬃcients from (b) on the y-axis. That is, each predictor is displayed as a single point in the plot. Its coeﬃcient in a simple linear regres- sion model is shown on the x-axis, and its coeﬃcient estimate in the multiple linear regression model is shown on the y-axis. (d) Is there evidence of non-linear association between any of the predictors and the response? To answer this question, for each predictor X, ﬁt a model of the form Y=β0+β1X+β2X2+β3X3+/epsilon1. 4 Classiﬁcation The linear regression model discussed in Chapter 3 assumes that the re- sponse variable Yis quantitative. But in many situations, the response variable is instead qualitative . For example, eye color is qualitative, takingqualitativeon values blue, brown, or green. Often qualitative variables are referred to ascategorical ; we will use these terms interchangeably. In this chapter, we study approaches for predicting qualitative responses, a process that is known as classiﬁcation . Predicting a qualitative response for an obser-classiﬁcationvation can be referred to as classifying that observation, since it involves assigning the observation to a category, or class. On the other hand, often the methods used for classiﬁcation ﬁrst predict the probability of each of the categories of a qualitative variable, as the basis for making the classi- ﬁcation. In this sense they also behave like regression methods. There are many possible classiﬁcation techniques, or classiﬁers , that oneclassiﬁermight use to predict a qualitative response. We touched on some of these in Sections 2.1.5 and 2.2.3. In this chapter we discuss three of the most widely-used classiﬁers: logistic regression ,linear discriminant analysis ,a n dlogistic regression linear discriminant analysisK-nearest neighbors . We discuss more computer-i ntensive methods in later K-nearest neighborschapters, such as generalized additive models (Chapter 7), trees, random forests, and boosting (Chapter 8), and support vector machines (Chap- ter 9). G. James et al., An Introduction to Statistical Learning: with Applications in R , Springer Texts in Statistics 103, DOI 10.1007/978-1-4614-7138-7 4, ©Springer Science+Business Media New York 2013127 128 4. Classiﬁcation 4.1 An Overview of Classiﬁcation Classiﬁcation problems occur often, p erhaps even more so than regression problems. Some examples include: 1. A person arrives at the emerge ncy room with a set of symptoms that could possibly be attributed to one of three medical conditions. Which of the three conditions does the individual have? 2. An online banking service must be able to determine whether or not a transaction being performed on the site is fraudulent, on the basis of the user’s IP address, past transaction history, and so forth. 3. On the basis of DNA sequence data for a number of patients with and without a given disease, a biologistwould like to ﬁgure out which DNA mutations are deleterious (disease-causing) and which are not. Just as in the regression setting, in the classiﬁcation setting we have a set of training observations ( x1,y1),...,(xn,yn) that we can use to build a classiﬁer. We want our classiﬁer to perform well not only on the training data,but alsoon test observationsthat werenot used to trainthe classiﬁer. In this chapter, we will illustrate the concept of classiﬁcation using the simulated Default data set. We are interested in predicting whether an individual will default on his or her credit card payment, on the basis of annual income and monthly credit card balance. The data set is displayed in Figure 4.1. We have plotted annual incomeand monthly credit card balanceforasubsetof10 ,000individuals.Theleft-handpanelofFigure4.1 displays individuals who defaulted in a given month in orange, and those who did not in blue. (The overall default rate is about 3%, so we have plotted only a fraction of the individuals who did not default.) It appears that individuals who defaulted tended to have higher credit card balances than those who did not. In the right-hand panel of Figure 4.1, two pairs of boxplots are shown. The ﬁrst shows the distribution of balancesplit by the binary defaultvariable; the second is a similar plot for income.I nt h i s chapter, we learn how to build a model to predict default (Y) for any given value of balance(X1)a n d income(X2). SinceYis not quantitative, the simple linear regression model of Chapter 3 is not appropriate. It is worth noting that Figure 4.1 displays a very pronounced relation- ship between the predictor balanceand the response default.I nm o s tr e a l applications, the relationship between the predictor and the response will not be nearly so strong. However, for the sake of illustrating the classiﬁca- tion procedures discussed in this chapter, we use an example in which the relationship between the predictor and the response is somewhat exagger- ated. 4.2 Why Not Linear Regression? 129 BalanceIncome Default Default0 500 1000 1500 2000 25000 20000 40000 60000 No Yes0 500 1000 1500 2000 2500Balance No Yes0 20000 40000 60000Income FIGURE 4.1. The Default data set. Left:The annual incomes and monthly credit card balances of a number of individuals. The individuals who defaulted on their credit card payments are shown in orange, and those who did not are shown in blue. Center: Boxplots of balance as a function of default status.Right: Boxplots of incomeas a function of default status. 4.2 Why Not Linear Regression? We have stated that linear regression is not appropriate in the case of a qualitative response. Why not? Suppose that we are trying to predict the medical condition of a patient in the emergency room on the basis of her symptoms. In this simpliﬁed example, there are three possible diagnoses: stroke,drug overdose ,a n d epileptic seizure . We could consider encoding these values as a quantita- tive response variable, Y, as follows: Y=⎧ ⎪⎨ ⎪⎩1i f stroke; 2i f drug overdose ; 3i f epileptic seizure . Usingthiscoding,leastsquarescouldbeusedtoﬁtalinearregressionmodel to predict Yon the basis of a set of predictors X1,...,X p. Unfortunately, this coding implies an ordering on the outcomes, putting drug overdose in between strokeand epileptic seizure , and insisting that the diﬀerence between strokeand drug overdose is the same as the diﬀerence between drug overdose and epileptic seizure . In practice there is no particular reason that this needs to be the case. For instance, one could choose an equally reasonable coding, Y=⎧ ⎪⎨ ⎪⎩1i f epileptic seizure ; 2i f stroke; 3i f drug overdose . 130 4. Classiﬁcation which would imply a totally diﬀerent relationship among the three condi- tions. Each of these codings would produce fundamentally diﬀerent linear models that would ultimately lead to d iﬀerent sets of predictions on test observations. If the response variable’s values did take on a natural ordering, such as mild,moderate ,a n dsevere, and we felt the gap between mild and moderate was similar to the gap between moderate and severe, then a 1, 2, 3 coding would be reasonable. Unfortunately, in general there is no natural way to convert a qualitative response variable with more than two levels into a quantitative response that is ready for linear regression. For abinary(two level) qualitative response, the situation is better. Forbinaryinstance, perhaps there are only two possibilities for the patient’s med- ical condition: strokeand drug overdose . We could then potentially use thedummy variable approach from Section 3.3.1 to code the response as follows: Y=/braceleftBigg 0i f stroke; 1i f drug overdose . We could then ﬁt a linear regression to this binary response, and predict drug overdose ifˆY>0.5a n d strokeotherwise. In the binary case it is not hard to show that even if we ﬂip the above coding, linear regression will produce the same ﬁnal predictions. For a binary response with a 0/1 coding as above, regression by least squaresdoes makesense; itcanbe shownthat the Xˆβobtained using linear regression is in fact an estimate of Pr( drug overdose |X) in this special case. However, if we use linear regre ssion, some of our estimates might be outside the [0 ,1] interval (see Figure 4.2), making them hard to interpret as probabilities! Nevertheless, the predictions provide an ordering and can be interpreted as crude probability estimates. Curiously, it turns out that the classiﬁcations that we get if we use linear regression to predict a binary response will be the same as for the linear discriminant analysis (LDA) procedure we discuss in Section 4.4. However, the dummy variable approach cannot be easily extended to accommodate qualitativ e responses with more than two levels. For these reasons, it is preferable to use a classiﬁcation method that is truly suited for qualitative response values, such as the ones presented next. 4.3 Logistic Regression Consider again the Defaultdata set, where the response defaultfalls into one of two categories, YesorNo. Rather than modeling this response Y directly, logistic regression models the probability thatYbelongs to a par- ticular category. 4.3 Logistic Regression 131 0 500 1000 1500 2000 25000.0 0.2 0.4 0.6 0.8 1.0 BalanceProbability of Default || |||| || | || | || ||| || || | || | | | ||| | | | | || | | || || | || || || | | | || || || | || | || ||| || || || | |||| | | || | | || | | | || || || | || || | | || | || || | || | | || | || | | || | | || |||| || |||| | || || || || | | || || | || || | || | || || || | || | | || || | | || | || ||| | | ||| | || || | || ||| || ||| | || | || ||| || | | || | | || | || | || || | || || ||| || || || | | | || | || || | ||||| || | || || | | || | | || || | | | | || | || |||| | || | || || | | | || | | | || || | || | ||| || | || || | || | || || | | || || || || || || | | || | ||| | || || || | || || | | | || | | ||| | || | | | || | | || | | | ||| || || || | || || | || || || | || |||| || || | |||| | ||| || ||| |||| | | ||| | | || | | |||| || || || | || || || | | || | | || | || | ||| || || | | || || | | ||| | | | || | || | | || || || | | | || | | || | || | | || | | || || || | || || | || | | | || | || | ||||| || || | || || | || || ||| | || | ||| | | | || | | |||| || | || || | | || ||| || | | |||| | | || || | || | ||| || || ||| || || | | | ||| || | ||| || | | ||| || | | | | ||| || ||| | || ||| | | | || || | | || | || || | || || |||||| || ||||| | || | | ||| || | |||| | || || || ||| || | | ||| | || | || || | || || ||| ||| | |||| || |||| | |||| | | || || | | | || | || | ||| || | | || ||| | | || | || |||| | | | || | | ||| | | || | | | || | | | || | | | || ||| || | | || | || ||| | || || | | || || | ||| || | || || |||| | || || | || | | | || || | || || || | | ||| || | || | || | ||| | | | || |||| || | | ||| || | | | || ||| ||| || | | | || ||| | || | || | ||| ||| || || | | || || || ||| || || || | | | || | || | | ||| || ||| || || | | || || | | | | | || ||| | || | | | || | | || | || |||| | || || | || || || | | || | | || | | || || || ||| | | | || | || | | || | || || | | || | || | || || ||| | | || ||| || || | || |||| | || | | || | || | || | | || || ||| | | ||| | || | || || ||| | | | ||||| | || || | || | | | ||| | || ||| | || | || | ||| ||| ||| | | | || | ||| | | | || | | || | || | ||| | | ||| | || || || ||| ||| ||||| | || | ||| | || |||| || ||||| | | | || | || || || || | || | | | || | | | |||| || | || |||| |||| || || || | | |||| || | || | | | | || || | || | || | | | | | | || | || | || || | || | | | | | | ||| | | || | || | ||| || | || | | | || | || | | || ||| ||| || | | || | ||| || || || || || || | | || | | |||| | || || | | || || | || || || | || || | || || | || || || || | ||| | | || | || | | | || || | |||| | | || || || | | | | |||||| || |||| ||| | || | || ||| | || | | || || | | || || || | || | || | | || | ||| || ||| ||| || | || |||| || || | | | || | || | ||| || || | | || || | || ||| | || | || || || | || | || | || || ||| || | | || || || | || | | || || | || || | | | || | || |||| | || || | || | ||| || || | | | || | | | ||| || ||| ||| | || | || ||| || || | || | || || | | || || |||| | || | | || | | | || | || || || | | || | ||| | | | || || | | | || ||| || || || || || | || || || || | | || | | || | ||| | || || ||| || |||| || |||| | ||| || || ||||||| || ||| |||| || | || || | | || ||||| || || || | | | || || || | || | || || | || | | | | || | | || | | | | ||| || || | || ||| | | | | || | | || || | || | | | || || ||||| | |||| |||||| || | || | || | || | | || ||| | || || || | | || | || | || | || || | ||||| | || | | || || || | | ||| ||| || || | || || | || | | || | | | | || |||| || || || | || || || | || || || | || | | | | || | | || || || | || | |||| | || | || || || | | || | | | ||| || || | | | | | | || | ||| || || || || || | ||| | |||| || |||| | ||||| || | | || || | || | | || || || | | | || ||| || | || | | || || || | ||| | ||||| | | || | || ||| |||| | | | | ||||| | | | | | |||| || || ||| || || | | |||| || | | || | |||| | | | || || || || || || || || || || | || || | | || | | | ||| || || || | || || | |||| | || || ||| | | || | | || | | | || | | || | ||| | || || | || |||| | || | | ||| | || | || | || ||| ||||| | || | ||| ||| | || || || | || || || || || | || | || | || ||| | || | || ||||| | || ||| | | || | || | | | || || | | || | | || | || | | | || || | | || | |||| | | || | || || | || | || | || || || | || ||| | | || || | || |||| ||| || | || || | | | | || || | | || || || | || | | |||| | ||| | | || || || | | || || | || | || || || ||||| || | | || |||| | || | || | || || ||||| | | || ||| || || | || | || |||| |||| || | | || | || | | || ||| | | || || | | | | || ||| | || ||| || | |||| || | |||| || || | | || | | || | | || ||| | | || | |||| || || || || | || | | || | || | || | || | || | || | |||| | || | | | || | || | || | | |||| | || ||| || || || | | || || || | || || ||| | || | ||| | | || | || ||| || || | | ||| || || || | | || ||| || || || || || || || || || | | || | || | | || | || | | | | || || || | || | |||| || | || | || | || | | || | || | || || || | || | || || || | | || || ||| | | | ||| | || | || | | || | | ||| | | | | || | | | || | | || || | || | || | ||| || | ||| | || || || || | ||| | || ||| | | | || || | || | | || | | || ||||| || | | ||| || | || | || || | | || || | ||| | | | | | || | || | || || | || ||| |||| || | || | | || | || || | | || | || | || ||| | ||| |||| || || || | || ||| | || | | || || | ||| | || | || || | || | | | | ||| || || || | ||| || || || ||| | ||||| | || || | || | || | || | || | | || | || | | |||||| | | ||||| || | || | || ||| | | || | | || ||| | || |||| || | || || || | || || || || | ||| | |||| | | || | || | || | | | | | || | | | | | || | ||| ||| | || || | || || || | ||| ||| || | || || | || || | ||| | || | || | || || | | | | || | |||| | | || | ||| | ||||| | | |||| | | | || | | ||| | || ||| || || || || | || | | || ||| || | | || | || | || || || || | | | | | || || || || | | ||| |||| || | | || | || | |||| || | | | |||| ||| | || | | | || | || || | ||| | || | | || | || || | || | || || | | | | || || | | | || ||| || ||| || || | | || | ||| | | |||| | ||| ||||| | || | || |||| || | | || | | || | || | || | || || || | | || | | || || | | || || | || ||| | || || | ||| | | |||| || | || | | || || | || || | || | || || | | || || || | ||| | ||| || | | | | |||| || | || | ||| || || || | | | | | || | | |||| || ||| || || | || || || ||| | || || | | || | || | |||| || | || || || ||| | | | || | ||| | | || | | || | || | | | || | |||| | | || | || | || | || | | || || || | |||||| | || || ||| | | | || || || ||| || ||| | || | ||| |||| || | | | |||||| || | ||| || ||| || | || | || | | | | | || | | | || ||| || | || | | ||| | || | | || | | | || |||| ||| || | | || |||| || || | | |||| ||| | || | |||| || || | ||| || ||| | | || || | || | || || | || ||| | ||||| ||| || | || ||| | || | ||||| ||| || || | ||| || | | || | | || | | || || | | || | || || | | | | || | || || || ||| || |||| ||| | | || | | || | || ||| ||| | | || || || | || || || | || || ||| | || |||| | ||| | ||| | | | || | | | | ||| || || | | | | | | ||| | || |||| || || | || | || | || |||| | || || | | | || | | || | | | || | || | | |||| | | || | | | ||| | | || | | || || | | | | ||| || | || | | || | ||| | | | | | || || | || || || || || | | || | ||| || || | | | | || || | | || | || || ||| | | | || | | | || | | ||| | | ||| | || | ||| || || || | | ||| || || ||| | | || | |||| | || | || || || || || || | || | | || || || || | ||| | ||| || | || | || | || | ||| || || || | || | || || || |||| | || | | | || || | || | || | | ||| | || | | || | ||| | | || |||| | || | || | || || | | || | | || | | | || |||| | ||| | | | || |||||| | || ||| || | || || | || | || | |||| | || ||| | ||| || ||| | | || | || || | | | ||| | ||| | || | | | || || | ||| ||| | || | | || || ||| || |||||| | | ||| || | | | || || ||| | | ||||||| || | ||| || | || | | | || || | || | | | | ||| |||| | || | | | || | || || || ||| | | || || | | || | || | || | | | | || | || | | | | | || || || | || | ||| | || | | || || || || || |||| |||| | || || |||| || | | | || || | ||| | || || || | | || | || | || | | ||| | ||||||| ||| | || | || || | || | | || ||| | || || | |||| | || | || ||| | | || | | || || | || | || | | ||||| || || ||| || | || | || | | | || | || || || | || | || | || || || | || | | | |||| || | || | ||| | || | ||||| || || || ||| || | || | || | |||| || | || | | | | | || || | | ||| || | | | ||| || | | || ||| || | | || | || || || || || || | || | | || | || || | || | || | | || || || | |||| | || ||| | || | || | |||| | || | || | || || | | || || ||| | ||||| | || || ||| | | || | || || | | |||| | || || || || || | | || || || | |||| | | || || | |||| || || | || || | |||| | || | || || ||| || || || | | || | | || |||||| | || | | | | | || | | || |||| | | || | | ||| || || || | ||| | || | || || ||| ||| | || | || | | | || || ||| || | ||| || || | || | | || | || |||| | || ||| | | | || | | | | || || | || | | | | ||| || | ||| || ||| | || || || || | | | || || || ||| | || || | | | || || | | ||| || ||| || | | | || | ||| || || || || | | || | || | || || || | | || |||| | || | | | | || | || || || | || | || | | | || || | || | || ||| | || | || ||| || || || | ||| | || || | || | | | |||| | |||| || ||| ||| || | ||| || | | | || | || || | || | | || || || | || | || || | || | | || ||| || || || ||| || | | || | | | || | ||||| | | ||| || | | | || | | || | | | | || | || || ||||| |||| ||| | ||| || || || | || || |||| || || || | || || | || | || ||| | || | || | ||| | | | |||| || ||| || || || | ||| || | ||| || | || || | | | || | | ||| || | || | || | || | || | | | || || || | || | || || | | | | || | || || | || || || | | || || | || || || | || || | || | | | | || | ||| || | || |||| | | ||| || | || || || || || | | | || | | | || | | || | | || ||| | | | | || | || |||| || | | | |||| | | ||||| | || ||| | | ||| || | | || || || | | || | | || | | || || | | | | ||| || || | || || | ||| | | | || | | | || | || | || || || | || | || ||| |||| || | |||| || | || | || | || ||| | || | | | | || | ||| | || | || | | || | || |||| || | || | | | ||| | | | | || | | || || || | || | || || | || ||| || || ||| || | | | || | || | |||| |||| | | | || || | | || | | || | | | || | || || || | | | || | ||| || || || | | || || || || ||| | | || | | ||| || || | || | |||| | || || | | || | | ||| | || | | | | || || | || | | || | || | | || | | || | | || ||| | || | || || | | || | || | || | ||| | | || || || | ||| || | | || || | || | | | || || | | || || | || | | || ||| || || | || | | | || | | || | || | || || | | || | ||| || | | ||| || || ||| | ||| || | || | | | || ||| | |||||| | | |||| || | || || | || | | | | || | | | || | | | || || || || | | || | | | | ||| | | || | || || || || || || || || | | | || || ||| | | || | || | | || || ||| | || | || || | || || | | || | || | | || | | || | || || || || | |||| | |||| | || | ||| || ||| ||| || || | | | |||| | || || || || || | | || | || | || | | || | | || | | | | || | | | || ||| | || | | | || ||| | | || || || || | || || || | || || || || || || || || || || ||| || | || || || || | || | | | || | | || || || | || || || || | || || ||| | | | || | || | |||| || | |||| | || | | || | || || | | ||| ||| | | | | |||| | | || | || | || | | | |||| | ||| || | | | || | ||| || | || || ||| || | | || | || || || || || || || || || || || || || || ||| || | | | || | || | || ||| | || || | || ||| || | || || | | || || | | || || | || || | || | | | | | || | | ||| ||||| | || | | | || || | || ||| || ||| | || | | ||| | | || | | | | || | | | | || || | ||| | || | | || | || ||| || | | || | || || | | | || | | | || | || | || || | ||| || | || | || || || || || | | || | | || | ||| | | || | ||| || || | | ||| ||| | | | | || | || ||| || || | | | || | | || | | || | | ||| || | | | || | | | || | || | | | || || | | | || | | || | || | | | ||| || | || || || || || || || | || | | || || | || |||||| | ||| || | || | |||| | || || | || | |||| || || || | | || || | || | || ||| | | ||| ||| | | || | || | | |||| | ||| || | || || ||| | || | | || | | || | | || || | || | | || || | | || || | |||| | || || | || | || || || | | | | |||| | ||| || | || | | | || | | | || || || | | || | || || | | || || | |||| | | || | | | || || | | | || || | | | || || | || || | || | | |||| | | | |||| |||| | | | || ||| | || || | | | | | || | || || || || ||| || | | || || | | |||| || || | ||| || | | | ||| || || || | || | ||| || | || ||| | | || || || | || || || || | | || || | | | || ||| ||||| | || || | || | | || || | || | || || || | |||| | | || | ||| | || ||| || | | || | || | || || ||||| || | || | | || | || || || | | | || || | | | || || ||| || | || |||| |||| | | | | ||| | |||| | || || || || ||| | || || | | | || || | || | | | || || || || ||| | || ||| | || |||| | | |||| | || | || || || | || | || ||| | | | |||| || | || | || | || | | || | || | | | | || ||||| |||||| || | | ||||| | || || | || | | || | || || | || || | | | || | || | || | | || | || | | || || | || || || | | | | || | | || || || | || || | | | | | ||| || || | || | | || | || || || | || | || || | || ||| ||| | | | || | | || | || || | || | | | | || || || || | ||||| || | | | || || | || | || | | | | ||| | || || || || ||| || || | || ||| | | || | || || | ||| || || | | | || | || || | || || || || || | || || | || | | | | || | | || | || | || || | || | | || | ||| ||| | | | | || | | | | || | | | || || | |||| | || | | || | || | | | | || | | | || | ||||| | | ||| |||||| || || | || || ||| || || | ||| | || || | || || | || | || || | | || | | | || | | | | |||| | || || || || || | || | || ||| | | | || | | | | | || | || | || | ||| || | | | || | | || | | | | | ||| | | | ||| ||| | | || || |||| | | ||| |||| | || || | | | | | || | |||||| || | ||| | | | || || || | | | ||| ||| |||| ||| || | || | || | | || | || | | | || | | | | || | || || | | || | | ||| | | | || || ||| | | || | || || | | || || | || || | | || || | || |||| || || | | || | || | || || | | || || || | || || || ||| | | | | || || | | | | |||| | || | ||| || || | |||| || || | || | || |||| || ||| || || | ||| || || || ||| || | || | ||| | || | || | ||| | || | | || | || | || | || | || | || | ||| | || | || || | || | || ||| | | || | | || | || || || |||| || | || | || | | || || | || |||| | | || | |||| | | || || | || |||| || || || || | | ||| | || | || | || || |||| || || |||| || || | || | || | | ||| || | || | | | || ||| |||| | | | || || | | || || | | || || | | || ||| | || | || | | | || || | || | || | | || || | || || |||| | | || || | || || | | || | | ||| | | | || | || | || || | | || | | || || | || | | || || |||| | || | || | | | || ||| | | | | |||| || || | | | ||| | || | || || | || |||| ||| | | | | | || ||| || | || | | || | || || | | | ||| | || | | || | | ||| | || ||| || | || || | || || | | || | | || | || | || ||||| | |||| || | || | ||||| | || | || | ||| | | || | || || | || | | || || | || || || | | || ||||| | || || | || |||| || | | ||| | | |||| ||||| | || | || | ||| || | | || | | | || | | | || ||| | || | || || ||| | || || || || | || || | || | || | | || | | ||| || ||| |||||| ||| || | | | | || | | |||| || || | | || | || || | || || | | | | || || || || | || ||| | | | | | | || | || | || || | | || || ||| || ||| | || | | | || | || || || | |||| ||| || | || || || | || | || | | || ||| || | || ||| || | | || ||| || | || | || || | | || | || || || | || | | || | | || | | |||| | | ||| | || | | || |||| | || ||| || |||| | | || | || || || | || | | | || | || || | || || | ||| || ||| || | |||| || || || | || | | ||| | | | | ||| | || | | || | | | || | || | ||| | | | || || || | || | || | || | ||| || || || || | | || | || | || | | || | || || | | ||| || | || | || | |||| | | ||| | || |||| | || ||| || | || || | || || | ||| || | | || | | || | || | || | || || | | | || ||| || | || | || || || | || || || || || || | | | || | || | || || | | | || || || | | || || || || | ||| || | | || | | || | || | |||| | || | | || | | || | | || | |||| || | | | ||| | || | | | ||| | | |||| ||||| | | || || | || || | || |||| || | || || || || | || || || | || | | ||| | | |||| || || | | || | || ||| | | | |||| |||| ||| || || | || |||| | || | || |||| |||| | || | || | | || ||||| || | | || | || |||| | | || || || || | | || | | || | | | | || | | || | | | || | | |||| | | || || ||| ||| || | || | | ||| || | |||| || || | | || || | || || | | || ||| | | | || || | || | | || || || | | || | || ||| | || | ||||| || | || || | || | | | || | | | | || || | || | || || || | || || ||||| | || | | || | || || || || || | |||| | | || || | || || ||||| | || || || ||| || | || || || | | | | || |||| | |||| || ||| | || | || || | || ||| || 0 500 1000 1500 2000 25000.0 0.2 0.4 0.6 0.8 1.0 BalanceProbability of Default || |||| || | || | || ||| || || | || | | | ||| | | | | || | | || || | || || || | | | || || || | || | || ||| || || || | |||| | | || | | || | | | || || || | || || | | || | || || | || | | || | || | | || | | || |||| || |||| | || || || || | | || || | || || | || | || || || | || | | || || | | || | || ||| | | ||| | || || | || ||| || ||| | || | || ||| || | | || | | || | || | || || | || || ||| || || || | | | || | || || | ||||| || | || || | | || | | || || | | | | || | || |||| | || | || || | | | || | | | || || | || | ||| || | || || | || | || || | | || || || || || || | | || | ||| | || || || | || || | | | || | | ||| | || | | | || | | || | | | ||| || || || | || || | || || || | || |||| || || | |||| | ||| || ||| |||| | | ||| | | || | | |||| || || || | || || || | | || | | || | || | ||| || || | | || || | | ||| | | | || | || | | || || || | | | || | | || | || | | || | | || || || | || || | || | | | || | || | ||||| || || | || || | || || ||| | || | ||| | | | || | | |||| || | || || | | || ||| || | | |||| | | || || | || | ||| || || ||| || || | | | ||| || | ||| || | | ||| || | | | | ||| || ||| | || ||| | | | || || | | || | || || | || || |||||| || ||||| | || | | ||| || | |||| | || || || ||| || | | ||| | || | || || | || || ||| ||| | |||| || |||| | |||| | | || || | | | || | || | ||| || | | || ||| | | || | || |||| | | | || | | ||| | | || | | | || | | | || | | | || ||| || | | || | || ||| | || || | | || || | ||| || | || || |||| | || || | || | | | || || | || || || | | ||| || | || | || | ||| | | | || |||| || | | ||| || | | | || ||| ||| || | | | || ||| | || | || | ||| ||| || || | | || || || ||| || || || | | | || | || | | ||| || ||| || || | | || || | | | | | || ||| | || | | | || | | || | || |||| | || || | || || || | | || | | || | | || || || ||| | | | || | || | | || | || || | | || | || | || || ||| | | || ||| || || | || |||| | || | | || | || | || | | || || ||| | | ||| | || | || || ||| | | | ||||| | || || | || | | | ||| | || ||| | || | || | ||| ||| ||| | | | || | ||| | | | || | | || | || | ||| | | ||| | || || || ||| ||| ||||| | || | ||| | || |||| || ||||| | | | || | || || || || | || | | | || | | | |||| || | || |||| |||| || || || | | |||| || | || | | | | || || | || | || | | | | | | || | || | || || | || | | | | | | ||| | | || | || | ||| || | || | | | || | || | | || ||| ||| || | | || | ||| || || || || || || | | || | | |||| | || || | | || || | || || || | || || | || || | || || || || | ||| | | || | || | | | || || | |||| | | || || || | | | | |||||| || |||| ||| | || | || ||| | || | | || || | | || || || | || | || | | || | ||| || ||| ||| || | || |||| || || | | | || | || | ||| || || | | || || | || ||| | || | || || || | || | || | || || ||| || | | || || || | || | | || || | || || | | | || | || |||| | || || | || | ||| || || | | | || | | | ||| || ||| ||| | || | || ||| || || | || | || || | | || || |||| | || | | || | | | || | || || || | | || | ||| | | | || || | | | || ||| || || || || || | || || || || | | || | | || | ||| | || || ||| || |||| || |||| | ||| || || ||||||| || ||| |||| || | || || | | || ||||| || || || | | | || || || | || | || || | || | | | | || | | || | | | | ||| || || | || ||| | | | | || | | || || | || | | | || || ||||| | |||| |||||| || | || | || | || | | || ||| | || || || | | || | || | || | || || | ||||| | || | | || || || | | ||| ||| || || | || || | || | | || | | | | || |||| || || || | || || || | || || || | || | | | | || | | || || || | || | |||| | || | || || || | | || | | | ||| || || | | | | | | || | ||| || || || || || | ||| | |||| || |||| | ||||| || | | || || | || | | || || || | | | || ||| || | || | | || || || | ||| | ||||| | | || | || ||| |||| | | | | ||||| | | | | | |||| || || ||| || || | | |||| || | | || | |||| | | | || || || || || || || || || || | || || | | || | | | ||| || || || | || || | |||| | || || ||| | | || | | || | | | || | | || | ||| | || || | || |||| | || | | ||| | || | || | || ||| ||||| | || | ||| ||| | || || || | || || || || || | || | || | || ||| | || | || ||||| | || ||| | | || | || | | | || || | | || | | || | || | | | || || | | || | |||| | | || | || || | || | || | || || || | || ||| | | || || | || |||| ||| || | || || | | | | || || | | || || || | || | | |||| | ||| | | || || || | | || || | || | || || || ||||| || | | || |||| | || | || | || || ||||| | | || ||| || || | || | || |||| |||| || | | || | || | | || ||| | | || || | | | | || ||| | || ||| || | |||| || | |||| || || | | || | | || | | || ||| | | || | |||| || || || || | || | | || | || | || | || | || | || | |||| | || | | | || | || | || | | |||| | || ||| || || || | | || || || | || || ||| | || | ||| | | || | || ||| || || | | ||| || || || | | || ||| || || || || || || || || || | | || | || | | || | || | | | | || || || | || | |||| || | || | || | || | | || | || | || || || | || | || || || | | || || ||| | | | ||| | || | || | | || | | ||| | | | | || | | | || | | || || | || | || | ||| || | ||| | || || || || | ||| | || ||| | | | || || | || | | || | | || ||||| || | | ||| || | || | || || | | || || | ||| | | | | | || | || | || || | || ||| |||| || | || | | || | || || | | || | || | || ||| | ||| |||| || || || | || ||| | || | | || || | ||| | || | || || | || | | | | ||| || || || | ||| || || || ||| | ||||| | || || | || | || | || | || | | || | || | | |||||| | | ||||| || | || | || ||| | | || | | || ||| | || |||| || | || || || | || || || || | ||| | |||| | | || | || | || | | | | | || | | | | | || | ||| ||| | || || | || || || | ||| ||| || | || || | || || | ||| | || | || | || || | | | | || | |||| | | || | ||| | ||||| | | |||| | | | || | | ||| | || ||| || || || || | || | | || ||| || | | || | || | || || || || | | | | | || || || || | | ||| |||| || | | || | || | |||| || | | | |||| ||| | || | | | || | || || | ||| | || | | || | || || | || | || || | | | | || || | | | || ||| || ||| || || | | || | ||| | | |||| | ||| ||||| | || | || |||| || | | || | | || | || | || | || || || | | || | | || || | | || || | || ||| | || || | ||| | | |||| || | || | | || || | || || | || | || || | | || || || | ||| | ||| || | | | | |||| || | || | ||| || || || | | | | | || | | |||| || ||| || || | || || || ||| | || || | | || | || | |||| || | || || || ||| | | | || | ||| | | || | | || | || | | | || | |||| | | || | || | || | || | | || || || | |||||| | || || ||| | | | || || || ||| || ||| | || | ||| |||| || | | | |||||| || | ||| || ||| || | || | || | | | | | || | | | || ||| || | || | | ||| | || | | || | | | || |||| ||| || | | || |||| || || | | |||| ||| | || | |||| || || | ||| || ||| | | || || | || | || || | || ||| | ||||| ||| || | || ||| | || | ||||| ||| || || | ||| || | | || | | || | | || || | | || | || || | | | | || | || || || ||| || |||| ||| | | || | | || | || ||| ||| | | || || || | || || || | || || ||| | || |||| | ||| | ||| | | | || | | | | ||| || || | | | | | | ||| | || |||| || || | || | || | || |||| | || || | | | || | | || | | | || | || | | |||| | | || | | | ||| | | || | | || || | | | | ||| || | || | | || | ||| | | | | | || || | || || || || || | | || | ||| || || | | | | || || | | || | || || ||| | | | || | | | || | | ||| | | ||| | || | ||| || || || | | ||| || || ||| | | || | |||| | || | || || || || || || | || | | || || || || | ||| | ||| || | || | || | || | ||| || || || | || | || || || |||| | || | | | || || | || | || | | ||| | || | | || | ||| | | || |||| | || | || | || || | | || | | || | | | || |||| | ||| | | | || |||||| | || ||| || | || || | || | || | |||| | || ||| | ||| || ||| | | || | || || | | | ||| | ||| | || | | | || || | ||| ||| | || | | || || ||| || |||||| | | ||| || | | | || || ||| | | ||||||| || | ||| || | || | | | || || | || | | | | ||| |||| | || | | | || | || || || ||| | | || || | | || | || | || | | | | || | || | | | | | || || || | || | ||| | || | | || || || || || |||| |||| | || || |||| || | | | || || | ||| | || || || | | || | || | || | | ||| | ||||||| ||| | || | || || | || | | || ||| | || || | |||| | || | || ||| | | || | | || || | || | || | | ||||| || || ||| || | || | || | | | || | || || || | || | || | || || || | || | | | |||| || | || | ||| | || | ||||| || || || ||| || | || | || | |||| || | || | | | | | || || | | ||| || | | | ||| || | | || ||| || | | || | || || || || || || | || | | || | || || | || | || | | || || || | |||| | || ||| | || | || | |||| | || | || | || || | | || || ||| | ||||| | || || ||| | | || | || || | | |||| | || || || || || | | || || || | |||| | | || || | |||| || || | || || | |||| | || | || || ||| || || || | | || | | || |||||| | || | | | | | || | | || |||| | | || | | ||| || || || | ||| | || | || || ||| ||| | || | || | | | || || ||| || | ||| || || | || | | || | || |||| | || ||| | | | || | | | | || || | || | | | | ||| || | ||| || ||| | || || || || | | | || || || ||| | || || | | | || || | | ||| || ||| || | | | || | ||| || || || || | | || | || | || || || | | || |||| | || | | | | || | || || || | || | || | | | || || | || | || ||| | || | || ||| || || || | ||| | || || | || | | | |||| | |||| || ||| ||| || | ||| || | | | || | || || | || | | || || || | || | || || | || | | || ||| || || || ||| || | | || | | | || | ||||| | | ||| || | | | || | | || | | | | || | || || ||||| |||| ||| | ||| || || || | || || |||| || || || | || || | || | || ||| | || | || | ||| | | | |||| || ||| || || || | ||| || | ||| || | || || | | | || | | ||| || | || | || | || | || | | | || || || | || | || || | | | | || | || || | || || || | | || || | || || || | || || | || | | | | || | ||| || | || |||| | | ||| || | || || || || || | | | || | | | || | | || | | || ||| | | | | || | || |||| || | | | |||| | | ||||| | || ||| | | ||| || | | || || || | | || | | || | | || || | | | | ||| || || | || || | ||| | | | || | | | || | || | || || || | || | || ||| |||| || | |||| || | || | || | || ||| | || | | | | || | ||| | || | || | | || | || |||| || | || | | | ||| | | | | || | | || || || | || | || || | || ||| || || ||| || | | | || | || | |||| |||| | | | || || | | || | | || | | | || | || || || | | | || | ||| || || || | | || || || || ||| | | || | | ||| || || | || | |||| | || || | | || | | ||| | || | | | | || || | || | | || | || | | || | | || | | || ||| | || | || || | | || | || | || | ||| | | || || || | ||| || | | || || | || | | | || || | | || || | || | | || ||| || || | || | | | || | | || | || | || || | | || | ||| || | | ||| || || ||| | ||| || | || | | | || ||| | |||||| | | |||| || | || || | || | | | | || | | | || | | | || || || || | | || | | | | ||| | | || | || || || || || || || || | | | || || ||| | | || | || | | || || ||| | || | || || | || || | | || | || | | || | | || | || || || || | |||| | |||| | || | ||| || ||| ||| || || | | | |||| | || || || || || | | || | || | || | | || | | || | | | | || | | | || ||| | || | | | || ||| | | || || || || | || || || | || || || || || || || || || || ||| || | || || || || | || | | | || | | || || || | || || || || | || || ||| | | | || | || | |||| || | |||| | || | | || | || || | | ||| ||| | | | | |||| | | || | || | || | | | |||| | ||| || | | | || | ||| || | || || ||| || | | || | || || || || || || || || || || || || || || ||| || | | | || | || | || ||| | || || | || ||| || | || || | | || || | | || || | || || | || | | | | | || | | ||| ||||| | || | | | || || | || ||| || ||| | || | | ||| | | || | | | | || | | | | || || | ||| | || | | || | || ||| || | | || | || || | | | || | | | || | || | || || | ||| || | || | || || || || || | | || | | || | ||| | | || | ||| || || | | ||| ||| | | | | || | || ||| || || | | | || | | || | | || | | ||| || | | | || | | | || | || | | | || || | | | || | | || | || | | | ||| || | || || || || || || || | || | | || || | || |||||| | ||| || | || | |||| | || || | || | |||| || || || | | || || | || | || ||| | | ||| ||| | | || | || | | |||| | ||| || | || || ||| | || | | || | | || | | || || | || | | || || | | || || | |||| | || || | || | || || || | | | | |||| | ||| || | || | | | || | | | || || || | | || | || || | | || || | |||| | | || | | | || || | | | || || | | | || || | || || | || | | |||| | | | |||| |||| | | | || ||| | || || | | | | | || | || || || || ||| || | | || || | | |||| || || | ||| || | | | ||| || || || | || | ||| || | || ||| | | || || || | || || || || | | || || | | | || ||| ||||| | || || | || | | || || | || | || || || | |||| | | || | ||| | || ||| || | | || | || | || || ||||| || | || | | || | || || || | | | || || | | | || || ||| || | || |||| |||| | | | | ||| | |||| | || || || || ||| | || || | | | || || | || | | | || || || || ||| | || ||| | || |||| | | |||| | || | || || || | || | || ||| | | | |||| || | || | || | || | | || | || | | | | || ||||| |||||| || | | ||||| | || || | || | | || | || || | || || | | | || | || | || | | || | || | | || || | || || || | | | | || | | || || || | || || | | | | | ||| || || | || | | || | || || || | || | || || | || ||| ||| | | | || | | || | || || | || | | | | || || || || | ||||| || | | | || || | || | || | | | | ||| | || || || || ||| || || | || ||| | | || | || || | ||| || || | | | || | || || | || || || || || | || || | || | | | | || | | || | || | || || | || | | || | ||| ||| | | | | || | | | | || | | | || || | |||| | || | | || | || | | | | || | | | || | ||||| | | ||| |||||| || || | || || ||| || || | ||| | || || | || || | || | || || | | || | | | || | | | | |||| | || || || || || | || | || ||| | | | || | | | | | || | || | || | ||| || | | | || | | || | | | | | ||| | | | ||| ||| | | || || |||| | | ||| |||| | || || | | | | | || | |||||| || | ||| | | | || || || | | | ||| ||| |||| ||| || | || | || | | || | || | | | || | | | | || | || || | | || | | ||| | | | || || ||| | | || | || || | | || || | || || | | || || | || |||| || || | | || | || | || || | | || || || | || || || ||| | | | | || || | | | | |||| | || | ||| || || | |||| || || | || | || |||| || ||| || || | ||| || || || ||| || | || | ||| | || | || | ||| | || | | || | || | || | || | || | || | ||| | || | || || | || | || ||| | | || | | || | || || || |||| || | || | || | | || || | || |||| | | || | |||| | | || || | || |||| || || || || | | ||| | || | || | || || |||| || || |||| || || | || | || | | ||| || | || | | | || ||| |||| | | | || || | | || || | | || || | | || ||| | || | || | | | || || | || | || | | || || | || || |||| | | || || | || || | | || | | ||| | | | || | || | || || | | || | | || || | || | | || || |||| | || | || | | | || ||| | | | | |||| || || | | | ||| | || | || || | || |||| ||| | | | | | || ||| || | || | | || | || || | | | ||| | || | | || | | ||| | || ||| || | || || | || || | | || | | || | || | || ||||| | |||| || | || | ||||| | || | || | ||| | | || | || || | || | | || || | || || || | | || ||||| | || || | || |||| || | | ||| | | |||| ||||| | || | || | ||| || | | || | | | || | | | || ||| | || | || || ||| | || || || || | || || | || | || | | || | | ||| || ||| |||||| ||| || | | | | || | | |||| || || | | || | || || | || || | | | | || || || || | || ||| | | | | | | || | || | || || | | || || ||| || ||| | || | | | || | || || || | |||| ||| || | || || || | || | || | | || ||| || | || ||| || | | || ||| || | || | || || | | || | || || || | || | | || | | || | | |||| | | ||| | || | | || |||| | || ||| || |||| | | || | || || || | || | | | || | || || | || || | ||| || ||| || | |||| || || || | || | | ||| | | | | ||| | || | | || | | | || | || | ||| | | | || || || | || | || | || | ||| || || || || | | || | || | || | | || | || || | | ||| || | || | || | |||| | | ||| | || |||| | || ||| || | || || | || || | ||| || | | || | | || | || | || | || || | | | || ||| || | || | || || || | || || || || || || | | | || | || | || || | | | || || || | | || || || || | ||| || | | || | | || | || | |||| | || | | || | | || | | || | |||| || | | | ||| | || | | | ||| | | |||| ||||| | | || || | || || | || |||| || | || || || || | || || || | || | | ||| | | |||| || || | | || | || ||| | | | |||| |||| ||| || || | || |||| | || | || |||| |||| | || | || | | || ||||| || | | || | || |||| | | || || || || | | || | | || | | | | || | | || | | | || | | |||| | | || || ||| ||| || | || | | ||| || | |||| || || | | || || | || || | | || ||| | | | || || | || | | || || || | | || | || ||| | || | ||||| || | || || | || | | | || | | | | || || | || | || || || | || || ||||| | || | | || | || || || || || | |||| | | || || | || || ||||| | || || || ||| || | || || || | | | | || |||| | |||| || ||| | || | || || | || ||| || FIGURE 4.2. Classiﬁcation using the Default data.Left:Estimated probabil- ity of default using linear regression. Some estimated probabilities are negative! The orange ticks indicate the 0/1 values coded for default(NoorYes).Right: Predicted probabilities of default using logistic regression. All probabilities lie between 0and1. For the Defaultdata,logisticregressionmodelstheprobabilityofdefault. For example, the probability of default given balancecan be written as Pr(default=Yes|balance). The values of Pr( default=Yes|balance), which we abbreviate p(balance),willrangebetween0and1.Thenforanygivenvalueof balance, a prediction can be made for default. For example, one might predict default =Yesfor any individual for whom p(balance)>0.5. Alterna- tively, if a company wishes to be conservative in predicting individuals who are at risk for default, then they may choose to use a lower threshold, such asp(balance)>0.1. 4.3.1 The Logistic Model How should we model the relationship between p(X)=P r (Y=1|X)a n d X? (For convenience we are using the generic 0/1 coding for the response). In Section 4.2 we talked of using a linear regression model to represent these probabilities: p(X)=β0+β1X. (4.1) If we use this approach to predict default=Yesusing balance,t h e nw e obtain the model shown in the left-hand panel of Figure 4.2. Here we see the problem with this approach: for balances close to zero we predict a negative probabilityof default; if we were to predict for verylargebalances, we would get values bigger than 1. These predictions are not sensible, since of course the true probability of default, regardless of credit card balance, must fall between 0 and 1. This problem is not unique to the credit default data. Any time a straight line is ﬁt to a binary response that is coded as 132 4. Classiﬁcation 0 or 1, in principle we can always predict p(X)<0 for some values of X andp(X)>1 for others (unless the range of Xis limited). To avoid this problem, we must model p(X) using a function that gives outputs between 0 and 1 for all values of X. Many functions meet this description. In logistic regression, we use the logistic function ,logistic function p(X)=eβ0+β1X 1+eβ0+β1X. (4.2) To ﬁt the model (4.2), we use a method called maximum likelihood ,w h i c hmaximum likelihood wediscuss inthe nextsection.The right-handpanel ofFigure4.2illustrates the ﬁt of the logistic regression model to the Defaultdata. Notice that for low balanceswe now predict the probabilityofdefault as closeto, but never below, zero. Likewise, for high balances we predict a default probability close to, but never above, one. The logistic function will always produce anS-shaped curve of this form, and so regardless of the value of X,w e will obtain a sensible prediction. We also see that the logistic model is better able to capturethe rangeofprobabilitiesthan isthe linearregression model in the left-hand plot. The average ﬁtted probability in both cases is 0.0333 (averaged over the training data), which is the same as the overall proportion of defaulters in the data set. After a bit of manipulation of (4.2), we ﬁnd that p(X) 1−p(X)=eβ0+β1X. (4.3) The quantity p(X)/[1−p(X)] is called the odds,a n dc a nt a k eo na n yv a l u eoddsbetween 0 and ∞. Values of the odds close to 0 and ∞indicate very low and very high probabilitiesof default, respectively.For example, on average 1 in 5 people with an odds of 1 /4 will default, since p(X)=0.2 implies an odds of0.2 1−0.2=1/4. Likewise on average nine out of every ten people with an odds of 9 will default, since p(X)=0.9 implies an odds of0.9 1−0.9=9 . Odds are traditionally used instead of probabilities in horse-racing, since they relate more naturally to the correct betting strategy. By taking the logarithm of both sides of (4.3), we arrive at log/parenleftbiggp(X) 1−p(X)/parenrightbigg =β0+β1X. (4.4) The left-hand side is called the log-odds orlogit. We see that the logisticlog-odds logitregression model (4.2) has a logit that is linear in X. Recall from Chapter 3 that in a linear regression model, β1gives the average change in Yassociated with a one-unit increase in X. In contrast, in alogisticregressionmodel,increasing Xbyoneunit changesthelogodds byβ1(4.4), or equivalently it multiplies the odds by eβ1(4.3). However, because the relationship between p(X)a n dXin (4.2) is not a straight line, 4.3 Logistic Regression 133 β1doesnotcorrespond to the change in p(X) associated with a one-unit increase in X. The amount that p(X) changes due to a one-unit change in Xwill depend on the current value of X. But regardless of the value of X, ifβ1is positive then increasing Xwill be associated with increasing p(X), and ifβ1is negative then increasing Xwill be associated with decreasing p(X). The fact that there is not a straight-line relationship between p(X) andX, and the fact that the rate of change in p(X) per unit change in X depends on the current value of X, can also be seen by inspection of the right-hand panel of Figure 4.2. 4.3.2 Estimating the Regression Coeﬃcients The coeﬃcients β0andβ1in (4.2) are unknown, and must be estimated basedontheavailabletrainingdata.InChapter3,weusedtheleastsquares approach to estimate the unknown linear regression coeﬃcients. Although we could use (non-linear) least squares to ﬁt the model (4.4), the more general method of maximum likelihood is preferred, since it has better sta- tistical properties. The basic intuition behind using maximum likelihood to ﬁt a logistic regression model is as follows: we seek estimates for β0and β1such that the predicted probability ˆ p(xi) of default for each individual, using (4.2), corresponds as closely as possible to the individual’s observed default status. In other words, we try to ﬁnd ˆβ0andˆβ1such that plugging these estimates into the model for p(X), given in (4.2), yields a number close to one for all individuals who defaulted, and a number close to zero for all individuals who did not. This intuition can be formalized using a mathematical equation called a likelihood function :likelihood function/lscript(β0,β1)=/productdisplay i:yi=1p(xi)/productdisplay i/prime:yi/prime=0(1−p(xi/prime)). (4.5) The estimates ˆβ0andˆβ1are chosen to maximize this likelihood function. Maximum likelihood is a very general approach that is used to ﬁt many of the non-linear models that we examine throughout this book. In the linear regressionsetting, the least squares approach is in fact a special case of maximum likelihood. The mathematical details of maximum likelihood are beyond the scope of this book. However, in general, logistic regression and other models can be easily ﬁt using a statistical software package such asR, and so we do not need to concern our selves with the details of the maximum likelihood ﬁtting procedure. Table 4.1 shows the coeﬃcient estim ates and related information that result from ﬁtting a logistic regression model on the Defaultdata in order to predict the probability of default=Yesusing balance.W es e et h a t ˆβ1= 0.0055; this indicates that an increase in balance is associated with an increase in the probability of default. To be precise, a one-unit increase in balanceis associated with an increase in the log odds of defaultby 0.0055 units. 134 4. Classiﬁcation Coeﬃcient Std. error Z-statistic P-value Intercept −10.6513 0.3612 −29.5<0.0001 balance 0.0055 0.0002 24.9 <0.0001 TABLE 4.1. For the Default data, estimated coeﬃcients of the logistic regres- sion model that predicts the probability of default using balance.Ao n e - u n i t increase in balance is associated with an increase in the log odds of default by 0.0055units. Many aspects of the logistic regression output shown in Table 4.1 are similar to the linear regression output of Chapter 3. For example, we can measure the accuracy of the coeﬃcient estimates by computing their stan- darderrors.The z-statisticin Table4.1playsthesameroleasthe t-statistic in the linear regression output, for example in Table 3.1 on page 68. For instance, the z-statistic associated with β1is equal to ˆβ1/SE(ˆβ1), and so a large (absolute) value of the z-statistic indicates evidence against the null hypothesis H0:β1= 0. This null hypothesis implies that p(X)=eβ0 1+eβ0— in other words, that the probability of defaultdoes not depend on balance. Since the p-value associated with balancein Table 4.1 is tiny, we can reject H0.In otherwords,weconclude that th ereis indeedanassociationbetween balanceand probability of default. The estimated intercept in Table 4.1 is typically not of interest; its main purpose is to adjust the average ﬁtted probabilities to the proportion of ones in the data. 4.3.3 Making Predictions Once the coeﬃcients have been estimated, it is a simple matter to compute the probability of defaultfor any given credit card balance. For example, usingthecoeﬃcientestimatesgiveninTable4.1,wepredictthatthedefault probability for an individual with a balanceof $1,000 is ˆp(X)=eˆβ0+ˆβ1X 1+eˆβ0+ˆβ1X=e−10.6513+0.0055×1,000 1+e−10.6513+0.0055×1,000=0.00576, which is below 1%. In contrast, the predicted probability of default for an individual with a balance of $2 ,000 is much higher, and equals 0 .586 or 58.6%. One can use qualitative predictors with the logistic regression model using the dummy variable approach from Section 3.3.1. As an example, the Defaultdata set contains the qualitative variable student.T oﬁ tt h e model we simply create a dummy variable that takes on a value of 1 for students and 0 for non-students. The logistic regression model that results from predicting probability of default from student status can be seen in Table 4.2. The coeﬃcient associated with the dummy variable is positive, 4.3 Logistic Regression 135 Coeﬃcient Std. error Z-statistic P-value Intercept −3.5041 0.0707 −49.55<0.0001 student[Yes] 0.4049 0.1150 3.52 0.0004 TABLE 4.2. For the Default data, estimated coeﬃcients of the logistic regres- sion model that predicts the probability of default using student status. Student status is encoded as a dummy variable, with a value of 1for a student and a value of0for a non-student, and represented by the variable student[Yes] in the table. and the associated p-value is statistically signiﬁcant. This indicates that students tend to have higher default probabilities than non-students: /hatwiderPr(default=Yes|student=Yes)=e−3.5041+0.4049×1 1+e−3.5041+0.4049×1=0.0431, /hatwiderPr(default=Yes|student=No)=e−3.5041+0.4049×0 1+e−3.5041+0.4049×0=0.0292. 4.3.4 Multiple Logistic Regression We nowconsiderthe problemofpredictingabinaryresponseusingmultiple predictors. By analogy with the extension from simple to multiple linear regression in Chapter 3, we can generalize (4.4) as follows: log/parenleftbiggp(X) 1−p(X)/parenrightbigg =β0+β1X1+···+βpXp, (4.6) whereX=(X1,...,X p)a r eppredictors. Equation 4.6 can be rewritten as p(X)=eβ0+β1X1+···+βpXp 1+eβ0+β1X1+···+βpXp. (4.7) Just asin Section 4.3.2,weuse themaximum likelihoodmethod toestimate β0,β1,...,β p. Table 4.3 shows the coeﬃcient estimat es for a logistic regression model that uses balance,income(in thousands of dollars), and studentstatus to predict probability of default. There is a surprising result here. The p- values associated with balanceand the dummy variable for studentstatus are very small, indicating that each of these variables is associated with the probability of default. However, the coeﬃcient for the dummy variable is negative, indicating that students are less likely to default than non- students. In contrast, the coeﬃcient f or the dummy variable is positive in Table 4.2. How is it possible for student status to be associated with an increase in probability of default in Table 4.2 and a decrease in probability of default in Table 4.3? The left-hand panel of Figure 4.3 provides a graph- ical illustration of this apparent paradox. The orange and blue solid lines show the average default rates for students and non-students, respectively, 136 4. Classiﬁcation Coeﬃcient Std. error Z-statistic P-value Intercept −10.8690 0.4923 −22.08<0.0001 balance 0.0057 0.0002 24.74 <0.0001 income 0.0030 0.0082 0.37 0.7115 student[Yes] −0.6468 0.2362 −2.74 0.0062 TABLE 4.3. For the Default data, estimated coeﬃcients of the logistic regres- sion model that predicts the probability of default using balance,income,a n d student status. Student status is encoded as a dummy variable student[Yes] , with a value of 1for a student and a value of 0for a non-student. In ﬁtting this model, incomewas measured in thousands of dollars. as a function of credit card balance. The negative coeﬃcient for studentin the multiple logistic regression indicates that for a ﬁxed value of balance and income, a student is less likely to default than a non-student. Indeed, we observe from the left-hand panel of Figure 4.3 that the student default rate is at or below that of the non-student default rate for every value of balance. But the horizontal broken lines near the base of the plot, which show the default rates for students and non-students averaged over all val- ues of balanceand income, suggest the opposite eﬀect: the overall student defaultrateishigherthanthenon-studentdefaultrate.Consequently,there is a positive coeﬃcient for studentin the single variable logistic regression output shown in Table 4.2. The right-hand panel of Figure 4.3 provides an explanation for this dis- crepancy. The variables studentand balanceare correlated. Students tend to hold higher levels of debt, which is in turn associated with higher prob- ability of default. In other words, students are more likely to have large credit card balances, which, as we k now from the left-hand panel of Fig- ure 4.3, tend to be associated with hi gh default rates. Thus, even though an individual student with a given credit card balance will tend to have a lower probability of default than a non-student with the same credit card balance, the fact that students on the whole tend to have higher credit card balances means that overall, students tend to default at a higher rate than non-students. This is an important distinction for a credit card company that is trying to determine to whom they should oﬀer credit. A student is riskier than a non-student if no information about the student’s credit card balance is available. However, that student is less risky than a non-student with the same credit card balance ! This simple example illustrates the dangers and subtleties associated with performing regressions involving only a single predictor when other predictors may also be relevant. As in the linear regression setting, the results obtained using one predictor may be quite diﬀerent from those ob- tained using multiple predictors,esp ecially whenthere iscorrelationamong the predictors. In general, the phenomenon seen in Figure 4.3 is known as confounding .confounding 4.3 Logistic Regression 137 Credit Card BalanceDefault Rate 500 1000 1500 20000.0 0.2 0.4 0.6 0.8 Yes No0 500 1000 1500 2000 2500 Student StatusCredit Card Balance FIGURE 4.3. Confounding in the Default data.Left:Default rates are shown for students (orange) and non-students (blue). The solid lines display default rate as a function of balance, while the horizontal broken lines display the overall default rates. Right:Boxplots of balance for students (orange) and non-students (blue) are shown. By substituting estimates for the regression coeﬃcients from Table 4.3 into (4.7), we can make predictions. For example, a student with a credit card balance of $1 ,500 and an income of $40 ,000 has an estimated proba- bility of default of ˆp(X)=e−10.869+0.00574×1,500+0.003×40−0.6468×1 1+e−10.869+0.00574×1,500+0.003×40−0.6468×1=0.058.(4.8) A non-student with the same balance and income has an estimated prob- ability of default of ˆp(X)=e−10.869+0.00574×1,500+0.003×40−0.6468×0 1+e−10.869+0.00574×1,500+0.003×40−0.6468×0=0.105.(4.9) (Here we multiply the incomecoeﬃcient estimate from Table 4.3 by 40, rather than by 40,000, because in that table the model was ﬁt with income measured in units of $1 ,000.) 4.3.5 Logistic Regression for >2 Response Classes We sometimes wish to classify a response variable that has more than two classes. For example, in Section 4.2 we had three categories of medical con- dition in the emergency room: stroke,drug overdose ,epileptic seizure . In this setting, we wish to model both Pr( Y=stroke|X)a n dP r ( Y= drug overdose |X), with the remaining Pr( Y=epileptic seizure |X)= 1−Pr(Y=stroke|X)−Pr(Y=drug overdose |X). The two-class logis- tic regression models discussed in the previous sections have multiple-class extensions, but in practice they tend not to be used all that often. One of the reasons is that the method w e discuss in the next section, discriminant 138 4. Classiﬁcation analysis, is popular for multiple-class classiﬁcation. So we do not go into the details of multiple-class logistic regression here, but simply note that such an approach is possible, and that software for it is available in R. 4.4 Linear Discriminant Analysis Logistic regression involves directly modeling Pr( Y=k|X=x)u s i n gt h e logistic function, given by (4.7) for the case of two response classes. In statistical jargon, we model the conditional distribution of the response Y, given the predictor(s) X. We now consider an alternative and less direct approach to estimating these probabilities. In this alternative approach, we model the distribution of the predictors Xseparately in each of the response classes (i.e. given Y), and then use Bayes’ theorem to ﬂip these around into estimates for Pr( Y=k|X=x). When these distributions are assumed to be normal, it turns out that the model is very similar in form to logistic regression. Why do we need another method, when we have logistic regression? There are several reasons: •When the classes are well-separated, the parameter estimates for the logistic regression model are surprisingly unstable. Linear discrimi- nant analysis does not suﬀer from this problem. •Ifnis small and the distribution of the predictors Xis approximately normal in each of the classes, the linear discriminant model is again more stable than the logistic regression model. •As mentioned in Section 4.3.5, linear discriminant analysis is popular when we have more than two response classes. 4.4.1 Using Bayes’ Theorem for Classiﬁcation Suppose that wewishto classifyanobservationinto oneof Kclasses,where K≥2. In other words, the qualitative response variable Ycan take on K possible distinct and unordered values. Let πkrepresentthe overallor priorpriorprobability that a randomly chosen observation comes from the kth class; this is the probability that a given observation is associated with the kth category of the response variable Y.L e tfk(X)≡Pr(X=x|Y=k)d e n o t e thedensity function ofXfor an observation that comes from the kth class.density function In other words, fk(x) is relatively large if there is a high probability that an observation in the kth class has X≈x,a n dfk(x) is small if it is very 4.4 Linear Discriminant Analysis 139 unlikely that an observation in the kth class has X≈x.T h e nBayes’ theoremstates thatBayes’ theorem Pr(Y=k|X=x)=πkfk(x)/summationtextK l=1πlfl(x). (4.10) In accordancewith our earlier notation, we will use the abbreviation pk(X) =P r (Y=k|X). This suggests that instead of directly computing pk(X) as in Section 4.3.1, we can simply plug in estimates of πkandfk(X)i n t o (4.10). In general, estimating πkis easy if we have a random sample of Ys from the population: we simply compute the fraction of the training observations that belong to the kth class. However, estimating fk(X) tends to be more challenging, unless we assume some simple forms for these densities. We refer to pk(x)a st h eposterior probability that an observationposteriorX=xbelongs to the kth class. That is, it is the probability that the observation belongs to the kth class, giventhe predictor value for that observation. We know from Chapter 2 that the Bayes classiﬁer, which classiﬁes an observation to the class for which pk(X) is largest, has the lowest possible error rate out of all classiﬁers. (This is of course only true if the terms in (4.10) are all correctly speciﬁed.) Therefore, if we can ﬁnd a way to estimate fk(X), then we can develop a classiﬁer that approximates the Bayes classiﬁer. Such an approach is the topic of the following sections. 4.4.2 Linear Discriminant Analysis for p=1 For now, assume that p= 1—that is, we have only one predictor. We would like to obtain an estimate for fk(x) that we can plug into (4.10) in order to estimate pk(x). We will then classify an observation to the class for which pk(x) is greatest. In order to estimate fk(x), we will ﬁrst make some assumptions about its form. Suppose we assume that fk(x)i snormalorGaussian .I n t h e o n e -normal Gaussian dimensional setting, the normal density takes the form fk(x)=1√ 2πσkexp/parenleftbigg −1 2σ2 k(x−μk)2/parenrightbigg , (4.11) whereμkandσ2 kare the mean and variance parameters for the kth class. For now,let us further assume that σ2 1=...=σ2 K: thatis,there is a shared variance term across all Kclasses, which for simplicity we can denote by σ2. Plugging (4.11) into (4.10), we ﬁnd that pk(x)=πk1√ 2πσexp/parenleftbig −1 2σ2(x−μk)2/parenrightbig /summationtextK l=1πl1√ 2πσexp/parenleftbig −1 2σ2(x−μl)2/parenrightbig. (4.12) (Note that in (4.12), πkdenotes the prior probability that an observation belongs to the kth class, not to be confused with π≈3.14159, the math- ematical constant.) The Bayes classiﬁer involves assigning an observation 140 4. Classiﬁcation −4 −2 0 2 4 −3 −2 −1 2 01 34012345 FIGURE 4.4. Left:Two one-dimensional normal density functions are shown. The dashed vertical line represents the Bayes decision boundary. Right:20 obser- vations were drawn from each of the two classes, and are shown as histograms. The Bayes decision boundary is again shown as a dashed vertical line. The solid vertical line represents the LDA decision boundary estimated from the training data. X=xto the class for which (4.12) is largest. Taking the log of (4.12) and rearranging the terms, it is not hard to show that this is equivalent to assigning the observation to the class for which δk(x)=x·μk σ2−μ2 k 2σ2+log(πk) (4.13) is largest. For instance, if K=2a n d π1=π2, then the Bayes classiﬁer assigns an observation to class 1 if 2 x(μ1−μ2)>μ2 1−μ2 2,a n dt oc l a s s 2 otherwise. In this case, the Bayes decision boundary corresponds to the point where x=μ2 1−μ2 2 2(μ1−μ2)=μ1+μ2 2. (4.14) An exampleisshownintheleft-handpanelofFigure4.4.Thetwonormal density functions that aredisplayed, f1(x)a n df2(x), representtwo distinct classes. The mean and variance parameters for the two density functions areμ1=−1.25,μ2=1.25, andσ2 1=σ2 2= 1. The two densities overlap, andsogiventhat X=x, thereis some uncertaintyabout the classto which the observation belongs. If we assume that an observation is equally likely to come from either class—that is, π1=π2=0.5—then by inspection of (4.14), we see that the Bayes classiﬁer assigns the observation to class 1 ifx<0 and class 2 otherwise. Note that in this case, we can compute the Bayes classiﬁer because we know that Xis drawn from a Gaussian distribution within each class, and we know all of the parameters involved. In a real-life situation, we are not able to calculate the Bayes classiﬁer. Inpractice,evenifwearequitecertainofourassumptionthat Xisdrawn from a Gaussian distribution within each class, we still have to estimate the parameters μ1,...,μ K,π1,...,π K,a n dσ2.T h elinear discriminant 4.4 Linear Discriminant Analysis 141 analysis (LDA) method approximates the Bayes classiﬁer by plugging esti-linear discriminant analysismates for πk,μk,a n dσ2into (4.13). In particular, the following estimates are used: ˆμk=1 nk/summationdisplay i:yi=kxi ˆσ2=1 n−KK/summationdisplay k=1/summationdisplay i:yi=k(xi−ˆμk)2(4.15) wherenis the total number of training observations, and nkis the number of training observations in the kth class. The estimate for μkis simply the average of all the training observations from the kth class, while ˆ σ2can be seen as a weighted average of the sample variances for each of the K classes. Sometimes we have knowledge of the class membership probabili- tiesπ1,...,π K, which can be used directly. In the absenceof any additional information, LDA estimates πkusing the proportion of the training obser- vations that belong to the kth class. In other words, ˆπk=nk/n. (4.16) TheLDAclassiﬁerplugstheestimatesgivenin(4.15)and(4.16)into(4.13), and assigns an observation X=xto the class for which ˆδk(x)=x·ˆμk ˆσ2−ˆμ2 k 2ˆσ2+log(ˆπk) (4.17) is largest. The word linearin the classiﬁer’s name stems from the fact that the discriminant functions ˆδk(x) in (4.17) are linear functions of x(asdiscriminant function opposed to a more complex function of x). The right-hand panel of Figure 4.4 displays a histogram of a random sample of 20 observations from each class. To implement LDA, we began byestimating πk,μk,andσ2using(4.15)and(4.16).Wethencomputedthe decision boundary, shown as a black solid line, that results from assigning an observation to the class for which (4.17) is largest. All points to the left of this line will be assigned to the green class, while points to the right of this line are assigned to the purple class. In this case, since n1=n2= 20, we have ˆ π1=ˆπ2. As a result, the decision boundary corresponds to the midpoint between the sample means for the two classes, (ˆ μ1+ˆμ2)/2. The ﬁgure indicates that the LDA decision boundary is slightly to the left of the optimal Bayes decision boundary, which instead equals ( μ1+μ2)/2= 0. How well does the LDA classiﬁer perform on this data? Since this is simulateddata,wecangeneratealarg enumberoftestobservationsinorder to compute the Bayes error rate and the LDA test error rate. These are 10.6%and11 .1%, respectively. In other words, the LDA classiﬁer’s error rate is only 0 .5% above the smallest possible error rate! This indicates that LDA is performing pretty well on this data set. 142 4. Classiﬁcation x1x1x2x2 FIGURE 4.5. Two multivariate Gaussian density functions are shown, with p=2.Left:The two predictors are uncorrelated. Right:The two variables have a correlation of 0.7. To reiterate, the LDA classiﬁer resul ts from assuming that the observa- tionswithin eachclasscomefromanormaldistribution withaclass-speciﬁc mean vector and a common variance σ2, and plugging estimates for these parameters into the Bayes classiﬁer. In Section 4.4.4, we will consider a less stringent set of assumptions, by allowing the observations in the kth class to have a class-speciﬁc variance, σ2 k. 4.4.3 Linear Discriminant Analysis for p>1 We now extend the LDA classiﬁer to the case of multiple predictors. To do this, we will assume that X=(X1,X2,...,X p)i sd r a w nf r o ma multi- variate Gaussian (or multivariatenormal)distribution, with aclass-speciﬁcmultivariate Gaussian meanvectorandacommoncovariancematrix.Webeginwithabriefreview of such a distribution. The multivariateGaussiandistributionassumesthat eachindividualpre- dictorfollowsaone-dimensionalnormaldistribution,asin(4.11),withsome correlation between each pair of predic tors. Two examples of multivariate Gaussian distributions with p= 2 are shown in Figure 4.5. The height of the surface at any particular point represents the probability that both X1 andX2fall in a small region around that point. In either panel, if the sur- faceis cutalongthe X1axisoralongthe X2axis,the resultingcross-section will havethe shape of a one-dimensionalnormal distribution. The left-hand panel of Figure 4.5 illustrates an example in which Var( X1)=V a r (X2)a n d Cor(X1,X2) = 0; this surface has a characteristic bell shape . However, the bell shape will be distorted if the predictors are correlated or have unequal variances, as is illustrated in the right-hand panel of Figure 4.5. In this situation, the base of the bell will have an elliptical, rather than circular, 4.4 Linear Discriminant Analysis 143 −4 −2 0 2 4−4 −2 0 2 4 −4 −2 0 2 4 X1−4 −2 0 2 4 X1X2 X2 FIGURE 4.6. An example with three classes. The observations from each class are drawn from a multivariate Gaussian distribution with p=2, with a class-spe- ciﬁc mean vector and a common covariance matrix. Left:Ellipses that contain 95% of the probability for each of the three classes are shown. The dashed lines are the Bayes decision boundaries. Right: 20 observations were generated from each class, and the corresponding LDA decision boundaries are indicated using solid black lines. The Bayes decision boundaries are once again shown as dashed lines. shape. To indicate that a p-dimensional random variable Xhas a multi- variate Gaussian distribution, we write X∼N(μ,Σ). HereE(X)=μis the mean of X(a vector with pcomponents), and Cov( X)=Σis the p×pcovariance matrix of X. Formally, the multivariate Gaussian density is deﬁned as f(x)=1 (2π)p/2|Σ|1/2exp/parenleftbigg −1 2(x−μ)TΣ−1(x−μ)/parenrightbigg .(4.18) In the case of p>1 predictors, the LDA classiﬁer assumes that the observations in the kth class are drawn from a multivariate Gaussian dis- tribution N(μk,Σ), where μkis a class-speciﬁc mean vector, and Σis a covariance matrix that is common to all Kclasses. Plugging the density function for the kth class, fk(X=x), into (4.10) and performing a little bit of algebra revealsthat the Bayesclassiﬁer assigns an observation X=x to the class for which δk(x)=xTΣ−1μk−1 2μT kΣ−1μk+logπk (4.19) is largest. This is the vector/matrix version of (4.13). An example is shown in the left-hand panel of Figure 4.6. Three equally- sized Gaussian classes are shown with class-speciﬁc mean vectors and a common covariance matrix. The three ellipses represent regions that con- tain 95% of the probability for each of the three classes. The dashed lines 144 4. Classiﬁcation are the Bayes decision boundaries. In other words, they represent the set of values xfor which δk(x)=δ/lscript(x); i.e. xTΣ−1μk−1 2μT kΣ−1μk=xTΣ−1μl−1 2μT lΣ−1μl(4.20) fork/negationslash=l.( T h el o g πkterm from (4.19) has disappeared because each of the three classes has the same number of training observations; i.e. πkis the same for each class.) Note that the re are three lines representing the Bayes decision boundaries because there are three pairs of classes among the three classes. That is, one Bayes decision boundary separates class 1 from class 2, one separates class 1 fro m class 3, and one separates class 2 from class 3. These three Bayes decision boundaries divide the predictor space into three regions. The Bayes classiﬁer will classify an observation according to the region in which it is located. Once again, we need to estimate the unknown parameters μ1,...,μ K, π1,...,π K,a n dΣ; the formulas are similar to those used in the one- dimensional case, given in (4.15). To assign a new observation X=x, LDA plugs these estimates into (4.19) and classiﬁes to the class for which ˆδk(x) is largest. Note that in (4.19) δk(x) is a linear function of x;t h a ti s , the LDA decision rule depends on xonly through a linear combination of its elements. Once again, this is the reason for the word linearin LDA. In the right-handpanel of Figure4.6,20 observationsdrawnfromeachof the three classes are displayed, and the resulting LDA decision boundaries are shown as solid black lines. Overall, the LDA decision boundaries are pretty close to the Bayes decision boundaries, shown again as dashed lines. ThetesterrorratesfortheBayesandLDAclassiﬁersare0 .0746and0 .0770, respectively. This indicates that LDA is performing well on this data. We can perform LDA on the Defaultdata in order to predict whether or not an individual will default on the basis of credit card balance and student status. The LDA model ﬁt to the 10 ,000 training samples results in atraining error rate of 2 .75%. This sounds like a low error rate, but two caveats must be noted. •First of all, training error rates will usually be lower than test error rates, which are the real quantit y of interest. In other words, we might expect this classiﬁer to perform worse if we use it to predict whether or not a new set of individuals will default. The reason is that we speciﬁcally adjust the parameters of our model to do well on the training data. The higher the ratio of parameters pto number of samples n, the more we expect this overﬁtting to play a role. Foroverﬁttingthese data we don’t expect this to be a problem, since p=4a n d n=1 0,000. •Second, since only 3 .33% of the individuals in the training sample defaulted, a simple but useless classiﬁer that always predicts that 4.4 Linear Discriminant Analysis 145 True default status No Yes Total Predicted No9,644 252 9,896 default status Yes 23 81 104 Total9,667 333 10,000 TABLE 4.4. A confusion matrix compares the LDA predictions to the true de- fault statuses for the 10,000training observations in the Default data set. Ele- ments on the diagonal of the matrix represent individuals whose default statuses were correctly predicted, while oﬀ-diagonal elements represent individuals that were misclassiﬁed. LDA made incorrect predictions for 23individuals who did not default and for 252individuals who did default. each individual will not default, regardless of his or her credit card balance and student status, will result in an error rate of 3 .33%. In other words, the trivial nullclassiﬁer will achieve an error rate thatnullis only a bit higher than the LDA training set error rate. In practice, a binary classiﬁer such as this one can make two types of errors: it can incorrectly assign an individual who defaults to the no default category, or it can incorrectly assign an individual who does not default to thedefaultcategory. It is often of interest to determine which of these two types of errors are being made. A confusion matrix , shown for the Defaultconfusion matrix data in Table 4.4, is a convenient way to display this information. The table reveals that LDA predicted that a total of 104 people would default. Of these people, 81 actually defaulted and 23 did not. Hence only 23 out of 9,667 of the individuals who did not default were incorrectly labeled. This looks like a pretty low error rate! However, of the 333 individuals who defaulted, 252 (or 75 .7%) were missed by LDA. So while the overall error rate is low, the error rate among individuals who defaulted is very high. From the perspective of a credit card company that is trying to identify high-risk individuals, an error rate of 252 /333= 75 .7% among individuals who default may well be unacceptable. Class-speciﬁc performance is also important in medicine and biology, where the terms sensitivity andspeciﬁcity characterize the performance ofsensitivity speciﬁcitya classiﬁer or screening test. In this ca se the sensitivity is the percentage of true defaulters that are identiﬁed, a low 24.3% in this case. The speciﬁcity is the percentage of non-defaulters that are correctly identiﬁed, here (1 − 23/9,667)×100 = 99 .8%. Why does LDA do such a poor job of classifying the customers who de- fault? In other words, why does it have such a low sensitivity? As we have seen, LDA is trying to approximate the Bayes classiﬁer, which has the low- esttotalerror rate out of all classiﬁers (if the Gaussian model is correct). That is, the Bayes classiﬁer will yield the smallest possible total number of misclassiﬁed observations, irresp ective of which class the errors come from. That is, some misclassiﬁcations will result from incorrectly assigning 146 4. Classiﬁcation True default status No Yes Total Predicted No9,432 138 9,570 default status Yes235 195 430 Total9,667 333 10,000 TABLE 4.5. A confusion matrix compares the LDA predictions to the true de- fault statuses for the 10,000training observations in the Default data set, using a modiﬁed threshold value that predicts default for any individuals whose posterior default probability exceeds 20%. a customer who does not default to th e default class, and others will re- sult from incorrectly assigning a cust omer who defaults to the non-default class. In contrast, a cred it card company might particularly wish to avoid incorrectly classifying an individual who will default, whereas incorrectly classifying an individual who will not default, though still to be avoided, is less problematic. We will now see that it is possible to modify LDA in order to develop a classiﬁer that be tter meets the credit card company’s needs. The Bayes classiﬁer works by assigning an observation to the class for which the posteriorprobability pk(X) is greatest.In the two-classcase, this amounts to assigning an observation to the defaultclass if Pr(default =Yes|X=x)>0.5. (4.21) Thus, the Bayes classiﬁer, and by extension LDA, uses a threshold of 50% for the posterior probability of default in order to assign an observation to thedefaultclass. However, if we are con cerned about incorrectly pre- dicting the default status for individuals who default, then we can consider lowering this threshold. For instance, we might label any customer with a posterior probability of default above 20% to the defaultclass. In other words, instead of assigning an observation to the defaultclass if (4.21) holds, we could instead assign an observation to this class if P(default =Yes|X=x)>0.2. (4.22) TheerrorratesthatresultfromtakingthisapproachareshowninTable4.5. Now LDA predicts that 430 individuals will default. Of the 333 individuals who default, LDA correctly predicts all but 138, or 41 .4% .T h i si sav a s t improvement over the error rate of 75 .7% that resulted from using the threshold of 50%. However, this improvement comes at a cost: now 235 individuals who do not default are incorrectly classiﬁed. As a result, the overallerrorratehasincreasedslightlyto3 .73%.Butacreditcardcompany mayconsiderthis slightincreaseinthetotalerrorrateto beasmallpriceto pay for more accurate identiﬁcation of individuals who do indeed default. Figure4.7illustratesthetrade-oﬀthatresultsfrommodifyingthethresh- old value for the posterior probability of default. Various error rates are 4.4 Linear Discriminant Analysis 147 0.0 0.1 0.2 0.3 0.4 0.50.0 0.2 0.4 0.6 ThresholdError Rate FIGURE 4.7. For the Default data set, error rates are shown as a function of the threshold value for the posterior probability that is used to perform the assign- ment. The black solid line displays the overall error rate. The blue dashed line represents the fraction of defaulting customers that are incorrectly classiﬁed, and the orange dotted line indicates the fraction of errors among the non-defaulting customers. shown as a function of the threshold value. Using a threshold of 0 .5, as in (4.21), minimizes the overall error rate, shown as a black solid line. This is to be expected, since the Bayes classiﬁer uses a threshold of 0 .5a n di s known to have the lowest overall error rate. But when a threshold of 0 .5i s used, the error rate among the individuals who default is quite high (blue dashed line). As the threshold is reduced, the error rate among individuals who default decreases steadily, but the error rate among the individuals who do not default increases. How can we decide which threshold value is best? Such a decision must be based on domain knowledge , such as detailed information about the costs associated with default. TheROC curve is a popular graphic for simultaneously displaying theROC curvetwo types of errors for all possible thresholds. The name “ROC” is his- toric, and comes from communications theory. It is an acronymfor receiver operating characteristics . Figure 4.8 displays the ROC curve for the LDA classiﬁer on the training data. The overall performance of a classiﬁer, sum- marized over all possible thresholds, is given by the area under the (ROC) curve(AUC). An idealROCcurvewill hugthetop left corner,sothe largerarea under the (ROC) curvethe AUC the better the classiﬁer. For this data the AUC is 0 .95, which is close to the maximum of one so would be considered very good. We expect a classiﬁer that performs no better than chance to have an AUC of 0.5 (when evaluated on an independent test set not used in model training). ROC curves are useful for comparing diﬀerent classiﬁers, since they take into accountall possiblethresholds. It turns out that the ROCcurvefor the logistic regression model of Section 4.3.4 ﬁt to these data is virtually indis- tinguishable from this one for the LDA model, so we do not display it here. As we have seen above, varying the classiﬁer threshold changes its true positive and false positive rate. These are also called the sensitivity and onesensitivity 148 4. Classiﬁcation ROC Curve False positive rateTrue positive rate 0.0 0.2 0.4 0.6 0.8 1.00.0 0.2 0.4 0.6 0.8 1.0 FIGURE 4.8. A ROC curve for the LDA classiﬁer on the Default data. It traces out two types of error as we vary the threshold value for the posterior probability of default. The actual thresholds are not shown. The true positive rate is the sensitivity: the fraction of defaulters that are correctly identiﬁed, using a given threshold value. The false positive rate is 1-speciﬁcity: the fraction of non-defaulters that we classify incorrectly as defaulters, using that same threshold value. The ideal ROC curve hugs the top left corner, indicating a high true positive rate and a low false positive rate. The dotted line represents the “no information” classiﬁer; this is what we would expect if student status and credit card balance are not associated with probability of default. Predicted class −or Null +o rN o n - n u l l Total True −or Null True Neg. (TN) False Pos. (FP) N class+o rN o n - n u l l False Neg. (FN) True Pos. (TP) P Total N∗P∗ TABLE 4.6. Possible results when applying a classiﬁer or diagnostic test to a population. minus the speciﬁcity of our classiﬁer. Since there is an almost bewilderingspeciﬁcityarray of terms used in this context, we now give a summary. Table 4.6 shows the possible results when applying a classiﬁer (or diagnostic test) to a population. To make the connection with the epidemiology literature, we think of “+” as the “disease” that we are trying to detect, and “ −”a s the “non-disease” state. To make the connection to the classical hypothesis testing literature, we think of “ −” as the null hypothesis and “+” as the alternative (non-null) hypothesis. In the context of the Defaultdata, “+” indicates an individual who defaults, and “ −” indicates one who does not. 4.4 Linear Discriminant Analysis 149 Name Deﬁnition Synonyms False Pos. rate FP/NType I error, 1 −Speciﬁcity True Pos. rate TP/P1−Type II error, power, sensitivity, recall Pos. Pred. value TP/P∗Precision, 1 −false discovery proportion Neg. Pred. value TN/N∗ TABLE 4.7. Important measures for classiﬁcation and diagnostic testing, derived from quantities in Table 4.6. Table4.7listsmanyofthepopularperformancemeasuresthatareusedin this context. The denominators for the false positive and true positive rates aretheactualpopulationcountsineachclass.Incontrast,thedenominators for the positive predictive value and the negative predictive value are the total predicted counts for each class. 4.4.4 Quadratic Discriminant Analysis As we have discussed, LDA assumes that the observations within each class are drawn from a multivariate Gaussian distribution with a class- speciﬁc mean vector and a covariance matrix that is common to all K classes.Quadratic discriminant analysis (QDA) provides an alternativequadratic discriminant analysisapproach. Like LDA, the QDA classiﬁer results from assuming that the observations from each class are drawn from a Gaussian distribution, and plugging estimates for the parameters into Bayes’ theorem in order to per- form prediction. However, unlike LDA, QDA assumes that each class has its own covariance matrix. That is, it assumes that an observationfrom the kth class is of the form X∼N(μk,Σk), where Σkis a covariance matrix for thekth class. Under this assumption, the Bayes classiﬁer assigns an observation X=xto the class for which δk(x)=−1 2(x−μk)TΣ−1 k(x−μk)+logπk =−1 2xTΣ−1 kx+xTΣ−1 kμk−1 2μT kΣ−1 kμk+logπk(4.23) is largest. So the QDA classiﬁer involves plugging estimates for Σk,μk, andπkinto (4.23), and then assigning an observation X=xto the class for which this quantity is largest. Unlike in (4.19), the quantity xappears as aquadratic function in (4.23). This is where QDA gets its name. Why does it matter whether or not we assume that the Kclasses share a common covariance matrix? In other words, why would one prefer LDA to QDA, or vice-versa? The answer lies in the bias-variance trade-oﬀ. When there are ppredictors, then estimating a covariance matrix requires esti- matingp(p+1)/2parameters.QDA estimates a separatecovariancematrix for eachclass,for a totalof Kp(p+1)/2parameters.With 50predictorsthis is some multiple of 1,225, which is a lot of parameters. By instead assum- ing that the Kclasses share a common covariance matrix, the LDA model 150 4. Classiﬁcation −4 −2 0 2 4−4 −3 −2 −1 0 1 2 −4 −2 0 2 4−4 −3 −2 −1 0 1 2 X1 X1 X2X2 FIGURE 4.9. Left:The Bayes (purple dashed), LDA (black dotted), and QDA (green solid) decision boundaries for a two-class problem with Σ1=Σ2.T h e shading indicates the QDA decision rule. Since the Bayes decision boundary is linear, it is more accurately approximated by LDA than by QDA. Right:Details are as given in the left-hand panel, except that Σ1/negationslash=Σ2. Since the Bayes decision boundary is non-linear, it is more accurately approximated by QDA than by LDA. becomes linear in x, which means there are Kplinear coeﬃcients to esti- mate. Consequently, LDA is a much less ﬂexible classiﬁer than QDA, and so has substantially lower variance. This can potentially lead to improved prediction performance. But there is a trade-oﬀ: if LDA’s assumption that theKclasses share a common covariance matrix is badly oﬀ, then LDA can suﬀer from high bias. Roughly speaking, LDA tends to be a better bet than QDA if there are relatively few training observations and so reducing variance is crucial. In contrast, QDA is recommended if the training set is very large, so that the variance of the classiﬁer is not a major concern, or if the assumption of a common covariance matrix for the Kc l a s s e si sc l e a r l y untenable. Figure4.9illustratestheperformancesofLDAandQDAintwoscenarios. In the left-hand panel, the two Gaussian classes have a common correla- tion of 0 .7 between X1andX2. As a result, the Bayes decision boundary is linear and is accurately approximated by the LDA decision boundary. The QDA decision boundary is inferior, because it suﬀers from higher vari- ance without a corresponding decrease in bias. In contrast, the right-hand panel displays a situation in which the orange class has a correlation of 0 .7 between the variables and the blue class has a correlation of −0.7. Now the Bayes decision boundary is quadratic, and so QDA more accurately approximates this boundary than does LDA. 4.5 A Comparison of Classiﬁcation Methods 151 4.5 A Comparison of Classiﬁcation Methods In this chapter,wehaveconsideredthreediﬀerentclassiﬁcationapproaches: logistic regression, LDA, and QDA. In Chapter 2, we also discussed the K-nearest neighbors (KNN) meth od. We now consider the types of scenarios in which one approach might dominate the others. Thoughtheirmotivationsdiﬀer,thelogisticregressionandLDAmethods are closely connected. Conside r the two-class setting with p=1p r e d i c t o r , andletp1(x)an dp2(x)=1−p1(x) be theprobabilitiesthatthe observation X=xbelongs to class 1 and class 2, res pectively. In the LDA framework, we can see from (4.12) to (4.13) (and a bit of simple algebra) that the log odds is given by log/parenleftbiggp1(x) 1−p1(x)/parenrightbigg =l o g/parenleftbiggp1(x) p2(x)/parenrightbigg =c0+c1x, (4.24) wherec0andc1are functions of μ1,μ2,a n dσ2. From (4.4), we know that in logistic regression, log/parenleftbiggp1 1−p1/parenrightbigg =β0+β1x. (4.25) Both (4.24) and (4.25) are linear functions of x. Hence, both logistic re- gression and LDA produce linear decision boundaries. The only diﬀerence between the two approaches lies in the fact that β0andβ1are estimated using maximum likelihood, whereas c0andc1are computed using the esti- matedmeanandvariancefromanormaldistribution.Thissameconnection between LDA and logistic regression also holds for multidimensional data withp>1. Since logistic regression and LDA diﬀer only in their ﬁtting procedures, one might expect the two approaches to give similar results. This is often, but not always, the case. LDA assumes that the observations are drawn from a Gaussian distribution with a common covariance matrix in each class, and so can provide some improvements over logistic regression when this assumption approximately holds. Conversely, logistic regression can outperform LDA if these Gaussi an assumptions are not met. Recall from Chapter 2 that KNN takes a completely diﬀerent approach from the classiﬁers seen in this chapter. In order to make a prediction for an observation X=x,t h eKtraining observations that are closest to xare identiﬁed. Then Xis assigned to the class to which the plurality of these observations belong. Hence KNN is a completely non-parametricapproach: no assumptions are made about the shape of the decision boundary. There- fore, we can expect this approach to dominate LDA and logistic regression when the decision boundary is highly non-linear. On the other hand, KNN does not tell us which predictors are important; we don’t get a table of coeﬃcients as in Table 4.3. 152 4. Classiﬁcation SCENARIO 1 SCENARIO 2 KNN−1 KNN−CV LDA Logistic QDA KNN−1 KNN−CV LDA Logistic QDA KNN−1 KNN−CV LDA Logistic QDA0.25 0.30 0.35 0.40 0.45 0.15 0.20 0.25 0.30 0.20 0.25 0.30 0.35 0.40 0.45SCENARIO 3 FIGURE 4.10. Boxplots of the test error rates for each of the linear scenarios described in the main text. KNN−1 KNN−CV LDA Logistic QDA KNN−1 KNN−CV LDA Logistic QDA KNN−1 KNN−CV LDA Logistic QDA0.30 0.35 0.40SCENARIO 4 0.20 0.25 0.30 0.35 0.40SCENARIO 5 0.18 0.20 0.22 0.24 0.26 0.28 0.30 0.32SCENARIO 6 FIGURE 4.11. Boxplots of the test error rates for each of the non-linear sce- narios described in the main text. Finally, QDA serves as a compromise between the non-parametric KNN method and the linear LDA and logistic regression approaches. Since QDA assumes a quadratic decision boundary, it can accurately model a wider range of problems than can the linear methods. Though not as ﬂexible as KNN, QDA can perform better in the presence of a limited number of training observations because it does make some assumptions about the form of the decision boundary. To illustrate the performances of these four classiﬁcation approaches, we generated data from six diﬀerent scenarios. In three of the scenarios, the Bayes decision boundary is linear, and in the remaining scenarios it is non-linear. For each scenario, we produced 100 random training data sets. On each of these training sets, we ﬁt each method to the data and computed the resulting test error rat e on a large test set. Results for the linear scenarios are shown in Figure 4.10, and the results for the non-linear scenarios are in Figure 4.11. The KNN method requires selection of K,t h e number of neighbors. We performed KNN with two values of K:K=1 , 4.5 A Comparison of Classiﬁcation Methods 153 and a value of Kthat was chosen automatically using an approach called cross-validation , which we discuss further in Chapter 5. In each of the six scen arios, there were p= 2 predictors. The scenarios were as follows: Scenario 1: Therewere20trainingobservationsineachoftwoclasses. The observations within each class were uncorrelated random normal variables with a diﬀerent mean in each class. The left-hand panel of Figure 4.10 shows that LDA performed well in this setting, as one would expect since this is the model assumed by LDA. KNN performed poorly because it paid a price in terms of variance that was not oﬀset by a reduction in bias. QDA also performed worse than LDA, since it ﬁt a more ﬂexible classiﬁer than necessary. Since logistic regressionassumes a linear decision boundary, its results were only slightly inferior to those of LDA. Scenario 2: Details are as in Scenario 1, except that within each class, the two predictors had a correlation of −0.5. The center panel of Figure 4.10 indicates little change in the relative performances of the methods as compared to the previous scenario. Scenario 3: We generated X1andX2from the t-distribution , witht- distribution 50 observations per class. The t-distribution has a similar shape to the normal distribution, but it has a tendency to yield more extreme points—that is, more points that are far from the mean. In this set- ting, the decision boundary was still linear, and so ﬁt into the logistic regression framework. The set-up violated the assumptions of LDA, since the observations were not drawn from a normal distribution. The right-hand panel of Figure 4.10 shows that logistic regression outperformed LDA, though both methods were superior to the other approaches. In particular, the QDA results deteriorated considerably as a consequence of non-normality. Scenario 4: The data were generated fr om a normal distribution, with a correlation of 0 .5 between the predictors in the ﬁrst class, and correlation of −0.5 between the predictors in the second class. This setup corresponded to the QDA assumption, and resulted in quadratic decision boundaries. The left-hand panel of Figure 4.11 shows that QDA outperformed all of the other approaches. Scenario 5: Within each class, the obser vations were generated from a normal distribution with uncorrelated predictors. However, the re- sponses were sampled from the logistic function using X2 1,X2 2,a n d X1×X2as predictors. Consequently, there is a quadratic decision boundary. The center panel of Figure 4.11 indicates that QDA once again performed best, followed closely by KNN-CV. The linear meth- ods had poor performance. 154 4. Classiﬁcation Scenario 6: Details are as in the previous scenario, but the responses were sampled from a more complicated non-linear function. As a re- sult, even the quadratic decision boundaries of QDA could not ade- quately model the data. The right-hand panel of Figure 4.11 shows that QDA gave slightly better results than the linear methods, while the much more ﬂexible KNN-CV method gave the best results. But KNN with K= 1 gave the worst results out of all methods. This highlights the fact that even when the data exhibits a complex non- linear relationship, a non-parametric method such as KNN can still give poor results if the level of smoothness is not chosen correctly. These six examples illustrate that no one method will dominate the oth- ers in every situation. When the true decision boundaries are linear, then theLDAandlogisticregressionapproacheswilltendtoperformwell.When the boundaries are moderately non-linear, QDA may give better results. Finally, for much more complicated decision boundaries, a non-parametric approach such as KNN can be superior. But the level of smoothness for a non-parametric approach must be chosen carefully. In the next chapter we examine a number of approaches for choosing the correct level of smooth- ness and, in general, for selecting the best overall method. Finally,recallfromChapter3thatin theregressionsettingwecanaccom- modate a non-linear relationship bet ween the predictors and the response by performing regressionusing transformations of the predictors. A similar approachcould be takenin the classiﬁcationsetting. For instance, we could create a more ﬂexible version of logistic regression by including X2,X3, and even X4as predictors. This may or may not improve logistic regres- sion’s performance, depending on whether the increase in variance due to the added ﬂexibility is oﬀset by a suﬃciently large reduction in bias. We could do the same for LDA. If we added all possible quadratic terms and cross-products to LDA, the form of the model would be the same as the QDA model, although the parameter estimates would be diﬀerent. This device allows us to move somewhere between an LDA and a QDA model. 4.6 Lab: Logistic Regression, LDA, QDA, and KNN 4.6.1 The Stock Market Data We will begin by examining some numerical and graphical summaries of theSmarketdata, which is part of the ISLRlibrary. This data set consists of percentage returns for the S&P 500 stock index over 1 ,250 days, from the beginning of 2001 until the end of 2005. For each date, we have recorded the percentage returns for each of the ﬁve previous trading days, Lag1 through Lag5. We have also recorded Volume(the number of shares traded 4.6 Lab: Logistic Regression, LDA, QDA, and KNN 155 on the previous day, in billions), Today(the percentage return on the date in question) and Direction (whether the market was UporDownon this date). > library(ISLR) > names(Smarket) [1] \"Year\" \"Lag1\" \"Lag2\" \"Lag3\" \"Lag4\" [6] \"Lag5\" \"Volume\" \"Today\" \"Direction \" > dim(Smarket) [1] 1250 9 > summary(Smarket) Year Lag1 Lag2 Min. :2001 Min. :-4.92200 Min. :-4.92200 1st Qu.:2002 1st Qu.:-0.63950 1st Qu.:-0.63950 Median :2003 Median : 0.03900 Median : 0.03900 Mean :2003 Mean : 0.00383 Mean : 0.00392 3rd Qu.:2004 3rd Qu.: 0.59675 3rd Qu.: 0.59675 Max. :2005 Max. : 5.73300 Max. : 5.73300 Lag3 Lag4 Lag5 Min. :-4.92200 Min. :-4.92200 Min. :-4.92200 1st Qu.:-0.64000 1st Qu.:-0.64000 1st Qu.:-0.64000 Median : 0.03850 Median : 0.03850 Median : 0.03850 Mean : 0.00172 Mean : 0.00164 Mean : 0.00561 3rd Qu.: 0.59675 3rd Qu.: 0.59675 3rd Qu.: 0.59700 Max. : 5.73300 Max. : 5.73300 Max. : 5.73300 Volume Today Direction Min. :0.356 Min. :-4.92200 Down:602 1st Qu.:1.257 1st Qu.:-0.63950 Up :648 Median :1.423 Median : 0.03850 Mean :1.478 Mean : 0.00314 3rd Qu.:1.642 3rd Qu.: 0.59675 Max. :3.152 Max. : 5.73300 > pairs(Smarket) The cor()function produces a matrix that contains all of the pairwise correlations among the predictors in a data set. The ﬁrst command below gives an error message because the Direction variable is qualitative. > cor(Smarket) Error in cor(Smarket) : ’x’ must be numeric > cor(Smarket[,-9]) Year Lag1 Lag2 Lag3 Lag4 Lag5 Year 1.0000 0.02970 0.03060 0.03319 0.03569 0.02979 Lag1 0.0297 1.00000 -0.02629 -0.01080 -0.00299 -0.00567 Lag2 0.0306 -0.02629 1.00000 -0.02590 -0.01085 -0.00356 Lag3 0.0332 -0.01080 -0.02590 1.00000 -0.02405 -0.01881 Lag4 0.0357 -0.00299 -0.01085 -0.02405 1.00000 -0.02708 Lag5 0.0298 -0.00567 -0.00356 -0.01881 -0.02708 1.00000 Volume 0.5390 0.04091 -0.04338 -0.04182 -0.04841 -0.02200 Today 0.0301 -0.02616 -0.01025 -0.00245 -0.00690 -0.03486 Volume Today Year 0.5390 0.03010 156 4. Classiﬁcation Lag1 0.0409 -0.02616 Lag2 -0.0434 -0.01025 Lag3 -0.0418 -0.00245 Lag4 -0.0484 -0.00690 Lag5 -0.0220 -0.03486 Volume 1.0000 0.01459 Today 0.0146 1.00000 As one would expect, the correlations between the lag variables and to- day’s returns are close to zero. In other words, there appears to be little correlation between today’s returns and previous days’ returns. The only substantial correlation is between Yearand Volume. By plotting the data we see that Volumeis increasing over time. In other words, the averagenumber of shares traded daily increased from 2001 to 2005. > attach(Smarket) > plot(Volume) 4.6.2 Logistic Regression Next, we will ﬁt a logistic regression model in order to predict Direction using Lag1through Lag5and Volume.T h e glm()function ﬁts generalizedglm()linear models , aclass ofmodels thatincludes logisticregression.The syntaxgeneralized linear model of the glm()function is similar to that of lm(),e x c e p tt h a tw em u s tp a s si n the argument family=binomial in order to tell Rto run a logistic regression rather than some other type o f generalized linear model. > glm.fit=glm(Direction ∼Lag1+Lag2+Lag3+Lag4+Lag5+ Volume , data=Smarket ,family=binomial) > summary(glm.fit) Call: glm(formula = Direction ∼Lag1 + Lag2 + Lag3 + Lag4 + Lag5 + Volume , family = binomial, data = Smarket) Deviance Residuals : Min 1Q Median 3Q Max -1.45 -1.20 1.07 1.15 1.33 Coefficients: Estimate Std. Error z value Pr(>|z|) (Intercept ) -0.12600 0.24074 -0.52 0.60 Lag1 -0.07307 0.05017 -1.46 0.15 Lag2 -0.04230 0.05009 -0.84 0.40 Lag3 0.01109 0.04994 0.22 0.82 Lag4 0.00936 0.04997 0.19 0.85 Lag5 0.01031 0.04951 0.21 0.83 Volume 0.13544 0.15836 0.86 0.39 4.6 Lab: Logistic Regression, LDA, QDA, and KNN 157 (Dispersion parameter for binomial family taken to be 1) Null deviance: 1731.2 on 1249 degrees of freedom Residual deviance: 1727.6 on 1243 degrees of freedom AIC: 1742 Number of Fisher Scoring iterations : 3 The smallest p-value here is associated with Lag1. The negative coeﬃcient forthispredictorsuggeststhatifthemarkethadapositivereturnyesterday, then it is less likely to go up today. However, at a value of 0 .15, the p-value is still relatively large, and so there is no clear evidence of a real association between Lag1and Direction . We use the coef()function in order to access just the coeﬃcients for this ﬁtted model. We can also use the summary() function to access particular aspects of the ﬁtted model, such as the p-values for the coeﬃcients. > coef(glm.fit) (Intercept ) Lag1 Lag2 Lag3 Lag4 -0.12600 -0.07307 -0.04230 0.01109 0.00936 Lag5 Volume 0.01031 0.13544 > summary(glm.fit)$coef Estimate Std. Error z value Pr(>|z|) (Intercept ) -0.12600 0.2407 -0.523 0.601 Lag1 -0.07307 0.0502 -1.457 0.145 Lag2 -0.04230 0.0501 -0.845 0.398 Lag3 0.01109 0.0499 0.222 0.824 Lag4 0.00936 0.0500 0.187 0.851 Lag5 0.01031 0.0495 0.208 0.835 Volume 0.13544 0.1584 0.855 0.392 > summary(glm.fit)$coef[,4] (Intercept ) Lag1 Lag2 Lag3 Lag4 0.601 0.145 0.398 0.824 0.851 Lag5 Volume 0.835 0.392 The predict() function can be used to predict the probability that the market will go up, given values of the predictors. The type=\"response\" option tells Rto output probabilities of the form P(Y=1|X), as opposed to other information such as the logit. If no data set is supplied to the predict() function, then the probabilities are computed for the training data that wasused to ﬁt the logisticregressionmodel. Here wehaveprinted only the ﬁrst ten probabilities. We know that these values correspond to the probability of the market going up, rather than down, because the contrasts() function indicates that Rhas created a dummy variable with a1f o r Up. > glm.probs=predict(glm.fit,type=\"response \") > glm.probs[1:10] 123456789 1 0 0.507 0.481 0.481 0.515 0.511 0.507 0.493 0.509 0.518 0.489 158 4. Classiﬁcation > contrasts (Direction ) Up Down 0 Up 1 In order to make a prediction as to whether the market will go up or down on a particular day, we must convert these predicted probabilities into class labels, UporDown. The following two commands create a vector of class predictions based on whether the predicted probability of a market increase is greate rt h a no rl e s st h a n0 .5. > glm.pred=rep(\"Down\" ,1250) > glm.pred[glm.probs >.5]=\"Up\" The ﬁrst command creates a vector of 1,250 Downelements. The second line transforms to Upall of the elements for which the predicted probability of a market increase exceeds 0 .5. Given these predictions, the table()functiontable()can be used to produce a confusion matrix in order to determine how many observations were correctly or incorrectly classiﬁed. > table(glm.pred,Direction ) Direction glm.pred Down Up Down 145 141 Up 457 507 > (507+145) /1250 [1] 0.5216 > mean(glm.pred==Direction ) [1] 0.5216 The diagonalelements of the confusion matrix indicate correct predictions, while the oﬀ-diagonals represent incorrect predictions. Hence our model correctly predicted that the market would go up on 507 days and that it would go down on 145 days, for a total of 507 + 145 = 652 correct predictions. The mean()function can be used to compute the fraction of days for which the prediction was correct. In this case, logistic regression correctly predicted the movement of the market 52 .2%ofthetime. At ﬁrst glance, it appears that the logistic regression model is working a little better than random guessing. However, this result is misleading because we trained and tested the model on the same set of 1 ,250 observa- tions. In other words, 100 −52.2=4 7.8% is the training error rate. As we have seen previously, the training error rate is often overly optimistic—it tends to underestimate the test error rate. In order to better assess the ac- curacy of the logistic regression model in this setting, we can ﬁt the model using part of the data, and then examine how well it predicts the held out data. This will yield a more realistic error rate, in the sense that in prac- tice we will be interested in our model’s performance not on the data that we used to ﬁt the model, but rather on days in the future for which the market’s movements are unknown. 4.6 Lab: Logistic Regression, LDA, QDA, and KNN 159 To implement this strategy, we will ﬁrst create a vector corresponding to the observations from 2001 through 2004. We will then use this vector to create a held out data set of observations from 2005. > train=(Year <2005) > Smarket .2005= Smarket[!train ,] > dim(Smarket .2005) [1] 252 9 > Direction .2005=Direction [!train] The object trainis a vector of 1 ,250 elements, corresponding to the ob- servations in our data set. The elements of the vector that correspond to observations that occurred before 2005 are set to TRUE, whereas those that correspond to observations in 2005 are set to FALSE. The object trainis aBoolean vector, since its elements are TRUEand FALSE. Boolean vectorsbooleancan be used to obtain a subset of the rows or columns of a matrix. For instance, the command Smarket[train,] would pick out a submatrix of the stock market data set, corresponding only to the dates before 2005, since those are the ones for which the elements of trainareTRUE.T h e !symbol can be used to reverse all of the elements of a Boolean vector. That is, !trainis a vector similar to train, except that the elements that are TRUE intrainget swapped to FALSEin!train, and the elements that are FALSE intrainget swapped to TRUEin!train. Therefore, Smarket[!train,] yields a submatrix of the stock market data containing only the observations for which trainisFALSE—that is, the observations with dates in 2005. The output above indicates that there are 252 such observations. We now ﬁt a logistic regression model using only the subset of the obser- vations that correspond to dates before 2005, using the subsetargument. We then obtain predicted probabilities of the stock market going up for each of the days in our test set—that is, for the days in 2005. > glm.fit=glm(Direction ∼Lag1+Lag2+Lag3+Lag4+Lag5+ Volume , data=Smarket ,family=binomial,subset=train) > glm.probs=predict(glm.fit,Smarket .2005,type=\"response \") Notice that we have trained and test ed our model on two completely sep- arate data sets: training was performed using only the dates before 2005, and testing was performed using only the dates in 2005. Finally, we com- pute the predictions for 2005 and compare them to the actual movements of the market over that time period. > glm.pred=rep(\"Down\",252) > glm.pred[glm.probs >.5]=\"Up\" > table(glm.pred,Direction .2005) Direction .2005 glm.pred Down Up Down 77 97 Up 34 44 > mean(glm.pred==Direction .2005) 160 4. Classiﬁcation [1] 0.48 > mean(glm.pred!=Direction .2005) [1] 0.52 The !=notation means not equal to , and so the last command computes the test set error rate. The results are r ather disappointing: the test error rate is 52%, which is worse than random guessing! Of course this result is not all that surprising, given that one would not generally expect to be able to use previous days’ returns to predict future market performance. (After all, if it were possible to do so, then the authors of this book would be out striking it rich rather than writing a statistics textbook.) We recall that the logistic regression model had very underwhelming p- values associated with all of the pred ictors, and that the smallest p-value, though not very small, corresponded to Lag1. Perhaps by removing the variables that appear not to be helpful in predicting Direction ,w ec a n obtain a more eﬀective model. After all, using predictors that have no relationship with the response tends to cause a deterioration in the test error rate (since such predictors cause an increase in variance without a corresponding decrease in bias), and so removing such predictors may in turn yield animprovement.Belowwe have reﬁtthe logistic regressionusing just Lag1and Lag2, which seemed to have the highest predictive power in the original logistic regression model. > glm.fit=glm(Direction ∼Lag1+Lag2,data=Smarket , family=binomial , subset=train) > glm.probs=predict(glm.fit,Smarket .2005,type=\"response \") > glm.pred=rep(\"Down\",252) > glm.pred[glm.probs >.5]=\"Up\" > table(glm.pred,Direction .2005) Direction .2005 glm.pred Down Up Down 35 35 Up 76 106 > mean(glm.pred==Direction .2005) [1] 0.56 > 106/(106+76) [1] 0.582 Now the results appear to be more promising: 56% of the daily movements have been correctly predicted. The con fusion matrix suggests that on days when logistic regression predicts that the market will decline, it is only correct 50% of the time. However, on days when it predicts an increase in the market, it has a 58% accuracy rate. Suppose that we want to predict the returns associated with particular values of Lag1and Lag2. In particular, we want to predict Direction on a day when Lag1and Lag2equal 1.2 and 1.1, respectively, and on a day when they equal 1.5 and −0.8. We do this using the predict() function. 4.6 Lab: Logistic Regression, LDA, QDA, and KNN 161 > predict(glm.fit,newdata=data.frame(Lag1=c(1.2,1.5), Lag2=c(1.1,-0.8)),type=\"response \") 12 0.4791 0.4961 4.6.3 Linear Discriminant Analysis Now we will perform LDA on the Smarketdata. In R,w eﬁ taL D Am o d e l using the lda()function, which is part of the MASSlibrary. Notice that thelda()syntax for the lda()function is identical to that of lm(), and to that of glm()except for the absence of the familyoption. We ﬁt the model using only the observations before 2005. > library(MASS) > lda.fit=lda(Direction ∼Lag1+Lag2,data=Smarket , subset=train) > lda.fit Call: lda(Direction ∼Lag1 + Lag2, data = Smarket , subset = train) Prior probabilities of groups: Down Up 0.492 0.508 Group means: Lag1 Lag2 Down 0.0428 0.0339 Up -0.0395 -0.0313 Coefficients of linear discriminants: LD1 Lag1 -0 .642 Lag2 -0 .514 > plot(lda.fit) The LDA output indicates that ˆ π1=0.492 and ˆπ2=0.508; in other words, 49.2% of the training observations correspond to days during which the market went down. It also provides the group means; these are the average of each predictor within each class, and are used by LDA as estimates ofμk. These suggest that there is a tendency for the previous 2 days’ returns to be negative on days when the market increases, and a tendency for the previous days’ returns to be positive on days when the market declines. The coeﬃcients of linear discriminants output provides the linear combination of Lag1and Lag2that are used to form the LDA decision rule. In other words, these are the multipliers of the elements of X=xin (4.19). If −0.642×Lag1−0.514×Lag2is large, then the LDA classiﬁer will predict a market increase, and if it is small, then the LDA classiﬁer will predict a market decline. The plot()function produces plots of the linear discriminants , obtained by computing −0.642×Lag1−0.514×Lag2for each of the training observations. 162 4. Classiﬁcation The predict() function returns a list with three elements. The ﬁrst ele- ment, class,containsLDA’spredictionsaboutthemovementofthemarket. The second element, posterior , is a matrix whose kth column contains the posterior probability that the corresponding observation belongs to the kth class, computed from (4.10). Finally, xcontains the linear discriminants, described earlier. > lda.pred=predict(lda.fit, Smarket .2005) > names(lda.pred) [1] \"class\" \"posterior \" \"x\" As we observed in Section 4.5, the LDA and logistic regression predictions are almost identical. > lda.class=lda.pred$class > table(lda.class ,Direction .2005) Direction .2005 lda.pred Down Up Down 35 35 Up 76 106 > mean(lda.class==Direction .2005) [1] 0.56 Applying a 50% threshold to the posterior probabilities allows us to recre- ate the predictions contained in lda.pred$class . > sum(lda.pred$posterior[,1]> =.5) [1] 70 > sum(lda.pred$posterior[,1]<.5) [1] 182 Notice that the posterior probability output by the model corresponds to the probability that the market will decrease: > lda.pred$posterior [1:20,1] > lda.class[1:20] If we wanted to use a posterior probability threshold other than 50% in orderto make predictions, then wecould easilydo so. Forinstance, suppose thatwewishtopredictamarketdecrea seonlyifweareverycertainthatthe market will indeed decrease on that day—say, if the posterior probability is at least 90%. > sum(lda.pred$posterior[,1]>.9) [1] 0 No days in 2005 meet that threshold! In fact, the greatest posterior prob- ability of decrease in all of 2005 was 52 .02%. 4.6.4 Quadratic Discriminant Analysis We will now ﬁt a QDA model to the Smarketdata. QDA is implemented inRusing the qda()function, which is also part of the MASSlibrary. Theqda()syntax is identical to that of lda(). 4.6 Lab: Logistic Regression, LDA, QDA, and KNN 163 > qda.fit=qda(Direction ∼Lag1+Lag2,data=Smarket , subset=train) > qda.fit Call: qda(Direction ∼Lag1 + Lag2, data = Smarket , subset = train) Prior probabilities of groups: Down Up 0.492 0.508 Group means: Lag1 Lag2 Down 0.0428 0.0339 Up -0.0395 -0.0313 The output contains the group means. But it does not contain the coef- ﬁcients of the linear discriminants, because the QDA classiﬁer involves a quadratic, rather than a linear, function of the predictors. The predict() function works in exactly the same fashion as for LDA. > qda.class=predict(qda.fit,Smarket .2005)$class > table(qda.class ,Direction .2005) Direction .2005 qda.class Down Up Down 30 20 Up 81 121 > mean(qda.class==Direction .2005) [1] 0.599 Interestingly, the QDA predictions are accurate almost 60% of the time, even thoughthe 2005data was not used to ﬁt the model. This levelof accu- racy is quite impressive for stock market data, which is known to be quite hard to model accurately. This suggests that the quadratic form assumed by QDA may capture the true relationship more accurately than the linear forms assumed by LDA and logistic regression. However, we recommend evaluating this method’s performance on a larger test set before betting that this approach will consistently beat the market! 4.6.5K-Nearest Neighbors We will now perform KNN using the knn()function, which is part of theknn()classlibrary. This function works rather diﬀerently from the other model- ﬁtting functions that we have encountered thus far. Rather than a two-step approachin which we ﬁrst ﬁt the model and then we use the model to make predictions, knn()forms predictions using a single command. The function requires four inputs. 1. A matrix containing the predictors associated with the training data, labeled train.Xbelow. 2. Amatrix containingthepredictorsassociatedwith thedata forwhich we wish to make predictions, labeled test.Xbelow. 164 4. Classiﬁcation 3. A vector containing the class labels for the training observations, labeled train.Direction below. 4. A value for K, the number of nearest neighbors to be used by the classiﬁer. We use the cbind()function, short for column bind ,t ob i n dt h e Lag1andcbind()Lag2variables together into two matrices, one for the training set and the other for the test set. > library(class) > train.X=cbind(Lag1,Lag2)[train ,] > test.X=cbind(Lag1,Lag2)[!train ,] > train.Direction =Direction [train] Now the knn()function can be used to predict the market’s movement for the dates in 2005. We set a random seed before we apply knn()because if several observations are tied as nearest neighbors, then Rwill randomly break the tie. Therefore, a seed must be set in order to ensure reproducibil- ity of results. > set.seed(1) > knn.pred=knn(train.X,test.X,train.Direction ,k=1) > table(knn.pred,Direction .2005) Direction .2005 knn.pred Down Up Down 43 58 Up 68 83 > (83+43) /252 [1] 0.5 The results using K= 1 are not very good, since only 50% of the observa- tions are correctly predicte d. Of course, it may be that K= 1 results in an overly ﬂexible ﬁt to the data. Below, we repeat the analysis using K=3 . > knn.pred=knn(train.X,test.X,train.Direction ,k=3) > table(knn.pred,Direction .2005) Direction .2005 knn.pred Down Up Down 48 54 Up 63 87 > mean(knn.pred==Direction .2005) [1] 0.536 The results have improved slightly. But increasing Kfurther turns out to provide no further improvements. It appears that for this data, QDA provides the best results of the methods that we have examined so far. 4.6.6 An Application to Caravan Insurance Data Finally, we will apply the KNN approach to the Caravandata set, which is part of the ISLRlibrary. This data set includes 85 predictors that measure 4.6 Lab: Logistic Regression, LDA, QDA, and KNN 165 demographic characteristics for 5,822 individuals. The response variable is Purchase , which indicates whether or not a given individual purchases a caravan insurance policy. In this data set, only 6% of people purchased caravan insurance. > dim(Caravan) [1] 5822 86 > attach(Caravan) > summary(Purchase) No Yes 5474 348 > 348/5822 [1] 0.0598 Because the KNN classiﬁer predicts the class of a given test observation by identifying the observations that are nearest to it, the scale of the variables matters. Any variables that are on a large scale will have a much larger eﬀect on the distance between the observations, and hence on the KNN classiﬁer, than variables that are on a small scale. For instance, imagine a data set that contains two variables, salaryand age(measured in dollars and years, respectively). As far as KNN is concerned, a diﬀerence of $1,000 in salary is enormous compared to a diﬀerence of 50 years in age. Conse- quently, salarywill drive the KNN classiﬁcation results, and agewill have almost no eﬀect. This is contrary to our intuition that a salary diﬀerence of $1,000 is quite small compared to an age diﬀerence of 50 years. Further- more, the importance of scale to the KNN classiﬁer leads to another issue: if we measured salaryin Japanese yen, or if we measured agein minutes, then we’d get quite diﬀerent classiﬁcation results from what we get if these two variables are measured in dollars and years. A good way to handle this problem is to standardize t h ed a t as ot h a ta l lstandardizevariables are given a mean of zero and a standard deviation of one. Then all variables will be on a comparable scale. The scale()function does justscale()this. In standardizing the data, we exclude column 86, because that is the qualitative Purchase variable. > standardized.X= scale(Caravan[,-86]) > var(Caravan [ ,1]) [1] 165 > var(Caravan [ ,2]) [1] 0.165 > var(standardized.X[,1]) [1] 1 > var(standardized.X[,2]) [1] 1 Now every column of standardized.X has a standard deviation of one and a mean of zero. We now split the observations into a test set, containing the ﬁrst 1,000 observations, and a training set, containing the remaining observations. 166 4. Classiﬁcation We ﬁt a KNN model on the training data using K= 1, and evaluate its performance on the test data. > test=1:1000 > train.X= standardized.X[-test,] > test.X= standardized.X[test,] > train.Y=Purchase[-test] > test.Y=Purchase[test] > set.seed(1) > knn.pred=knn(train.X,test.X,train.Y,k=1) > mean(test.Y!=knn.pred) [1] 0.118 > mean(test.Y!=\"No\") [1] 0.059 The vector testis numeric, with values from 1 through 1 ,000. Typing standardized.X[test,] yields the submatrix of the data containing the ob- servations whose indices range from 1 to 1 ,000, whereas typing standardized.X[-test,] yields the submatrix containing the observations whose indices do notrange from 1 to 1 ,000. The KNN error rate on the 1,000 test observations is just under 12%. At ﬁrst glance, this may ap- pear to be fairly good. However, sin ce only 6% of customers purchased insurance, we could get the error rat e down to 6% by always predicting No regardless of the values of the predictors! Suppose that there is some non-trivial cost to trying to sell insurance to a given individual. For instance, perhaps a salesperson must visit each potential customer. If the company tries to sell insurance to a random selection of customers, then the success rate will be only 6%, which may be far too low given the costs involved. Instead, the company would like to try to sell insurance only to customers who are likely to buy it. So the overall error rate is not of interest. Instead, the fraction of individuals that are correctly predicted to buy insurance is of interest. It turns out that KNN with K= 1 does far better than random guessing among the customers that are predicted to buy insurance. Among 77 such customers, 9, or 11 .7%, actually do purchase insurance. This is double the rate that one would obtain from random guessing. > table(knn.pred,test.Y) test.Y knn.pred No Yes No 873 50 Yes 68 9 > 9/(68+9) [1] 0.117 UsingK= 3, the success rate increases to 19%, and with K=5t h er a t ei s 26.7%. This is over four times the rate that results from random guessing. It appears that KNN is ﬁnding some real patterns in a diﬃcult data set! 4.6 Lab: Logistic Regression, LDA, QDA, and KNN 167 > knn.pred=knn(train.X,test.X,train.Y,k=3) > table(knn.pred,test.Y) test.Y knn.pred No Yes No 920 54 Yes 21 5 > 5/26 [1] 0.192 > knn.pred=knn(train.X,test.X,train.Y,k=5) > table(knn.pred,test.Y) test.Y knn.pred No Yes No 930 55 Yes 11 4 > 4/15 [1] 0.267 As a comparison, we can also ﬁt a logistic regression model to the data. If we use 0 .5 as the predicted probability cut-oﬀ for the classiﬁer, then we have a problem: only seven of the test observations are predicted to purchase insurance. Even worse, we are wrong about all of these! However, we are not required to use a cut-oﬀ of 0 .5. If we instead predict a purchase any time the predicted probability of purchase exceeds 0 .25, we get much better results: we predict that 33 people will purchase insurance, and we are correct for about 33% of these people. This is over ﬁve times better than random guessing! > glm.fit=glm(Purchase ∼.,data=Caravan ,family=binomial , subset=-test) Warning message: glm.fit: fitted probabilities numerically 0 or 1 occurred > glm.probs=predict(glm.fit,Caravan[ test ,], type=\"response \") > glm.pred=rep(\"No\",1000) > glm.pred[glm.probs >.5]=\"Yes\" > table(glm.pred,test.Y) test.Y glm.pred No Yes No 934 59 Yes 7 0 > glm.pred=rep(\"No\",1000) > glm.pred[glm.probs >.25]=\" Yes\" > table(glm.pred,test.Y) test.Y glm.pred No Yes No 919 48 Yes 22 11 > 11/(22+11) [1] 0.333 168 4. Classiﬁcation 4.7 Exercises Conceptual 1. Using a little bit of algebra, prove that (4.2) is equivalent to (4.3). In other words, the logistic function representation and logit represen- tation for the logistic regression model are equivalent. 2. It was stated in the text that classifying an observation to the class for which (4.12) is largest is equivalent to classifying an observation to the class for which (4.13) is largest. Prove that this is the case. In other words, under the assumption that the observations in the kth class are drawn from a N(μk,σ2) distribution, the Bayes’ classiﬁer assignsanobservationtothe classforwhich thediscriminantfunction is maximized. 3. This problem relates to the QDA model, in which the observations within each class are drawn from a normal distribution with a class- speciﬁc mean vector and a class sp eciﬁc covariance matrix. We con- sider the simple case where p= 1; i.e. there is only one feature. Suppose that we have Kclasses, and that if an observation belongs to thekth class then Xcomes from a one-dimensional normal dis- tribution, X∼N(μk,σ2 k). Recall that the density function for the one-dimensional normal distribution is given in (4.11). Prove that in this case, the Bayes’ classiﬁer is notlinear. Argue that it is in fact quadratic. Hint: For this problem, you should follow the arguments laid out in Section 4.4.2, but without making the assumption that σ2 1=...=σ2 K. 4. When the number of features pis large, there te nds to be a deteri- oration in the performance of KNN and other localapproaches that perform prediction using only observations that are nearthe test ob- servation for which a prediction must be made. This phenomenon is known as the curse of dimensionality , and it ties into the fact thatcurse of di- mensionality non-parametric approaches often perform poorly when pis large. We will now investigate this curse. (a) Suppose that we have a set of observations, each with measure- ments on p=1f e a t u r e , X. We assume that Xis uniformly (evenly) distributed on [0 ,1]. Associated with each observation is a responsevalue. Suppose thatwe wish to predicta test obser- vation’s responseusing only observationsthat arewithin 10% of the range of Xclosest to that test observation. For instance, in ordertopredicttheresponseforatestobservationwith X=0.6, 4.7 Exercises 169 we will use observations in the range [0 .55,0.65]. On average, what fraction of the available observations will we use to make the prediction? (b) Now suppose that we have a set of observations, each with measurements on p=2f e a t u r e s , X1andX2. We assume that (X1,X2) are uniformly distributed on [0 ,1]×[0,1]. We wish to predictatestobservation’sresponseusingonlyobservationsthat are within 10% of the range of X1andwithin 10% of the range ofX2closest to that test observation. For instance, in order to predict the response for a test observation with X1=0.6a n d X2=0.35, we will use observations in the range [0 .55,0.65] for X1and in the range [0 .3,0.4] forX2. On average, what fraction of the available observations will we use to make the prediction? (c) Now suppose that we have a set of observations on p= 100 fea- tures. Again the observations are uniformly distributed on each feature, and again each feature ranges in value from 0 to 1. We wish to predict a test observatio n’s response using observations within the 10%ofeachfeature’s rangethatis closestto thattest observation. What fraction of the available observations will we use to make the prediction? (d) Using your answers to parts (a)–(c), argue that a drawback of KNN when pis large is that there are very few training obser- vations “near” any given test observation. (e) Now suppose that we wish to make a prediction for a test obser- vation by creating a p-dimensional hypercube centered around the test observation that contains, on average,10% of the train- ing observations. For p=1,2, and 100, what is the length of each side of the hypercube? Comment on your answer. Note: A hypercube is a generalization of a cube to an arbitrary number of dimensions. When p=1, a hypercube is simply a line segment, when p=2it is a square, and when p= 100it is a 100-dimensional cube. 5. We now examine the diﬀerences between LDA and QDA. (a) If the Bayes decision boundary is linear, do we expect LDA or QDA to perform better on the training set? On the test set? (b) If the Bayes decision boundary is non-linear, do we expect LDA or QDA to perform better on the training set? On the test set? (c) In general, as the sample size nincreases, do we expect the test predictionaccuracyofQDArelat iveto LDAto improve,decline, or be unchanged? Why? 170 4. Classiﬁcation (d) True or False: Even if the Bayes decision boundary for a given problem is linear, we will probably achieve a superior test er- ror rate using QDA rather than LDA because QDA is ﬂexible enoughtomodelalineardecisionboundary.Justifyyouranswer. 6. Suppose we collect data for a group of students in a statistics class with variables X1=hours studied, X2=undergrad GPA, and Y= receive an A. We ﬁt a logistic regr ession and produce estimated coeﬃcient, ˆβ0=−6,ˆβ1=0.05,ˆβ2=1 . (a) Estimate the probability that a student who studies for 40h and has an undergrad GPA of 3 .5 gets an A in the class. (b) How many hours would the student in part (a) need to study to have a 50% chance of getting an A in the class? 7. Suppose that we wish to predict whether a given stock will issue a dividend this year (“Yes” or “No”) based on X, last year’s percent proﬁt.We examinealargenumberofcompaniesanddiscoverthat the mean value of Xfor companies that issued a dividend was ¯X= 10, while the mean for those that didn’t was ¯X= 0. In addition, the variance of Xfor these two sets of companies was ˆ σ2= 36. Finally, 80% of companies issued dividends. Assuming that Xfollows a nor- mal distribution, predict the probability that a company will issue a dividend this year given th at its percentage proﬁt was X=4l a s t year. Hint: Recall that the density function for a normal random variable isf(x)=1√ 2πσ2e−(x−μ)2/2σ2. You will need to use Bayes’ theorem. 8. Suppose that we take a data set, divide it into equally-sized training and test sets, and then try out two di ﬀerent classiﬁcationprocedures. First we use logistic regression and get an error rate of 20% on the training data and 30% on the test data. Next we use 1-nearest neigh- bors (i.e. K= 1) and get an average error rate (averaged over both test and training data sets) of 18 %. Based on these results, which method should we prefer to use for classiﬁcationof new observations? Why? 9. This problem has to do with odds. (a) On average, what fraction of people with an odds of 0.37 of defaulting on their credit card payment will in fact default? (b) Suppose that an individual has a 16% chance of defaulting on her credit card payment. What are the odds that she will de- fault? 4.7 Exercises 171 Applied 10. This question should be answered using the Weeklydata set, which is part of the ISLRpackage. This data is similar in nature to the Smarketdata from this chapter’s lab, except that it contains 1 ,089 weekly returns for 21 years, from the beginning of 1990 to the end of 2010. (a) Produce some numerical and graphical summaries of the Weekly data. Do there appear to be any patterns? (b) Use the full data set to perform a logistic regression with Direction as the response and the ﬁve lag variables plus Volume as predictors. Use the summary function to print the results. Do any of the predictors appear to be statistically signiﬁcant? If so, which ones? (c) Compute the confusion matrix and overall fraction of correct predictions. Explain what the confusion matrix is telling you about the types of mistakes made by logistic regression. (d) Nowﬁtthelogisticregressionmodelusingatrainingdataperiod from 1990to 2008,with Lag2as the only predictor. Compute the confusion matrix and the overall fraction of correct predictions for the held out data (that is, the data from 2009 and 2010). (e) Repeat (d) using LDA. (f) Repeat (d) using QDA. (g) Repeat (d) using KNN with K=1 . (h) Which of these methods appears to provide the best results on this data? (i) Experiment with diﬀerent com binations of predictors, includ- ing possible transformations and interactions, for each of the methods. Report the variables, method, and associated confu- sion matrix that appears to provide the best results on the held out data. Note that you should also experiment with values for Kin the KNN classiﬁer. 11. In this problem, you will develop a model to predict whether a given car gets high or low gas mileage based on the Autodata set. (a) Create a binary variable, mpg01, that contains a 1 if mpgcontains a value above its median, and a 0 if mpgcontains a value below its median. You can compute the median using the median() function. Note you may ﬁnd it helpful to use the data.frame() function to create a single data set containing both mpg01and the other Autovariables. 172 4. Classiﬁcation (b) Explore the data graphically in order to investigate the associ- ation between mpg01and the other features. Which of the other features seem most likely to be useful in predicting mpg01?S c a t - terplots and boxplots may be useful tools to answer this ques- tion. Describe your ﬁndings. (c) Split the data into a training set and a test set. (d) Perform LDA on the training data in order to predict mpg01 using the variables that seemed most associated with mpg01in (b). What is the test error of the model obtained? (e) Perform QDA on the training data in order to predict mpg01 using the variables that seemed most associated with mpg01in (b). What is the test error of the model obtained? (f) Perform logistic regression on the training data in order to pre- dict mpg01using the variables that seemed most associated with mpg01in (b). What is the test error of the model obtained? (g) Perform KNN on the training data, with several values of K,i n order to predict mpg01. Use only the variables that seemed most associated with mpg01in (b). What test errors do you obtain? Which value of Kseems to perform the best on this data set? 12. This problem involves writing functions. (a) Write a function, Power(), that prints out the result of raising 2 to the 3rd power. In other words, your function should compute 23and print out the results. Hint: Recall that x^araises xto the power a.U s et h e print() function to output the result. (b) Create a new function, Power2() , that allows you to pass any two numbers, xand a, and prints out the value of x^a.Y o uc a n do this by beginning your function with the line > Power2=function(x,a){ Youshouldbeabletocallyourfunctionbyentering,forinstance, > Power2(3,8) onthecommandline.Thisshouldoutputthevalueof38,namely , 6,561. (c) Using the Power2() function that you just wrote, compute 103, 817, and 1313. (d) Now create a new function, Power3() , that actually returnsthe result x^aas an Robject, rather than simply printing it to the screen. That is, if you store the value x^ain an object called resultwithin your function, then you can simply return() thisreturn()result, using the following line: 4.7 Exercises 173 return(result) The line above should be the last line in your function, before the}symbol. (e) Now using the Power3() function, create a plot of f(x)=x2. Thex-axis should display a range of integers from 1 to 10, and they-axis should display x2. Label the axes appropriately, and use an appropriatetitle for the ﬁgure. Consider displayingeither thex-axis, the y-axis, or both on the log-scale. You can do this by using log=‘‘x’’ ,log=‘‘y’’ ,o r log=‘‘xy’’ as arguments to theplot()function. (f) Create a function, PlotPower() , that allows you to create a plot ofxagainst x^afor a ﬁxed aand for a range of values of x.F o r instance, if you call > PlotPower (1:10,3) then a plot should be created with an x-axis taking on values 1,2,...,10, and a y-axis taking on values 13,23,...,103. 13. Using the Bostondata set, ﬁt classiﬁcation models in order to predict whether a given suburb has a crime rate above or below the median. Explorelogisticregression,LDA, andKNN models using varioussub- sets of the predictors. Describe your ﬁndings. 5 Resampling Methods Resampling methods are an indispensable tool in modern statistics. They involverepeatedlydrawingsamplesfromatrainingsetandreﬁttingamodel of interest on each sample in order to obtain additional information about the ﬁtted model. Forexample,in ordertoestimate thevariabilityofalinear regression ﬁt, we can repeatedly draw diﬀerent samples from the training data, ﬁt a linear regression to each new sample, and then examine the extent to which the resulting ﬁts diﬀer. Such an approach may allow us to obtain information that would not be available from ﬁtting the model only once using the original training sample. Resampling approaches can be computationally expensive, because they involve ﬁtting the same statistical method multiple times using diﬀerent subsets of the training da ta. However, due to recen t advances in computing power, the computational requirements of resampling methods generally are not prohibitive. In this chapter, we discuss two of the most commonly usedresamplingmethods, cross-validation andthebootstrap .Bothmethods are important tools in the practical application of many statistical learning procedures. For example, cross-valid ation can be used to estimate the test errorassociatedwithagivenstatistica llearningmethodinordertoevaluate its performance, or to select the appropriate level of ﬂexibility. The process ofevaluatingamodel’s performanceis knownas model assessment ,w h e re asmodel assessment the processofselecting the properlevelofﬂexibility fora modelis knownas model selection . The bootstrap is used in sever al contexts, most commonlymodel selection to provide a measure of accuracy of a parameter estimate or of a given statistical learning method. G. James et al., An Introduction to Statistical Learning: with Applications in R , Springer Texts in Statistics 103, DOI 10.1007/978-1-4614-7138-7 5, ©Springer Science+Business Media New York 2013175 176 5. Resampling Methods 5.1 Cross-Validation In Chapter 2 we discuss the distinction between the test error rate and the training errorrate .Thetesterroristheaverageerrorthatresultsfromusing astatisticallearningmethodtopredicttheresponseonanewobservation— that is, a measurement that was not used in training the method. Given a data set, the use of a particular statistical learning method is warranted if it results in a low test error. The test error can be easily calculated if a designated test set is available. Unfortunately, this is usually not the case. In contrast, the training error can be easily calculated by applying the statistical learning method to the observations used in its training. But as we saw in Chapter 2, the training errorrate often is quite diﬀerent from the test errorrate, andin particularthe formercan dramaticallyunderestimate the latter. In the absence of a very large designated test set that can be used to directly estimate the test error rat e, a number of techniques can be used to estimate this quantity using the available training data. Some methods make a mathematical adjustment to the training error rate in order to estimate the test error rate. Such approaches are discussed in Chapter 6. In this section, we instead consider a class of methods that estimate the test error rate by holding out a subset of the training observations from the ﬁtting process, and then applying the statistical learning method to those held out observations. In Sections 5.1.1–5.1.4, for simplicity we assume that we are interested in performing regression with a quantitative response. In Section 5.1.5 we consider the case of classiﬁcation with a qualitative response. As we will see, the key concepts remain the same r egardless of whether the response is quantitative or qualitative. 5.1.1 The Validation Set Approach Suppose that we would like to estimate the test error associated with ﬁt- ting a particular statistical learning method on a set of observations. The validation set approach , displayed in Figure 5.1, is a very simple strategyvalidation set approach for this task. It involves randomly dividing the available set of observa- tions into two parts, a training set and avalidation set orhold-out set .T h evalidation set hold-out setmodel is ﬁt on the training set, and the ﬁtted model is used to predict the responsesforthe observationsin the validationset. The resultingvalidation set error rate—typically assessed using MSE in the case of a quantitative response—provides an estimate of the test error rate. Weillustratethevalidationsetapproachonthe Autodataset.Recallfrom Chapter 3 that there appears to be a n on-linear relationship between mpg and horsepower , and that a model that predicts mpgusing horsepower and horsepower2gives better results than a model that uses only a linear term. It is natural to wonder whether a cubic or higher-order ﬁt might provide 5.1 Cross-Validation 177 1 2 3 7 22 13n 91 FIGURE 5.1. A schematic display of the validation set approach. A set of n observations are randomly split into a training set (shown in blue, containing observations 7, 22, and 13, among others) and a validation set (shown in beige, and containing observation 91, among others). The statistical learning method is ﬁt on the training set, and its performance is evaluated on the validation set. even better results. We answer this question in Chapter 3 by looking at the p-values associated with a cubic term and higher-order polynomial terms in a linear regression. But we could also answer this question using the validation method. We randomly split the 392 observations into two sets, a training set containing 196 of the data points, and a validation set containing the remaining 196 observations. The validation set error rates that result from ﬁtting various regression models on the training sample and evaluating their performance on the validation sample, using MSE as a measure of validation set error, are shown in the left-hand panel of Figure 5.2. The validation set MSE for the quadratic ﬁt is considerably smallerthanforthelinearﬁt.However,thevalidationsetMSEforthecubic ﬁt is actually slightly larger than for the quadratic ﬁt. This implies that including a cubic term in the regression does not lead to better prediction than simply using a quadratic term. Recall that in order to create the left-hand panel of Figure 5.2, we ran- domly divided the data set into two parts, a training set and a validation set. If we repeat the process of randomly splitting the sample set into two parts, we will get a somewhat diﬀerent estimate for the test MSE. As an illustration, the right-hand panel of Figure 5.2 displays ten diﬀerent vali- dation set MSE curves from the Autodata set, produced using ten diﬀerent random splits of the observations into training and validation sets. All ten curves indicate that the model with a quadratic term has a dramatically smaller validation set MSE than the model with only a linear term. Fur- thermore, all ten curves indicate that there is not much beneﬁt in including cubic or higher-orderpolynomial terms in the model. But it is worth noting that each of the ten curves results in a diﬀerent test MSE estimate for each of the ten regression models considered. And there is no consensus among the curves as to which model results in the smallest validation set MSE. Based on the variability among these curves, all that we can conclude with any conﬁdence is that the linear ﬁt is not adequate for this data. The validation set approach is conceptually simple and is easy to imple- ment. But it has two potential drawbacks: 178 5. Resampling Methods 2468 1 016 18 20 22 24 26 28 16 18 20 22 24 26 28 Degree of PolynomialMean Squared Error 2468 1 0 Degree of PolynomialMean Squared Error FIGURE 5.2. The validation set approach was used on the Autodata set in order to estimate the test error that results from predicting mpgusing polynomial functions of horsepower .Left:Validation error estimates for a single split into training and validation data sets. Right:The validation method was repeated ten times, each time using a diﬀerent random split of the observations into a training set and a validation set. This illustrates the variability in the estimated test MSE that results from this approach. 1. As is shown in the right-hand panel of Figure 5.2, the validation esti- mate of the test error rate can be highly variable, depending on pre- cisely which observations are included in the training set and which observations are included in the validation set. 2. In the validation approach, only a subset of the observations—those that are included in the training set rather than in the validation set—are used to ﬁt the model. Since statistical methods tend to per- form worse when trained on fewer observations, this suggests that the validation set error rate may tend to overestimate the test error rate for the model ﬁt on the entire data set. In the coming subsections, we will present cross-validation , a reﬁnement of the validation set approach that addresses these two issues. 5.1.2 Leave-One-Out Cross-Validation Leave-one-out cross-validation (LOOCV)iscloselyrelatedto the validationleave-one- out cross- validationset approach of Section 5.1.1, but it attempts to address that method’s drawbacks. Like the validation set approach, LOOCV involves splitting the set of observations into two parts. However, instead of creating two subsets of comparable size, a single observation ( x1,y1) is used for the validation set, and the remaining observations {(x2,y2),...,(xn,yn)}make up the training set. The statistical learning method is ﬁt on the n−1 training observations, and a prediction ˆ y1is made for the excluded observation, usingitsvalue x1.Since(x1,y1)wasnotusedintheﬁttingprocess,MSE 1= 5.1 Cross-Validation 179 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3n n n n n· · · FIGURE 5.3. A schematic display of LOOCV. A set of ndata points is repeat- edly split into a training set (shown in blue) containing all but one observation, and a validation set that contains only t hat observation (shown in beige). The test error is then estimated by averaging the nresulting MSE’s. The ﬁrst training set contains all but observation 1, the second training set contains all but observation 2, and so forth. (y1−ˆy1)2provides an approximately unbiased estimate for the test error. But even though MSE 1is unbiased for the test error, it is a poor estimate because it is highly variable, since it is based upon a single observation (x1,y1). We can repeat the procedure by selecting ( x2,y2) for the validation data, training the statistical learning procedure on the n−1o b s e r v a t i o n s {(x1,y1),(x3,y3),...,(xn,yn)},andcomputingMSE 2=(y2−ˆy2)2.Repeat- ing this approach ntimes produces nsquared errors, MSE 1,...,MSEn. The LOOCV estimate for the test MSE is the average of these ntest error estimates: CV(n)=1 nn/summationdisplay i=1MSEi. (5.1) A schematic of the LOOCV approach is illustrated in Figure 5.3. LOOCV has a couple of major advantages over the validation set ap- proach. First, it has far less bias. In LOOCV, we repeatedly ﬁt the sta- tistical learning method using training sets that contain n−1o b s e r v a - tions, almost as many as are in the entire data set. This is in contrast to the validation set approach, in which the training set is typically around half the size of the original data set. Consequently, the LOOCV approach tends not to overestimate the test error rate as much as the validation set approach does. Second, in contrast to the validation approach which will yield diﬀerent results when app lied repeatedly due to randomness in the training/validation set splits, performing LOOCV multiple times will 180 5. Resampling Methods 2 4 6 8 10 2 4 6 8 1016 18 20 22 24 26 28 16 18 20 22 24 26 28LOOCV Degree of PolynomialMean Squared Error10−fold CV Degree of PolynomialMean Squared Error FIGURE 5.4. Cross-validation was used on the Autodata set in order to es- timate the test error that results from predicting mpgusing polynomial functions ofhorsepower .Left:The LOOCV error curve. Right: 10 -fold CV was run nine separate times, each with a diﬀerent random split of the data into ten parts. The ﬁgure shows the nine slightly diﬀerent CV error curves. always yield the same results: there is no randomness in the training/vali- dation set splits. We used LOOCV on the Autodata set in order to obtain an estimate of the test set MSE that results from ﬁtting a linear regression model to predict mpgusingpolynomialfunctionsof horsepower . Theresultsareshown in the left-hand panel of Figure 5.4. LOOCV has the potential to be expensive to implement, since the model has to be ﬁt ntimes. This can be very time consuming if nis large, and if each individual model is slow to ﬁt. With least squareslinear or polynomial regression,anamazingshortcutmakesthe costofLOOCVthe sameasthat of a single model ﬁt! The following formula holds: CV(n)=1 nn/summationdisplay i=1/parenleftbiggyi−ˆyi 1−hi/parenrightbigg2 , (5.2) where ˆyiis theith ﬁtted value from the original least squares ﬁt, and hiis the leverage deﬁned in (3.37) on page 98. This is like the ordinary MSE, except the ith residual is divided by 1 −hi. The leverage lies between 1 /n and 1, and reﬂects the amount that an observation inﬂuences its own ﬁt. Hence the residuals for high-leverage points are inﬂated in this formula by exactly the right amount for this equality to hold. LOOCV is a very general method, and can be used with any kind of predictive modeling. For example we could use it with logistic regression or linear discriminant analysis, or any of the methods discussed in later 5.1 Cross-Validation 181 1 2 3 11 76 5 11 76 5 11 76 5 11 76 5 11 76 5n 47 47 47 47 47 FIGURE 5.5. A schematic display of 5-fold CV. A set of nobservations is randomly split into ﬁve non-overlapping groups. Each of these ﬁfths acts as a validation set (shown in beige), and the remainder as a training set (shown in blue). The test error is estimated by averaging the ﬁve resulting MSE estimates. chapters. The magic formula (5.2) does not hold in general, in which case t h em o d e lh a st ob er e ﬁ t ntimes. 5.1.3k-Fold Cross-Validation An alternative to LOOCV is k-fold CV . This approach involves randomlyk-fold CVdividing the set of observations into kgroups, or folds, of approximately equal size. The ﬁrst fold is treated as a validation set, and the method is ﬁt on the remaining k−1 folds. The mean squared error, MSE 1,i s then computed on the observations in the held-out fold. This procedure is repeated ktimes; each time, a diﬀerent group of observations is treated as a validation set. This process results in kestimates of the test error, MSE1,MSE2,...,MSEk.T h ek-foldCV estimateis computedby averaging these values, CV(k)=1 kk/summationdisplay i=1MSEi. (5.3) Figure 5.5 illustrates the k-fold CV approach. Itis nothardto seethatLOOCVisa specialcaseof k-foldCVin which k is set to equal n. In practice, one typically performs k-fold CV using k=5 ork= 10. What is the advantage of using k=5o rk= 10 rather than k=n? The most obvious advantage is computational. LOOCV requires ﬁtting the statistical learning method ntimes. This has the potential to be computationally expensive (except f or linear models ﬁt by least squares, in which case formula (5.2) can be used). But cross-validation is a very general approach that can be applied to almost any statistical learning method. Some statistical learning methods have computationally intensive ﬁtting procedures, and so performing LOOCV may pose computational problems, especially if nis extremely large. In contrast, performing 10-fold 182 5. Resampling Methods 2 5 10 20 2 5 10 20 2 5 10 200.0 0.5 1.0 1.5 2.0 2.5 3.0 0.0 0.5 1.0 1.5 2.0 2.5 3.0 FlexibilityMean Squared Error FlexibilityMean Squared Error 0 5 10 15 20 FlexibilityMean Squared Error FIGURE 5.6. True and estimated test MSE for the simulated data sets in Fig- ures 2.9 ( left), 2.10 ( center) ,a n d2 . 1 1( right). The true test MSE is shown in blue, the LOOCV estimate is shown as a black dashed line, and the 10-fold CV estimate is shown in orange. The crosses indicate the minimum of each of the MSE curves. CV requires ﬁtting the learning procedure only ten times, which may be much more feasible. As we see in Section 5.1.4, there also can be other non-computational advantages to performing 5-fold or 10-fold CV, which involve the bias-variance trade-oﬀ. The right-hand panel of Figure 5.4 displays nine diﬀerent 10-fold CV estimates for the Autodata set, each resulting from a diﬀerent random split of the observations into ten folds. As we can see from the ﬁgure, there is some variability in the CV estimates as a result of the variability in how the observations are divided into ten folds. But this variability is typically much lower than the variability in the test errorestimates that results from the validation set approach (right-hand panel of Figure 5.2). When we examine real data, we do not know the truetest MSE, and so it is diﬃcult to determine the accuracy of the cross-validation estimate. However, if we examine simulated data, then we can compute the true test MSE, and can thereby evaluate the accuracy of our cross-validation results. In Figure 5.6, we plot the cross-validation estimates and true test error rates that result from applying smoothing splines to the simulated data sets illustrated in Figures 2.9–2.11 of Chapter 2. The true test MSE is displayed in blue. The black dashed and orange solid lines respectively show the estimated LOOCV and 10-fold CV estimates. In all three plots, the two cross-validation estimates are very similar. In the right-hand panel of Figure 5.6, the true test MSE and the cross-validation curves are almost identical.In the centerpanelofFigure 5.6,the twosets ofcurvesaresimilar at the lower degrees of ﬂexibility, while the CV curves overestimatethe test setMSEforhigherdegreesofﬂexibility.Intheleft-handpanelofFigure5.6, the CV curves have the correct general shape, but they underestimate the true test MSE. 5.1 Cross-Validation 183 When we perform cross-validation, our goal might be to determine how well a given statistical learning pro cedure can be expected to perform on independent data; in this case, the actual estimate of the test MSE is of interest. But at other times we are interested only in the location of theminimum point in the estimated test MSE curve . This is because we might be performing cross-validation on a number of statistical learning methods, or on a single method using diﬀerent levels of ﬂexibility, in order toidentify themethodthat resultsinthe lowesttesterror.Forthis purpose, the location of the minimum point in the estimated test MSE curve is important, but the actual value of the estimated test MSE is not. We ﬁnd in Figure 5.6 that despite the fact that they sometimes underestimate the true test MSE, all of the CV curves come close to identifying the correct levelofﬂexibility—that is,the ﬂexibility levelcorrespondingto the smallest test MSE. 5.1.4 Bias-Variance Trade-Oﬀ for k-Fold Cross-Validation We mentioned in Section 5.1.3 that k-fold CV with k<nhas a compu- tational advantage to LOOCV. But putting computational issues aside, a less obvious but potentially more important advantage of k-fold CV is that it often gives more accurate estimates of the test error rate than does LOOCV. This has to do with a bias-variance trade-oﬀ. It was mentioned in Section 5.1.1 that the validation set approach can lead to overestimates of the test error rate, since in this approach the training set used to ﬁt the statistical learning method contains only half the observations of the entire data set. Using this logic, it is not hard to see that LOOCV will give approximately unbiased estimates of the test error, since each training set contains n−1 observations, which is almost as many as the number of observations in the full data set. And performing k-fold CV for, say, k=5o rk= 10 will lead to an intermediate level of bias, since each training set contains ( k−1)n/kobservations—fewer than in the LOOCV approach, but substantially more than in the validation set approach. Therefore, from the perspective of bias reduction, it is clear that LOOCV is to be preferred to k-fold CV. However, we know that bias is not the only source for concern in an esti- mating procedure; we must also consid er the procedure’s variance. It turns outthatLOOCVhashighervariancethandoes k-foldCV with k<n.Wh y is this the case? When we perform LOOCV, we are in eﬀect averaging the outputs of nﬁtted models, each of which is trained on an almost identical set of observations; therefore, these o utputs are highly (positively) corre- lated with each other. In contrast, when we perform k-fold CV with k<n, we are averaging the outputs of kﬁtted models that are somewhat less correlated with each other, since the o verlap between the training sets in each model is smaller. Since the mean of many highly correlated quantities 184 5. Resampling Methods has higher variance than does the mean of many quantities that are not as highly correlated, the test error estimate resulting from LOOCV tends to have higher variance than does th e test error estimate resulting from k-fold CV. To summarize, there is a bias-varia nce trade-oﬀ associated with the choice of kink-fold cross-validation. Typically, given these considerations, one performs k-fold cross-validation using k=5o rk= 10, as these values have been shown empirically to yield test error rate estimates that suﬀer neither from excessively high bias nor from very high variance. 5.1.5 Cross-Validation on Classiﬁcation Problems In this chapter so far, we have illustrated the use of cross-validation in the regression setting where the outcome Yis quantitative, and so have used MSE to quantify test error. But cross-validation can also be a very useful approach in the classiﬁcation setting when Yis qualitative. In this setting, cross-validation works just as described earlier in this chapter, except that rather than using MSE to quantify test error, we instead use the number of misclassiﬁed observations. For instance, in the classiﬁcation setting, the LOOCV error rate takes the form CV(n)=1 nn/summationdisplay i=1Erri, (5.4) where Err i=I(yi/negationslash=ˆyi). Thek-fold CV error rate and validation set error rates are deﬁned analogously. As an example, we ﬁt various logistic regression models on the two- dimensional classiﬁcation data displayed in Figure 2.13. In the top-left panelofFigure5.7,the blacksolidline showsthe estimateddecisionbound- ary resulting from ﬁtting a standard logistic regression model to this data set. Since this is simulated data, we can compute the truetest error rate, which takes a value of 0 .201 and so is substantially larger than the Bayes error rate of 0 .133. Clearly logistic regression does not have enough ﬂexi- bility to model the Bayes decision boundary in this setting. We can easily extend logistic regressionto obtain a non-lineardecision boundary by using polynomial functions ofthe predictors,as wedid in the regressionsetting in Section 3.3.2. For example, we can ﬁt a quadratic logistic regression model, given by log/parenleftbiggp 1−p/parenrightbigg =β0+β1X1+β2X2 1+β3X2+β4X2 2.(5.5) The top-right panel of Figure 5.7 displays the resulting decision boundary, whichisnowcurved.However,thetesterrorratehasimprovedonlyslightly, to 0.197. A much larger improvement is apparent in the bottom-left panel 5.1 Cross-Validation 185 Degree=1 o o o oo oo o o oo oo oo oo oo oo oooo o oo o oo oo oo o oo oo o oo o ooo o ooooo ooo o o oo oo oo oo ooo oo o oo o oo ooo ooooo o oo o ooo ooo oo oo oo oo o oo o oo oo o oooo o o ooo o oo oo o oo o oooo oo oo oo oo o oo o oo oooo o oo ooo ooo o oooo o oooo o o ooo ooo ooo ooo oo oo o oo oo oooo ooDegree=2 o o o oo oo o o oo oo oo oo oo oo oooo o oo o oo oo oo o oo oo o oo o ooo o ooooo ooo o o oo oo oo oo ooo oo o oo o oo ooo ooooo o oo o ooo ooo oo oo oo oo o oo o oo oo o oooo o o ooo o oo oo o oo o oooo oo oo oo oo o oo o oo oooo o oo ooo ooo o oooo o oooo o o ooo ooo ooo ooo oo oo o oo oo oooo oo Degree=3 o o o oo oo o o oo oo oo oo oo oo oooo o oo o oo oo oo o oo oo o oo o ooo o ooooo ooo o o oo oo oo oo ooo oo o oo o oo ooo ooooo o oo o ooo ooo oo oo oo oo o oo o oo oo o oooo o o ooo o oo oo o oo o oooo oo oo oo oo o oo o oo oooo o oo ooo ooo o oooo o oooo o o ooo ooo ooo ooo oo oo o oo oo oooo ooDegree=4 o o o oo oo o o oo oo oo oo oo oo oooo o oo o oo oo oo o oo oo o oo o ooo o ooooo ooo o o oo oo oo oo ooo oo o oo o oo ooo ooooo o oo o ooo ooo oo oo oo oo o oo o oo oo o oooo o o ooo o oo oo o oo o oooo oo oo oo oo o oo o oo oooo o oo ooo ooo o oooo o oooo o o ooo ooo ooo ooo oo oo o oo oo oooo oo FIGURE 5.7. Logistic regression ﬁts on the two-dimensional classiﬁcation data displayed in Figure 2.13. The Bayes decision boundary is represented using a purple dashed line. Estimated decision boundaries from linear, quadratic, cubic and quartic (degrees 1–4) logistic regressions are displayed in black. The test error rates for the four logistic regression ﬁts are respectively 0.201,0.197,0.160,a n d 0.162, while the Bayes error rate is 0.133. of Figure 5.7, in which we have ﬁt a logistic regression model involving cubic polynomials of the predictors. Now the test error rate has decreased to 0.160. Going to a quartic polynomial (bottom-right) slightly increases the test error. In practice, for real data, the Bayes decision boundary and the test er- ror rates are unknown. So how might we decide between the four logistic regression models displayed in Figure 5.7? We can use cross-validation in order to make this decision. The left-hand panel of Figure 5.8 displays in 186 5. Resampling Methods 2468 1 00.12 0.14 0.16 0.18 0.20 0.12 0.14 0.16 0.18 0.20 Order of Polynomials UsedError Rate 0.01 0.02 0.05 0.10 0.20 0.50 1.00 1/KError Rate FIGURE 5.8. Test error (brown), training error (blue), and 10-fold CV error (black) on the two-dimensional classiﬁcation data displayed in Figure 5.7. Left: Logistic regression using polynomial functions of the predictors. The order of the polynomials used is displayed on the x-axis.Right:The KNN classiﬁer with diﬀerent values of K, the number of neighbors used in the KNN classiﬁer. black the 10-fold CV error rates that result from ﬁtting ten logistic regres- sion models to the data, using polynomial functions of the predictors up to tenth order. The true test errors are shown in brown, and the training errors are shown in blue. As we have seen previously, the training error tends to decrease as the ﬂexibility of the ﬁt increases. (The ﬁgure indicates that though the training error rate doesn’t quite decrease monotonically, it tends to decrease on the whole as th e model complexity increases.) In contrast, the test error displays a characteristic U-shape. The 10-fold CV error rate provides a pretty good approximation to the test error rate. While it somewhat underestimates the error rate, it reaches a minimum when fourth-order polynomials are used, which is very close to the min- imum of the test curve, which occurs when third-order polynomials are used. In fact, using fourth-order polynomials would likely lead to good test set performance, as the true test erro r rate is approximately the same for third, fourth, ﬁfth, and sixth-order polynomials. The right-hand panel of Figure 5.8 displays the same three curves us- ing the KNN approach for classiﬁcation, as a function of the value of K (which in this context indicates the number of neighbors used in the KNN classiﬁer, rather than the number of CV folds used). Again the training error rate declines as the method becomes more ﬂexible, and so we see that the training error rate cannot be used to select the optimal value for K. Though the cross-validation error curve slightly underestimates the test error rate, it takes on a minimum v ery close to the best value for K. 5.2 The Bootstrap 187 5.2 The Bootstrap Thebootstrap is a widely applicable and extremely powerful statistical toolbootstrapthat can be used to quantify the uncerta inty associated with a given esti- mator or statistical learning method. As a simple example, the bootstrap can be used to estimate the standard errors of the coeﬃcients from a linear regressionﬁt. In the speciﬁc caseoflinearregression,this is notparticularly useful, since we saw in Chapter 3 that standard statistical software such as Routputs such standard errors automatically. However, the power of the bootstrap lies in the fact that it can be easily applied to a wide range of statistical learning methods, including some for which a measure of vari- ability is otherwise diﬃcult to obtain and is not automatically output by statistical software. In this section we illustrate the bootstrap on a toy example in which we wish to determine the best investment allocation under a simple model. In Section 5.3 we explore the use of the bootstrap to assess the variability associated with the regression co eﬃcients in a linear model ﬁt. Suppose that we wish to invest a ﬁxed sum of money in two ﬁnancial assets that yield returns of XandY, respectively, where XandYare random quantities. We will invest a fraction αof our money in X, and will invest the remaining 1 −αinY. Since there is variability associated with the returns on these two assets, we wish to choose αto minimize the total risk, or variance, of our investment. In other words, we want to minimize Var(αX+(1−α)Y). One can show that the value that minimizes the risk is given by α=σ2 Y−σXY σ2 X+σ2 Y−2σXY, (5.6) whereσ2 X=V a r (X),σ2 Y=V a r (Y), andσXY=C o v (X,Y). In reality,the quantities σ2 X,σ2 Y,an dσXYareunknown.Wecancompute estimates for these quantities, ˆ σ2 X,ˆσ2 Y,a n dˆσXY,u s i n gad a t as e tt h a t contains past measurements for XandY. We can then estimate the value ofαthat minimizes the variance of our investment using ˆα=ˆσ2 Y−ˆσXY ˆσ2 X+ˆσ2 Y−2ˆσXY. (5.7) Figure 5.9 illustrates this approach for estimating αon a simulated data set. In each panel, we simulated 100 pairs of returns for the investments XandY. We used these returns to estimate σ2 X,σ2 Y,a n dσXY,w h i c hw e then substituted into (5.7) in order to obtain estimates for α. The value of ˆαresulting from each simulated data set ranges from 0 .532 to 0.657. It is natural to wish to quantify the accuracy of our estimate of α.T o estimate the standard deviation of ˆ α, we repeated the process of simu- lating 100 paired observations of XandY, and estimating αusing (5.7), 188 5. Resampling Methods −2 −1 0 1 2 −2 −1 0 1 2 −2 −1 0 1 2 −2 −1 0 12 XY XY−3 −2 −1 0 1 2 −3 −2 −1 0 1 2 −3 −2 −1 0 1 2 XY −2 −1 0 1 2 3 XY FIGURE 5.9. Each panel displays 100simulated returns for investments XandY. From left to right and top to bottom, the resulting estimates for α are0.576,0.532,0.657,a n d0.651. 1,000 times. We thereby obtained 1,000 estimates for α,w h i c hw ec a nc a l l ˆα1,ˆα2,...,ˆα1,000. The left-hand panel of Figure 5.10 displays a histogram of the resulting estimates. For these simulations the parameters were set to σ2 X=1,σ2 Y=1.25, andσXY=0.5, and so we know that the true value of αis 0.6.We indicated this value using a solid vertical line on the histogram. The mean over all 1,000 estimates for αis ¯α=1 1,0001,000/summationdisplay r=1ˆαr=0.5996, very close to α=0.6, and the standard deviation of the estimates is /radicaltp/radicalvertex/radicalvertex/radicalbt1 1,000−11,000/summationdisplay r=1(ˆαr−¯α)2=0.083. This gives us a very good idea of the accuracy of ˆ α:S E ( ˆα)≈0.083. So roughly speaking, for a random sample from the population, we would expect ˆαto diﬀer from αby approximately 0 .08, on average. In practice, however, the procedure for estimating SE(ˆ α) outlined above cannot be applied, because for real data we cannot generate new samples from the original population. However, the bootstrap approach allows us to use a computer to emulate the process of obtaining new sample sets, 5.2 The Bootstrap 189 0.4 0.5 0.6 0.7 0.8 0.9 0.4 0.3 0.5 0.6 0.7 0.8 0.9 0.4 0.3 0.5 0.6 0.7 0.8 0.90 50 100 150 200 0 50 100 150 200 True Bootstrap α α α FIGURE 5.10. Left:A histogram of the estimates of αobtained by generating 1,000 simulated data sets from the true population. Center:A histogram of the estimates of αobtained from 1,000 bootstrap samples from a single data set. Right:The estimates of αdisplayed in the left and center panels are shown as boxplots. In each panel, the pink line indicates the true value of α. so that we can estimate the variability of ˆ αwithout generating additional samples. Rather than repeatedly obtaining independent data sets from the population, we instead obtain distinct data sets by repeatedly sampling observations from the original data set . This approach is illustrated in Figure 5.11 on a simple data set, which we callZ, that contains only n= 3 observations. We randomly select n observations from the data set in order to produce a bootstrap data set, Z∗1. The sampling is performed with replacement , which means that thereplacementsame observation can occur more than once in the bootstrap data set. In this example, Z∗1containsthethird observationtwice,the ﬁrstobservation once,andnoinstancesofthesecondobservation.Notethatifanobservation is contained in Z∗1,t h e nb o t hi t s XandYvalues are included. We can use Z∗1to produce a new bootstrap estimate for α, which we call ˆ α∗1.T h i s procedureisrepeated Btimesforsomelargevalueof B,in ordertoproduce Bdiﬀerent bootstrap data sets, Z∗1,Z∗2,...,Z∗B,a n dBcorresponding α estimates, ˆ α∗1,ˆα∗2,...,ˆα∗B. We can compute the standard error of these bootstrap estimates using the formula SEB(ˆα)=/radicaltp/radicalvertex/radicalvertex/radicalbt1 B−1B/summationdisplay r=1/parenleftBigg ˆα∗r−1 BB/summationdisplay r/prime=1ˆα∗r/prime/parenrightBigg2 . (5.8) This serves as an estimate of the standard error of ˆ αestimated from the original data set. The bootstrap approach is illustrated in the center panel of Figure 5.10, which displays a histogram of 1,000 bootstrap estimates of α, each com- puted using a distinct bootstrap data set. This panel was constructed on the basis of a single data set, and hence could be created using real data. 190 5. Resampling Methods Obs 3 5.3 2.8 3 5.3 2.81 4.3 2.4XY Obs Original Data (Z)Z*1 Z*2 Z*B1 4.3 2.4 3 5.3 2.82 2.1 1.1XYObs 2 2.1 1.1 1 4.3 2.43 5.3 2.8XY Obs 2 2.1 1.1 1 4.3 2.42 2.1 1.1XY······· ·····························a*1 a*2 a*Bˆ ˆ ˆ FIGURE 5.11. A graphical illustration of the bootstrap approach on a small sample containing n=3observations. Each bootstrap data set contains nobser- vations, sampled with replacement from the original data set. Each bootstrap data set is used to obtain an estimate of α. Note that the histogramlooksverysimilar to the left-hand panel which dis- plays the idealized histogram of the estimates of αobtained by generating 1,000 simulated data sets from the true population. In particular the boot- strap estimate SE(ˆ α) from (5.8) is 0 .087,very close to the estimate of 0 .083 obtained using1,000simulateddata sets.The right-handpanel displaysthe information in the center and left panels in a diﬀerent way, via boxplots of the estimates for αobtained by generating 1,000 simulated data sets from the true population and using the bootstrap approach. Again, the boxplots are quite similar to each other, indicating that the bootstrap approach can be used to eﬀectively estimate the variability associated with ˆ α. 5.3 Lab: Cross-Validation and the Bootstrap In this lab, we explore the resampling techniques covered in this chapter. Some of the commands in this lab may take a while to run on your com- puter. 5.3 Lab: Cross-Validation and the Bootstrap 191 5.3.1 The Validation Set Approach We explore the use of the validation set approach in order to estimate the test error rates that result from ﬁtting various linear models on the Auto data set. Before we begin, we use the set.seed() function in order to set a seedforseedR’s random number generator, so that the reader of this book will obtain precisely the same results as those shown below. It is generally a good idea to set a random seed when performing an analysis such as cross-validation that contains an element of randomne ss, so that the results obtained can be reproduced precisely at a later time. We begin by using the sample() function to split the set of observationssample()into two halves, by selecting a random subset of 196 observations out of the original392 observations.We refer to these observations as the training set. > library(ISLR) > set.seed(1) > train=sample(392,196) (Here we use a shortcut in the sample command; see ?samplefor details.) We then use the subsetoption in lm()to ﬁt a linear regression using only the observations corresponding to the training set. > lm.fit=lm(mpg ∼horsepower ,data=Auto,subset=train) We now use the predict() function to estimate the response for all 392 observations, and we use the mean()function to calculate the MSE of the 196 observations in the validation set. Note that the -trainindex below selects only the observations that are not in the training set. > attach(Auto) > mean((mpg-predict(lm.fit,Auto))[-train]^2) [1] 26.14 Therefore, the estimated test MS E for the linear regression ﬁt is 26 .14. We can use the poly()function to estimate the test error for the polynomial and cubic regressions. > lm.fit2=lm(mpg ∼poly(horsepower ,2),data= Auto, subset=train) > mean((mpg-predict(lm. fit2, Auto ))[- train]^2) [1] 19.82 > lm.fit3=lm(mpg ∼poly(horsepower ,3),data= Auto, subset=train) > mean((mpg-predict(lm. fit3, Auto ))[- train]^2) [1] 19.78 These error rates are 19 .82 and 19 .78, respectively. If we choose a diﬀerent training set instead, then we will obtain somewhat diﬀerent errors on the validation set. > set.seed(2) > train=sample(392,196) > lm.fit=lm(mpg ∼horsepower ,subset=train) 192 5. Resampling Methods > mean((mpg-predict(lm.fit,Auto))[-train]^2) [1] 23.30 > lm.fit2=lm(mpg ∼poly(horsepower ,2),data= Auto, subset=train) > mean((mpg-predict(lm. fit2, Auto ))[- train]^2) [1] 18.90 > lm.fit3=lm(mpg ∼poly(horsepower ,3),data= Auto, subset=train) > mean((mpg-predict(lm. fit3, Auto ))[- train]^2) [1] 19.26 Using this split of the observations into a training set and a validation set, we ﬁnd that the validation set error rates for the models with linear, quadratic, and cubic terms are 23 .30, 18.90, and 19 .26, respectively. These results are consistent with our previous ﬁndings: a model that predicts mpgusing a quadratic function of horsepower performs better than a model that involves only a linear function of horsepower ,a n dt h e r ei s little evidence in favor of a model that uses a cubic function of horsepower . 5.3.2 Leave-One-Out Cross-Validation The LOOCV estimate can be automatically computed for any generalized linear model using the glm()and cv.glm() functions. In the lab for Chap-cv.glm()ter 4, we used the glm()function to perform logistic regression by passing in the family=\"binomial\" argument. But if we use glm()to ﬁt a model without passing in the familyargument, then it performs linear regression, just like the lm()function. So for instance, > glm.fit=glm(mpg ∼horsepower ,data=Auto) > coef(glm.fit) (Intercept ) horsepower 39.936 -0.158 and > lm.fit=lm(mpg ∼horsepower ,data=Auto) > coef(lm.fit) (Intercept ) horsepower 39.936 -0.158 yield identical linear regression models. In this lab, we will perform linear regression using the glm()function rather than the lm()function because the latter can be used together with cv.glm() .T h e cv.glm() function is part of the bootlibrary. > library(boot) > glm.fit=glm(mpg ∼horsepower ,data=Auto) > cv.err=cv.glm(Auto ,glm.fit) > cv.err$delta 11 24.23 24.23 The cv.glm() function produces a list with several components. The two numbers in the deltavector contain the cross-va lidation results. In this 5.3 Lab: Cross-Validation and the Bootstrap 193 case the numbers are identical (up to two decimal places) and correspond to the LOOCV statistic given in (5.1). Below, we discuss a situation in which the two numbers diﬀer. Our cross-validation estimate for the test error is approximately 24 .23. We can repeat this procedure for incr easingly complex polynomial ﬁts. To automate the process, we use the for()function to initiate a for loopfor() for loopwhich iteratively ﬁts polynomial regressions for polynomials of order i=1 toi= 5, computes the associated cross-validation error, and stores it in theith element of the vector cv.error . We begin by initializing the vector. This command will likely take a couple of minutes to run. > cv.error=rep(0,5) > for (i in 1:5){ + glm.fit=glm(mpg ∼poly(horsepower ,i),data=Auto) + cv.error[i]=cv.glm(Auto,glm.fit)$delta[1] +} > cv.error [1] 24.23 19.25 19.33 19.42 19.03 As in Figure 5.4, we see a sharp drop in the estimated test MSE between the linear and quadratic ﬁts, but then no clear improvement from using higher-order polynomials. 5.3.3k-Fold Cross-Validation The cv.glm() f u n c t i o nc a na l s ob eu s e dt oi m p l e m e n t k-fold CV. Below we usek= 10, a common choice for k,o nt h e Autodata set. We once again set a random seed and initialize a vector in which we will store the CV errors corresponding to the polynomial ﬁts of orders one to ten. > set.seed(17) > cv.error.10=rep(0 ,10) > for (i in 1:10){ + glm.fit=glm(mpg ∼poly(horsepower ,i),data=Auto) + cv.error.10[i]=cv.glm(Auto,glm.fit,K=10)$delta[1] +} > cv.error.10 [1] 24.21 19.19 19.31 19.34 18.88 19.02 18.90 19.71 18.95 19.50 Notice that the computation time is much shorter than that of LOOCV. (In principle, the computation time for LOOCV for a least squares linear model should be faster than for k-fold CV, due to the availability of the formula (5.2) for LOOCV; however, unfortunately the cv.glm() function does not make use of this formula.) We still see little evidence that using cubicorhigher-orderpolynomialtermsleadstolowertesterrorthansimply using a quadratic ﬁt. We saw in Section 5.3.2 that the two numbers associated with deltaare essentially the same when LOOCV is performed. When we instead perform k-fold CV, then the two numbers associated with deltadiﬀer slightly. The 194 5. Resampling Methods ﬁrst is the standard k-fold CV estimate, as in (5.3). The second is a bias- corrected version. On this data set, the two estimates are very similar to each other. 5.3.4 The Bootstrap We illustrate the use of the bootstrap in the simple example of Section 5.2, as well as on an example involving estimating the accuracy of the linear regression model on the Autodata set. Estimating the Accuracy of a Statistic of Interest One of the great advantages of the bootstrap approach is that it can be applied in almost all situations. No complicated mathematical calculations are required. Performing a bootstrap analysis in Rentails only two steps. First, we must create a function that computes the statistic of interest. Second, we use the boot()function, which is part of the bootlibrary, toboot()perform the bootstrap by repeatedly sampling observations from the data set with replacement. The Portfolio data set in the ISLRpackage is described in Section 5.2. To illustrate the use of the bootstrap on this data, we must ﬁrst create a function, alpha.fn() , which takes as input the ( X,Y)d a t aa sw e l la s a vector indicating which observations should be used to estimate α.T h e function then outputsthe estimatefor αbasedonthe selectedobservations. > alpha.fn=function(data,index){ + X=data$X[index] + Y=data$Y[index] + return((var(Y)-cov(X,Y))/(var(X)+var(Y)-2*cov(X,Y))) +} This function returns, or outputs, an estimate for αbased on applying (5.7) to the observations indexed by the argument index. For instance, the following command tells Rto estimate αusing all 100 observations. > alpha.fn(Portfolio ,1:100) [1] 0.576 The next command uses the sample() function to randomly select 100 ob- servations from the range 1 to 100, with replacement. This is equivalent to constructing a new bootst rap data set and recomputing ˆ αbased on the new data set. > set.seed(1) > alpha.fn(Portfolio ,sample(100,100, replace=T)) [1] 0.596 We can implement a bootstrap analysis by performing this command many times, recording all of the corresponding estimates for α, and computing 5.3 Lab: Cross-Validation and the Bootstrap 195 the resulting standard deviation. However, the boot()function automatesboot()this approach. Below we produce R=1,000 bootstrap estimates for α. > boot(Portfolio ,alpha.fn,R=1000) ORDINARY NONPARAMETRIC BOOTSTRAP Call: boot(data = Portfolio , statistic = alpha.fn, R = 1000) Bootstrap Statistics : original bias std. error t1* 0.5758 -7.315e-05 0.0886 The ﬁnal output shows that using the original data, ˆ α=0.5758, and that the bootstrap estimate for SE(ˆ α)i s0.0886. Estimating the Accuracy of a Linear Regression Model The bootstrap approach can be used to assess the variability of the coef- ﬁcient estimates and predictions fro m a statistical learning method. Here we use the bootstrap approach in order to assess the variability of the estimates for β0andβ1, the intercept and slope terms for the linear regres- sion model that uses horsepower to predict mpgin the Autodata set. We will compare the estimates obtained using the bootstrap to those obtained using the formulas for SE( ˆβ0) and SE( ˆβ1) described in Section 3.1.2. We ﬁrst create a simple function, boot.fn() , which takes in the Autodata set as well as a set of indices for the observations, and returns the intercept and slope estimates for the linear regression model. We then apply this function to the full set of 392 observations in order to compute the esti- mates of β0andβ1on the entire data set using the usual linear regression coeﬃcient estimate formulas from C hapter 3. Note that we do not need the {and}at the beginning and end of the function because it is only one line long. > boot.fn=function(data,index) + return(coef(lm(mpg ∼horsepower ,data= data, subset=index))) > boot.fn(Auto ,1:392) (Intercept ) horsepower 39.936 - 0.158 The boot.fn() function can also be used in order to create bootstrap esti- mates for the intercept and slope terms by randomly sampling from among the observations with replacement. Here we give two examples. > set.seed(1) > boot.fn(Auto,sample(392,392, replace=T)) (Intercept ) horsepower 38.739 -0.148 > boot.fn(Auto,sample(392,392, replace=T)) (Intercept ) horsepower 40.038 -0.160 196 5. Resampling Methods Next, we use the boot()function to compute the standard errors of 1,000 bootstrap estimates for the intercept and slope terms. > boot(Auto,boot.fn,1000) ORDINARY NONPARAMETRIC BOOTSTRAP Call: boot(data = Auto, statistic = boot.fn, R = 1000) Bootstrap Statistics : original bias std. error t1* 39.936 0.0297 0.8600 t2* -0.158 -0.0003 0.0074 This indicates that the bootstrap estimate for SE( ˆβ0)i s0.86, and that the bootstrap estimate for SE( ˆβ1)i s0.0074. As discussed in Section 3.1.2, standard formulas can be used to compute the standard errors for the regression coeﬃcients in a linear model. These can be obtained using the summary() function. > summary(lm(mpg ∼horsepower ,data=Auto))$coef Estimate Std. Error t value Pr(>|t|) (Intercept ) 39.936 0.71750 55.7 1.22e-187 horsepower -0.158 0.00645 -24.5 7.03e-81 The standard error estimates for ˆβ0andˆβ1obtained using the formulas from Section 3.1.2 are 0 .717 for the intercept and 0 .0064 for the slope. Interestingly, these are somewhat diﬀerent from the estimates obtained using the bootstrap. Does this indicate a problem with the bootstrap? In fact, it suggests the opposite. Recall that the standard formulas given in Equation 3.8 on page 66 rely on certain assumptions. For example, they depend ontheunknownparameter σ2,thenoisevarian ce.We thenestimate σ2using the RSS. Now although the formula for the standard errors do not rely on the linear model bein g correct, the estimate for σ2does. We see in Figure3.8onpage91thatthereis anon-linearrelationshipin thedata,and so the residuals from a linear ﬁt will be inﬂated, and so will ˆ σ2. Secondly, the standard formulas assume (somewhat unrealistically) that the xiare ﬁxed, and all the variability comes from the variation in the errors /epsilon1i.T h e bootstrap approach does not rely on any of these assumptions, and so it is likely giving a more accurate estimate of the standard errors of ˆβ0andˆβ1 than is the summary() function. Below we compute the bootstrap standard error estimates and the stan- dardlinearregressionestimatesthatresultfromﬁttingthe quadraticmodel to the data. Since this model provides a good ﬁt to the data (Figure 3.8), there is now a better correspondence between the bootstrap estimates and the standard estimates of SE( ˆβ0), SE(ˆβ1) and SE( ˆβ2). 5.4 Exercises 197 > boot.fn=function(data,index) + coefficients(lm(mpg ∼horsepower +I(horsepower ^2),data=data, subset=index)) > set.seed(1) > boot(Auto,boot.fn,1000) ORDINARY NONPARAMETRIC BOOTSTRAP Call: boot(data = Auto, statistic = boot.fn, R = 1000) Bootstrap Statistics : original bias std. error t1* 56.900 6.098e-03 2.0945 t2* -0.466 -1.777e-04 0.0334 t3* 0.001 1.324e-06 0.0001 > summary(lm(mpg ∼horsepower +I(horsepower ^2),data=Auto))$coef Estimate Std. Error t value Pr(>|t|) (Intercept ) 56.9001 1.80043 32 1.7e-109 horsepower -0.4662 0.03112 -15 2.3e-40 I(horsepower ^2) 0.0012 0.00012 10 2.2e-21 5.4 Exercises Conceptual 1. Using basic statistical properties of the variance, as well as single- variable calculus, derive (5.6). In other words, prove that αgiven by (5.6) does indeed minimize Var( αX+(1−α)Y). 2. We will now derive the probability that a given observation is part of a bootstrap sample. Suppose that we obtain a bootstrap sample from a set of nobservations. (a) What is the probability that the ﬁrst bootstrap observation is notthejth observation from the original sample? Justify your answer. (b) What is the probability that the second bootstrap observation isnotthejth observation from the original sample? (c) Argue that the probability that the jth observationis notin the bootstrap sample is (1 −1/n)n. (d) When n= 5, what is the probability that the jth observation is in the bootstrap sample? (e) When n= 100, what is the probability that the jth observation is in the bootstrap sample? 198 5. Resampling Methods (f) When n=1 0,000, what is the probability that the jth observa- tion is in the bootstrap sample? (g) Create a plot that displays, for each integer value of nfrom 1 to 100,000, the probability that the jth observation is in the bootstrap sample. Comment on what you observe. (h) We will now investigate numerically the probability that a boot- strap sample of size n= 100 contains the jth observation. Here j= 4. We repeatedly create bootstrap samples, and each time we record whether or not the fourt h observation is contained in the bootstrap sample. > store=rep(NA, 10000) > for(i in 1:10000){ store[i]=sum(sample(1:100, rep=TRUE)==4)>0 } > mean(store) Comment on the results obtained. 3. We now review k-fold cross-validation. (a) Explain how k-fold cross-validation is implemented. (b) What are the advantages and disadvantages of k-fold cross- validation relative to: i. The validation set approach? ii. LOOCV? 4. Suppose that we use some statistical learning method to make a pre- diction for the response Yfor a particular value of the predictor X. Carefully describe how we might estimate the standard deviation of our prediction. Applied 5. In Chapter 4, we used logistic regression to predict the probability of defaultusing incomeand balanceon the Defaultdata set. We will now estimate the test error of this logistic regression model using the validation set approach. Do not forget to set a random seed before beginning your analysis. (a) Fit a logistic regression model that uses incomeand balanceto predict default. (b) Using the validation set approach, estimate the test error of this model. In orderto do this, youmust perform the followingsteps: i. Split the sample set into a training set and a validation set. 5.4 Exercises 199 ii. Fit a multiple logistic regressionmodel using only the train- ing observations. iii. Obtain a prediction of default status for each individual in the validation set by computing the posterior probability of default for that individual, and classifying the individual to thedefaultcategory if the posterior probability is greater than 0.5. iv. Compute the validation set error, which is the fraction of the observations in the validation set that are misclassiﬁed. (c) Repeat the processin (b) three t imes, using three diﬀerent splits of the observations into a training set and a validation set. Com- ment on the results obtained. (d) Now consider a logistic regression model that predicts the prob- ability of defaultusing income,balance, and a dummy variable forstudent. Estimate the test error for this model using the val- idation set approach. Comment on whether or not including a dummy variable for studentleads to a reduction in the test error rate. 6. We continue to consider the use of a logistic regression model to predict the probability of defaultusing incomeand balanceon the Defaultdata set. In particular, we will now compute estimates for the standard errors of the incomeand balancelogistic regression co- eﬃcients in two diﬀerent ways: (1) using the bootstrap, and (2) using the standard formula for computing the standard errors in the glm() function. Do not forget to set a random seed before beginning your analysis. (a) Using the summary() and glm()functions, determine the esti- mated standarderrorsfor the coeﬃcients associated with income and balance in a multiple logistic regression model that uses both predictors. (b) Write afunction, boot.fn() , thattakesasinputthe Defaultdata set as well as an index of the observations, and that outputs the coeﬃcient estimates for incomeand balancein the multiple logistic regression model. (c) Usethe boot()functiontogetherwithyour boot.fn() functionto estimate the standarderrorsofth e logisticregressioncoeﬃcients forincomeand balance. (d) Comment on the estimated standard errors obtained using the glm()function and using your bootstrap function. 7. In Sections 5.3.2 and 5.3.3, we saw that the cv.glm() function can be used in order to compute the LOOCV test error estimate. Alterna- tively, one could compute those quantities using just the glm()and 200 5. Resampling Methods predict.glm() functions, and a for loop. You will now take this ap- proach in order to compute the LOOCV error for a simple logistic regression model on the Weeklydata set. Recall that in the context of classiﬁcation problems, the LOOCV error is given in (5.4). (a) Fitalogisticregressionmodelthatpredicts Direction using Lag1 and Lag2. (b) Fitalogisticregressionmodelthatpredicts Direction using Lag1 and Lag2using all but the ﬁrst observation . (c) Use the model from(b) topredict the direction ofthe ﬁrst obser- vation. You can do this by predicting that the ﬁrst observation will go up if P(Direction=\"Up\" |Lag1,Lag2)>0.5 .W a st h i so b - servation correctly classiﬁed? (d) Write a for loop from i=1t oi=n,w h e r enis the number of observations in the data set, that performs each of the following steps: i. Fit a logistic regression model using all but the ith obser- vation to predict Direction using Lag1and Lag2. ii. Compute the posterior probability of the market moving up for theith observation. iii. Usethe posteriorprobabilityforthe ithobservationinorder to predict whether or not the market moves up. iv. Determine whether or not an error was made in predicting the direction for the ith observation. If an error was made, then indicate this as a 1, and otherwise indicate it as a 0. (e) Take the average of the nnumbers obtained in (d)iv in order to obtain the LOOCV estimate for the test error. Comment on the results. 8. We will now perform cross-validation on a simulated data set. (a) Generate a simulated data set as follows: > set.seed(1) > y=rnorm(100) > x=rnorm(100) > y=x-2*x^2+rnorm(100) In this data set, what is nand what is p? Write out the model used to generate the data in equation form. (b) Createa scatterplotof XagainstY. Comment onwhat youﬁnd. (c) Set a random seed, and then compute the LOOCV errors that result from ﬁtting the following four models using least squares: 5.4 Exercises 201 i.Y=β0+β1X+/epsilon1 ii.Y=β0+β1X+β2X2+/epsilon1 iii.Y=β0+β1X+β2X2+β3X3+/epsilon1 iv.Y=β0+β1X+β2X2+β3X3+β4X4+/epsilon1. Note you may ﬁnd it helpful to use the data.frame() function to create a single data set containing both XandY. (d) Repeat (c) using another random seed, and report your results. Are your results the same as what you got in (c)? Why? (e) Which of the models in (c) had the smallest LOOCV error? Is this what you expected? Explain your answer. (f) Comment on the statistical signiﬁcance of the coeﬃcient esti- mates that results from ﬁtting each of the models in (c) using least squares. Do these results agree with the conclusions drawn based on the cross-validation results? 9. We will now consider the Bostonhousing data set, from the MASS library. (a) Based on this data set, provide an estimate for the population mean of medv. Call this estimate ˆ μ. (b) Provide an estimate of the standard error of ˆ μ. Interpret this result. Hint: We can compute the standard error of the sample mean by dividing the sample standard deviation by the square root of the number of observations. (c) Now estimate the standard error of ˆ μusing the bootstrap. How does this compare to your answer from (b)? (d) Based on your bootstrap estimate from (c), provide a 95% con- ﬁdence interval for the mean of medv. Compare it to the results obtained using t.test(Boston$medv) . Hint: You can approximate a 95% conﬁdence interval using the formula[ˆμ−2SE(ˆμ),ˆμ+2SE(ˆμ)]. (e) Basedonthisdataset,provideanestimate, ˆ μmed,forthemedian value of medvin the population. (f) Wenowwouldliketoestimatethestandarderrorof ˆ μmed.Unfor- tunately, there is no simple formula for computing the standard error of the median. Instead, estimate the standard error of the median using the bootstrap. Comment on your ﬁndings. (g) Based on this data set, provide an estimate for the tenth per- centile of medvin Boston suburbs. Call this quantity ˆ μ0.1.( Y o u can use the quantile() function.) (h) Use the bootstrap to estimate the standard error of ˆ μ0.1.C o m - ment on your ﬁndings. 6 Linear Model Selection and Regularization In the regression setting, the standard linear model Y=β0+β1X1+···+βpXp+/epsilon1 (6.1) is commonly used to describe the re lationship between a response Yand a set of variables X1,X2,...,X p. We have seen in Chapter 3 that one typically ﬁts this model using least squares. In the chapters that follow, we consider some approaches for extending the linear model framework. In Chapter 7 we generalize (6.1) in order to accommodate non-linear, but still additive, relationships, while in Chap- ter 8 we consider even more general non -linear models. However, the linear modelhasdistinctadvantagesintermsofinferenceand,onreal-worldprob- lems, is often surprisingly competitive in relation to non-linear methods. Hence, before moving to the non-linear world, we discuss in this chapter some ways in which the simple linear model can be improved, by replacing plain least squares ﬁtting with some alternative ﬁtting procedures. Why might we want to use another ﬁtting procedure instead of least squares? As we will see, alternative ﬁtting procedures can yield better pre- diction accuracy andmodel interpretability . •Prediction Accuracy : Provided that the true relationship between the response and the predictors is approximately linear, the least squares estimates will have low bias. If n/greatermuchp—that is, if n,t h en u m b e ro f observations,ismuchlargerthan p,thenumberofvariables—thenthe least squares estimates tend to also have low variance, and hence will perform well on test observations. However, if nis not much larger G. James et al., An Introduction to Statistical Learning: with Applications in R , Springer Texts in Statistics 103, DOI 10.1007/978-1-4614-7138-7 6, ©Springer Science+Business Media New York 2013203 204 6. Linear Model Selection and Regularization thanp, then there can be a lot of variability in the least squares ﬁt, resulting in overﬁtting and consequently poor predictions on future observations not used in model training. And if p>n, then there is no longer a unique least squares coeﬃcient estimate: the variance isinﬁniteso the method cannot be used at all. By constraining or shrinking the estimatedcoeﬃcients,wecanoftensubstantiallyreduce the variance at the cost of a negligible increase in bias. This can lead to substantial improvements in the accuracy with which we can predict the response for observations not used in model training. •Model Interpretability : It is often the case that some or many of the variables used in a multiple regression model are in fact not associ- ated with the response. Including such irrelevant variables leads to unnecessary complexity in the resulting model. By removing these variables—that is, by setting the c orresponding coeﬃcient estimates to zero—we can obtain a model that is more easily interpreted. Now least squares is extremely unlikely to yield any coeﬃcient estimates that are exactly zero. In this chapter, we see some approaches for au- tomaticallyperforming feature selection orvariable selection —that is,feature selection variable selectionfor excluding irrelevant variables from a multiple regression model. There are many alternatives, both classical and modern, to using least squares to ﬁt (6.1). In this chapter, we discuss three important classes of methods. •Subset Selection . This approach involves identifying a subset of the p predictors that we believe to be related to the response. We then ﬁt a model using least squares on the reduced set of variables. •Shrinkage . This approach involves ﬁtting a model involving all ppre- dictors.However,theestimatedco eﬃcientsareshrunkentowardszero relative to the least squares estimates. This shrinkage (also known as regularization )hastheeﬀectofreducingvariance.Dependingonwhat type of shrinkage is performed, some of the coeﬃcients may be esti- mated to be exactly zero. Hence, shrinkage methods can also perform variable selection. •Dimension Reduction . This approachinvolves projecting theppredic- tors into a M-dimensional subspace, where M<p.T h i si sa c h i e v e d by computing Mdiﬀerent linear combinations ,o rprojections ,o ft h e variables. Then these Mprojections are used as predictors to ﬁt a linear regression model by least squares. In the following sections we describe each of these approachesin greaterde- tail, along with their advantages and disadvantages. Although this chapter describes extensions and modiﬁcations to the linear model for regression seen in Chapter 3, the same concepts apply to other methods, such as the classiﬁcation models seen in Chapter 4. 6.1 Subset Selection 205 6.1 Subset Selection In this section weconsidersome metho ds for selecting subsetsofpredictors. These include best subset and stepwise model selection procedures. 6.1.1 Best Subset Selection To perform best subset selection , we ﬁt a separate least squares regressionbest subset selection foreachpossiblecombinationofthe ppredictors.Thatis,weﬁt all pmodels that contain exactly one predictor, all/parenleftbigp 2/parenrightbig =p(p−1)/2m od e l st h a tc o n t a i n exactly two predictors, and so forth. We then look at all of the resulting models, with the goal of identifying the one that is best. The problem of selecting the best model from among the 2ppossibilities considered by best subset selection is not trivial. This is usually broken up into two stages, as described in Algorithm 6.1. Algorithm 6.1 Best subset selection 1. LetM0denote the null model , which contains no predictors. This model simply predicts the sample mean for each observation. 2. Fork=1,2,...p: (a) Fit all/parenleftbigp k/parenrightbig models that contain exactly kpredictors. (b) Pick the best among these/parenleftbigp k/parenrightbig models, and call it Mk.H e r ebest is deﬁned as havingthe smallest RSS, or equivalently largest R2. 3. Select a single best model from among M0,...,Mpusing cross- validated prediction error, Cp(AIC), BIC, or adjusted R2. In Algorithm 6.1, Step 2 identiﬁes the best model (on the training data) for each subset size, in order to reduce the problem from one of 2ppossible models to one of p+ 1 possible models. In Figure 6.1, these models form the lower frontier depicted in red. Now in order to select a single best model, we must simply choose among thesep+ 1 options. This task must be performed with care, because the RSS of these p+1 models decreases monotonically, and the R2increases monotonically, as the number of features included in the models increases. Therefore, if we use these statistics to select the best model, then we will always end up with a model involving all of the variables. The problem is that a low RSS or a high R2indicates a model with a low training error, whereas we wish to choose a model that has a low testerror. (As shown in Chapter 2 in Figures 2.9–2.11, training error tends to be quite a bit smaller than test error, and a low training error by no means guarantees a low test error.) Therefore, in Step 3, we use cross-validated prediction 206 6. Linear Model Selection and Regularization 2e+07 4e+07 6e+07 8e+07 Number of PredictorsResidual Sum of Squares Number of PredictorsR2 10 8 6 4 2 10 8 6 4 2 1.0 0.8 0.6 0.4 0.2 0.0 FIGURE 6.1. For each possible model containing a subset of the ten predictors in the Creditdata set, the RSS and R2are displayed. The red frontier tracks the bestmodel for a given number of predictors, according to RSS and R2. Though the data set contains only ten predictors, the x-axis ranges from 1to11,s i n c eo n e of the variables is categorical and takes on three values, leading to the creation of two dummy variables. error,Cp, BIC, or adjusted R2in order to select among M0,M1,...,Mp. These approaches are discussed in Section 6.1.3. An application of best subset selection is shown in Figure 6.1. Each plotted point corresponds to a least squares regression model ﬁt using a diﬀerent subset of the 11 predictors in the Creditdata set, discussed in Chapter 3. Here the variable ethnicity is a three-level qualitative variable, andsoisrepresentedbytwodummyvari ables,whichareselectedseparately in this case. We have plotted the RSS and R2statistics for each model, as a function of the number of variables. The red curves connect the best models for each model size, according to RSS or R2. The ﬁgure shows that, as expected, these quantities improve a s the number of variables increases; however, from the three-variable model on, there is little improvement in RSS and R2as a result of including additional predictors. Although we have presented best subs et selection here for least squares regression, the same ideas apply to oth er types of models, such as logistic regression. In the case of logistic regression, instead of ordering models by RSS in Step 2 of Algorithm 6.1, we instead use the deviance,am e a s u r edeviancethat plays the role of RSS for a broader class of models. The deviance is negative two times the maximized log-likelihood; the smaller the deviance, the better the ﬁt. While best subset selection is a simple and conceptually appealing ap- proach, it suﬀers from computational limitations. The number of possible models that must be considered grows rapidly as pincreases. In general, there are 2pmodels that involve subsets of ppredictors. So if p= 10, then there are approximately 1,000possible models to be considered, and if 6.1 Subset Selection 207 p= 20,then thereareoveronemillionpossibilities!Consequently,bestsub- set selectionbecomescomputationallyinfeasible forvaluesof pgreaterthan around 40, even with extremely fast m odern computers. There are compu- tational shortcuts—so called branch-and-bound techniques—for eliminat- ing some choices, but these have their limitations as pgets large. They also only work for least squares linear regression. We present computationally eﬃcient alternatives to b est subset selection next. 6.1.2 Stepwise Selection For computational reasons, best subset selection cannot be applied with very large p. Best subset selection may also suﬀer from statistical problems whenpislarge.Thelargerthe searchspace,thehigherthe chanceofﬁnding models that look good on the training data, even though they might not have any predictive power on future data. Thus an enormous search space can lead to overﬁtting and high varia nce of the coeﬃcient estimates. For both of these reasons, stepwise methods, which explore a far more restricted set of models, are attractive alternatives to best subset selection. Forward Stepwise Selection Forward stepwise selection is a computationally eﬃcient alternative to bestforward stepwise selectionsubset selection. While the best subset selection procedure considers all 2ppossible models containing subsets of the ppredictors, forward step- wise considers a much smaller set of mo dels. Forward stepwise selection begins with a model containing no predictors, and then adds predictors to the model, one-at-a-time, until all of the predictors are in the model. In particular, at each step the variable that gives the greatest additional improvement to the ﬁt is added to the model. More formally, the forward stepwise selection procedur e is given in Algorithm 6.2. Algorithm 6.2 Forward stepwise selection 1. LetM0denote the nullmodel, which contains no predictors. 2. Fork=0,...,p−1: (a) Consider all p−kmodels that augment the predictors in Mk with one additional predictor. (b) Choose the bestamong these p−kmodels, and call it Mk+1. Herebestis deﬁned as having smallest RSS or highest R2. 3. Select a single best model from among M0,...,Mpusing cross- validated prediction error, Cp(AIC), BIC, or adjusted R2. 208 6. Linear Model Selection and Regularization Unlike best subset selection, which involved ﬁtting 2pmodels, forward stepwise selection involves ﬁtting one null model, along with p−kmodels in thekth iteration, for k=0,...,p−1. This amounts to a total of 1 +/summationtextp−1 k=0(p−k)=1+p(p+1)/2models. This is a substantial diﬀerence: when p= 20, best subset selection requires ﬁtting 1 ,048,576 models, whereas forward stepwise selection requires ﬁtting only 211 models.1 In Step 2(b) of Algorithm 6.2, we must identify the bestmodel from among those p−kthat augment Mkwith one additionalpredictor. We can do this by simply choosing the model with the lowest RSS or the highest R2. However, in Step 3, we must identify the best model among a set of models with diﬀerent numbers of variables. This is more challenging, and is discussed in Section 6.1.3. Forward stepwise selection’s computational advantage over best subset selection is clear. Though forward stepwise tends to do well in practice, it is not guaranteed to ﬁnd the best possible model out of all 2pmod- els containing subsets of the ppredictors. For instance, suppose that in a given data set with p= 3 predictors, the best possible one-variable model contains X1, and the best possible two-variable model instead contains X2 andX3. Then forward stepwise selection will fail to select the best possible two-variable model, because M1will contain X1,s oM2must also contain X1together with one additional variable. Table 6.1, which shows the ﬁrst four selected models for best subset and forward stepwise selection on the Creditdata set, illustrates this phe- nomenon. Both best subset selection and forward stepwise selection choose ratingfor the best one-variablemodel and then include incomeand student for the two- and three-variable models . However, best subset selection re- places ratingbycardsin the four-variable model, while forward stepwise selection must maintain ratingin its four-variable model. In this example, Figure 6.1 indicates that there is no t much diﬀerence between the three- and four-variable models in terms of RSS, so either of the four-variable models will likely be adequate. Forward stepwise selection can be applied even in the high-dimensional setting where n<p; however, in this case, it is possible to construct sub- modelsM0,...,Mn−1only, since each submodel is ﬁt using least squares, which will not yield a unique solution if p≥n. Backward Stepwise Selection Like forward stepwise selection, backward stepwise selection provides anbackward stepwise selectioneﬃcient alternative to best subset selection. However, unlike forward 1Though forward stepwise selection considers p(p+1 )/2+1m o d e l s ,i tp e r f o r m sa guidedsearch over model space, and so the eﬀective model space considered contains substantially more than p(p+1)/2+1mod e ls. 6.1 Subset Selection 209 #V a r i a b l e s Best subset Forward stepwise One rating rating Two rating,income rating ,income Three rating,income,student rating ,income,student Four cards,income rating ,income, student,limit student ,limit TABLE 6.1. The ﬁrst four selected models for best subset selection and forward stepwise selection on the Creditdata set. The ﬁrst three models are identical but the fourth models diﬀer. stepwise selection, it begins with the full least squares model containing allppredictors, and then iteratively r emoves the least useful predictor, one-at-a-time. Details are given in Algorithm 6.3. Algorithm 6.3 Backward stepwise selection 1. LetMpdenote the fullmodel, which contains all ppredictors. 2. Fork=p,p−1,...,1: (a) Consider all kmodels that contain all but one of the predictors inMk, for a total of k−1p r e d i c t o r s . (b) Choose the bestamong these kmodels, and call it Mk−1.H e r e bestis deﬁned as having smallest RSS or highest R2. 3. Select a single best model from among M0,...,Mpusing cross- validated prediction error, Cp(AIC), BIC, or adjusted R2. Likeforwardstepwiseselection,theb ackwardselectionapproachsearches through only 1+ p(p+1)/2 models, and so can be applied in settings where pis too large to apply best subset selection.2Also like forward stepwise selection, backward stepwise sel ection is not guaranteed to yield the best model containing a subset of the ppredictors. Backward selection requires that the number of samples nis larger than the number of variables p(so that the full model can be ﬁt). In contrast, forward stepwise can be used even when n<p, and so is the only viable subset method when pis very large. 2Like forward stepwise selection, backward stepwise selection performs a guided search over model space, andsoeﬀectively considerssubstantiallymorethan 1+ p(p+1)/2 models. 210 6. Linear Model Selection and Regularization Hybrid Approaches The best subset, forward stepwise, a nd backward stepwise selection ap- proaches generally give similar but not identical models. As another al- ternative, hybrid versions of forward and backward stepwise selection are available,in which variablesareadded to the model sequentially,in analogy to forward selection. However, after adding each new variable, the method may also remove any variables that no longer provide an improvement in the model ﬁt. Such an approach attempts to more closely mimic best sub- set selection while retaining the computational advantages of forward and backward stepwise selection. 6.1.3 Choosing the Optimal Model Best subset selection, forward select ion, and backward selection result in the creation of a set of models, each of which contains a subset of the ppre- dictors. In order to implement these methods, we need a way to determine which of these models is best. As we discussed in Section 6.1.1, the model containing all of the predictors will always have the smallest RSS and the largestR2, since these quantities are related to the training error. Instead, we wish to choose a model with a low test error. As is evident here, and as we show in Chapter 2, the training error can be a poor estimate of the test error. Therefore, RSS and R2are not suitable for selecting the best model among a collection of models with d iﬀerent numbers of predictors. In order to select the best model with respect to test error, we need to estimate this test error. There are two common approaches: 1. We can indirectly estimate test error by making an adjustment to the training error to account for the bias due to overﬁtting. 2. We can directlyestimate the test error, using either a validation set approach or a cross-validation approach, as discussed in Chapter 5. We consider both of these approaches below. Cp,A I C ,B I C ,a n dA d j u s t e d R2 We show in Chapter 2 that the training set MSE is generally an under- estimate of the test MSE. (Recall that MSE = RSS /n.) This is because when we ﬁt a model to the training data using least squares, we speciﬁ- cally estimate the regression coeﬃci ents such that the training RSS (but not the test RSS) is as small as possible. In particular, the training error will decrease as more variables are included in the model, but the test error may not. Therefore, training set RSS and training set R2cannot be used to select from among a set of models with diﬀerent numbers of variables. However, a number of techniques for adjusting the training error for the modelsizeareavailable.Theseapproachescanbeusedtoselectamongaset 6.1 Subset Selection 211 2468 1 010000 15000 20000 25000 30000 Number of PredictorsCp 2468 1 010000 15000 20000 25000 30000 Number of PredictorsBIC 2468 1 00.86 0.88 0.90 0.92 0.94 0.96 Number of PredictorsAdjusted R2 FIGURE 6.2. Cp, BIC, and adjusted R2are shown for the best models of each size for the Creditdata set (the lower frontier in Figure 6.1). Cpand BIC are estimates of test MSE. In the middle plot we see that the BIC estimate of test error shows an increase after four variables are selected. The other two plots are rather ﬂat after four variables are included. of models with diﬀerent numbers of variables. We now consider four such approaches: Cp,Akaike information criterion (AIC),Bayesian informationCp Akaike information criterioncriterion (BIC), and adjusted R2.Figure6.2displays Cp,BIC,andadjusted Bayesian information criterion adjusted R2R2for the best model of each size produced by best subset selection on the Creditdata set. For a ﬁtted least squares model containing dpredictors, the Cpestimate of test MSE is computed using the equation Cp=1 n/parenleftbig RSS+2dˆσ2/parenrightbig , (6.2) where ˆσ2is an estimate of the variance of the error /epsilon1associated with each response measurementin (6.1).3Essentially,the Cpstatistic adds a penalty of 2dˆσ2to the training RSS in order to adjust for the fact that the training errortends to underestimatethe test error.Clearly,the penalty increasesas the number of predictors in the model increases; this is intended to adjust for the corresponding decrease in training RSS. Though it is beyond the scope of this book, one can show that if ˆ σ2is an unbiased estimate of σ2in (6.2), then Cpis an unbiased estimate of test MSE. As a consequence, the Cpstatistic tends to take on a small value for models with a low test error, so when determining which of a set of models is best, we choose the model with the lowest Cpvalue. In Figure 6.2, Cpselects the six-variable model containing the predictors income,limit,rating,cards,ageand student. 3Mallow’s Cpis sometimes deﬁned as C/prime p=R S S /ˆσ2+2d−n.T h i si se q u i v a l e n tt o the deﬁnition given above in the sense that Cp=ˆσ2(C/prime p+n), and so the model with smallest Cpalso has smallest C/prime p. 212 6. Linear Model Selection and Regularization The AIC criterion is deﬁned for a large class of models ﬁt by maximum likelihood. In the case of the model (6.1) with Gaussian errors, maximum likelihood and least squaresare the same thing. In this case AIC is given by AIC =1 nˆσ2/parenleftbig RSS+2dˆσ2/parenrightbig , where, for simplicity, we have omitte d an additive constant. Hence for least squares models, Cpand AIC are proportional to each other, and so only Cpis displayed in Figure 6.2. BIC is derived from a Bayesianpoint ofview, but ends up lookingsimilar toCp(and AIC) as well. For the least squares model with dpredictors, the BIC is, up to irrelevant constants, given by BIC =1 n/parenleftbig RSS+log( n)dˆσ2/parenrightbig . (6.3) LikeCp, the BIC will tend to take on a small value for a model with a low test error, and so generally we select the model that has the lowest BIC value. Notice that BIC replaces the 2 dˆσ2used byCpwith a log( n)dˆσ2 term, where nis the number of observations. Since log n>2 for any n>7, the BIC statistic generally places a h eavier penalty on models with many variables, and hence results in the selection of smaller models than Cp. In Figure 6.2, we see that this is indeed the case for the Creditdata set; BIC chooses a model that contains only the four predictors income,limit, cards,a n d student. In this case the curves are very ﬂat and so there does not appear to be much diﬀerence in accu racybetween the four-variableand six-variable models. Theadjusted R2statisticisanotherpopularapproachforselectingamong a set of models that contain diﬀerent numbers of variables. Recall from Chapter 3 that the usual R2is deﬁned as 1 −RSS/TSS, where TSS =/summationtext(yi−y)2is thetotal sum of squares for the response. Since RSS always decreasesasmorevariablesareadded to the model, the R2alwaysincreases as more variables are added. For a least squares model with dvariables, the adjusted R2statistic is calculated as Adjusted R2=1−RSS/(n−d−1) TSS/(n−1). (6.4) UnlikeCp,A I C ,a n dB I C ,f o rw h i c ha smallvalue indicates a model with a low test error, a largevalue of adjusted R2indicates a model with a small test error. Maximizing the adjusted R2is equivalent to minimizing RSS n−d−1.While RSS alwaysdecreasesasthe numberofvariablesinthe model increases,RSS n−d−1may increase or decrease, due to the presence of din the denominator. The intuition behind the adjusted R2is that once all of the correct variableshavebeenincludedinthemodel,addingadditional noisevariables 6.1 Subset Selection 213 will lead to only a very small decrease in RSS. Since adding noise variables leads to an increase in d, such variables will lead to an increase inRSS n−d−1, and consequently a decrease in the adjusted R2. Therefore, in theory, the model with the largest adjusted R2will have only correct variables and no noise variables. Unlike the R2statistic, the adjusted R2statistic pays ap r i c efor the inclusion of unnecessary variables in the model. Figure 6.2 displays the adjusted R2for the Creditdata set. Using this statistic results in the selection of a model that contains seven variables, adding genderto the model selected by Cpand AIC. Cp, AIC, and BIC all have rigorous theoretical justiﬁcations that are beyond the scope of this book. These justiﬁcations rely on asymptotic ar- guments (scenarios where the sample size nis very large). Despite its pop- ularity, and even though it is quite intuitive, the adjusted R2is not as well motivated in statistical theory as AIC, BIC, and Cp. All of these measures are simple to use and compute. Here we have presented the formulas for AIC, BIC, and Cpin the case of a linear model ﬁt using least squares; however, these quantities can also be deﬁned for more general types of models. Validation and Cross-Validation As an alternative to the approaches just discussed, we can directly esti- mate the test error using the validation set and cross-validation methods discussed in Chapter 5. We can compute the validation set error or the cross-validation error for each model under consideration, and then select the model for which the resulting estimated test error is smallest. This pro- cedure has an advantagerelativeto AIC, BIC, Cp,a n da d j u s t e d R2,i nt h a t it provides a direct estimate of the tes t error,and makes fewer assumptions about the true underlying model. It can also be used in a wider range of model selection tasks, even in cases wh ere it is hard to pinpoint the model degrees of freedom (e.g. the number of predictors in the model) or hard to estimate the error variance σ2. In the past, performing cross-validation was computationally prohibitive for many problems with large pand/or large n, and so AIC, BIC, Cp, and adjusted R2were more attractive approaches for choosing among a set of models. However, nowadays with fast computers, the computations required to perform cross-validation are hardly ever an issue. Thus, cross- validation is a very attractive approach for selecting from among a number of models under consideration. Figure 6.3 displays,as a function of d, the BIC, validation set errors,and cross-validation errors on the Creditdata, for the best d-variable model. The validation errors were calculated by randomly selecting three-quarters of the observations as the training set, and the remainder as the valida- tion set. The cross-validation errors were computed using k=1 0f o l d s . In this case, the validation and cross-validation methods both result in a 214 6. Linear Model Selection and Regularization 2468 1 0100 120 140 160 180 200 220 Number of PredictorsSquare Root of BIC 2468 1 0100 120 140 160 180 200 220 Number of PredictorsValidation Set Error 2468 1 0100 120 140 160 180 200 220 Number of PredictorsCross−Validation Error FIGURE 6.3. For the Creditdata set, three quantities are displayed for the best model containing dpredictors, for dranging from 1to11. The overall best model, based on each of these quantities, is shown as a blue cross. Left:Square root of BIC. Center:Validation set errors. Right:Cross-validation errors. six-variable model. However, all three approaches suggest that the four-, ﬁve-, and six-variable models are roughly equivalent in terms of their test errors. In fact, the estimated test error curve s displayed in the center and right- handpanelsofFigure6.3arequiteﬂat.Whileathree-variablemodelclearly haslowerestimatedtesterrorthanatw o-variablemodel, the estimated test errors of the 3- to 11-variable models are quite similar. Furthermore, if we repeated the validation set approach using a diﬀerent split of the data into a training set and a validation set, or if we repeated cross-validation using a diﬀerent set of cross-validation folds, then the precise model with the lowest estimated test error would surely change. In this setting, we can select a model using the one-standard-error rule . We ﬁrst calculate theone- standard- error rulestandard error of the estimated test MSE for each model size, and then select the smallest model for which the estimated test error is within one standard error of the lowest point on the curve. The rationale here is that if a set of models appear to be more or less equally good, then we might as well choose the simplest model—that is, the model with the smallest number of predictors. In this case, applying the one-standard-error rule to the validation set or cross-validation approach leads to selection of the three-variable model. 6.2 Shrinkage Methods The subset selection methods described in Section 6.1 involve using least squares to ﬁt a linear model that contains a subset of the predictors. As an alternative, we can ﬁt a model containing all ppredictors using a technique thatconstrains orregularizes the coeﬃcient estimates, or equivalently, that shrinksthe coeﬃcient estimates towards zero. It may not be immediately 6.2 Shrinkage Methods 215 obvious why such a constraint should improve the ﬁt, but it turns out that shrinking the coeﬃcient estimates ca n signiﬁcantly reduce their variance. The two best-known techniques for shrinking the regression coeﬃcients towards zero are ridge regression and thelasso. 6.2.1 Ridge Regression Recall from Chapter 3 that the least squares ﬁtting procedure estimates β0,β1,...,β pusing the values that minimize RSS =n/summationdisplay i=1⎛ ⎝yi−β0−p/summationdisplay j=1βjxij⎞ ⎠2 . Ridge regression is very similar to least squares, except that the coeﬃcientsridge regression are estimated by minimizing a slightly diﬀerent quantity. In particular, the ridge regression co eﬃcient estimates ˆβRare the values that minimize n/summationdisplay i=1⎛ ⎝yi−β0−p/summationdisplay j=1βjxij⎞ ⎠2 +λp/summationdisplay j=1β2 j=R S S+ λp/summationdisplay j=1β2 j,(6.5) whereλ≥0i satuning parameter , to be determined separately. Equa-tuning parameter tion 6.5 trades oﬀ two diﬀerent criteria. As with least squares, ridge regres- sion seeks coeﬃcient estimates that ﬁt the data well, by making the RSS small. However, the second term, λ/summationtext jβ2 j, called a shrinkage penalty ,i sshrinkage penalty small when β1,...,β pare close to zero, and so it has the eﬀect of shrinking the estimates of βjtowards zero. The tuning parameter λserves to control the relative impact of these two ter ms on the regression coeﬃcient esti- mates. When λ= 0, the penalty term has no eﬀect, and ridge regression will produce the least squaresestimates. However,as λ→∞, the impact of the shrinkage penalty grows, and the ridge regression coeﬃcient estimates will approachzero. Unlike least square s, which generates only one set of co- eﬃcient estimates, ridge regressionwill produce a diﬀerent set of coeﬃcient estimates, ˆβR λ, for each value of λ. Selecting a good value for λis critical; we defer this discussion to Section 6.2.3, where we use cross-validation. Note that in (6.5), the shrinkage penalty is applied to β1,...,β p, but not to the intercept β0. We want to shrink the estimated association of each variable with the response; however, we do not want to shrink the intercept, which is simply a measure of the mean value of the response whenxi1=xi2=...=xip= 0. If we assume that the variables—that is, the columns of the data matrix X—have been centered to have mean zero before ridge regression is performed, then the estimated intercept will take the form ˆβ0=¯y=/summationtextn i=1yi/n. 216 6. Linear Model Selection and Regularization 1e−02 1e+00 1e+02 1e+04−300 −100 0 100 200 300 400Standardized CoefficientsIncome Limit Rating Student 0.0 0.2 0.4 0.6 0.8 1.0−300 −100 0 100 200 300 400Standardized Coefficients λ ˆβR λ2/ˆβ2 FIGURE 6.4. The standardized ridge regression coeﬃcients are displayed for theCreditdata set, as a function of λand/bardblˆβR λ/bardbl2//bardblˆβ/bardbl2. An Application to the Credit Data In Figure 6.4, the ridge regression coeﬃcient estimates for the Creditdata set are displayed. In the left-hand panel, each curve corresponds to the ridge regression coeﬃcien t estimate for one of the ten variables, plotted as a function of λ. For example, the black solid line represents the ridge regressionestimate for the incomecoeﬃcient, as λis varied. At the extreme left-hand side of the plot, λis essentially zero, and so the corresponding ridge coeﬃcient estimates are the same as the usual least squares esti- mates. But as λincreases, the ridge coeﬃcien t estimates shrink towards zero. When λis extremely large, then all of the ridge coeﬃcient estimates are basically zero; this corresponds to the null model that contains no pre- dictors. In this plot, the income,limit,rating,a n d studentvariables are displayed in distinct colors, since these variables tend to have by far the largest coeﬃcient estimates. While th e ridge coeﬃcient estimates tend to decrease in aggregate as λincreases, individual coeﬃcients, such as rating and income, may occasionally increase as λincreases. The right-hand panel of Figure 6.4 displays the same ridge coeﬃcient estimates as the left-hand panel, but instead of displaying λon thex-axis, we now display /bardblˆβR λ/bardbl2//bardblˆβ/bardbl2,w h e r e ˆβdenotes the vector of least squares coeﬃcient estimates. The notation /bardblβ/bardbl2denotes the /lscript2norm(pronounced/lscript2norm “ell 2”) of a vector, and is deﬁned as /bardblβ/bardbl2=/radicalBig/summationtextp j=1βj2.I tm e a s u r e s the distance of βfrom zero. As λincreases, the /lscript2norm of ˆβR λwillalways decrease, and so will /bardblˆβR λ/bardbl2//bardblˆβ/bardbl2. The latter quantity ranges from 1 (when λ= 0, in which case the ridge regressi on coeﬃcient estimate is the same as the least squares estimate, and so their /lscript2norms are the same) to 0 (whenλ=∞, in which case the ridge regre ssion coeﬃcient estimate is a vector of zeros, with /lscript2norm equal to zero). Therefore, we can think of the x-axis in the right-hand panel of Figure 6.4 as the amount that the ridge 6.2 Shrinkage Methods 217 regression coeﬃcient est imates have been shrunken towards zero; a small value indicates that they have been shrunken very close to zero. The standard least squares coeﬃcien t estimates discussed in Chapter 3 arescale invariant : multiplying Xjby a constant csimply leads to a scalingscale invariant of the least squares coeﬃcient estimates by a factor of 1 /c.I no t h e rw o r d s , regardless of how the jth predictor is scaled, Xjˆβjwill remain the same. In contrast, the ridge regression co eﬃcient estimates can change substantially when multiplying a given predictor by a constant. For instance, consider the incomevariable, which is measured in dollars. One could reasonably have measured income in thousands of dollars, which would result in a reduction in the observed values of incomeby a factor of 1,000. Now due to the sum of squared coeﬃcients term in the ridge regression formulation (6.5), such a change in scale will not simply cause the ridge regression coeﬃcient estimate for incometo change by a factor of 1,000. In other words,XjˆβR j,λwill depend not only on the value of λ, but also on the scaling of the jth predictor. In fact, the value of XjˆβR j,λmay even depend on the scaling of the otherpredictors! Therefore, it is best to apply ridge regression after standardizing the predictors ,u s i n gt h ef o r m u l a ˜xij=xij/radicalBig 1 n/summationtextn i=1(xij−xj)2, (6.6) so that they are all on the same scale. In (6.6), the denominator is the estimated standard deviation of the jth predictor. Consequently, all of the standardized predictors will have a standard deviation of one. As a re- sult the ﬁnal ﬁt will not depend on the scale on which the predictors are measured. In Figure 6.4, the y-axis displays the standardized ridge regres- sion coeﬃcientestimates —that is, the coeﬃcient estimates that result from performing ridge regression using standardized predictors. Why Does Ridge Regression Improve Over Least Squares? Ridgeregression’sadvantageoverleastsquaresisrootedinthe bias-variance trade-oﬀ.A sλincreases, the ﬂexibility of the ridge regression ﬁt decreases, leading to decreased variance but increased bias. This is illustrated in the left-hand panel of Figure 6.5, using a simulated data set containing p=4 5 predictors and n= 50 observations. The green curve in the left-hand panel of Figure 6.5 displays the variance of the ridge regression predictions as a function of λ. At the least squares coeﬃcien t estimates, which correspond to ridge regressionwith λ= 0, the variance is high but there is no bias. But asλincreases, the shrinkage of the rid ge coeﬃcient estimates leads to a substantial reduction in the variance of the predictions, at the expense of a slightincrease in bias. Recall that th e test meansquarederror(MSE), plot- ted in purple, is a function of the variance plus the squared bias. For values 218 6. Linear Model Selection and Regularization Mean Squared Error 1e−01 1e+01 1e+030 102 03 04 05 06 0 0.0 0.2 0.4 0.6 0.8 1.001 0 2 0 3 0 405 06 0Mean Squared Error λ ˆβR λ2/ˆβ2 FIGURE 6.5. Squared bias (black), variance (green), and test mean squared error (purple) for the ridge regression predictions on a simulated data set, as a function of λand/bardblˆβR λ/bardbl2//bardblˆβ/bardbl2. The horizontal dashed lines indicate the minimum possible MSE. The purple crosses indicate the ridge regression models for which the MSE is smallest. ofλup to about 10, the variance decreases rapidly, with very little increase in bias, plotted in black. Consequently, the MSE drops considerably as λ increases from 0 to 10. Beyond this po int, the decrease in variance due to increasing λslows, and the shrinkage on the coeﬃcients causes them to be signiﬁcantly underestimated, resulting in a large increase in the bias. The minimum MSE is achieved at approximately λ= 30. Interestingly, because of its high variance, the MSE associ ated with the least squares ﬁt, when λ= 0, is almost as high as that of the null model for which all coeﬃcient estimates are zero, when λ=∞. However, for an intermediate value of λ, the MSE is considerably lower. The right-hand panel of Figure 6.5 displays the same curves as the left- hand panel, this time plotted against the /lscript2norm of the ridge regression coeﬃcient estimates divided by the /lscript2norm of the least squares estimates. Now as we move from left to right, the ﬁts become more ﬂexible, and so the bias decreases and th e variance increases. In general, in situations where the relationship between the response and the predictors is close to linear, the least squares estimates will have low bias but may have high variance. This means that a small change in the training data can cause a large cha nge in the least squares coeﬃcient estimates. In particular, when the number of variables pis almost as large as the number of observations n, as in the example in Figure 6.5, the least squares estimates will be extremely variable. And if p>n, then the least squares estimates do not even ha ve a unique solution, whereas ridge regression can still perform well by trading oﬀ a small increase in bias for a large decrease in variance. Hence, ridg e regression works best in situations where the least squares esti mates have high variance. Ridge regressionalsohas substantialcomputationaladvantagesoverbest subset selection, which requires searching through 2pmodels. As we 6.2 Shrinkage Methods 219 discussed previously, even for moderate values of p,s u c has e a r c hc a n be computationally infeasible. In contrast, for any ﬁxed value of λ,r i d g e regression only ﬁts a single model, and the model-ﬁtting procedure can be performed quite quickly. In fact, one can show that the computations required to solve (6.5), simultaneously for all values of λ, are almost iden- tical to those for ﬁtting a model using least squares. 6.2.2 The Lasso Ridge regression does have one obvious disadvantage. Unlike best subset, forward stepwise, and backward stepwise selection, which will generally select models that involve just a subset of the variables, ridge regression will include all ppredictors in the ﬁnal model. The penalty λ/summationtextβ2 jin (6.5) will shrinkallofthe coeﬃcientstowardszero,butitwill notsetanyofthem exactly to zero (unless λ=∞). This may not be a problem for prediction accuracy,but it can createa challenge in model interpretation in settings in which the number of variables pis quite large. For example, in the Credit data set, it appears that the most important variables are income,limit, rating,a n d student. So we might wish to build a model including just these predictors. However, ridge regression will always generate a model involving all ten predictors. Increasing the value of λwill tend to reduce the magnitudes of the coeﬃcients, but will not result in exclusion of any of the variables. Thelassois a relatively recent alternative to ridge regression that over-lassocomes this disadvantage. The lasso coeﬃcients, ˆβL λ, minimize the quantity n/summationdisplay i=1⎛ ⎝yi−β0−p/summationdisplay j=1βjxij⎞ ⎠2 +λp/summationdisplay j=1|βj|=R S S+ λp/summationdisplay j=1|βj|.(6.7) Comparing (6.7) to (6.5), we see that the lasso and ridge regression have similar formulations. The only diﬀerence is that the β2 jterm in the ridge regressionpenalty (6.5) has been replacedby |βj|in the lasso penalty (6.7). In statistical parlance, the lasso uses an /lscript1(pronounced “ell 1”) penalty instead of an /lscript2penalty. The /lscript1norm of a coeﬃcient vector βis given by /bardblβ/bardbl1=/summationtext|βj|. As with ridge regression, the lasso shrinks the coeﬃcient estimates towards zero. However, in the case of the lasso, the /lscript1penalty has the eﬀect of forcing some of the coeﬃcient estim ates to be exactly equal to zero when the tuningparameter λissuﬃcientlylarge.Hence, muchlikebestsubsetse- lection, the lasso performs variable selection . As a result, models generated from the lasso are generally much easi er to interpret than those produced by ridge regression. We say that the lasso yields sparsemodels—that is,sparse models that involve only a subset of the variables. As in ridge regression, selecting a good value of λfor the lasso is critical; we defer this discussion to Section 6.2.3, where we use cross-validation. 220 6. Linear Model Selection and Regularization Standardized Coefficients 20 50 100 200 500 2000 5000−200 0 100 200 300 400 0.0 0.2 0.4 0.6 0.8 1.0−300 −100 0 100 200 300 400Standardized CoefficientsIncome Limit Rating Student λ ˆβL λ1/ˆβ1 FIGURE 6.6. The standardized lasso coeﬃcients on the Creditdata set are shown as a function of λand/bardblˆβL λ/bardbl1//bardblˆβ/bardbl1. As an example,considerthe coeﬃcient plots in Figure6.6,which aregen- erated from applying the lasso to the Creditdata set. When λ=0 ,t h e n the lasso simply gives the least squares ﬁt, and when λbecomes suﬃciently large, the lasso gives the null model in which all coeﬃcient estimates equal zero. However, in between these two extremes, the ridge regression and lasso models are quite diﬀerent from each other. Moving from left to right in the right-hand panel of Figure 6.6, we observe that at ﬁrst the lasso re- sults in a model that contains only the ratingpredictor. Then studentand limitenter the model almost simultaneously, shortly followed by income. Eventually, the remaining variables enter the model. Hence, depending on the value of λ, the lasso can produce a model involving any number of vari- ables. In contrast,ridge regressionwill always include all of the variables in the model, although the magnitude of the coeﬃcient estimates will depend onλ. Another Formulation for Ridge Regression and the Lasso One can show that the lasso and ridge regressioncoeﬃcient estimates solve the problems minimize β⎧ ⎪⎨ ⎪⎩n/summationdisplay i=1⎛ ⎝yi−β0−p/summationdisplay j=1βjxij⎞ ⎠2⎫ ⎪⎬ ⎪⎭subject top/summationdisplay j=1|βj|≤s (6.8) and minimize β⎧ ⎪⎨ ⎪⎩n/summationdisplay i=1⎛ ⎝yi−β0−p/summationdisplay j=1βjxij⎞ ⎠2⎫ ⎪⎬ ⎪⎭subject top/summationdisplay j=1β2 j≤s, (6.9) 6.2 Shrinkage Methods 221 respectively. In other words, for every value of λ,t h e r ei ss o m e ssuch that the Equations (6.7) and (6.8) will give the same lasso coeﬃcient estimates. Similarly, for every value of λthere is a corresponding ssuch that Equa- tions(6.5)and(6.9)willgivethesameridgeregressioncoeﬃcientestimates. Whenp= 2, then (6.8) indicates that the lasso coeﬃcient estimates have the smallest RSS out of all points that lie within the diamond deﬁned by |β1|+|β2|≤s. Similarly, the ridge regression estimates have the smallest RSS out of all points that lie within the circle deﬁned by β2 1+β2 2≤s. We canthink of(6.8)asfollows.When weperformthe lassowearetrying to ﬁnd the setof coeﬃcientestimates that lead to the smallest RSS, subject to the constraint that there is a budgetsfor how large/summationtextp j=1|βj|can be. Whensis extremely large, then this budget is not very restrictive, and so the coeﬃcient estimates can be large. In fact, if sis large enough that the least squares solution falls within the budget, then (6.8) will simply yield the least squares solution. In contrast, if sis small, then/summationtextp j=1|βj|must be small in order to avoid violating the budget. Similarly, (6.9) indicates that when we perform ridge regression, w e seek a set of coeﬃcient estimates such that the RSS is as small as possible, subject to the requirement that/summationtextp j=1β2 jnot exceed the budget s. The formulations (6.8) and (6.9) reveal a close connection between the lasso, ridge regression, and best subs et selection. Consider the problem minimize β⎧ ⎪⎨ ⎪⎩n/summationdisplay i=1⎛ ⎝yi−β0−p/summationdisplay j=1βjxij⎞ ⎠2⎫ ⎪⎬ ⎪⎭subject top/summationdisplay j=1I(βj/negationslash=0 )≤s. (6.10) HereI(βj/negationslash= 0)isanindicatorvariable:ittakesonavalueof1if βj/negationslash=0 ,a n d equals zerootherwise.Then (6.10)amounts to ﬁnding a setofcoeﬃcientes- timates such that RSS is as small as possible, subject to the constraint that nomorethan scoeﬃcientscanbenonzero.Theproblem(6.10)isequivalent to best subset selection. Unfortunately, solving (6.10) is computationally infeasible when pis large, since it requires considering all/parenleftbigp s/parenrightbig models con- tainingspredictors. Therefore, we can interpret ridge regression and the lasso as computationally feasible alternatives to best subset selection that replace the intractable form of the budget in (6.10) with forms that are much easier to solve. Of course, the lasso is much more closely related to best subset selection, since only the lasso performs feature selection for s suﬃciently small in (6.8). The Variable Selection Property of the Lasso Why is it that the lasso, unlike ridge regression, results in coeﬃcient estimates that are exactly equal to zero? The formulations (6.8) and (6.9) can be used to shed light on the issue. Figure 6.7 illustrates the situation. The least squares solution is marked as ˆβ, while the blue diamond and 222 6. Linear Model Selection and Regularization β2 β2 β1 β1β β^ ^ FIGURE 6.7. Contours of the error and constraint functions for the lasso (left)and ridge regression (right). The solid blue areas are the constraint re- gions,|β1|+|β2|≤sandβ2 1+β2 2≤s, while the red ellipses are the contours of the RSS. circle represent the lasso and ridge regressionconstraints in (6.8) and (6.9), respectively. If sis suﬃciently large, then the constraint regions will con- tainˆβ, and so the ridge regression and lasso estimates will be the same as the least squares estimates. (Such a large value of scorresponds to λ=0 in (6.5) and (6.7).) However, in Figure 6.7 the least squares estimates lie outside of the diamond and the circle, and so the least squares estimates are not the same as the lasso and ridge regression estimates. The ellipses that are centered around ˆβrepresent regions of constant RSS. In other words, all of the points on a given ellipse share a common value of the RSS. As the ellipses expand away from the least squares co- eﬃcient estimates, the RSS increases . Equations (6.8) and (6.9) indicate that the lasso and ridge regression coeﬃcient estimates are given by the ﬁrst point at which an ellipse contacts the constraint region. Since ridge regression has a circular constraint with no sharp points, this intersection will not generally occur on an axis, an d so the ridge regression coeﬃcient estimates will be exclusively non-zer o. However, the lasso constraint has cornersat each of the axes, and so the ellipse will often intersect the con- straint region at an axis. When this occurs, one ofthe coeﬃcients will equal zero.Inhigherdimensions, manyofthe coeﬃcientestimates mayequalzero simultaneously. In Figure 6.7, the intersection occurs at β1=0 ,a n ds ot h e resulting model will only include β2. In Figure 6.7, we considered the simple case of p=2 .W h e n p=3 , then the constraint region for ridge r egression becomes a sphere, and the constraint region for the lasso becomes a polyhedron. When p>3, the 6.2 Shrinkage Methods 223Mean Squared Error 0.02 0.10 0.50 2.00 10.00 50.000 1 02 03 04 05 06 0 0.0 0.2 0.4 0.6 0.8 1.00 1 02 03 04 05 06 0 R2 on Training DataMean Squared Error λ FIGURE 6.8. Left:Plots of squared bias (black), variance (green), and test MSE (purple) for the lasso on a simulated data set. Right:Comparison of squared bias, variance and test MSE between lasso (solid) and ridge (dashed). Both are plotted against their R2on the training data, as a common form of indexing. The crosses in both plots indicate the lasso model for which the MSE is smallest. constraint for ridge regression becomes a hypersphere, and the constraint for the lasso becomes a polytope. However, the key ideas depicted in Fig- ure 6.7 still hold. In particular, the lasso leads to feature selection when p>2 due to the sharp corners of the polyhedron or polytope. Comparing the Lasso and Ridge Regression It is clear that the lasso has a major advantage over ridge regression, in that it produces simpler and more interpretable models that involve only a subset of the predictors. However, which method leads to better prediction accuracy? Figure 6.8 displays the variance, squared bias, and test MSE of the lasso applied to the same simulated data as in Figure 6.5. Clearly the lasso leads to qualitatively similar behavior to ridge regression, in that as λ increases, the variance decreases and the bias increases. In the right-hand panel of Figure 6.8, the dotted lines represent the ridge regression ﬁts. Here we plot both against their R2on the training data. This is another useful way to index models, and can be used to compare models with diﬀerent types of regularization, as is the case here. In this example, the lasso and ridge regression result in al most identical biases. However, the variance of ridge regression is slightly lower than the variance of the lasso. Consequently,theminimum MSEofridgeregressionisslightlysmallerthan that of the lasso. However, the data in Figure 6.8 were generated in such a way that all 45 predictorswererelatedtotheresponse—thatis,noneofthetruecoeﬃcients β1,...,β 45equaled zero. The lasso implicitly assumes that a number of the coeﬃcients truly equal zero. Conseque ntly, it is not surprising that ridge regressionoutperforms the lasso in terms of prediction error in this setting. Figure 6.9 illustrates a similar situation, except that now the response is a 224 6. Linear Model Selection and Regularization Mean Squared Error 0.02 0.10 0.50 2.00 10.00 50.0002 0 40 60 80 100 0.4 0.5 0.6 0.7 0.8 0.9 1.002 0 40 60 80 100 R2 on Training DataMean Squared Error λ FIGURE 6.9. Left:Plots of squared bias (black), variance (green), and test MSE (purple) for the lasso. The simulated data is similar to that in Figure 6.8, except that now only two predictors are related to the response. Right:Comparison of squared bias, variance and test MSE between lasso (solid) and ridge (dashed). Both are plotted against their R2on the training data, as a common form of indexing. The crosses in both plots indicate the lasso model for which the MSE is smallest. function of only 2 out of 45 predictors. Now the lasso tends to outperform ridge regression in terms of bias, variance, and MSE. These two examples illustrate that neither ridge regression nor the lasso will universally dominate the other. In general, one might expect the lasso to perform better in a setting where a relatively small number of predictors have substantial coeﬃcients, and the remaining predictors have coeﬃcients that are very small or that equal zero. Ridge regression will perform better when the response is a function of many predictors, all with coeﬃcients of roughly equal size. However, the number of predictors that is related to the response is never known ap r i o r i for real data sets. A technique such as cross-validationcan be used in order to determine which approachis better on a particular data set. As with ridge regression, when the le ast squares estimates have exces- sively high variance, the lasso solution can yield a reduction in variance at the expense of a small increase in bias, and consequently can gener- ate more accurate predictions. Unlike ridge regression, the lasso performs variable selection, and hence results i n models that are easier to interpret. Thereareveryeﬃcientalgorithmsforﬁttingbothridgeandlassomodels; in both cases the entire coeﬃcient paths can be computed with about the same amount of work as a single least squares ﬁt. We will explore this further in the lab at the end of this chapter. A Simple Special Case for Ridge Regression and the Lasso In order to obtain a better intuition about the behavior of ridge regression and the lasso, consider a simple special case with n=p,a n dXa diag- onal matrix with 1’s on the diagonal and 0’s in all oﬀ-diagonal elements. 6.2 Shrinkage Methods 225 To simplify the problemfurther, assume alsothatweareperformingregres- sion without an intercept. With these assumptions, the usual least squares problem simpliﬁes to ﬁnding β1,...,β pthat minimize p/summationdisplay j=1(yj−βj)2. (6.11) In this case, the least squares solution is given by ˆβj=yj. And in this setting, ridgeregressionamountsto ﬁnding β1,...,β psuchthat p/summationdisplay j=1(yj−βj)2+λp/summationdisplay j=1β2 j (6.12) is minimized, and the lasso amounts to ﬁnding the coeﬃcients such that p/summationdisplay j=1(yj−βj)2+λp/summationdisplay j=1|βj| (6.13) is minimized. One can show that in this setting, the ridge regression esti- mates take the form ˆβR j=yj/(1+λ), (6.14) and the lasso estimates take the form ˆβL j=⎧ ⎪⎨ ⎪⎩yj−λ/2i fyj>λ /2; yj+λ/2i fyj<−λ/2; 0i f |yj|≤λ/2.(6.15) Figure 6.10 displays the situation. We can see that ridge regression and the lasso perform two very diﬀerent types of shrinkage. In ridge regression, each least squares coeﬃcient estimat e is shrunken by the same proportion. In contrast, the lasso shrinks each least squares coeﬃcient towards zero by a constant amount, λ/2; the least squares coeﬃcients that are less than λ/2 in absolute value are shrunken entirely to zero. The type of shrink- age performed by the lasso in this simple setting (6.15) is known as soft- thresholding . The fact that some lasso coeﬃcients are shrunken entirely tosoft- thresholding zero explains why the lasso pe rforms feature selection. In the case of a more general data matrix X, the story is a little more complicated than what is depicted in Figure 6.10, but the main ideas still hold approximately: ridge regression more or less shrinks every dimension of the data by the same proportion, whereas the lasso more or less shrinks all coeﬃcients toward zero by a simila r amount, and suﬃciently small co- eﬃcients are shrunken all the way to zero. 226 6. Linear Model Selection and Regularization Coefficient EstimateRidge Least Squares −1.5 −0.5 0.0 0.5 1.0 1.5−1.5 −0.5 0.5 1.5 −1.5 −0.5 0.0 0.5 1.0 1.5−1.5 −0.5 0.5 1.5Coefficient EstimateLasso Least Squares yj yj FIGURE 6.10. The ridge regression and lasso coeﬃcient estimates for a simple setting with n=pandXa diagonal matrix with 1’s on the diagonal. Left:The ridge regression coeﬃcient estimates are shrunken proportionally towards zero, relative to the least squares estimates. Right:The lasso coeﬃcient estimates are soft-thresholded towards zero. Bayesian Interpretation for Ridge Regression and the Lasso We now show that one can view ridge regression and the lasso through a Bayesian lens. A Bayesian viewpoint for regression assumes that the coeﬃcient vector βhas some priordistribution, say p(β), where β= (β0,β1,...,β p)T. The likelihood of the data can be written as f(Y|X,β), whereX=(X1,...,X p). Multiplying the prior distribution by the likeli- hood gives us (up to a proportionality constant) the posterior distribution ,posterior distribution which takes the form p(β|X,Y)∝f(Y|X,β)p(β|X)=f(Y|X,β)p(β), where the proportionality above follows from Bayes’ theorem, and the equality above follows from the assumption that Xis ﬁxed. We assume the usual linear model, Y=β0+X1β1+...+Xpβp+/epsilon1, and suppose that the errors are independent and drawn from a normal dis- tribution. Furthermore, assume that p(β)=/producttextp j=1g(βj), for some density function g. It turns out that ridge regression and the lasso follow naturally from two special cases of g: •Ifgis a Gaussian distribution with mean zero and standard deviation a function of λ, then it follows that the posterior mode forβ—thatposterior mode is, the most likely value for β, given the data—is given by the ridge regression solution. (In fact, the ridge regression solution is also the posterior mean.) 6.2 Shrinkage Methods 2270.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 −3 −2 −1 2 30.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 βj βj (βj)j(β) 1 0 −3 −2 −1 2 3 1 0 FIGURE 6.11. Left:Ridge regression is the posterior mode for βunder a Gaus- sian prior. Right:The lasso is the posterior mode for βunder a double-exponential prior. •Ifgis a double-exponential (Laplace) distribution with mean zero and scale parameter a function of λ, then it follows that the posterior mode for βis the lasso solution. (However, the lasso solution is not the posterior mean, and in fact, the posterior mean does not yield a sparse coeﬃcient vector.) The Gaussian and double-exponential priors are displayed in Figure 6.11. Therefore, from a Bayesian viewpoint, ridge regression and the lasso follow directly from assuming the usual linear model with normal errors, together with a simple prior distribution for β. Notice that the lasso prior is steeply peaked at zero, while the Gaussian is ﬂatter and fatter at zero. Hence, the lasso expects a priori that many of the coeﬃcients are (exactly) zero, while ridge assumes the coeﬃcients are r andomly distributed about zero. 6.2.3 Selecting the Tuning Parameter Just as the subset selection approaches considered in Section 6.1 require a method to determine which of the models under consideration is best, implementing ridge regression and the lasso requires a method for selecting a value for the tuning parameter λin (6.5) and (6.7), or equivalently, the value of the constraint sin (6.9) and (6.8). Cross-validationprovides a sim- ple way to tackle this problem. We choose a grid of λvalues, and compute the cross-validationerror for each value of λ, as described in Chapter 5. We then select the tuning parameter value for which the cross-validation error is smallest. Finally, the model is re-ﬁt using all of the available observations and the selected value of the tuning parameter. Figure 6.12 displays the choice of λthat results from performing leave- one-out cross-validation on the ridge regression ﬁts from the Creditdata set. The dashed vertical lines indicate the selected value of λ.I nt h i sc a s e the value is relatively small, indicating that the optimal ﬁt only involves a 228 6. Linear Model Selection and Regularization 5e−03 5e−02 5e−01 5e+0025.0 25.2 25.4 25.6Cross−Validation Error 5e−03 5e−02 5e−01 5e+00−300 −100 0 100 300Standardized Coefficients λ λ FIGURE 6.12. Left:Cross-validation errors that result from applying ridge regression to the Creditdata set with various value of λ.Right:The coeﬃcient estimates as a function of λ. The vertical dashed lines indicate the value of λ selected by cross-validation. smallamountofshrinkagerelativetotheleastsquaressolution.Inaddition, the dip is not very pronounced, so there is rather a wide range of values that would give very similar error. In a case like this we might simply use the least squares solution. Figure 6.13 providesan illustration of ten-fold cross-validationapplied to the lasso ﬁts on the sparse simulated d ata from Figure 6.9. The left-hand panelofFigure6.13displaysthe cross-validationerror,whiletheright-hand panel displays the coeﬃcient estimat es. The vertical dashed lines indicate the point at which the cross-validation error is smallest. The two colored lines in the right-hand panel of Figure 6.13 represent the two predictors that are related to the response, wh ile the grey lines represent the unre- lated predictors; these are often referred to as signalandnoisevariables,signalrespectively. Not only has the lasso correctly given much larger coeﬃ- cient estimates to the two signal pred ictors, but also the minimum cross- validation error corresponds to a set of coeﬃcient estimates for which only the signal variables are non-zero. Hence cross-validation together with the lasso has correctly identiﬁed the two signal variables in the model, even though this is a challenging setting, with p= 45 variables and only n=5 0 observations. In contrast, the least squares solution—displayed on the far right of the right-hand panel of Figure 6.13—assigns a large coeﬃcient estimate to only one of the two signal variables. 6.3 Dimension Reduction Methods The methods that we have discussed so far in this chapter have controlled variance in two diﬀerent ways, either by using a subset of the original vari- ables, or by shrinking their coeﬃcients toward zero. All of these methods 6.3 Dimension Reduction Methods 229 0.0 0.2 0.4 0.6 0.8 1.00 200 600 1000 1400Cross−Validation Error 0.0 0.2 0.4 0.6 0.8 1.0−50 51 0 1 5Standardized Coefficients ˆβL λ1/ˆβ1ˆβL λ1/ˆβ1 FIGURE 6.13. Left: Ten-fold cross-validation MSE for the lasso, applied to the sparse simulated data set from Figure 6.9. Right:The corresponding lasso coeﬃcient estimates are displayed. The vertical dashed lines indicate the lasso ﬁt for which the cross-validation error is smallest. are deﬁned using the original predictors, X1,X2,...,X p.W en o we x p l o r e a class of approaches that transform the predictors and then ﬁt a least squares model using the transformed variables. We will refer to these tech- niques as dimension reduction methods.dimension reduction LetZ1,Z2,...,Z Mrepresent M<plinear combinations of our original linear combinationppredictors. That is, Zm=p/summationdisplay j=1φjmXj (6.16) for some constants φ1m,φ2m...,φpm,m=1,...,M. We can then ﬁt the linear regression model yi=θ0+M/summationdisplay m=1θmzim+/epsilon1i,i=1,...,n, (6.17) using least squares. Note that in (6.17) , the regressioncoeﬃcients are given byθ0,θ1,...,θ M.Iftheconstants φ1m,φ2m,...,φ pmarechosenwisely,then such dimension reduction approaches can often outperform least squares regression. In other words, ﬁtting (6.17) using least squares can lead to better results than ﬁtting (6.1) using least squares. The term dimension reduction comes from the fact that this approach reduces the problem of estimating the p+1 coeﬃcients β0,β1,...,β pto the simpler problem of estimating the M+1 coeﬃcients θ0,θ1,...,θ M,w h e r e M<p. In other words, the dimension of the problem has been reduced fromp+1toM+1. Notice that from (6.16), M/summationdisplay m=1θmzim=M/summationdisplay m=1θmp/summationdisplay j=1φjmxij=p/summationdisplay j=1M/summationdisplay m=1θmφjmxij=p/summationdisplay j=1βjxij, 230 6. Linear Model Selection and Regularization 10 20 30 40 50 60 700 5 10 15 20 25 30 35 PopulationAd Spending FIGURE 6.14. The population size ( pop) and ad spending ( ad)f o r100diﬀerent cities are shown as purple circles. The green solid line indicates the ﬁrst principal component, and the blue dashed line indicates the second principal component. where βj=M/summationdisplay m=1θmφjm. (6.18) Hence (6.17) can be thought of as a special case of the original linear regression model given by (6.1). Dimension reduction serves to constrain the estimated βjcoeﬃcients, since now they must take the form (6.18). This constraint on the form of the coeﬃ cients has the potential to bias the coeﬃcient estimates. How ever, in situations where pis large relative to n, selectingavalueof M/lessmuchpcansigniﬁcantlyreducethevarianceoftheﬁtted coeﬃcients. If M=p,a n da l lt h e Zmare linearly independent, then (6.18) poses no constraints. In this case, no dimension reduction occurs, and so ﬁtting (6.17) is equivalent to performing least squares on the original p predictors. All dimension reduction methods work in two steps. First, the trans- formed predictors Z1,Z2,...,Z Mare obtained. Second, the model is ﬁt using these Mpredictors. However, the choice of Z1,Z2,...,Z M, or equiv- alently, the selection of the φjm’s, can be achieved in diﬀerent ways. In this chapter,wewill considertwoapproachesforthis task: principal components andpartial least squares . 6.3.1 Principal Components Regression Principal components analysis (PCA) is a popular approach for derivingprincipal components analysisa low-dimensional set of features from a large set of variables. PCA is discussedingreaterdetailasatoolfor unsupervised learning inChapter10. Here we describe its use as a dimension reduction technique for regression. 6.3 Dimension Reduction Methods 231 An Overview of Principal Components Analysis PCA is a technique for reducing the dimension of a n×pdata matrix X. Theﬁrst principal component direction of the data is that along which the observations vary the most . For instance,consider Figure 6.14,whichshows population size ( pop) in tens of thousands of people, and ad spending for a particular company ( ad) in thousands of dollars, for 100 cities. The green solid line represents the ﬁrst principal component direction of the data. We can see by eye that this is the direction along which there is the greatest variability in the data. That is, if we projected the 100 observations onto this line (as shown in the left-hand panel of Figure 6.15),then the resulting projected observations would have the largest possible variance; projecting the observations onto any other line would yield projected observations with lower variance. Projecting a point onto a line simply involves ﬁnding the location on the line which is closest to the point. The ﬁrstprincipalcomponent is displayedgraphicallyinFigure6.14,but how can it be summarized mathematically? It is given by the formula Z1=0.839×(pop−pop)+0.544×(ad−ad). (6.19) Hereφ11=0.839 and φ21=0.544 are the principal component loadings, which deﬁne the direction referred to above. In (6.19), popindicates the mean of all popvalues in this data set, and adindicates the mean of all ad- vertisingspending. Theidea isthat out ofeverypossible linear combination ofpopand adsuch that φ2 11+φ2 21= 1, this particular linear combination yields the highest variance: i.e. this is the linear combination for which Var(φ11×(pop−pop)+φ21×(ad−ad)) is maximized. It is necessary to consider only linear combinations of the form φ2 11+φ2 21= 1, since otherwise we could increase φ11andφ21arbitrarily in order to blow up the variance. In (6.19), the two loadings are both positive and have similar size, and so Z1is almost an averageof the two variables. Sincen= 100, popand adare vectors of length 100, and so is Z1in (6.19). For instance, zi1=0.839×(popi−pop)+0.544×(adi−ad).(6.20) The values of z11,...,z n1areknownas the principal component scores ,a n d can be seen in the right-hand panel of Figure 6.15. There is also another interpretation for PCA: the ﬁrst principal compo- nent vector deﬁnes the line that is as close as possible to the data. For instance, in Figure 6.14, the ﬁrst principal component line minimizes the sum of the squared perpendicular dis tances between each point and the line. These distances are plotted as dashed line segments in the left-hand panel of Figure 6.15, in which the crosses represent the projection of each point ontothe ﬁrst principal component line. The ﬁrst principal component has been chosen so that the pro jected observations are as close as possible to the original observations. 232 6. Linear Model Selection and Regularization PopulationAd Spending 20 30 40 505 1 01 52 02 53 0 −20 −10 0 10 20−10 −5 0 5 10 1st Principal Component2nd Principal Component FIGURE 6.15. A subset of the advertising data. The mean popandadbudgets are indicated with a blue circle. Left:The ﬁrst principal component direction is shown in green. It is the dimension along which the data vary the most, and it also deﬁnes the line that is closest to all nof the observations. The distances from each observation to the principal component are represented using the black dashed line segments. The blue dot represents (pop,ad).Right:The left-hand panel has been rotated so that the ﬁrst principal component direction coincides with the x-axis. In the right-hand panel of Figure 6.15, the left-hand panel has been rotated so that the ﬁrst principal component direction coincides with the x-axis. It is possible to show that the ﬁrst principal component score for theith observation, given in (6.20), is the distance in the x-direction of the ith cross from zero. So for example, t he point in the bottom-left corner of the left-hand panel of Figure 6.15 has a large negative principal component score,zi1=−26.1, while the point in the top-right corner has a large positive score, zi1=1 8.7. These scores can be computed directly using (6.20). We can think of the values of the principal component Z1as single- number summaries of the joint popand adbudgets for each location. In this example, if zi1=0.839×(popi−pop)+0.544×(adi−ad)<0, then this indicates a city with below-average population size and below- averageadspending. A positive scoresuggests the opposite.Howwellcan a single number representboth popand ad? In this case,Figure6.14indicates that popand adhave approximately a linear relationship, and so we might expect that a single-number summary will work well. Figure 6.16 displays zi1versus both popand ad. The plots show a strong relationship between the ﬁrst principal component and the t wo features. In other words, the ﬁrst principal component appears to capture most of the information contained in the popand adpredictors. So far we have concentrated on the ﬁrst principal component. In gen- eral, one can construct up to pdistinct principal components. The second principal component Z2is a linear combination of the variables that is un- correlated with Z1, and has largest variance subject to this constraint. The second principal component direction is illustrated as a dashed blue line in Figure 6.14. It turns out that the zero correlation condition of Z1withZ2 6.3 Dimension Reduction Methods 233 1st Principal ComponentPopulation −3 −2 −1 0 1 2 3 −3 −2 −1 0 1 2 320 30 40 50 60 5 1 01 52 02 53 0 1st Principal ComponentAd Spending FIGURE 6.16. Plots of the ﬁrst principal component scores zi1versus popand ad. The relationships are strong. is equivalent to the condition that the direction must be perpendicular ,o rperpendicularorthogonal , to the ﬁrst principal component direction. The second principalorthogonalcomponent is given by the formula Z2=0.544×(pop−pop)−0.839×(ad−ad). Since the advertising data has two predictors, the ﬁrst two principal com- ponents contain all of the information that is in popand ad. However, by construction, the ﬁrst component will contain the most information. Con- sider, for example, the much larger variability of zi1(thex-axis) versus zi2(they-axis) in the right-hand panel of Figure 6.15. The fact that the second principal component scores are much closer to zero indicates that this component captures far less information. As another illustration, Fig- ure 6.17 displays zi2versus popand ad. There is little relationship between the second principal component and these two predictors, again suggesting that in this case, one only needs the ﬁrst principal component in order to accurately represent the popand adbudgets. With two-dimensional data, such as in our advertising example, we can construct at most two principal components. However, if we had other predictors, such as population age, income level, education, and so forth, then additional components could be c onstructed. They would successively maximize variance, subject to the const raint of being uncorrelatedwith the preceding components. The Principal Components Regression Approach Theprincipal components regression (PCR) approachinvolvesconstructingprincipal components regressionthe ﬁrstMprincipalcomponents, Z1,...,Z M, andthen usingthesecompo- nents as the predictors in a linear regression model that is ﬁt using least squares. The key idea is that often a small number of prin- cipal components suﬃce to explain most of the variability in the data, as well as the relationship with the response. In other words, we assume that the directions in which X1,...,X pshow the most variation are the direc- tions that are associated with Y. While this assumption is not guaranteed 234 6. Linear Model Selection and Regularization 2nd Principal ComponentPopulation −1.0 −0.5 0.0 0.5 1.0 −1.0 −0.5 0.0 0.5 1.020 30 40 50 60 51 0 1 5 2 0 2 5 3 0 2nd Principal ComponentAd Spending FIGURE 6.17. Plots of the second principal component scores zi2versus pop and ad. The relationships are weak. Number of ComponentsMean Squared Error 0 10 20 30 40 0 10 20 30 400 1 02 03 04 05 06 0 7 0 0 50 100 150 Number of ComponentsMean Squared ErrorSquared Bias Test MSE Variance FIGURE 6.18. PCR was applied to two simulated data sets. Left:Simulated data from Figure 6.8. Right:Simulated data from Figure 6.9. to be true, it often turns out to be a reasonable enough approximation to give good results. If the assumption underlying PCR holds, then ﬁtting a least squares model to Z1,...,Z Mwill lead to better results than ﬁtting a least squares model to X1,...,X p, since most or all of the information in the data that relates to the response is contained in Z1,...,Z M, and by estimating only M/lessmuchpcoeﬃcients we can mitigate overﬁtti ng. In the advertising data, the ﬁrst principal component explains most of the variance in both popand ad, so a principal component regressionthat uses this single variable to predict some response of interest, such as sales, will likely perform quite well. Figure 6.18 displays the PCR ﬁts on the simulated data sets from Figures 6.8 and 6.9. Recall that both data sets were generated using n=5 0 observations and p= 45 predictors. However,while the response in the ﬁrst data setwasa function ofallthe predictors,the responsein the seconddata set was generated using only two of the predictors. The curves are plotted as a function of M, the number of principal components used as predic- tors in the regression model. As more principal components are used in 6.3 Dimension Reduction Methods 235 PCR Number of ComponentsMean Squared ErrorSquared Bias Test MSE Variance 0 1 02 03 04 00 1 02 03 04 05 06 07 0 0 1 02 03 04 05 06 07 0 0.0 0.2 0.4 0.6 0.8 1.0Ridge Regression and Lasso Shrinkage FactorMean Squared Error FIGURE 6.19. PCR, ridge regression, and the lasso were applied to a simulated data set in which the ﬁrst ﬁve principal components of Xcontain all the informa- tion about the response Y. In each panel, the irreducible error Var (/epsilon1)is shown as a horizontal dashed line. Left:Results for PCR. Right:Results for lasso (solid) and ridge regression (dotted). The x-axis displays the shrinkage factor of the co- eﬃcient estimates, deﬁned as the /lscript2norm of the shrunken coeﬃcient estimates divided by the /lscript2norm of the least squares estimate. the regression model, the bias decreases, but the variance increases. This results in a typical U-shape for the mean squarederror.When M=p= 45, then PCR amounts simply to a least squares ﬁt using all of the original predictors. The ﬁgure indicates that performing PCR with an appropriate choice of Mcan result in a substantial impro vement over least squares, es- pecially in the left-hand panel. However, by examining the ridge regression and lasso results in Figures 6.5, 6.8, and 6.9, we see that PCR does not perform as well as the two shrinkage methods in this example. The relatively worseperformance of PCR in Figure 6.18 is a consequence of the fact that the data were generated in such a way that many princi- pal components are required in order to adequately model the response. In contrast, PCR will tend to do well in cases when the ﬁrst few principal components are suﬃcient to capture most of the variation in the predictors as well as the relationship with the response. The left-hand panel of Fig- ure 6.19 illustrates the results from another simulated data set designed to be more favorable to PCR. Here the re sponse was generated in such a way that it depends exclusively on the ﬁrst ﬁve principal components. Now the bias drops to zero rapidly as M, the number of principal components used in PCR, increases. The mean squared error displays a clear minimum at M= 5. The right-hand panel of Figure 6.19 displays the results on these data using ridge regression and the lasso. All three methods oﬀer a signif- icant improvement over least squares. However, PCR and ridge regression slightly outperform the lasso. We note that even though PCR provides a simple way to perform regression using M<ppredictors, it is nota feature selection method. This is because each of the Mprincipal components used in the regression 236 6. Linear Model Selection and Regularization 2468 1 0−300 −100 0 100 200 300 400 Number of ComponentsStandardized CoefficientsIncome Limit Rating Student 2468 1 020000 40000 60000 80000 Number of ComponentsCross−Validation MSE FIGURE 6.20. Left:PCR standardized coeﬃcient estimates on the Creditdata set for diﬀerent values of M.Right:The ten-fold cross validation MSE obtained using PCR, as a function of M. is a linear combination of all pof theoriginal features. For instance, in (6.19),Z1was a linear combination of both popand ad. Therefore, while PCR often performs quite well in many practical settings, it does not result in the development of a model that relies upon a small set of the original features. In this sense, PCR is more cl osely related to ridge regressionthan to the lasso. In fact, one can show that PCR and ridge regression are very closely related. One can even think of ridge regression as a continuous ver- sion of PCR!4 In PCR, the number of principal components, M, is typically chosen by cross-validation. The results of applying PCR to the Creditdata set are shown in Figure 6.20; the right-hand panel displays the cross-validation errors obtained, as a function of M. On these data, the lowest cross- validation error occurs when there are M= 10 components; this corre- sponds to almost no dimension reduction at all, since PCR with M=1 1 is equivalent to simply performing least squares. When performing PCR, we generally recommend standardizing each predictor, using (6.6), prior to generating the principal components. This standardization ensures that all variables are on the same scale. In the absence of standardization, the high-variance variables will tend to play a larger role in the principal components obtained, and the scale on which the variables are measured will ulti mately have an eﬀect on the ﬁnal PCR model. However, if the variables are all measured in the same units (say, kilograms, or inches), then one might choose not to standardize them. 4More details can be found in Section 3.5 of Elements of Statistical Learning by Hastie, Tibshirani, and Friedman. 6.3 Dimension Reduction Methods 237 20 30 40 50 605 1 01 52 02 53 0 PopulationAd Spending FIGURE 6.21. For the advertising data, the ﬁrst PLS direction (solid line) and ﬁrst PCR direction (dotted line) are shown. 6.3.2 Partial Least Squares ThePCRapproachthat wejust describedinvolvesidentifying linearcombi- nations, or directions , that best represent the predictors X1,...,X p.T h e s e directions are identiﬁed in an unsupervised way, since the response Yis not used to help determine the principal component directions. That is, the response does not supervise the identiﬁcation of the principal components. Consequently, PCR suﬀers from a drawback: there is no guarantee that the directions that best explain the pred ictors will also be the best directions to use for predicting the response. Unsupervised methods are discussed further in Chapter 10. We now present partial least squares (PLS), a supervised alternative topartial least squares PCR.LikePCR,PLSisadimensionreductionmethod,whichﬁrstidentiﬁes anew setoffeatures Z1,...,Z Mthatarelinearcombinationsoftheoriginal features, and then ﬁts a linear mod el via least squares using these Mnew features. But unlike PCR, PLS identiﬁes these new features in a supervised way—that is, it makes use of the response Yin order to identify new features that not only approximate the old features well, but also that are r e l a t e dt ot h er e s p o n s e . Roughly speaking, the PLS approach attempts to ﬁnd directions that help explain both the response and the predictors. We now describe how the ﬁrst PLS di rection is computed. After stan- dardizing the ppredictors, PLS comput es the ﬁrst direction Z1by setting eachφj1in (6.16) equal to the coeﬃcient f rom the simple linear regression ofYontoXj. One can show that this coeﬃcient is proportional to the cor- relation between YandXj. Hence, in computing Z1=/summationtextp j=1φj1Xj,P L S places the highest weight on the variables that are most strongly related to the response. Figure6.21displaysanexampleofPLSonthe advertisingdata.Thesolid green line indicates the ﬁrst PLS direction, while the dotted line shows the ﬁrstprincipalcomponentdirection.PLShaschosenadirectionthathasless change in the addimension per unit change in the popdimension, relative 238 6. Linear Model Selection and Regularization to PCA. This suggests that popis more highly correlated with the response than is ad. The PLS direction does not ﬁt the predictors as closely as does PCA, but it does a better job explaining the response. To identify the second PLS direction we ﬁrst adjusteach of the variables forZ1, by regressing each variable on Z1and taking residuals . These resid- uals can be interpreted as the remai ning information that has not been explained by the ﬁrst PLS direction. We then compute Z2using this or- thogonalized data in exactly the same fashion as Z1was computed based on the original data. This iterative approach can be repeated Mtimes to identify multiple PLS components Z1,...,Z M. Finally, at the end of this procedure, we use least square s to ﬁt a linear model to predict Yusing Z1,...,Z Min exactly the same fashion as for PCR. As with PCR, the number Mof partial least squares directions used in PLS is a tuning parameter that is typically chosen by cross-validation. We generally standardize the predictors and response before performing PLS. PLS is popular in the ﬁeld of chemometrics, where many variables arise from digitized spectrometry signals. I n practice it often performs no better than ridge regression or PCR. While the supervised dimension reduction of PLS can reduce bias, it also has the potential to increase variance, so that the overall beneﬁt of PLS relative to PCR is a wash. 6.4 Considerations in High Dimensions 6.4.1 High-Dimensional Data Most traditional statistical techniqu es for regression and classiﬁcation are intended for the low-dimensional setting in which n, the number of ob-low- dimensional servations, is much greater than p, the number of features. This is due in part to the fact that throughout most of the ﬁeld’s history, the bulk of sci- entiﬁc problems requiring the use of statistics have been low-dimensional. For instance, consider the task of dev eloping a model to predict a patient’s blood pressure on the basis of his or her age, gender, and body mass index (BMI). There are three predictors, or four if an intercept is included in the model, and perhaps several thousand patients for whom blood pressure and age, gender, and BMI are available. Hence n/greatermuchp, and so the problem is low-dimensional. (By dimension here we are referring to the size of p.) In the past 20 years, new technologies have changed the way that data are collected in ﬁelds as diverse as ﬁna nce, marketing, and medicine. It is now commonplace to collect an almost unlimited number of feature mea- surements ( pvery large). While pcan be extremely large, the number of observations nis often limited due to cost, sample availability, or other considerations. Two ex amples are as follows: 1. Rather than predicting blood pressure on the basis of just age, gen- der, and BMI, one might also collect measurements for half a million 6.4 Considerations in High Dimensions 239 single nucleotide polymorphisms (SNPs; these are individual DNA mutations that are relatively common in the population) for inclu- sion in the predictive model. Then n≈200 and p≈500,000. 2. Amarketinganalystinterestedinunderstandingpeople’sonlineshop- ping patterns could treat as features all of the search terms entered by users of a search engine. This is sometimes known as the “bag-of- words” model. The same researcher might have access to the search histories of only a few hundred or a few thousand search engine users who have consented to share their information with the researcher. For a given user, each of the psearch terms is scored present (0) or absent (1), creating a large binary feature vector. Then n≈1,000 andpis much larger. Data sets containing more features than observations are often referred to ashigh-dimensional . Classical approaches such as least squares linearhigh- dimensional regression are not appropriate in this setting. Many of the issues that arise in the analysis of high-dimensional data were discussed earlier in this book, since they apply alsowhen n>p: these include the roleof the bias-variance trade-oﬀ and the danger of overﬁtting. Though these issues are always rele- vant, they can become particularly important when the number of features is very large relative to the number of observations. We have deﬁned the high-dimensional setting as the casewhere the num- ber of features pis larger than the number of observations n.B u tt h ec o n - siderations that we will now discuss certainly also apply if pis slightly smaller than n, and are best always kept in mind when performing super- vised learning. 6.4.2 What Goes Wrong in High Dimensions? In order to illustrate the need for extra care and specialized techniques for regression and classiﬁcation when p>n, we begin by examining what can go wrong if we apply a statistical technique not intended for the high- dimensional setting. For this purpose, we examine least squares regression. But the sameconceptsapplyto logisticregression,lineardiscriminantanal- ysis, and other classical statistical approaches. When the number of features pis as large as, or larger than, the number ofobservations n, leastsquaresas describedin Chapter 3 cannot(orrather, should not ) be performed. The reason is simple: regardless of whether or not there truly is a relationship between the features and the response, least squares will yield a set of coeﬃcient estimates that result in a perfect ﬁt to the data, such that the residuals are zero. AnexampleisshowninFigure6.22with p= 1feature(plusanintercept) in two cases: when there are 20 observations, and when there are only two observations. When there are 20 observations, n>pand the least 240 6. Linear Model Selection and Regularization −1.5 −1.0 −0.5 0.0 0.5 1.0−10 −5 0 5 10 −1.5 −1.0 −0.5 0.0 0.5 1.0−10 −5 0 5 10 X X YY FIGURE 6.22. Left:Least squares regression in the low-dimensional setting. Right:Least squares regression with n=2observations and two parameters to be estimated (an intercept and a coeﬃcient). squaresregressionlinedoesnotperfectlyﬁtthedata;instead,theregression line seeks to approximate the 20 observations as well as possible. On the other hand, when there are only two observations, then regardless of the values of those observations, the regression line will ﬁt the data exactly. This is problematic because this perfect ﬁt will almost certainly lead to overﬁtting of the data. In other words, though it is possible to perfectly ﬁt the trainingdata in the high-dimensionalsetting, the resultinglinearmodel will perform extremely poorly on an independent test set, and therefore does not constitute a useful model. In fact, we can see that this happened in Figure 6.22: the least squares line obtained in the right-hand panel will perform very poorly on a test set comprised of the observations in the left- hand panel. The problem is simple: when p>norp≈n, a simple least squares regression line is too ﬂexibleand hence overﬁts the data. Figure 6.23 further illustrates the risk ofcarelesslyapplying least squares when the number of features pis large. Data were simulated with n=2 0 observations,andregressionwasperformedwithbetween1and20features, each of which was completely unrelat ed to the response. As shown in the ﬁgure,the model R2increasesto1asthe numberoffeaturesincluded in the model increases, and correspondingly the training set MSE decreases to 0 as the number of features increases, even though the features are completely u n r e l a t e dt ot h er e s p o n s e . On the other hand, the MSE on an independent test setbecomes extremely large as the number of features included in the model increases, because including the additional predictors leads to a vast increase in the variance of the coeﬃci ent estimates. Looking at the test set MSE, it is clear that the best model contains at most a few variables. However, someone who carelessly examines only the R2or the training set MSE might erroneously conclude that the model with the greatest number of variables is best. This indicates the importance of applying extra care 6.4 Considerations in High Dimensions 241 5 10 15 5 10 15 5 10 15 Number of VariablesR2 Number of VariablesTraining MSE0.2 0.4 0.6 0.8 1.0 0.0 0.2 0.4 0.6 0.8 1 5 50 500 Number of VariablesTest MSE FIGURE 6.23. On a simulated example with n=2 0training observations, features that are completely unrelated to the outcome are added to the model. Left:TheR2increases to 1 as more features are included. Center:The training set MSE decreases to 0 as more features are included. Right:The test set MSE increases as more features are included. when analyzing data sets with a large number of variables, and of always evaluating model performance on an independent test set. InSection6.1.3,wesawanumberofapproachesforadjustingthetraining set RSS or R2in order to account for the number of variables used to ﬁt a least squares model. Unfortunately, the Cp, AIC, and BIC approaches are not appropriate in the high-dimensional setting, because estimating ˆ σ2 is problematic. (For instance, the formula for ˆ σ2from Chapter 3 yields an estimate ˆ σ2= 0 in this setting.) Similarly, problems arise in the application of adjusted R2in the high-dimensional setting, since one can easily obtain a model with an adjusted R2value of 1. Clearly, alternative approaches that are better-suited to the high-dimensional setting are required. 6.4.3 Regression in High Dimensions It turns out that many of the methods seen in this chapter for ﬁtting less ﬂexible least squares models, such as forward stepwise selection, ridge regression, the lasso, and principal components regression, are particularly usefulforperformingregressioninthehigh-dimensionalsetting.Essentially, these approaches avoid overﬁtting by using a less ﬂexible ﬁtting approach than least squares. Figure 6.24 illustrates the performance of the lasso in a simple simulated example. There are p= 20, 50, or 2 ,000 features, of which 20 are truly associated with the outcome. The lasso was performed on n= 100 training observations, and the mean squared error was evaluated on an independent test set. As the number of features increases, the test set error increases. Whenp= 20, the lowest validation set error was achieved when λin (6.7) was small; however, when pwas larger then the lowest validation set error was achieved using a larger value of λ. In each boxplot, rather than reporting the values of λused, the degrees of freedom of the resulting 242 6. Linear Model Selection and Regularization 1 16 21 1 28 51 1 70 111012345 012345 012345p =2 0 p =5 0 p = 2000 Degrees of Freedom Degrees of Freedom Degrees of Freedom FIGURE 6.24. The lasso was performed with n= 100observations and three values of p, the number of features. Of the pfeatures, 20 were associated with the response. The boxplots show the test MSEs that result using three diﬀerent values of the tuning parameter λin (6.7). For ease of interpretation, rather than reporting λ,t h edegrees of freedom are reported; for the lasso this turns out to be simply the number of estimated non-zero coeﬃcients. When p=2 0,t h e lowest test MSE was obtained with the smallest amount of regularization. When p=5 0, the lowest test MSE was achieved when there is a substantial amount of regularization. When p=2,000the lasso performed poorly regardless of the amount of regularization, due to the fact that only 20 of the 2,000 features truly are associated with the outcome. lasso solution is displayed; this is simply the number of non-zero coeﬃcient estimates in the lasso solution, and is a measure of the ﬂexibility of the lasso ﬁt. Figure 6.24 highlights three important points: (1) regularization or shrinkage plays a key role in high-dimensional problems, (2) appropriate tuning parameter selection is crucial for good predictive performance, and (3) the test error tends to increase as the dimensionality of the problem (i.e. the number of features or predictors) increases, unless the additional features are truly associated with the response. The third point above is in fact a key principle in the analysis of high- dimensionaldata,whichisknownasthe curse of dimensionality .O n em i g h tcurse of di- mensionality think that as the number of features used to ﬁt a model increases, the quality of the ﬁtted model will increase as well. However, comparing the left-hand and right-hand panels in Figure 6.24, we see that this is not necessarily the case: in this exampl e, the test set MSE almost doubles as pincreases from 20 to 2,000. In general, adding additional signal features that are truly associated with the response will improve the ﬁtted model , in the sense of leading to a reduction in test set error. However, adding noise features that are not truly associated with the response will lead to a deterioration in the ﬁtted model, a nd consequently an increased test set error. This is because noise featur es increase the dimensionality of the 6.4 Considerations in High Dimensions 243 problem, exacerbating the risk of overﬁtting (since noise features may be assigned nonzero coeﬃcients due to ch ance associations with the response on the training set) without any potential upside in terms of improved test set error. Thus, we see that new technologies that allow for the collection of measurements for thousands or millions of features are a double-edged sword: they can lead to improved predi ctive models if these features are in fact relevant to the problem at hand, but will lead to worse results if the features are not relevant. Even if they are relevant, the variance incurred in ﬁtting their coeﬃcients may outweigh the reduction in bias that they bring. 6.4.4 Interpreting Results in High Dimensions When we perform the lasso, ridge regression, or other regression proce- dures in the high-dimensional setting, we must be quite cautious in the way that we report the results obtained. In Chapter 3, we learned about multi- collinearity , the concept that the variables in a regression might be corre- lated with each other. In the high-dimensional setting, the multicollinearity problem is extreme: any variable in the model can be written as a linear combination of all of the other variables in the model. Essentially, this means that we can never know exactly which variables (if any) truly are predictive of the outcome, and we can never identify the bestcoeﬃcients for use in the regression. At most, we can hope to assign large regression coeﬃcients to variables that are correlatedwith the variables that truly are predictive of the outcome. For instance, suppose that we are trying to predict blood pressure on the basis of half a million SNPs, and that forward stepwise selection indicates that 17 of those SNPs lead to a good predictive model on the training data. It would be incorrecttoconclude that these 17SNPs predict blood pressure more eﬀectively than the other SNPs not included in the model. There are likely to be many sets of 17 SNPs that would predict blood pressure just as well as the selected model. If we were to obtain an independent data set and perform forward stepwise select ion on that data set, we would likely obtain a model containing a diﬀerent, and perhaps even non-overlapping, set of SNPs. This does not detract fr om the value of the model obtained— for instance, the model might turn out to be very eﬀective in predicting blood pressure on an independent set of patients, and might be clinically useful for physicians. But we must be careful not to overstate the results obtained, and to make it clear that what we have identiﬁed is simply one of many possible models for predicting blood pressure, and that it must be further validated on independent data sets. It is also important to be particularly careful in reporting errors and measures of model ﬁt in the high-dimensional setting. We have seen that whenp>n, it is easy to obtain a useless model that has zero residu- als. Therefore, one should neveruse sum of squared errors, p-values, R2 244 6. Linear Model Selection and Regularization statistics, or other traditional measures of model ﬁt on the training data as evidence of a good model ﬁt in the high-dimensional setting. For instance, as we saw in Figure 6.23, one can easily obtain a model with R2=1w h e n p>n. Reporting this fact might mislead others into thinking that a sta- tistically valid and useful model has been obtained, whereas in fact this provides absolutely no evidence of a compelling model. It is important to instead reportresults on an independent test set, or cross-validationerrors. For instance, the MSE or R2on an independent test set is a valid measure of model ﬁt, but the MSE on the training set certainly is not. 6.5 Lab 1: Subset Selection Methods 6.5.1 Best Subset Selection Here we apply the best subset selection approach to the Hittersdata. We wish to predict a baseball player’s Salaryon the basis of various statistics associated with performance in the previous year. First of all, we note that the Salaryvariable is missing for some of the players. The is.na()function can be used to identify the missing observa-is.na()tions. It returns a vector of the same length as the input vector,with a TRUE for any elements that are missing, and a FALSEfor non-missing elements. The sum()function can then be used to count all of the missing elements.sum() > library(ISLR) > fix(Hitters) > names(Hitters) [1] \"AtBat\" \"Hits\" \"HmRun\" \"Runs\" \"RBI\" [6] \"Walks\" \"Years\" \"CAtBat\" \"CHits\" \"CHmRun\" [11] \"CRuns\" \"CRBI\" \"CWalks\" \"League\" \"Division\" [16] \"PutOuts\" \"Assists\" \"Errors\" \"Salary\" \"NewLeague \" > dim(Hitters) [1] 322 20 > sum(is.na(Hitters$Salary)) [1] 59 Hence we see that Salaryis missing for 59 players. The na.omit() function removes all of the rows that have missing values in any variable. > Hitters=na.omit(Hitters) > dim(Hitters) [1] 263 20 > sum(is.na(Hitters)) [1] 0 The regsubsets() function (part of the leapslibrary) performs best sub-regsubsets()set selection by identifying the best model that contains a given number of predictors, where bestis quantiﬁed using RSS. The syntax is the same as for lm().T h e summary() command outputs the best set of variables for each model size. 6.5 Lab 1: Subset Selection Methods 245 > library(leaps) > regfit.full=regsubsets (Salary ∼.,Hitters) > summary(regfit.full) Subset selection object Call: regsubsets .formula(Salary ∼., Hitters) 19 Variables (and intercept ) ... 1 subsets of each size up to 8 Selection Algorithm : exhaustive AtBat Hits HmRun Runs RBI Walks Years CAtBat CHits 1 (1)\"\" \"\" \"\" \"\" \"\"\"\" \"\" \"\" \"\" 2 (1)\"\" \" * \" \"\" \"\" \"\"\"\" \"\" \"\" \"\" 3 (1)\"\" \" * \" \"\" \"\" \"\"\"\" \"\" \"\" \"\" 4 (1)\"\" \" * \" \"\" \"\" \"\"\"\" \"\" \"\" \"\" 5 ( 1 ) \"*\" \"*\" \" \" \" \" \" \" \" \" \" \" \" \" \" \" 6 ( 1 ) \"*\" \"*\" \" \" \" \" \" \" \"*\" \" \" \" \" \" \" 7 (1)\"\" \" * \" \"\" \"\" \"\"\" * \" \"\" \" * \" \" * \" 8 ( 1 ) \"*\" \"*\" \" \" \" \" \" \" \"*\" \" \" \" \" \" \" CHmRun CRuns CRBI CWalks LeagueN DivisionW PutOuts 1 (1)\"\" \"\" \" * \" \"\" \"\" \"\" \"\" 2 (1)\"\" \"\" \" * \" \"\" \"\" \"\" \"\" 3 (1)\"\" \"\" \" * \" \"\" \"\" \"\" \" * \" 4 (1)\"\" \"\" \" * \" \"\" \"\" \" * \" \" * \" 5 (1)\"\" \"\" \" * \" \"\" \"\" \" * \" \" * \" 6 (1)\"\" \"\" \" * \" \"\" \"\" \" * \" \" * \" 7 (1)\" * \" \"\" \"\" \"\" \"\" \" * \" \" * \" 8 ( 1 ) \"*\" \"*\" \" \" \"*\" \" \" \"*\" \"*\" Assists Errors NewLeagueN 1 (1)\"\" \"\" \"\" 2 (1)\"\" \"\" \"\" 3 (1)\"\" \"\" \"\" 4 (1)\"\" \"\" \"\" 5 (1)\"\" \"\" \"\" 6 (1)\"\" \"\" \"\" 7 (1)\"\" \"\" \"\" 8 (1)\"\" \"\" \"\" An asterisk indicates that a given variable is included in the corresponding model. For instance, this output indicates that the best two-variable model contains only Hitsand CRBI. By default, regsubsets() only reports results up to the best eight-variable model. But the nvmaxoption can be used in order to return as many variables as are desired. Here we ﬁt up to a 19-variable model. > regfit.full=regsubsets (Salary ∼.,data=Hitters , nvmax=19) > reg.summary=summary(regfit.full) The summary() function also returns R2, RSS, adjusted R2,Cp,a n dB I C . We can examine these to try to select the bestoverall model. > names(reg.summary) [1] \"which\" \"rsq\" \"rss\" \"adjr2\" \"cp\" \"bic\" [7] \"outmat\" \"obj\" 246 6. Linear Model Selection and Regularization For instance, we see that the R2statistic increases from 32%, when only one variable is included in the model, to almost 55%, when all variables are included. As expected, the R2statistic increases monotonically as more variables are included. > reg.summary$rsq [1] 0.321 0.425 0.451 0.475 0.491 0.509 0.514 0.529 0.535 [10] 0.540 0.543 0.544 0.544 0.545 0.545 0.546 0.546 0.546 [19] 0.546 Plotting RSS, adjusted R2,Cp, and BIC for all of the models at once will help us decide which model to select. Note the type=\"l\" option tells Rto connect the plotted points with lines. > par(mfrow=c(2,2)) > plot(reg.summary$rss ,xlab=\"Number of Variables \",ylab=\"RSS\", type=\"l\") > plot(reg.summary$adjr2 ,xlab=\"Number of Variables \", ylab=\"Adjusted RSq\",type=\"l\") The points() command works like the plot()command, except that itpoints()puts points on a plot that has already been created, instead of creating a new plot. The which.max() function can be used to identify the location of the maximum point of a vector. We will now plot a red dot to indicate the model with the largest adjusted R2statistic. > which.max(reg. summary$adjr2) [1] 11 > points(11,reg. summary$adjr2[11], col=\"red\",cex=2,pch =20) In a similar fashion we can plot the Cpand BIC statistics, and indicate the models with the smallest statistic using which.min() .which.min() > plot(reg.summary$cp ,xlab=\"Number of Variables \",ylab=\"Cp\", type=’l’) > which.min(reg.summary$cp ) [1] 10 > points(10,reg.summary$cp [10],col=\"red\",cex=2,pch=20) > which.min(reg.summary$bic ) [1] 6 > plot(reg.summary$bic ,xlab=\"Number of Variables \",ylab=\"BIC\", type=’l’) > points(6,reg.summary$bic [6],col=\"red\",cex=2,pch=20) The regsubsets() function has a built-in plot()command which can be used to display the selected variables for the best model with a given number of predictors, ranked according to the BIC, Cp, adjusted R2,o r AIC. To ﬁnd out more about this function, type ?plot.regsubsets . > plot(regfit.full,scale=\"r2\") > plot(regfit.full,scale=\"adjr2\") > plot(regfit.full,scale=\"Cp\") > plot(regfit.full,scale=\"bic\") 6.5 Lab 1: Subset Selection Methods 247 The top row of each plot contains a black square for each variable selected according to the optimal model associat ed with that statistic. For instance, we see that several models share a BIC close to −150. However, the model with the lowest BIC is the six-variable model that contains only AtBat, Hits,Walks,CRBI,DivisionW ,a n d PutOuts. We can use the coef()function to see the coeﬃcient estimates associated with this model. > coef(regfit.full ,6) (Intercept ) AtBat Hits Walks CRBI 91.512 -1.869 7.604 3.698 0.643 DivisionW PutOuts -122.952 0.264 6.5.2 Forward and Backward Stepwise Selection We can also use the regsubsets() function to perform forward stepwise or backward stepwise selection, using the argument method=\"forward\" or method=\"backward\" . > regfit.fwd=regsubsets (Salary ∼.,data=Hi tters , nvmax=19, method=\"forward\") > summary(regfit.fwd) > regfit.bwd=regsubsets (Salary ∼.,data=Hi tters , nvmax=19, method=\"backward \") > summary(regfit.bwd) For instance, we see that using forward stepwise selection, the best one- variable model contains only CRBI, and the best two-variable model ad- ditionally includes Hits. For this data, the best one-variable through six- variable models are each identical for best subset and forward selection. However, the best seven-variable models identiﬁed by forward stepwise se- lection, backwardstepwise selection, and best subset selectionare diﬀerent. > coef(regfit.full ,7) (Intercept ) Hits Walks CAtBat CHits 79.451 1.283 3.227 -0.375 1.496 CHmRun DivisionW PutOuts 1.442 -129.987 0.237 > coef(regfit.fwd ,7) (Intercept ) AtBat Hits Walks CRBI 109.787 -1.959 7.450 4.913 0.854 CWalks DivisionW PutOuts -0.305 -127.122 0.253 > coef(regfit.bwd ,7) (Intercept ) AtBat Hits Walks CRuns 105.649 -1.976 6.757 6.056 1.129 CWalks DivisionW PutOuts -0.716 -116.169 0.303 248 6. Linear Model Selection and Regularization 6.5.3 Choosing Among Models Using the Validation Set Approach and Cross-Validation We just saw that it is possible to choose among a set of models of diﬀerent sizes using Cp,B I C ,a n da d j u s t e d R2. We will now consider how to do this using the validation set and cross-validation approaches. In order for these approaches to yield accurate estimates of the test error, we must use only the training observations to perform all aspects of model-ﬁtting—including variableselection. Therefore,the determination of which model of a given size is best must be made using only the training observations . This point is subtle but important. If the full data set is used to perform the best subset selection step, the validation set errors and cross-validation errors that we obtain will not be accurate estimates of the test error. In order to use the validation set approach, we begin by splitting the observations into a training set and a test set. We do this by creating a random vector, train,o fe l e m e n t se q u a lt o TRUEif the corresponding observation is in the training set, and FALSEotherwise. The vector testhas aTRUEif the observation is in the test set, and a FALSEotherwise. Note the !in the command to create testcauses TRUEst ob es w i t c h e dt o FALSEsa n d vice versa. We also set a random seed so that the user will obtain the same training set/test set split. > set.seed(1) > train=sample(c(TRUE,FALSE), nrow(Hitters),rep=TRUE) > test=(!train) Now, we apply regsubsets() to the training set in order to perform best subset selection. > regfit.best=regsubsets (Salary ∼.,data=Hitters[ train ,], nvmax=19) Notice that we subset the Hittersdata frame directly in the call in or- der to access only the training subset of the data, using the expression Hitters[train,] . We now compute the validation set error for the best model of each model size. We ﬁrst make a model matrix from the test data. test.mat=model.matrix(Salary ∼.,data=Hitters[test ,]) The model.matrix() function is used in many regressionpackages for build-model. matrix() ing an “X” matrix from data. Now we run a loop, and for each size i,w e extract the coeﬃcients from regfit.best for the best model of that size, multiply them into the appropriate columns of the test model matrix to form the predictions, and compute the test MSE. > val.errors=rep(NA,19) > for(i in 1:19){ + coefi=coef(regfit.best,id=i) 6.5 Lab 1: Subset Selection Methods 249 + pred=test.mat[,names(coefi)]%*%coefi + val.errors[i]=mean(( Hitters$Salary[ test]-pred)^2) } We ﬁnd that the best model is the one that contains ten variables. > val.errors [1] 220968 169157 178518 163426 168418 171271 162377 157909 [9] 154056 148162 151156 151742 152214 157359 158541 158743 [17] 159973 159860 160106 > which.min(val.errors) [1] 10 > coef(regfit.best ,10) (Intercept ) AtBat Hits Walks CAtBat -80.275 -1.468 7.163 3.643 -0 .186 CHits CHmRun CWalks LeagueN DivisionW 1.105 1.384 -0 .748 84.558 -53.029 PutOuts 0.238 This was a little tedious, partly because there is no predict() method forregsubsets() . Since we will be using this function again,we can capture our steps above and write our own predict method. > predict.regsubsets =function(object , newdata ,id ,...){ + form=as.formula(object$call [[2]]) + mat=model.matrix(form,newdata) + coefi=coef(object ,id=id) + xvars=names(coefi) + mat[,xvars]%*%coefi +} Our function pretty much mimics what we did above. The only complex part is how we extracted the formula used in the call to regsubsets() .W e demonstrate how we use this function below, when we do cross-validation. Finally, we perform best subset sel ection on the full data set, and select the best ten-variable model. It is i mportant that we make use of the full data set in order to obtain more accura te coeﬃcient estimates. Note that we performbestsubsetselectiononthe full data setand selectthe bestten- variable model, rather than simply using the variables that were obtained from the training set, because the best ten-variable model on the full data set may diﬀer from the corresponding model on the training set. > regfit.best=regsubsets (Salary ∼.,data=Hitters , nvmax=19) > coef(regfit.best ,10) (Intercept ) AtBat Hits Walks CAtBat 162.535 -2.169 6.918 5.773 -0 .130 CRuns CRBI CWalks DivisionW PutOuts 1.408 0.774 -0 .831 -112.380 0.297 Assists 0.283 250 6. Linear Model Selection and Regularization In fact, we see that the best ten-var iable model on the full data set has a diﬀerent set of variables than the best ten-variable model on the training set. We now try to choose among the models of diﬀerent sizes using cross- validation. This approach is somewhat involved, as we must perform best subset selection within each of the ktraining sets . Despite this, we see that with its clever subsetting syntax, Rmakes this job quite easy. First, we create a vector that allocate s each observation to one of k= 10 folds, and we create a matrix in which we will store the results. > k=10 > set.seed(1) > folds=sample(1 :k,nrow(Hitters),replace=TRUE) > cv.errors=matrix(NA,k,19, dimnames=list(NULL, paste(1:19))) Now we write a for loop that performs cross-validation. In the jth fold, the elements of foldsthat equal jare in the test set, and the remainder are in the training set. We make our predictions for each model size (using our new predict() method), compute the test errorson the appropriatesubset, and store them in the appropriate slot in the matrix cv.errors . > for(j in 1:k){ + best.fit=regsubsets (Salary ∼.,data=Hitters[folds!=j,], nvmax=19) + for(i in 1:19){ + pred=predict(best.fit,Hitters[folds==j,],id=i) + cv.errors[ j,i]= mean( ( Hitters$Salary[ folds==j]-pred)^2) +} +} This hasgivenus a10 ×19matrix,ofwhich the ( i,j)th elementcorresponds to the test MSE for the ith cross-validation fold for the best j-variable model. We use the apply()function to average over the columns of thisapply()matrix in order to obtain a vector for which the jth element is the cross- validation error for the j-variable model. > mean.cv.errors=apply(cv.e rrors ,2, mean) > mean.cv.errors [1] 160093 140197 153117 151159 146841 138303 144346 130208 [9] 129460 125335 125154 128274 133461 133975 131826 131883 [17] 132751 133096 132805 > par(mfrow=c(1,1)) > plot(mean.cv. errors , type=’b’) We see that cross-validation selects an 11-variable model. We now perform best subset selection on the full data set in order to obtain the 11-variable model. > reg.best=regsubsets (Salary ∼.,data=Hitters , nvmax=19) > coef(reg.best ,11) (Intercept ) AtBat Hits Walks CAtBat 135.751 -2.128 6.924 5.620 -0 .139 6.6 Lab 2: Ridge Regression and the Lasso 251 CRuns CRBI CWalks LeagueN DivisionW 1.455 0.785 -0 .823 43.112 -111.146 PutOuts Assists 0.289 0.269 6.6 Lab 2: Ridge Regression and the Lasso We will use the glmnetpackage in order to perform ridge regression and the lasso. The main function in this package is glmnet() ,w h i c hc a nb eu s e dglmnet()to ﬁt ridge regression models, lasso models, and more. This function has slightly diﬀerent syntax from other model-ﬁtting functions that we have encountered thus far in this book. In particular, we must pass in an x matrix as well as a yvector, and we do not use the y∼xsyntax. We will now perform ridge regression and the lasso in order to predict Salaryon the Hittersdata. Before proceeding ensur e that the missing values have been removed from the data, a s described in Section 6.5. > x=model.matrix(Salary ∼.,Hitters)[,-1] > y=Hitters$Salary The model.matrix() function is particularly useful for creating x; not only does it produce a matrix corresponding to the 19 predictors but it also automatically transforms any qualitative variables into dummy variables. The latter propertyis important because glmnet() can only take numerical, quantitative inputs. 6.6.1 Ridge Regression The glmnet() function has an alphaargument that determines what type of model is ﬁt. If alpha=0then a ridge regressionmodel is ﬁt, and if alpha=1 then a lasso model is ﬁt. We ﬁrst ﬁt a ridge regression model. > library(glmnet) > grid=10^seq(10,-2,length=100) > ridge.mod=glmnet(x,y,alpha=0,lambda=grid) By default the glmnet() function performsridgeregressionforanautomati- callyselected rangeof λvalues.However,herewe havechosento implement the function over a grid of values ranging from λ=1 010toλ=1 0−2,e s - sentially covering the full range of scenarios from the null model containing only the intercept, to the least square s ﬁt. As we will see, we can also com- pute model ﬁts for a particular value of λthat is not one of the original gridvalues. Note that by default, the glmnet() function standardizes the variables so that they are on the same scale.To turn oﬀ this default setting, use the argument standardize=FALSE . Associated with each value of λis a vectorofridge regressioncoeﬃcients, storedinamatrixthatcanbeaccessedby coef().Inthiscase,itisa20 ×100 252 6. Linear Model Selection and Regularization matrix, with 20 rows (one for each predictor, plus an intercept) and 100 columns (one for each value of λ). > dim(coef(ridge.mod)) [1] 20 100 We expect the coeﬃcientestimates tobe muchsmaller,in termsof /lscript2norm, when a large value of λis used, as compared to when a small value of λis used. These are the coeﬃcients when λ=1 1,498, along with their /lscript2norm: > ridge.mod$lambda [50] [1] 11498 > coef(ridge.mod)[ ,50] (Intercept ) AtBat Hits HmRun Runs 407.356 0.037 0.138 0.525 0.231 RBI Walks Years CAtBat CHits 0.240 0.290 1.108 0.003 0.012 CHmRun CRuns CRBI CWalks LeagueN 0.088 0.023 0.024 0.025 0.085 DivisionW PutOuts Assists Errors NewLeagueN -6.215 0.016 0.003 -0.021 0.301 > sqrt(sum(coef(ridge.mod)[-1,50]^2)) [1] 6.36 In contrast, here are the coeﬃcients when λ= 705, along with their /lscript2 norm. Note the much larger /lscript2norm of the coeﬃcients associated with this smaller value of λ. > ridge.mod$lambda [60] [1] 705 > coef(ridge.mod)[ ,60] (Intercept ) AtBat Hits HmRun Runs 54.325 0.112 0.656 1.180 0.938 RBI Walks Years CAtBat CHits 0.847 1.320 2.596 0.011 0.047 CHmRun CRuns CRBI CWalks LeagueN 0.338 0.094 0.098 0.072 13.684 DivisionW PutOuts Assists Errors NewLeagueN -54.659 0.119 0.016 -0.704 8.612 > sqrt(sum(coef(ridge.mod)[-1,60]^2)) [1] 57.1 We can use the predict() function for a number of purposes. For instance, we can obtain the ridge regression coeﬃcients for a new value of λ, say 50: > predict(ridge.mod,s=50,type=\" coefficients\") [1:20,] (Intercept ) AtBat Hits HmRun Runs 48.766 -0.358 1.969 -1.278 1.146 RBI Walks Years CAtBat CHits 0.804 2.716 -6 .218 0.005 0.106 CHmRun CRuns CRBI CWalks LeagueN 0.624 0.221 0.219 -0.150 45.926 DivisionW PutOuts Assists Errors NewLeagueN -118.201 0.250 0.122 -3.279 -9.497 6.6 Lab 2: Ridge Regression and the Lasso 253 We now split the samples into a training set and a test set in order to estimate the test error of ridge regression and the lasso. There are two commonwaystorandomlysplit adataset.The ﬁrstistoproducearandom vector of TRUE,FALSEelements and select the observations corresponding to TRUEfor the training data. The second is to randomly choose a subset of numbers between 1 and n; these can then be used as the indices for the training observations. The two approaches work equally well. We used the former method in Section 6.5.3. Her e we demonstrate the latter approach. We ﬁrst set a random seed so that the results obtained will be repro- ducible. > set.seed(1) > train=sample(1:nrow(x), nrow(x)/2) > test=(-train) > y.test=y[test] Next we ﬁt a ridge regression model on the training set, and evaluate its MSE on the test set, using λ= 4. Note the use of the predict() function again. This time we get predictions for a test set, by replacing type=\"coefficients\" with the newxargument. > ridge.mod=glmnet(x[t rain ,],y[ train],alpha=0,lambda= grid, thresh=1e-12) > ridge.pred=predict(ridge.mod,s=4,newx=x[test ,]) > mean((ridge.pred-y.test)^2) [1] 101037 The test MSE is 101037. Note that if we had instead simply ﬁt a model with just an intercept, we would have predicted each test observation using the mean of the training observations. In that case, we could compute the test set MSE like this: > mean((mean(y[train])-y.test)^2) [1] 193253 We could also get the same result by ﬁtting a ridge regression model with averylarge value of λ.N o t et h a t 1e10means 1010. > ridge.pred=predict(ridge.mod,s=1e10,newx=x[ test ,]) > mean((ridge.pred-y.test)^2) [1] 193253 So ﬁtting a ridge regression model with λ= 4 leads to a much lower test MSE than ﬁtting a model with just an intercept. We now check whether there is any beneﬁt to performing ridge regression with λ= 4 instead of just performing least squares regression. Recall that least squares is simply ridge regression with λ=0 .5 5In order for glmnet() to yield the exact least squares coeﬃcients when λ=0 , we use the argument exact=T when calling the predict() function. Otherwise, the predict() function will interpolate over the grid of λvalues used in ﬁtting the 254 6. Linear Model Selection and Regularization > ridge.pred=predict(ridge.mod,s=0,newx=x[test,],exact=T) > mean((ridge.pred-y.test)^2) [1] 114783 >l m ( y∼x, subset=train) > predict(ridge.mod,s=0,exact=T,type=\" coefficients\")[1:20,] In general, if we want to ﬁt a (unpenalized) least squares model, then we should use the lm()function, since that function provides more useful outputs, such as standard errors and p-values for the coeﬃcients. In general, instead of arbitrarily choosing λ= 4, it would be better to use cross-validationto choose the tuning parameter λ. We can do this using the built-in cross-validationfunction, cv.glmnet() . By default, the functioncv.glmnet()performs ten-fold cross-validation, though this can be changed using the argument folds. Note that we set a random seed ﬁrst so our results will be reproducible, since the choice of the cross-validation folds is random. > set.seed(1) > cv.out=cv.glmnet(x[t rain ,],y[ train],alpha=0) > plot(cv.out) > bestlam=cv.out$lambda .min > bestlam [1] 212 Therefore, we see that the value of λthat results in the smallest cross- validation error is 212. What is the test MSE associated with this value of λ? > ridge.pred=predict(ridge.mod,s=bestlam ,newx=x[ test ,]) > mean((ridge.pred-y.test)^2) [1] 96016 This represents a further improvement over the test MSE that we got using λ= 4. Finally, we reﬁt our ridge regression model on the full data set, using the value of λchosen by cross-validation, and examine the coeﬃcient estimates. > out=glmnet(x,y,alpha=0) > predict(out,type=\" coefficients\",s= bestlam) [1:20,] (Intercept ) AtBat Hits HmRun Runs 9.8849 0.0314 1.0088 0.1393 1.1132 RBI Walks Years CAtBat CHits 0.8732 1.8041 0.1307 0.0111 0.0649 CHmRun CRuns CRBI CWalks LeagueN 0.4516 0.1290 0.1374 0.0291 27.1823 DivisionW PutOuts Assists Errors NewLeagueN -91.6341 0.1915 0.0425 -1 .8124 7.2121 glmnet() model, yielding approximate results. When we use exact=T , there remains a slight discrepancy in the third decimal place between the output of glmnet() when λ= 0 and the output of lm(); this is due to numerical approximation on the part of glmnet() . 6.6 Lab 2: Ridge Regression and the Lasso 255 As expected, none of the coeﬃcients are zero—ridge regression does not perform variable selection! 6.6.2 The Lasso We saw that ridge regression with a wise choice of λcan outperform least squares as well as the null model on the Hitters data set. We now ask whether the lasso can yield either a m ore accurate or a more interpretable model than ridge regression. In order to ﬁt a lasso model, we once again use the glmnet() function; however,this time we use the argument alpha=1. Other than that change, we proceed just as we did in ﬁtting a ridge model. > lasso.mod=glmnet(x[t rain ,],y[ train],alpha=1,lambda=grid) > plot(lasso.mod) We can see from the coeﬃcient plot that depending on the choice of tuning parameter, some of the coeﬃcients will be exactly equal to zero. We now perform cross-validation and compute the associated test error. > set.seed(1) > cv.out=cv.glmnet(x[t rain ,],y[ train],alpha=1) > plot(cv.out) > bestlam=cv.out$lambda .min > lasso.pred=predict(lasso.mod,s=bestlam ,newx=x[ test ,]) > mean((lasso.pred-y.test)^2) [1] 100743 This is substantially lower than the test set MSE of the null model and of least squares, and very similar to the test MSE of ridge regression with λ chosen by cross-validation. However, the lasso has a substantial advantage over ridge regression in that the resulting coeﬃcient estimat es are sparse. Here we see that 12 of the 19 coeﬃcient estimates are exactly zero. So the lasso model with λ chosen by cross-validation contains only seven variables. > out=glmnet(x,y,alpha=1,lambda=grid) > lasso.coef=predict(out,type=\" coefficients\",s= bestlam) [1:20,] > lasso.coef (Intercept ) AtBat Hits HmRun Runs 18.539 0.000 1.874 0.000 0.000 RBI Walks Years CAtBat CHits 0.000 2.218 0.000 0.000 0.000 CHmRun CRuns CRBI CWalks LeagueN 0.000 0.207 0.413 0.000 3.267 DivisionW PutOuts Assists Errors NewLeagueN -103.485 0.220 0.000 0.000 0.000 > lasso.coef[lasso.coef!=0] (Intercept ) Hits Walks CRuns CRBI 18.539 1.874 2.218 0.207 0.413 LeagueN DivisionW PutOuts 3.267 -103.485 0.220 256 6. Linear Model Selection and Regularization 6.7 Lab 3: PCR and PLS Regression 6.7.1 Principal Components Regression Principal components regression (PCR) can be performed using the pcr()pcr()function, whichis partofthe plslibrary.WenowapplyPCRto the Hitters data, in order to predict Salary. Again, ensure that the missing values have been removed from the data, a s described in Section 6.5. > library(pls) > set.seed(2) > pcr.fit=pcr(Salary ∼., data=Hit ters , scale= TRUE, validation =\"CV\") The syntax for the pcr()function is similar to that for lm(), with a few additional options. Setting scale=TRUE has the eﬀect of standardizing each predictor,using (6.6),priorto generatingthe principalcomponents,so that the scale on which each variable is measured will not have an eﬀect. Setting validation=\"CV\" causes pcr()tocompute the ten-foldcross-validationerror foreachpossiblevalueof M, the numberofprincipal componentsused.The resulting ﬁt can be examined using summary() . > summary(pcr.fit) Data: X dimension : 263 19 Y dimension : 263 1 Fit method: svdpc Number of components considered : 19 VALIDATION : RMSEP Cross -validated using 10 random segments. (Intercept ) 1 comps 2 comps 3 comps 4 comps CV 452 348.9 352.2 353.5 352.8 adjCV 452 348.7 351.8 352.9 352.1 ... TRAINING : % variance explained 1 comps 2 comps 3 comps 4 comps 5 comps 6 comps X 38.31 60.16 70.84 79.03 84.29 88.63 Salary 40.63 41.58 42.17 43.22 44.90 46.48 ... The CV score is provided for each possible number of components, ranging fromM= 0 onwards. (We have printed the CV output only up to M=4 . ) Note that pcr()reports the root mean squared error ; in order to obtain the usual MSE, we must square this qu antity. For instance, a root mean squared error of 352 .8 corresponds to an MSE of 352 .82= 124,468. One can also plot the cross-validation scores using the validationplot()validation plot() function. Using val.type=\"MSEP\" will cause the cross-validation MSE to be plotted. > validationplot(pcr.fit,val. type=\"MSEP\") 6.7 Lab 3: PCR and PLS Regression 257 We see that the smallest cro ss-validation error occurs when M=1 6c o m - ponents are used. This is barely fewer than M= 19, which amounts to simply performing least squares, because when all of the components are used in PCR no dimension reduction occurs. However, from the plot we also see that the cross-validation error is roughly the same when only one component is included in the model. This suggests that a model that uses just a small number of components might suﬃce. The summary() functionalsoprovidesthe percentage of variance explained in the predictors and in the response using diﬀerent numbers of compo- nents. This concept is discussed in greater detail in Chapter 10. Brieﬂy, we can think of this as the amount of information about the predictors or the response that is captured using Mprincipal components. For example, settingM= 1 only captures 38 .31% of all the variance, or information, in the predictors. In contrast, using M= 6 increases the value to 88 .63%. If we were to use all M=p= 19 components, this would increase to 100%. We now perform PCR on the training data and evaluate its test set performance. > set.seed(1) > pcr.fit=pcr(Salary ∼., data=Hit ters , subset= train , scale= TRUE, validation =\"CV\") > validationplot(pcr.fit,val. type=\"MSEP\") Now we ﬁnd that the lowest cross-validation error occurs when M=7 component are used. We compute the test MSE as follows. > pcr.pred=predict(pcr.fit,x[test,],ncomp=7) > mean((pcr.pred-y.test)^2) [1] 96556 This test set MSE is competitive with the results obtained using ridge re- gressionandthe lasso.However,asa resultofthe wayPCRis implemented, the ﬁnal model is more diﬃcult to interpret because it does not perform any kind of variable selection or even directly produce coeﬃcient estimates. Finally, we ﬁt PCR on the full data set, using M=7 ,t h en u m b e ro f components identiﬁed by cross-validation. > pcr.fit=pcr(y ∼x,scale=TRUE,ncomp=7) > summary(pcr.fit) Data: X dimension : 263 19 Y dimension : 263 1 Fit method: svdpc Number of components considered : 7 TRAINING : % variance explained 1 comps 2 comps 3 comps 4 comps 5 comps 6 comps X 38.31 60.16 70.84 79.03 84.29 88.63 y 40.63 41.58 42.17 43.22 44.90 46.48 7 comps X 92.26 y 46.69 258 6. Linear Model Selection and Regularization 6.7.2 Partial Least Squares We implement partial least squares (PLS) using the plsr()function, alsoplsr()in the plslibrary. The syntax is just like that of the pcr()function. > set.seed(1) > pls.fit=plsr(Salary ∼., data= Hitters , subset= train , scale= TRUE , validation =\"CV\") > summary(pls.fit) Data: X dimension : 131 19 Y dimension : 131 1 Fit method: kernelpls Number of components considered : 19 VALIDATION : RMSEP Cross -validated using 10 random segments. (Intercept ) 1 comps 2 comps 3 comps 4 comps CV 464.6 394.2 391.5 393.1 395.0 adjCV 464.6 393.4 390.2 391.1 392.9 ... TRAINING : % variance explained 1 comps 2 comps 3 comps 4 comps 5 comps 6 comps X 38.12 53.46 66.05 74.49 79.33 84.56 Salary 33.58 38.96 41.57 42.43 44.04 45.59 ... > validationplot(pls.fit,val. type=\"MSEP\") The lowest cross-validation error occurs when only M=2p a r t i a ll e a s t squares directions are used. We now evaluate the corresponding test set MSE. > pls.pred=predict(pls.fit,x[test,],ncomp=2) > mean((pls.pred-y.test)^2) [1] 101417 The test MSE is comparable to, but slightly higher than, the test MSE obtained using ridge regression, the lasso, and PCR. Finally, weperformPLSusingthe full dataset, using M=2 ,t h en u m be r of components identiﬁed by cross-validation. > pls.fit=plsr(Salary ∼., data= Hitters , scale= TRUE, ncomp=2) > summary(pls.fit) Data: X dimension : 263 19 Y dimension : 263 1 Fit method: kernelpls Number of components considered : 2 TRAINING : % variance explained 1 comps 2 comps X 38.08 51.03 Salary 43.05 46.40 Notice that the percentage of variance in Salarythat the two-component PLS ﬁt explains, 46 .40%, is almost as much as that explained using the 6.8 Exercises 259 ﬁnal seven-component model PCR ﬁt, 46 .69%. This is because PCR only attempts to maximize the amount of variance explained in the predictors, while PLS searches for directions that explain variance in both the predic- tors and the response. 6.8 Exercises Conceptual 1. We perform best subset, forward stepwise, and backward stepwise selection on a single data set. For each approach, we obtain p+1 models, containing 0 ,1,2,...,ppredictors. Explain your answers: (a) Which of the three models with kpredictors has the smallest training RSS? (b) Which of the three models with kpredictors has the smallest testRSS? (c) True or False: i. The predictors in the k-variable model identiﬁed by forward stepwise are a subset of the predictors in the ( k+1)-variable model identiﬁed by forward stepwise selection. ii. The predictors in the k-variable model identiﬁed by back- ward stepwise are a subset of the predictors in the ( k+1)- variable model identiﬁed by backward stepwise selection. iii. The predictors in the k-variable model identiﬁed by back- ward stepwise are a subset of the predictors in the ( k+1)- variable model identiﬁed by forward stepwise selection. iv. The predictors in the k-variable model identiﬁed by forward stepwise are a subset of the predictors in the ( k+1)-variable model identiﬁed by backward stepwise selection. v. The predictors in the k-variable model identiﬁed by best subset are a subset of the predictors in the ( k+1)-v ariable model identiﬁed by best subset selection. 2. For parts (a) through (c), indicate which of i. through iv. is correct. Justify your answer. (a) The lasso, relative to least squares, is: i. More ﬂexible and hence will give improved prediction ac- curacy when its increase in bia s is less than its decrease in variance. ii. More ﬂexible and hence will give improved prediction accu- racy when its increase in varia nce is less than its decrease in bias. 260 6. Linear Model Selection and Regularization iii. Less ﬂexible and hence will give improved prediction accu- racy when its increase in bia s is less than its decrease in variance. iv. Less ﬂexible and hence will gi ve improved prediction accu- racy when its increase in varia nce is less than its decrease in bias. (b) Repeat (a) for ridge regression relative to least squares. (c) Repeat (a) for non-linear met hods relative to least squares. 3. Suppose we estimate the regression coeﬃcients in a linear regression model by minimizing n/summationdisplay i=1⎛ ⎝yi−β0−p/summationdisplay j=1βjxij⎞ ⎠subject top/summationdisplay j=1|βj|≤s for a particular value of s. For parts (a) through (e), indicate which of i. through v. is correct. Justify your answer. (a) As we increase sfrom 0, the training RSS will: i. Increase initially, and then eventually start decreasing in an inverted U shape. ii. Decrease initially, and then eventually start increasing in a Us h a p e . iii. Steadily increase. iv. Steadily decrease. v. Remain constant. (b) Repeat (a) for test RSS. (c) Repeat (a) for variance. (d) Repeat (a) for (squared) bias. (e) Repeat (a) for the irreducible error. 4. Suppose we estimate the regression coeﬃcients in a linear regression model by minimizing n/summationdisplay i=1⎛ ⎝yi−β0−p/summationdisplay j=1βjxij⎞ ⎠+λp/summationdisplay j=1β2 j for a particular value of λ. For parts (a) through (e), indicate which of i. through v. is correct. Justify your answer. 6.8 Exercises 261 (a) As we increase λfrom 0, the training RSS will: i. Increase initially, and then eventually start decreasing in an inverted U shape. ii. Decrease initially, and then eventually start increasing in a Us h a p e . iii. Steadily increase. iv. Steadily decrease. v. Remain constant. (b) Repeat (a) for test RSS. (c) Repeat (a) for variance. (d) Repeat (a) for (squared) bias. (e) Repeat (a) for the irreducible error. 5. It is well-known that ridge regression tends to give similar coeﬃcient values to correlated variables, whereas the lasso may give quite dif- ferent coeﬃcient values to correla ted variables. We will now explore this property in a very simple setting. Suppose that n=2 ,p=2 ,x11=x12,x21=x22.F u r t h e r m o r e , suppose that y1+y2=0a n dx11+x21=0a n dx12+x22=0 ,s ot h a t the estimate for the intercept in a least squares, ridge regression, or lasso model is zero: ˆβ0=0 . (a) Write out the ridge regression optimization problem in this set- ting. (b) Argue that in this setting, the ridge coeﬃcient estimates satisfy ˆβ1=ˆβ2. (c) Write out the lasso optimization problem in this setting. (d) Argue that in this setting, the lasso coeﬃcients ˆβ1andˆβ2are not unique—in other words, there are many possible solutions to the optimization problem in (c). Describe these solutions. 6. We will now explore (6.12) and (6.13) further. (a) Consider (6.12) with p= 1. For some choice of y1andλ>0, plot (6.12) as a function of β1. Your plot should conﬁrm that (6.12) is solved by (6.14). (b) Consider (6.13) with p= 1. For some choice of y1andλ>0, plot (6.13) as a function of β1. Your plot should conﬁrm that (6.13) is solved by (6.15). 262 6. Linear Model Selection and Regularization 7. We will now derive the Bayesian connection to the lasso and ridge regression discussed in Section 6.2.2. (a) Suppose that yi=β0+/summationtextp j=1xijβj+/epsilon1iwhere/epsilon11,...,/epsilon1 nareinde- pendent andidenticallydistributed froma N(0,σ2)distribution. Write out the likelihood for the data. (b) Assume the following prior for β:β1,...,β pare independent and identically distributed according to a double-exponential distribution with mean 0 and common scale parameter b: i.e. p(β)=1 2bexp(−|β|/b). Write out the posterior for βin this setting. (c) Argue that the lasso estimate is the modeforβunder this pos- terior distribution. (d) Nowassumethe followingpriorfor β:β1,...,β pareindependent and identically distributed according to a normal distribution with mean zero and variance c. Write out the posterior for βin this setting. (e) Argue that the ridge regression estimate is both the modeand themeanforβunder this posterior distribution. Applied 8. In this exercise, we will generate simulated data, and will then use this data to perform best subset selection. (a) Use the rnorm()function to generate a predictor Xof length n= 100, as well as a noise vector /epsilon1of length n= 100. (b) Generate a response vector Yof length n= 100 according to the model Y=β0+β1X+β2X2+β3X3+/epsilon1, whereβ0,β1,β2,a n dβ3are constants of your choice. (c) Use the regsubsets() function to perform best subset selection in order to choose the best model containing the predictors X,X2,...,X10. What is the best model obtained according to Cp,B I C ,a n da d j u s t e d R2? Show some plots to provide evidence for youranswer,and reportthe coeﬃcients ofthe bestmodel ob- tained. Note you will need to use the data.frame() function to create a single data set containing both XandY. 6.8 Exercises 263 (d) Repeat(c), usingforwardstepwiseselection andalsousingback- wards stepwise selection. How does your answer compare to the results in (c)? (e) Now ﬁt a lasso model to the simulated data, again using X,X2, ...,X10as predictors. Use cross-va lidation to select the optimal value ofλ.Createplotsofthecross-validationerrorasafunction ofλ. Report the resulting coeﬃcient estimates, and discuss the results obtained. (f) Now generate a response vector Yaccording to the model Y=β0+β7X7+/epsilon1, and perform best subset selection and the lasso. Discuss the results obtained. 9. In this exercise, we will predict t he number of applications received using the other variables in the Collegedata set. (a) Split the data set into a training set and a test set. (b) Fit a linear model using least squares on the training set, and report the test error obtained. (c) Fit a ridge regression model on the training set, with λchosen by cross-validation. Report the test error obtained. (d) Fit a lasso model on the training set, with λchosen by cross- validation. Report the test error obtained, along with the num- ber of non-zero coeﬃcient estimates. (e) Fit a PCR model on the training set, with Mchosen by cross- validation. Report the test error obtained, along with the value ofMselected by cross-validation. (f) Fit a PLS model on the training set, with Mchosen by cross- validation. Report the test error obtained, along with the value ofMselected by cross-validation. (g) Comment on the results obtained. How accurately can we pre- dict the number of college applic ations received? Is there much diﬀerence among the test errors resulting from these ﬁve ap- proaches? 10. Wehaveseenthatasthenumberoffeaturesusedinamodelincreases, thetrainingerrorwill necessarilydecrease,butthe testerrormaynot. We will now explore this in a simulated data set. (a) Generate a data set with p=2 0f e a t u r e s , n=1,000 observa- tions, and an associated quantitative response vector generated according to the model Y=Xβ+/epsilon1, whereβhas some elements that are exactly equal to zero. 264 6. Linear Model Selection and Regularization (b) Splityourdatasetintoatrainingsetcontaining100observations and a test set containing 900 observations. (c) Perform best subset selection on the training set, and plot the training set MSE associated with the best model of each size. (d) Plot the test set MSE associated with the best model of each size. (e) For which model size does the test set MSE take on its minimum value?Commentonyourresults.Ifittakesonitsminimumvalue for a model containing only an intercept or a model containing all of the features, then play around with the way that you are generating the data in (a) until you come up with a scenario in which the test set MSE is minimized for an intermediate model size. (f) How does the model at which the test set MSE is minimized compare to the true model used to generate the data? Comment on the coeﬃcient values. (g) Create a plot displaying/radicalBig/summationtextp j=1(βj−ˆβr j)2for a range of values ofr,w h e r eˆβr jis thejth coeﬃcient estimate for the best model containing rcoeﬃcients. Comment on what you observe. How does this compare to the test MSE plot from (d)? 11. We will now try to predict per capita crime rate in the Bostondata set. (a) Try out someof the regressionmethods explored in this chapter, such as best subset selection, the lasso, ridge regression, and PCR. Present and discuss results for the approaches that you consider. (b) Propose a model (or set of models) that seem to perform well on this data set, and justify your answer. Make sure that you are evaluating model performance us ing validation set error, cross- validation, or some other reasonable alternative, as opposed to using training error. (c) Does your chosen model involve all of the features in the data set? Why or why not? 7 Moving Beyond Linearity So far in this book, we have mostly focused on linearmodels. Linearmodels are relatively simple to describe and implement, and have advantages over other approaches in terms of interpretation and inference. However, stan- dard linear regression can have signiﬁcant limitations in terms of predic- tive power. This is because the linearity assumption is almost always an approximation, and sometimes a poor one. In Chapter 6 we see that we can improve upon least squares using ridg e regression,the lasso, principal com- ponents regression, and other techniques. In that setting, the improvement is obtained by reducing the complexity of the linear model, and hence the variance of the estimates. But we are still using a linear model, which can only be improved so far! In this chapter we relax the linearity assumption while still attempting to maintain as much interpretability as possible. We do this by examining very simple extensions of linear models like polyno- mialregressionandstepfunctions,aswellasmoresophisticatedapproaches such as splines, local regression, and generalized additive models. •Polynomial regression extends the linear model by adding extra pre- dictors, obtained by raising each of the original predictors to a power. For example, a cubicregression uses three variables, X,X2,a n dX3, as predictors. This approach provides a simple way to provide a non- linear ﬁt to data. •Step functions cut the range of a variable into Kdistinct regions in order to produce a qualitative variable. This has the eﬀect of ﬁtting a piecewise constant function. G. James et al., An Introduction to Statistical Learning: with Applications in R , Springer Texts in Statistics 103, DOI 10.1007/978-1-4614-7138-7 7, ©Springer Science+Business Media New York 2013265 266 7. Moving Beyond Linearity •Regression splines are more ﬂexible than polynomials and step functions, and in fact are an extension of the two. They involve di- viding the range of XintoKdistinct regions. Within each region, a polynomial function is ﬁt to the data. However, these polynomials are constrained so that they join smoothly at the region boundaries, orknots. Provided that the interval is divided into enough regions, this can produce an extremely ﬂexible ﬁt. •Smoothing splines are similar to regression splines, but arise in a slightly diﬀerent situation. Smoothing splines result from minimizing a residual sum of squares criterion subject to a smoothness penalty. •Local regression is similar to splines, but diﬀers in an important way. The regions are allowed to overlap, and indeed they do so in a very smooth way. •Generalized additive models a l l o wu st oe x t e n dt h em e t h o d sa b o v et o deal with multiple predictors. In Sections 7.1–7.6, we present a number of approaches for modeling the relationship between a response Yand a single predictor Xin a ﬂexible way. In Section 7.7, we show that these approaches can be seamlessly inte- grated in order to model a response Yas a function of several predictors X1,...,X p. 7.1 Polynomial Regression Historically, the standard way to ext end linear regression to settings in which the relationship between the predictors and the response is non- linear has been to replace the standard linear model yi=β0+β1xi+/epsilon1i with a polynomial function yi=β0+β1xi+β2x2 i+β3x3 i+...+βdxd i+/epsilon1i, (7.1) where/epsilon1iistheerrorterm.This approachis knownas polynomial regression ,polynomial regression and in fact we saw an example of this method in Section 3.3.2. For large enoughdegree d, apolynomial regressionallowsus to producean extremely non-linearcurve.Noticethatthecoeﬃci entsin(7.1)canbeeasilyestimated using least squares linear regression because this is just a standard linear model with predictors xi,x2 i,x3 i,...,xd i. Generally speaking, it is unusual to usedgreater than 3 or 4 because for large values of d, the polynomial curve can become overly ﬂexible and ca n takeon some very strangeshapes. This is especially true near the boundary of the Xvariable. 7.1 Polynomial Regression 267 AgeWageDegree−4 Polynomial 20 30 40 50 60 70 8050 100 150 200 250 300 20 30 40 50 60 70 800.00 0.05 0.10 0.15 0.20 Age| | || | || ||| || | | ||| | ||| | |||| || | || | | | ||| || | | |||| || ||| | || |||| || || | | || || || || | || | || || || | | || | || | || | || || |||| || | || || ||| || ||| |||| | || | | || || || || ||| || | || || | | || | || | ||| ||| | | | | || || | || ||| | | || | || | | || || | || || | | || | || | | | |||| | | ||| | || | || | || | | | || | || | || | || | || | ||| || | || || | | || | | | |||| || || |||| || || || | | || | | || || | || ||| | | | |||| || || | |||| || | | ||| | || | || | || || | | | | | || || | | || | || || || | || ||| ||| || || || || || ||| || || || ||| | ||| || |||| | | || | || || | | || || | ||| || | || | ||| || | || | || | | || | || || || || || | | | || | | | | | || |||||| | || || || || | || || || | || || | ||| | || || | || | || || | || || | || || ||| |||| |||| | | || || || | || || | || || | || || | | | || || || || | || | | || || | || | || | | || | || || ||| ||| || | || |||| || ||| || | | || || || | | || | || || || ||| | | ||| || | ||||| || | | || | || | ||| || ||||| || || | || || | | | ||| | | | || || | ||| | || | | | || || | || || | | | | || ||| ||| | | ||| || | || | || | |||| | | | || | || || ||| || || || || | ||| | | |||| || | || || | | || | || || || ||| | | |||| | | | || || || || || ||| || ||| | | || | || ||| || || | | | | || | ||| | || | || ||| || | || || || | ||| |||| | || || ||| || | | || || | || | | | || | || | | || | || | | || | || | || |||| || | | || | |||| || | | | || | | || || || || | | | | | |||| | | || | || |||||| || | || | || | | | || || | || | | | || || || | | | | | || |||| | || | || ||| || || | | | | | ||||| || || || | | || | | || | || | || | | || || | || || | | | || || | || | | | || | ||| || |||| | | | |||| | || || | | | || |||| | ||||| || || | || || | | | || | | || | | ||| || | || | | || | | || | || | ||| || || ||| || | | | || | | || | || ||| |||| || |||| | || | | | || | | || | || | | || || ||| || | ||| || | || | | ||| | | | || || || | | || | | || || | || | || ||| | || || | | || ||| || | | || | || |||| | | || || | || || | ||| || || || ||| |||| | || || | | |||| || | || | ||| | | || ||| || || | | || || | || ||| || || || |||| || ||||| || | || || || | || | |||||| || | || || | || || | || | | | | || | || |||| | | | || | | || || | || | | || ||| || ||| | | | || |||| || | || | || ||| ||| || | | | || | || || | | | || | | ||| | | | || || | | | ||| || ||| | | | || || |||| | || || | || ||| | | | | || | || || || |||| | | || ||| || | | || | || || || ||| | | || | || | | | | || || ||| | | | || || ||| ||| | | || | || ||| ||| || || || || | ||||| | || || | || ||| | | || || || | || | | | |||| | || | | ||| || |||| | | || ||| | | | | |||| || | | |||| || | || || || | || | | || | | || || | | |||| || || | || | || | || || | | || | | | ||| || | || || || |||| | || | || |||| || || | | | | | || || | ||| || || || || | | | |||| | || ||| ||||| || ||| | || | || || | | || | | | | | || || ||| || || || | | || | | | ||| | || || || || | | | || || | || || | | |||| ||| | || | | || | || | | | | || | | || | ||| | ||||| ||| |||| | | | || || | | | ||| | | | || ||| || | || || | ||||| || | | ||| || || | || || |||| || ||| | ||||| || | | || | || ||| || | | ||| ||| || || | | | || | | | || | ||||| | | | | | || | | | | || | ||| || | || || || | | | || |||| || || | | | || | || | | || || || | || ||| || || || || | ||| ||| | || || | | | || | || | | ||| | | || || | || | |||| | || ||| | || | || || | ||| | || || | || || | || | | || ||| | || || |||| | | || | | | | | || | | || || | || || | | | | | || | || ||| || | | ||| | | |||| | || | | || | || | ||||| | | |||| || || || | | || ||| | || | | || || | | | || | || | |||||| || || | | || || || || | | | || ||| ||| |||||| || | | | || | || | | | | || | | | || || |||| | | || || | || | | | || | | | || | || | ||| | || |||| |||| || | || | ||| | || | | || | || | || ||| || | | | || || ||| || ||| || || | || ||| | | | | || | | | || || | || | | ||| | || ||||| | | || | | || | | | | | | || | || | | | || || || | || || || || || || | | || | | | | || | | | || | || || | || | | ||| || || || | | | || | || | ||| || ||| | || | | || || ||| | | | || | | | || ||||| | || | || | || || ||| | ||| | | || || | || | || | | | | || || || | | || | || | | || ||| |||| | ||| ||| || | | || | | || || | | | || |||| | | | || | || || | || || | ||| || || | || | | || || | || | |||| || || ||| || || | | | || | | || || | |||| | || ||| | || || | || | || || | | | | || |||| | || || ||| | || || | | | || | || || | | || || | || | || || | ||||| | || | | ||| ||| || || | | | || ||| ||| | || | || || | | || ||| || ||| || || | | | || || ||| | || | || || | | || | || ||| | | || | ||| || || || | | |||| || | | || | | || | | || || || | | ||| || | |||| || || | || | ||| | |||| | || || | || ||||| | | || |||| | || || |Pr(Wage>250 | Age) FIGURE 7.1. The Wagedata.Left:The solid blue curve is a degree-4 polynomial ofwage(in thousands of dollars) as a function of age, ﬁt by least squares. The dotted curves indicate an estimated 95% conﬁdence interval. Right:We model the binary event wage>250 using logistic regression, again with a degree-4 polynomial. The ﬁtted posterior probability of wageexceeding $250,000is shown in blue, along with an estimated 95% conﬁdence interval. The left-hand panel in Figure 7.1 is a plot of wageagainst agefor the Wagedata set, which contains income and demographic information for males who reside in the central Atlantic region of the United States. We see the results of ﬁtting a degree-4 polynomial using least squares (solid blue curve). Even though this is a linear regression model like any other, the individual coeﬃcients are not of particular interest. Instead, we look at the entire ﬁtted function across a grid of 62 values for agefrom 18 to 80 in order to understand the relationship between ageand wage. In Figure 7.1, a pair of dotted curves accompanies the ﬁt; these are (2 ×) standarderrorcurves.Let’s seehowthese arise.Suppose wehavecomputed the ﬁt at a particular value of age,x0: ˆf(x0)=ˆβ0+ˆβ1x0+ˆβ2x2 0+ˆβ3x3 0+ˆβ4x4 0. (7.2) What isthe varianceofthe ﬁt,i.e.Var ˆf(x0)?Leastsquaresreturnsvariance estimates for each of the ﬁtted coeﬃcients ˆβj, as well as the covariances between pairs of coeﬃcient estima tes. We can use these to compute the estimated variance of ˆf(x0).1The estimated pointwise standard error of ˆf(x0) is the square-root of this variance. This computation is repeated 1IfˆCis the 5 ×5 covariance matrix of the ˆβj,a n di f /lscriptT 0=( 1,x0,x2 0,x3 0,x4 0), then Var[ˆf(x0)] =/lscriptT 0ˆC/lscript0. 268 7. Moving Beyond Linearity at each reference point x0, and we plot the ﬁtted curve, as well as twice the standard error on either side of the ﬁtted curve. We plot twice the standard error because, for normally distributed error terms, this quantity corresponds to an approximate 95% conﬁdence interval. It seems like the wages in Figure 7.1 are from two distinct populations: there appears to be a high earners group earning more than $250 ,000 per annum, as well as a low earners group. We can treat wageas a binary variable by splitting it into these two groups. Logistic regression can then be used to predict this binary response, using polynomial functions of age as predictors. In other words, we ﬁt the model Pr(yi>250|xi)=exp(β0+β1xi+β2x2 i+...+βdxd i) 1+exp(β0+β1xi+β2x2 i+...+βdxd i).(7.3) The result is shown in the right-hand panel of Figure 7.1. The gray marks on the top and bottom of the panel indicate the ages of the high earners and the low earners. The solid blue curve indicates the ﬁtted probabilities of being a high earner, as a function of age. The estimated 95% conﬁdence interval is shown as well. We see thathere the conﬁdence intervalsare fairly wide, especially on the right-hand side. Although the sample size for this data set is substantial ( n=3,000), there are only 79 high earners, which results in a high variance in the estim ated coeﬃcients and consequently wide conﬁdence intervals. 7.2 Step Functions Using polynomial functions of the features as predictors in a linear model imposes a globalstructure on the non-linear function of X. We can instead usestep functions in order to avoid imposing such a global structure. Herestep functionwe break the range of Xintobins, and ﬁt a diﬀerent constant in each bin. Thisamountstoconvertingacontinuousvariableintoan ordered categorical variable.ordered categorical variableIn greater detail, we create cutpoints c1,c2,...,c Kin the range of X, a n dt h e nc o n s t r u c t K+1 new variables C0(X)= I(X<c 1), C1(X)= I(c1≤X<c 2), C2(X)= I(c2≤X<c 3), ... CK−1(X)=I(cK−1≤X<c K), CK(X)= I(cK≤X),(7.4) whereI(·)i sa nindicator function that returns a 1 if the condition is true,indicator function and returns a 0 otherwise.For example, I(cK≤X)equ al s1i f cK≤X,and 7.2 Step Functions 269 AgeWagePiecewise Constant 20 30 40 50 60 70 8050 100 150 200 250 300 20 30 40 50 60 70 800.00 0.05 0.10 0.15 0.20 Age| | || | || ||| || | | ||| | ||| | |||| || | || | | | ||| || | | |||| || ||| | || |||| || || | | || || || || | || | || || || | | || | || | || | || || |||| || | || || ||| || ||| |||| | || | | || || || || ||| || | || || | | || | || | ||| ||| | | | | || || | || |||| | || | || | | || || | || || | | || | || | | | |||| | | ||| | || | || | || | | | || | || | || | || ||| | ||| || | || || | | || | || |||| || || |||| || || || | | || | | || || | || ||| | | | |||| || | | | |||| | | |||| | | || | || | || || | | | | | || || | | || | || || || | || ||| ||| || || || || || ||| || || || ||| | ||| || |||| | | || | || || | | || || | ||| || | || | ||| || | || | || | | || | || | | || || || | | | || | | | | | || |||||| | || || || || | || || || | || || | ||| | || || | || | || || | || || | || || || | |||| |||| | | || || || | || || | || || | || || | | | || || || || | || | | || || | || | || | | || | || || ||| ||| || | || |||| || ||| || | | || || || | | || | || || || ||| | | ||| || | ||| | | || | | || | || | ||| || ||||| || || | || || | | | ||| | | | || ||| |||| || | | | || || | || || | | | | || ||| ||| | | || | || | || | || | |||| | | | || | || || ||| || || || ||| || | | | |||| || | || || | | || | || || || ||| | || || | | | | || || || |||| ||| || ||| | | || | || ||| || || | | | | || | || | | || | || ||| || | || || || | ||| |||| | || || ||| || | | || || | || | | | || | || | | || | |||| || | || | || |||| ||| | || | | ||| || || | || | | || || || || | | | | | |||| | | || | || |||||| || | || | || | | | || || | || | | | || | | || | | | | | || |||| | || | || ||| || || | | | | | ||||| || || || | | || | | || | || | || | | || || | || || | | | | || | | || | | | || | ||| || |||| | | | |||| | || || | | | || |||| | ||||| || || | || | | | | | || | || | || ||| || | || | | || | | || | || | ||| || || ||| || | | | || | | || | || ||| |||| || |||| | || | | | || | | || | || | | || || ||| || | ||| || | || | | ||| | | | || || || | | || | | || || | || | || ||| | || || | | || ||| || | | || | || |||| | | || || | || || | | || || || || || | |||| | || || | | |||| || | || | ||| | | || ||| || || | | || || | || ||| || || || |||| || ||||| || | || || || | || | ||||| | || | || || | || || | || | | | | || | || |||| | | | || | | || || | || | | || ||| || ||| | | | || || || || | || | || ||| ||| || | | | || | || || | | | || | | ||| | | | || || | | | ||| || ||| | | | || || ||||| || || | || ||| | | | | || | || || || |||| | | || ||| || | | || | || || || ||| | | ||| || | | | | || || ||| | | | || || ||| ||| | | || | || ||| ||| || || || || | ||||| | || || | || || | | | || || || | || | | | |||| | || | | ||| || |||| | | || ||| | | | | |||| || | | |||| || | || || || | || | | || | | || || | | |||| || || | || | || | || || | | || | | | ||| || | || || || |||| | || | || |||| || || | | || | || || | ||| || || || || | | | |||| | || ||| ||||| || ||| | || | || || | | || | | | | | || || | |||| || || | | || | | | ||| | || || || || | | | || || | || || | | ||| | ||| | || | | || | || | | | | || | | || | ||| | ||||| || | | ||| | | | || || | | | ||| | | | || || | || | || || | ||||| || | | ||| || || | || || |||| || ||| | ||||| || | | || ||| ||| || | | ||| ||| || || | | | || | | | || | ||||| | | | | | || | | | | || | ||| || | || || || | | | || |||| || || | | | || | || | | || || ||| ||||| || || || ||| ||| ||| | || || | | | || | || | | ||| | | || || | || | |||| | || ||| | || | || || | || | | || || | || || | || | | || ||| | || || |||| | | || | | | | | || | | || || | || || | | | | | || | || ||| || | | ||| | | |||| | || | | || | || | ||||| | | |||| || || || | | || ||| | || | | || || | | | || | || | |||||| || || | | || || || || | | | || ||| ||| |||||| || | | | || | || | | | | || | | | || || || || | | || || | || | | | || | | | || | || | ||| | || |||| |||| || | || | ||| | || | | || | || | || || | || | | | || || ||| || ||| || || | || ||| | | | | || | | | || || | || | | ||| | || ||||| | | || | | || | | || | | || | || | | | || || || | || || || || || || | | || | | | | || | | | || | || || | || | | ||| || || || | | | || | || | ||| || ||| | || | | || || ||| | | | || | | | || ||||| | || | || | || || ||| | | | | | | || || | || | || | | | | || || || | | || | || | | || ||| |||| | ||| ||| || | | || | | || || | | | || |||| | | | || | || || | || || | ||| || ||| || | | || || | || | |||| || || ||| || || | | | || | | || || | |||| | || ||| | || || || | | | || | || || | | | | || |||| | || || ||| | || || | | | || | || || | | || || | || | || || | ||||| | || | | ||| ||| || | || || || || | ||| | || | || || | | || ||| || ||| || | || | || | | || || || | | | || | || || | | || | || | ||| | | || ||||| || || || | | | |||| || | || | | | || | | ||| | | || || || | | ||| | ||| | ||| || || || | || | ||| || ||||| | || || | |||| ||| | || || | ||| || || || | | |||||| || ||| | ||| |||| |Pr(Wage>250 | Age) FIGURE 7.2. The Wagedata.Left:The solid curve displays the ﬁtted value from a least squares regression of wage(in thousands of dollars) using step functions ofage. The dotted curves indicate an estimated 95% conﬁdence interval. Right: We model the binary event wage>250 using logistic regression, again using step functions of age. The ﬁtted posterior probability of wageexceeding $250,000is shown, along with an estimated 95% conﬁdence interval. equals 0 otherwise. The se are sometimes called dummyvariables. Notice that for any value of X,C0(X)+C1(X)+...+CK(X)=1 ,s i n c e Xmust be in exactly one of the K+1 intervals. We then use least squares to ﬁt a linear model using C1(X),C2(X),...,C K(X)a sp r e d i c t o r s2: yi=β0+β1C1(xi)+β2C2(xi)+...+βKCK(xi)+/epsilon1i.(7.5) For a given value of X, at most one of C1,C2,...,C Kcan be non-zero. Note that when X<c 1, all of the predictors in (7.5) are zero, so β0can be interpreted as the mean value of YforX<c 1. By comparison, (7.5) predictsaresponseof β0+βjforcj≤X<c j+1,soβjrepresentstheaverage increase in the response for Xincj≤X<c j+1relative to X<c 1. An example of ﬁtting step functions to the Wagedata from Figure 7.1 is shownin theleft-handpanelofFigure7.2.We alsoﬁtthelogisticregression model 2We exclude C0(X) as a predictor in (7.5) because it is redundant with the intercept. This is similar to the fact that we need only two dummy variables to code a qualitative variable with three levels, provided that the model will contain an intercept. The decision to exclude C0(X) instead of some other Ck(X) in (7.5) is arbitrary. Alternatively, we could include C0(X),C1(X),...,C K(X), and exclude the intercept. 270 7. Moving Beyond Linearity Pr(yi>250|xi)=exp(β0+β1C1(xi)+...+βKCK(xi)) 1+exp(β0+β1C1(xi)+...+βKCK(xi))(7.6) in order to predict the probability that an individual is a high earneron the basis of age. The right-hand panel ofFigure 7.2 displays the ﬁtted posterior probabilities obtained using this approach. Unfortunately, unless there are natural breakpoints in the predictors, piecewise-constant functions can miss the action. For example, in the left- hand panel of Figure 7.2, the ﬁrst bin clearly misses the increasing trend ofwagewith age. Nevertheless, step function approaches are very popular in biostatistics and epidemiology, among other disciplines. For example, 5-year age groups are often used to deﬁne the bins. 7.3 Basis Functions Polynomial and piecewise-constant re gression models are in fact special cases of a basis function approach. The idea is to have at hand a fam-basis function ily of functions or transformations that can be applied to a variable X: b1(X),b2(X),...,b K(X). Instead of ﬁtting a linear model in X,w eﬁ tt h e model yi=β0+β1b1(xi)+β2b2(xi)+β3b3(xi)+...+βKbK(xi)+/epsilon1i.(7.7) Note that the basis functions b1(·),b2(·),...,b K(·) are ﬁxed and known. (In other words, we choose the functions ahead of time.) For polynomial regression, the basis functions are bj(xi)=xj i, and for piecewise constant functions they are bj(xi)=I(cj≤xi<cj+1). We can think of (7.7) as a standard linear mod el with predictors b1(xi),b2(xi),...,b K(xi). Hence, we can use least squares to estimate the unknown regression coeﬃcients in (7.7). Importantly, this means that all of the inference tools for linear models that are discussed in Chapter 3, such as standard errors for the coeﬃcient estimates and F -statistics for the model’s overall signiﬁcance, are available in this setting. Thus far we have considered the use of polynomial functions and piece- wise constant functions for our basis functions; however, many alternatives are possible. Forinstance, we canuse wa veletsorFourierseries to construct basis functions. In the next section, we investigate a very common choice for a basis function: regression splines .regression spline 7.4 Regression Splines 271 7.4 Regression Splines Now we discuss a ﬂexible class of basis functions that extends upon the polynomial regression and piecewise c onstant regression approaches that we have just seen. 7.4.1 Piecewise Polynomials Insteadofﬁttingahigh-degreepolynomialovertheentirerangeof X,piece- wise polynomial regression involves ﬁtting separate low-degree polynomialspiecewise polynomial regressionoverdiﬀerentregionsof X.Forexample,apiecewis ecubicpolynomialworks by ﬁtting a cubic regression model of the form yi=β0+β1xi+β2x2 i+β3x3 i+/epsilon1i, (7.8) where the coeﬃcients β0,β1,β2,a n dβ3diﬀer in diﬀerent parts of the range ofX. The points where the coeﬃcients change are called knots.knotFor example, a piecewise cubic with n o knots is just a standard cubic polynomial, as in (7.1) with d= 3. A piecewise cubic polynomial with a single knot at a point ctakes the form yi=/braceleftBigg β01+β11xi+β21x2 i+β31x3 i+/epsilon1iifxi<c; β02+β12xi+β22x2 i+β32x3 i+/epsilon1iifxi≥c. In other words, we ﬁt two diﬀerent polynomial functions to the data, one on the subset of the observations with xi<c, and one on the subset of the observations with xi≥c. The ﬁrst polynomial function has coeﬃcients β01,β11,β21,β31, and the second has coeﬃcients β02,β12,β22,β32.E a c ho f these polynomial functions can be ﬁt using least squares applied to simple functions of the original predictor. Using more knots leads to a more ﬂexi ble piecewise polynomial. In gen- eral, if we place Kdiﬀerent knots throughout the range of X,t h e nw e w i l le n du pﬁ t t i n g K+1 diﬀerent cubic polynomials. Note that we do not need to use a cubic polynomial. For e xample, we can instead ﬁt piecewise linear functions. In fact, our piecewise c onstant functions of Section 7.2 are piecewise polynomials of degree 0! The top left panel of Figure 7.3 shows a piecewise cubic polynomial ﬁt to a subset of the Wagedata, with a single knot at age=50. We immediately see a problem: the function is discontinuous and looks ridiculous! Since each polynomial has four parameters, we are using a total of eight degrees of freedomin ﬁtting this piecewise polynomial model.degrees of freedom 7.4.2 Constraints and Splines The top left panel of Figure 7.3 looks wrong because the ﬁtted curve is just too ﬂexible. To remedy this problem , we can ﬁt a piecewise polynomial 272 7. Moving Beyond Linearity AgeWagePiecewise Cubic 20 30 40 50 60 7050 100 150 200 250 20 30 40 50 60 7050 100 150 200 250 AgeWageContinuous Piecewise Cubic AgeWageCubic Spline 20 30 40 50 60 7050 100 150 200 250 20 30 40 50 60 7050 100 150 200 250 AgeWageLinear Spline FIGURE 7.3. Various piecewise polynomials are ﬁt to a subset of the Wage data, with a knot at age=50.Top Left: The cubic polynomials are unconstrained. Top Right: The cubic polynomials are constrained to be continuous at age=50. Bottom Left: The cubic polynomials are constrained to be continuous, and to have continuous ﬁrst and second derivatives. Bottom Right: A linear spline is shown, which is constrained to be continuous. under the constraint that the ﬁtted curve must be continuous. In other words,therecannotbe ajump when age=50. ThetoprightplotinFigure7.3 shows the resulting ﬁt. This looks better than the top left plot, but the V- shaped join looks unnatural. In thelowerleft plot,wehaveaddedtwoadditionalconstraints:nowboth the ﬁrst and second derivatives of the piecewise polynom ials are continuousderivativeatage=50. In other words, we are requiring that the piecewise polynomial be not only continuous when age=50, but also very smooth. Each constraint that we impose on the piecewise cubic p olynomials eﬀectively frees up one degree of freedom, by reducing the complexity of the resulting piecewise polynomial ﬁt. So in the top left plo t, we are using eight degrees of free- dom, but in the bottom left plot we imposed three constraints (continuity, continuity of the ﬁrst derivative, and continuity of the second derivative) and so are left with ﬁve degrees of freedom. The curve in the bottom left 7.4 Regression Splines 273 plot is called a cubic spline .3In general, a cubic spline with Kknots usescubic splinea total of 4+ Kdegrees of freedom. In Figure 7.3, the lower right plot is a linear spline , which is continuouslinear splineatage=50. The general deﬁnition ofa degree- dspline is that it is a piecewise degree-dpolynomial, with continuity in derivatives up to degree d−1a t each knot. Therefore, a linear spline is obtained by ﬁtting a line in each region of the predictor space deﬁned by the knots, requiring continuity at each knot. In Figure 7.3, there is a single knot at age=50. Of course, we could add more knots, and impose continuity at each. 7.4.3 The Spline Basis Representation The regression splines that we just saw in the previous section may have seemed somewhat complex: how can we ﬁt a piecewise degree- dpolynomial under the constraint that it (and possibly its ﬁrst d−1 derivatives) be continuous? It turns out that we can use the basis model (7.7) to represent a regression spline. A cubic spline with Kknots can be modeled as yi=β0+β1b1(xi)+β2b2(xi)+···+βK+3bK+3(xi)+/epsilon1i,(7.9) for an appropriate choice of basis functions b1,b2,...,b K+3. The model (7.9) can then be ﬁt using least squares. Just as there were several ways to repr esent polynomials, there are also many equivalent ways to represent cubi c splines using diﬀerent choices of basis functions in (7.9). The most direct way to represent a cubic spline using (7.9) is to start oﬀ with a basis for a cubic polynomial—namely, x,x2,x3—and then add one truncated power basis function per knot.truncated power basis A truncated power basis function is deﬁned as h(x,ξ)=(x−ξ)3 +=/braceleftbigg (x−ξ)3ifx>ξ 0o t h e r w i s e ,(7.10) whereξis the knot. One can show that adding a term of the form β4h(x,ξ) to the model (7.8) for a cubic polynomial will lead to a discontinuity in only the third derivative at ξ; the function will remain continuous, with continuous ﬁrst and second derivatives, at each of the knots. Inotherwords,inordertoﬁtacubicsplinetoadatasetwith Kknots,we perform least squares regression with an intercept and 3+ Kpredictors, of the form X,X2,X3,h(X,ξ1),h(X,ξ2),...,h(X,ξK), where ξ1,...,ξ Kare the knots. This amounts to estimating a total of K+ 4 regression coeﬃ- cients; for this reason,ﬁtting acubic spline with Kknots uses K+4degrees of freedom. 3Cubic splines are popular because most human eyes cannot detect the discontinuity at the knots. 274 7. Moving Beyond Linearity 20 30 40 50 60 7050 100 150 200 250 AgeWageNatural Cubic Spline Cubic Spline FIGURE 7.4. A cubic spline and a natural cubic spline, with three knots, ﬁt to as u b s e to ft h e Wagedata. Unfortunately, splines can have high variance at the outer range of the predictors—that is, when Xtakes on either a very small or very large value. Figure 7.4 shows a ﬁt to the Wagedata with three knots. We see that the conﬁdence bands in the boundary region appear fairly wild. A natu- ral spline is a regression spline with additional boundary constraints :t h enatural spline function is required to be linear at the boundary (in the region where Xis smaller than the smallest knot, or larger than the largest knot). This addi- tional constraint means that natural splines generally produce more stable estimates at the boundaries. In Figure 7.4, a natural cubic spline is also displayed as a red line. Note that the corresponding conﬁdence intervals are narrower. 7.4.4 Choosing the Number and Locations of the Knots When we ﬁt a spline, where should we place the knots? The regression spline is most ﬂexible in regions that contain a lot of knots, because in those regions the polynomial coeﬃcients can change rapidly. Hence, one option is to place more knots in places where we feel the function might vary most rapidly, and to place fewe r knots where it seems more stable. While this option can work well, in practice it is common to place knots in a uniform fashion. One way to do this is to specify the desired degrees of freedom, and then have the softwareautomatically place the corresponding number of knots at uniform quantiles of the data. Figure 7.5 shows an example on the Wagedata. As in Figure 7.4, we have ﬁt a natural cubic spline with three knots, except this time the knot locations were chosen automatically as the 25th, 50th, and 75th percentiles 7.4 Regression Splines 275 AgeWageNatural Cubic Spline 20 30 40 50 60 70 8050 100 150 200 250 300 20 30 40 50 60 70 800.00 0.05 0.10 0.15 0.20 Age| | || | || ||| || | | ||| | ||| | |||| || | || | | | ||| || | | |||| || ||| | || |||| || || | | || || || || | || | || || || | | || | || | || | || || |||| || | || || ||| || ||| |||| | || | | || || || || ||| || | || || | | || | || | |||||| | | | | || || | || |||| | || | || | | || || | || || | | || | || | | | |||| | | ||| | || | || | || | | | || | || | || | || | || | ||| || | || || | | || | || |||| || || |||| || || || | | || | | || || | || || | | | | |||| || | | | |||| | | |||| | | || | ||| || || | | | | | || || | | || | || || || | || ||| ||| || || || || || ||| || || || ||| | ||| || |||| | | || | || || | | || || | ||| || | || | ||| || | || | || | | || | || || || | | || | | | || | | | | | || |||||| | || || || || | || || || | || || | ||| | || || | || | || || | || || | || || || | |||| |||| | | || || || | || || | || || | || || | | | || || || || | || | | || || | || | || | | || | || || ||| ||| || | || |||| || ||| || | | || || || | | || | || || || ||| | | ||| || | ||||| || | | || | || | ||| || ||||| || || | || || | | | ||| | | | || || | |||| || | | | || || | || || | | | | || ||| ||| | | ||| || | ||| || | |||| | | | || | || || ||| || || || || | || | | | |||| || | || || | || |||| || || ||| | | |||| || | || || || || || ||| || ||| | | || | || ||| || || | | | | || | || | | || | || | || || | || || || | ||| |||| | || || ||| || | | || || | || | | | || | || | | || | || | | || | || | || |||| ||| | || | |||| || || | || | | || || || || | | | | | |||| | | || | || |||||| || | || | || | | | || || | || | | | || | | || | | | | | || |||| | || | || ||| || || | | | | | ||||| || || || | | || | | || | || | || | | || || | || || | | | | || | | || | | | || | ||| || |||| | | | |||| | || || | | | || |||| | ||||| || || | || || | | | || | || | || ||| || | || | | || | | || | || | ||| || || ||| || | | | || | | || | || ||| |||| || ||| | | || | | | || | | || | || | | || || ||| || | ||| || | || | | ||| | | | || || || | | || | | || || | || | || ||| | || || | | || ||| || | | || | || |||| | | || || | || || | | || || || || ||| |||| | || || | | |||| || | || | ||| | | || ||| || || | | || || | || ||| || || || |||| || ||||| || | || || || | || | ||||| | || | || || | || || | || | | | | || | |||||| | | | || | | || || | || | | || ||| || ||| | | | || || || || | || | || ||| ||| || | | | || | |||| | | | || | | ||| | | | || || | | | || | || ||| | | | || || |||| | || || | || ||| | | | | || | || || || |||| | | || ||| || | | || | || || || ||| | | || | || | | | | || || ||| | | | || || ||| ||| | | || | || ||| ||| || || || || | ||||| | || || | || || | | | || || || | || | | | |||| | || | | ||| || |||| | | || ||| | | | | |||| || | | |||| || | || || || | || | | || | | || || | | |||| || || | || | || | || || | | || | | | ||| || | || || || |||| | || | || |||| || || | | | | | || || | ||| || || || || | | | |||| | || ||| |||| | || ||| | || | || || | | || | | | | | || || | |||| || || | | || | | | ||| | || || || || | | | || || | || || | | |||| ||| | || | | || | || | | | | || | | || | ||| | ||||| ||| | ||| | | | || || | | | ||| | | | || ||| || | || || | |||| | || | | ||| || || || | || |||| || ||| | ||||| || | ||| | || ||| || | | ||| ||| || || | | | || | | | || | ||||| | | | | | || | | | | || | ||| || | || || || | | | || |||| || || | | | || | || | | || || || | ||||| || || || || | ||| ||| | || || | | | || | || | | ||| | | || || | || | |||| | || ||| | || | || || | || | | || || | || || | || | | | || || | || || |||| | | || | | | | | || | | || || | || | | | | || | || | || ||| || | | ||| | | |||| | || | | || | || | ||||| | | |||| || || || | | || ||| | || | | || | | || | || | || | |||||| || || | | || || || || | | | || ||| ||| |||||| || | | | || | || | | | | || | | | || || |||| | | || || | || | | | || | | | || | || | ||| | || |||| |||| || | || | ||| | || | | || | || | || ||| || | | | || || ||| || ||| || || | || ||| | | | | || | | | || || | || | | ||| | || ||||| | | ||| | || | | | | | | || | || | | | || || || | || || || || || || | | || | | | | || | | | || | || || | || | | ||| || || || | | | || | || | ||| || ||| | || | | || || ||| | | | || | | | || ||||| | || | || | || || ||| | | | | | | || || | || | || | | | | || || | || | | | | || | | || ||| |||| | ||| ||| || | | || | | || || | | | || |||| | | | || | || || | || || | || | | | ||| || | | || || | || | |||| || || ||| || || | | | || | | || || | |||| | || ||| | || || || | | | || | || || | | | | || |||| | || || ||| | || || | | | || | || || | | || || | || | || || | ||||| | || | | ||| ||| || | || || || ||| |||| || | || || | | || ||| || ||| || | || | || | | || || |||| | || | || || | | || | || | ||| | | || ||||| || || || | | | |||| || | || | | | || | | ||| | | || || || || ||| | ||| | ||| || || || | || | ||| || ||||| | | | || | |||| ||| | || || | ||| || || || | | |||||| || ||| | ||| |||||Pr(Wage>250 | Age) FIGURE 7.5. A natural cubic spline function with four degrees of freedom is ﬁt to the Wagedata.Left:As p l i n ei sﬁ tt o wage(in thousands of dollars) as af u n c t i o no f age.Right:Logistic regression is used to model the binary event wage>250 as a function of age. The ﬁtted posterior probability of wageexceeding $250,000is shown. ofage. This was speciﬁed by requesting f our degrees of freedom. The ar- gument by which four degrees of freedom leads to three interior knots is somewhat technical.4 How many knots should we use, or equivalently how many degrees of freedom should our spline contain? One option is to try out diﬀerent num- bers of knots and see which produces the best looking curve. A somewhat more objective approach is to use cross-validation, as discussed in Chap- ters 5 and 6. With this method, we removea portion of the data (say 10%), ﬁt a spline with a certain number of knots to the remaining data, and then use the spline to make predictions for the held-out portion. We repeat this process multiple times until each observation has been left out once, and then compute the overall cross-valid ated RSS. This procedure can be re- peated for diﬀerent numbers of knots K. Then the value of Kgiving the smallest RSS is chosen. 4There are actually ﬁve knots, including the two boundary knots. A cubic spline with ﬁve knots would have nine degrees of freedom. But natural cubic splines have two additional naturalconstraints at each boundary to enforce linearity, resulting in 9 −4=5 degrees of freedom. Since this includes a constant, which is absorbed in the intercept, we count it as four degrees of freedom. 276 7. Moving Beyond Linearity Degrees of Freedom of Natural SplineMean Squared Error 2468 1 01600 1620 1640 1660 1680 2468 1 01600 1620 1640 1660 1680 Degrees of Freedom of Cubic SplineMean Squared Error FIGURE 7.6. Ten-fold cross-validated mean squared errors for selecting the degrees of freedom when ﬁtting splines to the Wagedata. The response is wage and the predictor age.Left:A natural cubic spline. Right:Ac u b i cs p l i n e . Figure 7.6 shows ten-fold cross-validated mean squared errors for splines with various degrees of freedom ﬁt to the Wagedata. The left-hand panel corresponds to a natural spline and the right-hand panel to a cubic spline. The two methods produce almost identical results, with clear evidence that a one-degree ﬁt (a linear regression) is not adequate. Both curves ﬂatten out quickly, and it seems that three degrees of freedom for the natural spline and four degrees of freedom for the cubic spline are quite adequate. In Section 7.7 we ﬁt additive spline models simultaneously on several variables at a time. This could potentially require the selection of degrees of freedom for each variable. In cases like this we typically adopt a more pragmatic approach and set the degrees of freedom to a ﬁxed number, say four, for all terms. 7.4.5 Comparison to Polynomial Regression Regressionsplines oftengive superiorresults to polynomialregression.This is because unlike polynomials, which must use a high degree (exponent in the highest monomial term, e.g. X15) to produce ﬂexible ﬁts, splines intro- duce ﬂexibility by increasing the number of knots but keeping the degree ﬁxed. Generally, this approachproduces more stable estimates. Splines also allow us to place more knots, and hence ﬂexibility, over regions where the function fseems to be changing rapidly, and fewer knots where fappears more stable. Figure 7.7 compares a natural cubic spline with 15 degrees of freedom to a degree-15 polynomial on the Wagedata set. The extra ﬂexibil- ity in the polynomial produces undesirable results at the boundaries, while the natural cubic spline still provides a reasonable ﬁt to the data. 7.5 Smoothing Splines 277 20 30 40 50 60 70 8050 100 150 200 250 300 AgeWageNatural Cubic Spline Polynomial FIGURE 7.7. On the Wagedata set, a natural cubic spline with 15 degrees of freedom is compared to a degree- 15polynomial. Polynomials can show wild behavior, especially near the tails. 7.5 Smoothing Splines 7.5.1 An Overview of Smoothing Splines In the last section we discussed regre ssion splines, which we create by spec- ifying a set of knots, producing a sequence of basis functions, and then using least squares to estimate the spline coeﬃcients. We now introduce a somewhat diﬀerent approach that also produces a spline. In ﬁtting a smooth curve to a set of data, what we really want to do is ﬁnd some function, say g(x), that ﬁts the observed data well: that is, we want RSS =/summationtextn i=1(yi−g(xi))2to be small. However, there is a problem with this approach. If we don’t put any constraints on g(xi), then we can always make RSS zero simply by choosing gsuch that it interpolates all of theyi. Such a function would woefully overﬁt the data—it would be far too ﬂexible. What we really want is a function gthat makes RSS small, but that is also smooth. How might we ensure that gis smooth? There are a number of ways to do this. A natural approach is to ﬁnd the function gthat minimizes n/summationdisplay i=1(yi−g(xi))2+λ/integraldisplay g/prime/prime(t)2dt (7.11) whereλis a nonnegative tuning parameter . The function gthat minimizes (7.11) is known as a smoothing spline .smoothing spline What does (7.11) mean? Equation 7.11 takes the “Loss+Penalty” for- mulation that we encounter in the context of ridge regression and the lasso in Chapter 6. The term/summationtextn i=1(yi−g(xi))2is aloss function that encour-loss functionagesgto ﬁt the data well, and the term λ/integraltext g/prime/prime(t)2dtis apenalty term 278 7. Moving Beyond Linearity that penalizes the variability in g. The notation g/prime/prime(t) indicates the second derivative of the function g. The ﬁrst derivative g/prime(t) measures the slope of a function at t, and the second derivative corresponds to the amount by which the slope is changing. Hence, broadlyspeaking, the second derivative of a function is a measure of its roughness : it is large in absolute value if g(t)i sv e r yw i g g l yn e a r t, and it is close to zero otherwise. (The second derivative of a straight line is zero; note that a line is perfectly smooth.) The/integraltext notation is an integral, which we can think of as a summation over the range of t.I no t h e rw o r d s ,/integraltextg/prime/prime(t)2dtis simply a measure of the total change in the function g/prime(t), over its entire range. If gis very smooth, then g/prime(t) will be close to constant and/integraltext g/prime/prime(t)2dtwill take on a small value. Conversely, if gis jumpy and variable than g/prime(t) will vary signiﬁcantly and/integraltext g/prime/prime(t)2dtwill take on a large value. Therefore, in (7.11), λ/integraltext g/prime/prime(t)2dten- courages gto be smooth. The larger the value of λ,t h es m o o t h e r gwill be. Whenλ= 0, then the penalty term in (7.11) has no eﬀect, and so the function gwill be very jumpy and will exactly interpolate the training observations. When λ→∞,gwill be perfectly smooth—it will just be a straight line that passes as closely as possible to the training points. In fact, in this case, gwill be the linear least squares line, since the loss function in (7.11) amounts to minimizing the residual sum of squares. For an intermediate value of λ,gwill approximate the training observations but will be somewhat smooth. We see that λcontrols the bias-variance trade-oﬀ of the smoothing spline. The function g(x) that minimizes (7.11) can be shown to have some spe- cial properties: it is a piecewise cubic p olynomial with knots at the unique values of x1,...,x n, and continuous ﬁrst and second derivatives at each knot. Furthermore, it is linear in the region outside of the extreme knots. In other words, the function g(x)that minimizes (7.11) is a natural cubic spline with knots at x1,...,x n!However, it is not the same natural cubic spline that one would get if one applied the basis function approach de- scribed in Section 7.4.3 with knots at x1,...,x n—rather, it is a shrunken version of such a natural cubic spline, where the value of the tuning pa- rameterλin (7.11) controls the level of shrinkage. 7.5.2 Choosing the Smoothing Parameter λ We have seen that a smoothing spline is simply a natural cubic spline with knots at every unique value of xi. It might seem that a smoothing spline will have far too many degrees of freedom, since a knot at each data point allows a great deal of ﬂexibility. But the tuning parameter λcontrols the roughness of the smoothing spline, and hence the eﬀective degrees of freedom. It is possible to show that as λincreases from 0 to ∞, the eﬀectiveeﬀective degrees of freedomdegrees of freedom, which we write dfλ, decrease from nto 2. In the context of smoothing splines, why do we discuss eﬀective degrees of freedom instead of degrees of freed om? Usually degrees of freedom refer 7.5 Smoothing Splines 279 to the number of free parameters, such as the number of coeﬃcients ﬁt in a polynomial or cubic spline. Although a smoothing spline has nparameters and hence nnominal degrees of freedom, these nparameters are heavily constrained or shrunk down. Hence dfλis a measure of the ﬂexibility of the smoothingspline—the higherit is, the moreﬂexible(and the lower-biasbut higher-variance) the smoothing splin e. The deﬁnition of eﬀective degrees of freedom is somewhat technical. We can write ˆgλ=Sλy, (7.12) whereˆgis the solution to (7.11) for a particular choice of λ—that is, it is a n-vector containing the ﬁtted values of the smoothing spline at the training pointsx1,...,x n. Equation 7.12 indicates that the vector of ﬁtted values when applying a smoothing spline to the data can be written as a n×n matrixSλ(for which there is a formula) times the response vector y.T h e n the eﬀective degrees of freedom is deﬁned to be dfλ=n/summationdisplay i=1{Sλ}ii, (7.13) the sum of the diagonal elements of the matrix Sλ. In ﬁtting a smoothing spline, we do not need to select the number or location of the knots—there will be a knot at each training observation, x1,...,x n. Instead, we have another problem: we need to choose the value ofλ.Itshouldcomeasnosurprisethatonepossiblesolutiontothisproblem is cross-validation. In other words, we can ﬁnd the value of λthat makes the cross-validated RSS as small as possible. It turns out that the leave- one-outcross-validation error (LOOCV) can be computed very eﬃciently for smoothing splines, with essentially the same cost as computing a single ﬁt, using the following formula: RSScv(λ)=n/summationdisplay i=1(yi−ˆg(−i) λ(xi))2=n/summationdisplay i=1/bracketleftbiggyi−ˆgλ(xi) 1−{Sλ}ii/bracketrightbigg2 . The notation ˆ g(−i) λ(xi) indicates the ﬁtted value for this smoothing spline evaluated at xi, where the ﬁt uses all of the training observations except for theith observation ( xi,yi). In contrast, ˆ gλ(xi) indicates the smoothing spline function ﬁt to all of the training observations and evaluated at xi. This remarkable formula says that we can compute each of these leave- one-outﬁts using only ˆ gλ, the original ﬁt to allof the data!5We have a very similar formula (5.2) on page 180 in Chapter 5 for least squares linear regression. Using (5.2), we can very quickly perform LOOCV for the regression splines discussed earlie r in this chapter, as well as for least squares regression using arbitrary basis functions. 5The exact formulasfor computing ˆ g(xi)a n d Sλare very technical; however, eﬃcient algorithms are available for computing these quantities. 280 7. Moving Beyond Linearity 20 30 40 50 60 70 800 50 100 200 300 AgeWageSmoothing Spline 16 Degrees of Freedom 6.8 Degrees of Freedom (LOOCV) FIGURE 7.8. Smoothing spline ﬁts to the Wagedata. The red curve results from specifying 16eﬀective degrees of freedom. For the blue curve, λwas found automatically by leave-one-out cross-validation, which resulted in 6.8eﬀective degrees of freedom. Figure 7.8 shows the results from ﬁtting a smoothing spline to the Wage data. The red curve indicates the ﬁt obtained from pre-specifying that we would likeasmoothing spline with 16eﬀectivedegreesoffreedom.The blue curve is the smoothing spline obtained when λis chosen using LOOCV; in this case, the value of λchosen results in 6 .8 eﬀective degrees of freedom (computed using (7.13)). For this data, there is little discernible diﬀerence between the two smoothing splines, beyond the fact that the one with 16 degrees of freedom seems slightly wigglier. Since there is little diﬀerence between the two ﬁts, the smoothing spline ﬁt with 6 .8 degrees of freedom is preferable, since in general simpler models are better unless the data provides evidence in suppor t of a more complex model. 7.6 Local Regression Local regression is a diﬀerent approach for ﬁtting ﬂexible non-linear func-local regression tions, which involves computing the ﬁt at a target point x0using only the nearby training observations. Figure 7.9 illustrates the idea on some simu- lated data, with one target point near 0 .4, and another near the boundary at 0.05. In this ﬁgure the blue line represents the function f(x)f r o mw h i c h the data were generated, and the light orange line corresponds to the local regression estimate ˆf(x). Local regression is described in Algorithm 7.1. Note that in Step 3 of Algorithm 7.1, the weights Ki0will diﬀer for each value of x0. In other words, in order to obtain the local regression ﬁt at a new point, we need to ﬁt a new weighted least squares regression model by 7.6 Local Regression 281 O OO OO OOOO OO O O OOOOO OO OO OO O OOO OOOO OO OO O OOOO OO OO O OO OOOO O OOO O OOO OO O OOOO OOO OOOO O OO O OOO OO OO OOO OOO OOOO OOO O OO OO OO OOOO OO O O OOOOO OO OO 0.0 0.2 0.4 0.6 0.8 1.0−1.0 −0.5 0.0 0.5 1.0 1.5 0.0 0.2 0.4 0.6 0.8 1.0−1.0 −0.5 0.0 0.5 1.0 1.5O OO OO OOOO OO O O OOOOO OO OO OO O OOO OOOO OO OO O OOOO OO OO O OO OOOO O OOO O OOO OO O OOOO OOO OOOO O OO O OOO OO OO OOO OOO OOOO OOO O OO OO O OOO OOOO OO OO O OOOO OO OO O OO OOOO O OOO O OOO OO O OOOO OOO OLocal Regression FIGURE 7.9. Local regression illustrated on some simulated data, where the blue curve represents f(x)from which the data were generated, and the light orange curve corresponds to the local regression estimate ˆf(x). The orange colored points are local to the target point x0, represented by the orange vertical line. The yellow bell-shape superimposed on the plot indicates weights assigned to each point, decreasing to zero with distance from the target point. The ﬁt ˆf(x0)atx0is obtained by ﬁtting a weighted linear regression (orange line segment), and using the ﬁtted value at x0(orange solid dot) as the estimate ˆf(x0). minimizing (7.14) for a new set of weights. Local regression is sometimes referredtoasa memory-based procedure,becauselikenearest-neighbors,we need all the training data each time we wish to compute a prediction. We will avoid getting into the technical details of local regression here—there are books written on the topic. In order to perform local regression, there are a number of choices to be made, such as how to deﬁne the weighting function K, and whether to ﬁt a linear, constant, or quadratic regression in Step 3 above. (Equation 7.14 corresponds to a linear regression.) While all of these choices make some diﬀerence, the most important choice is the spans,d e ﬁ n e di nS t e p1a b o v e . The span plays a role like that of the tuning parameter λin smoothing splines: it controls the ﬂexibility of the non-linear ﬁt. The smaller the value ofs,t h em o r e localand wiggly will be our ﬁt; alternatively, a very large value of swill lead to a global ﬁt to the data using all of the training observations. We can again use cross-validation to choose s,o rw ec a n specify it directly. Figure 7.10 displays local linear regression ﬁts on the Wagedata, using two values of s:0.7a n d0.2. As expected, the ﬁt obtained usings=0.7 is smoother than that obtained using s=0.2. The idea of local regression can be generalized in many diﬀerent ways. In a setting with multiple features X1,X2,...,X p, one very useful general- ization involves ﬁtting a multiple linear regression model that is global in some variables, but local in another, such as time. Such varying coeﬃcient 282 7. Moving Beyond Linearity Algorithm 7.1 Local Regression At X=x0 1. Gather the fraction s=k/nof training points whose xiare closest tox0. 2. Assign a weight Ki0=K(xi,x0) to each point in this neighborhood, so that the point furthest from x0has weight zero, and the closest has the highest weight. All but these knearest neighbors get weight zero. 3. Fit a weighted least squares regression of theyion thexiusing the aforementioned weights, by ﬁnding ˆβ0andˆβ1that minimize n/summationdisplay i=1Ki0(yi−β0−β1xi)2. (7.14) 4. The ﬁtted value at x0is given by ˆf(x0)=ˆβ0+ˆβ1x0. modelsare a useful way of adapting a model to the most recently gatheredvarying coeﬃcient modeldata. Local regression also generalizes very naturally when we want to ﬁt models that are local in a pair of variables X1andX2, rather than one. We can simply use two-dimensional neighborhoods, and ﬁt bivariate linear regression models using the observations that are near each target point in two-dimensional space. Theoretically the same approach can be imple- mented in higher dimensions, using linear regressions ﬁt to p-dimensional neighborhoods. However, local r egression can perform poorly if pis much larger than about 3 or 4 because there will generally be very few training observations close to x0. Nearest-neighbors regr ession, discussed in Chap- ter 3, suﬀers from a similar problem in high dimensions. 7.7 Generalized Additive Models In Sections 7.1–7.6,we present a number of approaches for ﬂexibly predict- i n gar e s po n s e Yon the basis of a single predictor X. These approachescan be seen as extensions of simple linear r egression. Here we explore the prob- lem of ﬂexibly predicting Yon the basis of several predictors, X1,...,X p. This amounts to an extension of multiple linear regression. Generalized additive models (GAMs) provide a general framework forgeneralized additive modelextending a standard linear model by allowing non-linear functions of each ofthevariables,whilemaintaining additivity . Justlikelinearmodels,GAMs additivitycan be applied with both quantitative and qualitative responses. We ﬁrst examine GAMs for a quantitative response in Section 7.7.1, and then for a qualitative response in Section 7.7.2. 7.7 Generalized Additive Models 283 20 30 40 50 60 70 800 50 100 200 300 AgeWageLocal Linear Regression Span is 0.2 (16.4 Degrees of Freedom) Span is 0.7 (5.3 Degrees of Freedom) FIGURE 7.10. Local linear ﬁts to the Wagedata. The span speciﬁes the fraction of the data used to compute the ﬁt at each target point. 7.7.1 GAMs for Regression Problems A natural way to extend the multiple linear regression model yi=β0+β1xi1+β2xi2+···+βpxip+/epsilon1i in order to allow for non-linear relationships between each feature and the response is to replace each linear component βjxijwith a (smooth) non- linear function fj(xij). We would then write the model as yi=β0+p/summationdisplay j=1fj(xij)+/epsilon1i =β0+f1(xi1)+f2(xi2)+···+fp(xip)+/epsilon1i.(7.15) This is an example of a GAM. It is called an additive model because we calculate a separate fjfor each Xj, and then add together all of their contributions. In Sections 7.1–7.6, we discuss many methods for ﬁtting functions to a single variable. The beauty of GAMs is that we can use these methods as building blocks for ﬁtting an additive model. In fact, for most of the methods that we have seen so far in this chapter, this can be done fairly trivially. Take, for example, natural splines, and consider the task of ﬁtting the model wage=β0+f1(year)+f2(age)+f3(education )+/epsilon1(7.16) 284 7. Moving Beyond Linearity 2003 2005 2007 2009−30 −20 −10 0 10 20 30 20 30 40 50 60 70 80−50 −40 −30 −20 −10 0 10 20 −30 −20 −10 0 10 20 30 40<HS HS <Coll Coll >Collf1(year) f2(age) f3(education ) age yeareducation FIGURE 7.11. For the Wagedata, plots of the relationship between each feature and the response, wage, in the ﬁtted model (7.16). Each plot displays the ﬁtted function and pointwise standard errors. The ﬁrst two functions are natural splines inyearand age, with four and ﬁve degrees of freedom, respectively. The third function is a step function, ﬁt to the qualitative variable education . on the Wagedata. Here yearand ageare quantitative variables, and education is a qualitative variable with ﬁve levels: <HS,HS,<Coll,Coll, >Coll, referring to the amount of high school or college education that an individual has completed. We ﬁt the ﬁrst two functions using natural splines. We ﬁt the third function using a separate constant for each level, via the usual dummy variable approach of Section 3.3.1. Figure 7.11 shows the results of ﬁtting the model (7.16) using least squares. This is easy to do, since as di scussed in Section 7.4, natural splines can be constructed using an appropriately chosen set of basis functions. Hence the entire model is just a big regression onto spline basis variables and dummy variables, all packed into one big regression matrix. Figure 7.11 can be easily interpreted. The left-hand panel indicates that holding ageand education ﬁxed, wagetends to increase slightly with year; this may be due to inﬂation. The center panel indicates that holding education and yearﬁxed, wagetends to be highest for intermediate val- ues of age, and lowest for the very young and very old. The right-hand panel indicates that holding yearand ageﬁxed, wagetends to increase with education : the more educated a person is, the higher their salary, on average. All of these ﬁndings are intuitive. Figure 7.12 shows a similar triple of plots, but this time f1andf2are smoothing splines with four and ﬁve de grees of freedom, respectively. Fit- ting aGAM with asmoothingspline isnot quite assimpleasﬁtting a GAM with a natural spline, since in the case of smoothing splines, least squares cannot be used. However, standard software such as the gam()function in R can be used to ﬁt GAMs using smoothing splines, via an approach known asbackﬁtting . This method ﬁts a model involving multiple predictors bybackﬁtting 7.7 Generalized Additive Models 285 2003 2005 2007 2009−30 −20 −10 0 10 20 30 20 30 40 50 60 70 80−50 −40 −30 −20 −10 0 10 20 −30 −20 −10 0 10 20 30 40<HS HS <Coll Coll >Collf1(year) f2(age) f3(education ) age yeareducation FIGURE 7.12. Details are as in Figure 7.11, but now f1andf2are smoothing splines with four and ﬁve degrees of freedom, respectively. repeatedly updating the ﬁt for each predictor in turn, holding the others ﬁxed. The beauty of this approach is that each time we update a function, we simply apply the ﬁtting method for that variable to a partial residual .6 The ﬁtted functions in Figures 7.11 and 7.12 look rather similar. In most situations, the diﬀerences in the GAMs obtained using smoothing splines versus natural splines are small. We do not have to use splines as the building blocks for GAMs: we can just as well use local regression, polynomial regression, or any combination of the approaches seen earlier in this chapter in order to create a GAM. GAMsareinvestigatedinfurtherdetailinthelabattheendofthischapter. Pros and Cons of GAMs Before we move on, let us summarize the advantages and limitations of a GAM. ▲GAMs allow us to ﬁt a non-linear fjto eachXj,s ot h a tw ec a n automatically model non-linear relationships that standard linear re- gression will miss. This means that we do not need to manually try out many diﬀerent transformations on each variable individually. ▲The non-linear ﬁts can potentially make more accura te predictions for the response Y. ▲Because the model is additive, we can still examine the eﬀect of eachXjonYindividually while holding all of the other variables ﬁxed. Hence if we are interested i n inference, GAMs provide a useful representation. 6A partial residual for X3, for example, has the form ri=yi−f1(xi1)−f2(xi2). If we know f1andf2, then we can ﬁt f3by treating this residual as a response in a non-linear regression on X3. 286 7. Moving Beyond Linearity ▲The smoothness of the function fjfor the variable Xjcan be sum- marized via degrees of freedom. ◆The main limitation of GAMs is that the model is restricted to be additive. With many variables, important interactions can be missed. However, as with linear regression, we can manually add interaction terms to the GAM model by including additional predictors of the formXj×Xk. In addition we can add low-dimensional interaction functions of the form fjk(Xj,Xk) into the model; such terms can be ﬁt using two-dimensional smoothers such as local regression, or two-dimensional splines (not covered here). For fully general models, we have to look for even more ﬂexible approaches suchasrandomforestsandboosting,describedinChapter8.GAMsprovide a useful compromise between linear and fully nonparametric models. 7.7.2 GAMs for Classiﬁcation Problems G A M sc a na l s ob eu s e di ns i t u a t i o n sw h e r e Yis qualitative. For simplicity, here we will assume Ytakes on values zero or one, and let p(X)=P r (Y= 1|X) be the conditional probability(given the predictors)that the response equals one. Recall the logistic regression model (4.6): log/parenleftbiggp(X) 1−p(X)/parenrightbigg =β0+β1X1+β2X2+···+βpXp. (7.17) Thislogitis the log of the odds of P(Y=1|X)v e r s u sP(Y=0|X), which (7.17) represents as a linear function of the predictors. A natural way to extend (7.17) to allow for non-linear relationships is to use the model log/parenleftbiggp(X) 1−p(X)/parenrightbigg =β0+f1(X1)+f2(X2)+···+fp(Xp).(7.18) Equation 7.18 is a logistic regression GAM. It has all the same pros and cons as discussed in the previous section for quantitative responses. We ﬁt a GAM to the Wagedata in order to predict the probability that an individual’s income exceeds $250 ,000 per year. The GAM that we ﬁt takes the form log/parenleftbiggp(X) 1−p(X)/parenrightbigg =β0+β1×year+f2(age)+f3(education ),(7.19) where p(X)=P r ( wage>250|year,age,education ). 7.8 Lab: Non-linear Modeling 287 2003 2005 2007 2009−4 −2 0 2 4 20 30 40 50 60 70 80−8 −6 −4 −2 0 2 −400 −200 0 200 400<HS HS <Coll Coll >Collf1(year) f2(age) f3(education ) age yeareducation FIGURE 7.13. For the Wagedata, the logistic regression GAM given in (7.19) is ﬁt to the binary response I(wage>250) . Each plot displays the ﬁtted function and pointwise standard errors. The ﬁrst function is linear in year, the second function a smoothing spline with ﬁve degrees of freedom in age,a n dt h et h i r da step function for education . There are very wide standard errors for the ﬁrst level <HSofeducation . Once again f2is ﬁt using a smoothing spline with ﬁve degrees of freedom, andf3is ﬁt as a step function, by creating dummy variables for each of the levels of education. The resulting ﬁt is shown in Figure 7.13. The last panel looks suspicious, with very wide conﬁdence intervals for level <HS.I n fact, there are no ones for that category: no individuals with less than a high school education make more than $250 ,0 0 0p e ry e a r .H e n c ew er e ﬁ t the GAM, excluding the individuals with less than a high school education. The resulting model is shown in Figure 7.14. As in Figures 7.11 and 7.12, all three panels have the same vertical scale. This allows us to visually assess the relative contributions of each of the variables. We observe that ageand education have a much larger eﬀect than yearon the probability of being a high earner. 7.8 Lab: Non-linear Modeling In thislab,were-analyzethe Wagedataconsideredinthe examplesthrough- out this chapter, in order to illustrate the fact that many of the complex non-linear ﬁtting procedures discussed can be easily implemented in R.W e begin by loading the ISLRlibrary, which contains the data. > library(ISLR) > attach(Wage) 288 7. Moving Beyond Linearity 2003 2005 2007 2009−4 −2 0 2 4 20 30 40 50 60 70 80−8 −6 −4 −2 0 2 −4 −2 0 2 4HS <Coll Coll >Collf1(year) f2(age) f3(education ) age ryeaeducation FIGURE 7.14. The same model is ﬁt as in Figure 7.13, this time excluding the observations for which education is<HS. Now we see that increased education tends to be associated with higher salaries. 7.8.1 Polynomial Regression and Step Functions We now examine how Figure 7.1 was produced. We ﬁrst ﬁt the model using the following command: > fit=lm(wage ∼poly(age ,4),data=Wage) > coef(summary(fit)) Estimate Std. Error t value Pr(>|t|) (Intercept ) 111.704 0.729 153.28 <2e-16 poly(age, 4)1 447.068 39.915 11.20 <2e-16 poly(age, 4)2 -478.316 39.915 - 11.98 <2e-16 poly(age, 4)3 125.522 39.915 3.14 0.0017 poly(age, 4)4 -77.911 39.915 -1.95 0.0510 This syntax ﬁts a linear model, using the lm()function, in order to predict wageusingafourth-degreepolynomialin age:poly(age,4) .T h e poly()com- mand allows us to avoid having to write out a long formula with powers ofage. The function returns a matrix whose columns are a basis of or- thogonal polynomials , which essentially means that each column is a linearorthogonal polynomial combination of the variables age,age^2,age^3and age^4. However, we can also use poly()to obtain age,age^2,age^3and age^4 directly, if we prefer. We can do this by using the raw=TRUE argument to thepoly()function. Later we see that this does not aﬀect the model in a meaningful way—though the choice of b asis clearly aﬀects the coeﬃcient estimates, it does not aﬀect the ﬁtted values obtained. > fit2=lm(wage ∼poly(age,4,raw=T),data=Wage) > coef(summary(fit2)) Estimate Std. Error t value Pr(>|t|) (Intercept ) -1.84e+02 6.00e+01 -3.07 0.002180 poly(age, 4, raw = T)1 2.12e+01 5.89e+00 3.61 0.000312 poly(age, 4, raw = T)2 -5.64e-01 2.06e-01 -2.74 0.006261 7.8 Lab: Non-linear Modeling 289 poly(age, 4, raw = T)3 6.81e-03 3.07e-03 2.22 0.026398 poly(age, 4, raw = T)4 -3.20e-05 1.64e-05 -1.95 0.051039 Thereareseveralotherequivalent waysofﬁtting this model, whichshow- case the ﬂexibility of the formula language in R. For example > fit2a=lm(wage ∼age+I(age^2)+I(age^3)+I(age^4),data=Wage) > coef(fit2a) (Intercept ) age I(age^2) I(age^3) I(age^4) -1.84e+02 2.12e+01 -5.64e-01 6.81e-03 -3.20e-05 This simply creates the polynomial basis functions on the ﬂy, taking care to protect terms like age^2via thewrapperfunction I()(the ^symbol haswrapper a special meaning in formulas). > fit2b=lm(wage ∼cbind(age,age^2,age^3,age^4),data=Wage) This does the samemore compactly,using the cbind()function for building amatrixfromacollectionofvect ors;anyfunctioncallsuchas cbind()inside a formula also serves as a wrapper. We now create a grid of values for ageat which we want predictions, and then call the generic predict() function, specifying that we want standard errors as well. > agelims=range(age) > age.grid=seq(from=agelims[1],to=agelims [2]) > preds=predict(fit,newdata=list(age=age.grid),se=TRUE) > se.bands=cbind(preds$fit +2*preds$se.fit,preds$fit -2*preds$se. fit) Finally, we plot the data and add the ﬁt from the degree-4 polynomial. > par(mfrow=c(1,2),mar=c(4.5,4.5,1,1) ,oma=c(0,0,4,0)) > plot(age,wage,xlim=agelims ,cex=.5,col=\"darkgrey \") > title(\" Degree -4 Polynomial \",outer=T) > lines(age.grid,preds$fit ,lwd=2,col=\"blue\") > matlines(age.grid,se. bands ,lwd=1,col=\" blue\",lty=3) Here the marand omaarguments to par()allow us to control the margins of the plot, and the title()function creates a ﬁgure title that spans bothtitle()subplots. Wementionedearlierthatwhether ornotanorthogonalsetofbasisfunc- t i o n si sp r o d u c e di nt h e poly()function will not aﬀect the model obtained in a meaningful way. What do we mean by this? The ﬁtted values obtained in either case are identical: > preds2=predict(fit2,newdata=list(age=age.grid),se=TRUE) > max(abs(preds$fit -preds2$fit )) [1] 7.39e-13 In performing a polynomial regression we must decide on the degree of the polynomial to use. One way to do this is by using hypothesis tests. We now ﬁt models ranging from linear to a degree-5 polynomial and seek to determine the simplest model which is suﬃcient to explain the relationship 290 7. Moving Beyond Linearity between wageand age.W eu s et h e anova() function, which performs ananova()analysis of variance (ANOVA, using an F-test) in order to test the nullanalysis of variance hypothesis that a model M1is suﬃcient to explain the data against the alternative hypothesis that a more complex model M2is required. In order to use the anova() function, M1andM2must be nestedmodels: the predictors in M1must be a subset of the predictors in M2.I nt h i sc a s e , we ﬁt ﬁve diﬀerent models and sequen tially compare the simpler model to the more complex model. > fit.1=lm(wage ∼age,data=Wage) > fit.2=lm(wage ∼poly(age ,2),data=Wage) > fit.3=lm(wage ∼poly(age ,3),data=Wage) > fit.4=lm(wage ∼poly(age ,4),data=Wage) > fit.5=lm(wage ∼poly(age ,5),data=Wage) > anova(fit.1,fit.2,fit.3,fit.4,fit.5) Analysis of Variance Table Model 1: wage ∼age Model 2: wage ∼poly(age, 2) Model 3: wage ∼poly(age, 3) Model 4: wage ∼poly(age, 4) Model 5: wage ∼poly(age, 5) Res.Df RSS Df Sum of Sq F Pr(>F) 1 2998 5022216 2 2997 4793430 1 228786 143.59 <2e-16 *** 3 2996 4777674 1 15756 9.89 0.0017 ** 4 2995 4771604 1 6070 3.81 0.0510 . 5 2994 4770322 1 1283 0.80 0.3697 --- Signif. codes: 0 ’***’ 0.001 ’**’ 0.01 ’*’ 0.05 ’.’ 0.1 ’ ’ 1 The p-value comparing the linear Model 1to the quadratic Model 2is essentially zero ( <10−15), indicating that a linear ﬁt is not suﬃcient. Sim- ilarly the p-value comparing the quadratic Model 2to the cubic Model 3 is very low (0 .0017), so the quadratic ﬁt is also insuﬃcient. The p-value comparing the cubic and degree-4 polynomials, Model 3and Model 4,i sa p - proximately 5% while the degree-5 polynomial Model 5seems unnecessary because its p-value is 0 .37. Hence, either a cubic or a quartic polynomial appear to provide a reasonable ﬁt to the data, but lower- or higher-order models are not justiﬁed. Inthiscase,insteadofusingthe anova()function,wecouldhaveobtained these p-values more succinctly by exploiting the fact that poly()creates orthogonal polynomials. > coef(summary(fit.5)) Estimate Std. Error t value Pr(>|t|) (Intercept ) 111.70 0.7288 153.2780 0.000e+00 poly(age, 5)1 447.07 39.9161 11.2002 1.491e-28 poly(age, 5)2 -478.32 39.9161 -11.9830 2.368e-32 poly(age, 5)3 125.52 39.9161 3.1446 1.679e-03 7.8 Lab: Non-linear Modeling 291 poly(age, 5)4 -77.91 39.9161 - 1.9519 5.105e-02 poly(age, 5)5 -35.81 39.9161 - 0.8972 3.697e-01 Notice that the p-values are the same, and in fact the square of the t-statistics are equal to the F-statistics from the anova() function; for example: > (-11.983)^2 [1] 143.6 However, the ANOVA method works whether or not we used orthogonal polynomials; it also works when we have other terms in the model as well. For example, we can use anova()to compare these three models: > fit.1=lm(wage ∼education +age,data=Wage) > fit.2=lm(wage ∼education +poly(age ,2),data=Wage) > fit.3=lm(wage ∼education +poly(age ,3),data=Wage) > anova(fit.1,fit.2,fit.3) As an alternativeto using hypothesis tests and ANOVA, we couldchoose the polynomial degree using cross-validation, as discussed in Chapter 5. Next we considerthe task ofpredicting whether an individual earnsmore than $250 ,000 per year. We proceed much as before, except that ﬁrst we create the appropriate response vector, and then apply the glm()function using family=\"binomial\" in order to ﬁt a polynomial logistic regression model. > fit=glm(I(wage >250) ∼poly(age ,4),data= Wage, family=binomial) Note that we again use the wrapper I()to create this binary response variable on the ﬂy. The expression wage>250 evaluates to a logical variable containing TRUEsa n d FALSEs, which glm()coerces to binary by setting the TRUEst o1a n dt h e FALSEst o0 . Once again, we make predictions using the predict() function. > preds=predict(fit,newdata=list(age=age.grid),se=T) However, calculating the conﬁdence intervals is slightly more involved than in the linear regression case. The default prediction type for a glm()model istype=\"link\" , which is what we use here. This means we get predictions for thelogit: that is, we have ﬁt a model of the form log/parenleftbiggPr(Y=1|X) 1−Pr(Y=1|X)/parenrightbigg =Xβ, andthepredictions givenareofthe form Xˆβ.Thestandarderrorsgivenare also of this form. In order to obtain conﬁdence intervals for Pr( Y=1|X), we use the transformation Pr(Y=1|X)=exp(Xβ) 1+exp(Xβ). 292 7. Moving Beyond Linearity > pfit=exp(preds$fit )/(1+exp(preds$fit )) > se.bands.logit = cbind(preds$fit +2*preds$se.fit, preds$fit -2* preds$se.fit) > se.bands = exp(se.bands.logit)/(1+exp(se.bands.logit)) Note that we could have directly computed the probabilities by selecting thetype=\"response\" option in the predict() function. > preds=predict(fit,newdata=list(age=age.grid),type=\"response\", se=T) However, the corresponding conﬁdence intervals would not have been sen- sible because we would end up with negative probabilities! Finally, the right-hand plot from Figure 7.1 was made as follows: > plot(age,I( wage >250),xlim=agelims ,type=\"n\",ylim=c(0,.2)) > points(jitter(age), I((wage >250)/5),cex=.5,pch =\"|\", col=\"darkgrey \") > lines(age.grid,pfit,lwd=2, col=\"blue\") > matlines(age.grid,se. bands ,lwd=1,col=\" blue\",lty=3) We have drawn the agevalues corresponding to the observations with wage values above 250 as gray marks on the top of the plot, and those with wage values below 250 are shown as gray marks on the bottom of the plot. We used the jitter() function to jitter the agevalues a bit sothat observationsjitter()with the same agevalue do not cover each other up. This is often called a rug plot.rug plotIn order to ﬁt a step function, as discussed in Section 7.2, we use the cut()function.cut() > table(cut(age ,4)) (17.9,33.5] (33.5,49] (49,64.5] (64.5,80.1] 750 1399 779 72 > fit=lm(wage ∼cut(age ,4),data=Wage) > coef(summary(fit)) Estimate Std. Error t value Pr(>|t|) (Intercept ) 94.16 1.48 63.79 0.00e+00 cut(age, 4)(33.5,49] 24.05 1.83 13.15 1.98e-38 cut(age, 4)(49,64.5] 23.66 2.07 11.44 1.04e-29 cut(age, 4)(64.5,80.1] 7.64 4.99 1.53 1.26e-01 Here cut()automatically picked the cutpoints at 33 .5, 49, and 64 .5y e a r s of age. We could also have speciﬁed our own cutpoints directly using the breaksoption. The function cut()returns an ordered categorical variable; thelm()function then creates a set of dummy variables for use in the re- gression. The age<33.5 category is left out, so the intercept coeﬃcient of $94,160 can be interpreted as the average salary for those under 33 .5y e a r s of age, and the other coeﬃcients can b e interpreted as the average addi- tional salary for those in the other age groups. We can produce predictions and plots just as we did in the case of the polynomial ﬁt. 7.8 Lab: Non-linear Modeling 293 7.8.2 Splines In order to ﬁt regression splines in R,w eu s et h e splineslibrary. In Section 7.4,we sawthatregressionsplines canbe ﬁtby constructinganappropriate matrix of basis functions. The bs()function generates the entire matrix ofbs()basis functions for splines with the speciﬁed set of knots. By default, cubic splines are produced. Fitting wagetoageusing a regression spline is simple: > library(splines) > fit=lm(wage ∼bs(age,knots=c(25,40,60) ),data=Wage) > pred=predict(fit,newdata=list(age=age.grid),se=T) > plot(age,wage,col=\"gray\") > lines(age.grid,pred$fit,lwd=2) > lines(age.grid,pred$fit +2*pred$se ,lty=\"dashed\") > lines(age.grid,pred$fit -2*pred$se ,lty=\"dashed\") Here we have prespeciﬁed knots at ages 25, 40, and 60. This produces a spline with six basis functions. (Recall that a cubic spline with three knots has seven degrees of freedom; these degrees of freedom are used up by an intercept, plus six basis functions.) We could also use the dfoption to produce a spline with knots at uniform quantiles of the data. > dim(bs(age,knots=c(25,40,60))) [1] 3000 6 > dim(bs(age,df=6)) [1] 3000 6 > attr(bs(age,df=6),\"knots\") 25% 50% 75% 33.8 42.0 51.0 In this case Rchooses knots at ages 33 .8,42.0, and 51 .0, which correspond to the 25th, 50th, and 75th percentiles of age. The function bs()also has adegreeargument, so we can ﬁt splines of any degree, rather than the default degree of 3 (which yields a cubic spline). In order to instead ﬁt a natural spline, we use the ns()function. Herens()we ﬁt a natural spline with four degrees of freedom. > fit2=lm(wage ∼ns(age,df=4),data=Wage) > pred2=predict(fit2,newdata=list(age=age.grid),se=T) > lines(age.grid, pred2$fit ,col=\"red\",lwd=2) As with the bs()function, we could instead specify the knots directly using theknotsoption. In order to ﬁt a smoothing spline, we use the smooth.spline() function.smooth. spline() Figure 7.8 was produced with the following code: > plot(age,wage,xlim=agelims ,cex=.5,col=\"darkgrey \") > title(\"Smoothing Spline\") > fit=smooth.spline(age,wage,df=16) > fit2=smooth.spline(age,wage,cv=TRUE) > fit2$df [1] 6.8 > lines(fit,col=\"red\",lwd=2) 294 7. Moving Beyond Linearity > lines(fit2,col=\"blue\",lwd=2) > legend(\"topright\",legend=c(\"16 DF\" ,\"6.8 DF\"), col=c(\"red\",\"blue\"),lty=1,lwd=2,cex=.8) Notice that in the ﬁrst call to smooth.spline() , we speciﬁed df=16.T h e function then determineswhich value of λleadsto 16degreesoffreedom.In the second call to smooth.spline() , we select the smoothness level by cross- validation; this results in a value of λthat yields 6.8 degrees of freedom. In order to perform local regression, we use the loess()function.loess() > plot(age,wage,xlim=agelims ,cex=.5,col=\"darkgrey \") > title(\"Local Regression \") > fit=loess(wage ∼age,span=.2,data=Wage) > fit2=loess(wage ∼age,span=.5,data=Wage) > lines(age.grid,predict(fit,data.frame(age=age.grid)), col=\"red\",lwd=2) > lines(age.grid,predict(fit2,data.frame(age=age.grid)), col=\"blue\",lwd=2) > legend(\"topright\",legend=c(\"Span=0.2\",\" Span=0.5\"), col=c(\"red\",\"blue\"),lty=1,lwd=2,cex=.8) Here we have performed local linear regression using spans of 0 .2a n d0.5: that is, eachneighborhoodconsists of20% or 50% ofthe observations.The larger the span, the smoother the ﬁt. The locfitlibrary can also be used for ﬁtting local regression models in R. 7.8.3 GAMs We now ﬁt a GAM to predict wageusing natural spline functions of year and age, treating education as a qualitative predictor, as in (7.16). Since this is just a big linear regression model using an appropriate choice of basis functions, we can simply do this using the lm()function. > gam1=lm(wage ∼ns(year ,4)+ns(age ,5)+education ,data=Wage) We now ﬁt the model (7.16) using smoothing splines rather than natural splines. In order to ﬁt more general sorts of GAMs, using smoothing splines or other components that cannot be expressed in terms of basis functions and then ﬁt using least squares regression, we will need to use the gam library in R. The s()function, which is part of the gamlibrary,is used to indicate thats()we would like to use a smoothing spline. We specify that the function of yearshould have 4 degrees of freedom, and that the function of agewill have 5 degrees of freedom. Since education is qualitative, we leave it as is, and it is converted into four dummy variables. We use the gam()function ingam()order to ﬁt a GAM using these components. All of the terms in (7.16) are ﬁt simultaneously, taking each other into account to explain the response. > library(gam) > gam.m3=gam(wage ∼s(year ,4)+s(age ,5)+education ,data=Wage) 7.8 Lab: Non-linear Modeling 295 In order to produce Figure 7.12, we simply call the plot()function: > par(mfrow=c(1,3)) > plot(gam.m3, se=TRUE,col=\" blue\") The generic plot()function recognizes that gam2is an object of class gam, andinvokestheappropriate plot.gam() method. Conveniently,eventhoughplot.gam()gam1is not of class gambut rather of class lm,w ec a n stilluseplot.gam() on it. Figure 7.11 was produced using the following expression: > plot.gam(gam1, se=TRUE, col=\"red\") Notice here we had to use plot.gam() rather than the generic plot() function. In these plots, the function of yearlooks rather linear. We can perform a series of ANOVA tests in order to determine which of these three models is best: a GAM that excludes year(M1), a GAM that uses a linear function ofyear(M2), or a GAM that uses a spline function of year(M3). > gam.m1=gam(wage ∼s(age ,5)+education ,data=Wage) > gam.m2=gam(wage ∼year+s(age ,5)+education ,data=Wage) > anova(gam.m1,gam.m2,gam.m3,test=\"F\") Analysis of Deviance Table Model 1: wage ∼s(age, 5) + education Model 2: wage ∼year + s(age, 5) + education Model 3: wage ∼s(year, 4) + s(age, 5) + education Resid. Df Resid. Dev Df Deviance F Pr(>F) 1 2990 3711730 2 2989 3693841 1 17889 14.5 0.00014 *** 3 2986 3689770 3 4071 1.1 0.34857 --- Signif. codes: 0 ’***’ 0.001 ’**’ 0.01 ’*’ 0.05 ’.’ 0.1 ’ ’ 1 We ﬁnd that there is compelling evidence that a GAM with a linear func- tion of yearis better than a GAM that does not include yearat all (p-value=0.00014). However, there is no evidence that a non-linear func- tionof yearisneeded(p-value=0.349).Inotherwords,basedonthe results of this ANOVA, M2is preferred. The summary() function produces a summary of the gam ﬁt. > summary(gam.m3) Call: gam(formula = wage ∼s(year, 4) + s(age, 5) + education , data = Wage) Deviance Residuals : Min 1Q Median 3Q Max -119.43 -19.70 -3.33 14.17 213.48 (Dispersion Parameter for gaussian family taken to be 1236) Null Deviance: 5222086 on 2999 degrees of freedom Residual Deviance: 3689770 on 2986 degrees of freedom 296 7. Moving Beyond Linearity AIC: 29888 Number of Local Scoring Iterations : 2 DF for Terms and F-values for Nonparametric Effects Df Npar Df Npar F Pr(F) (Intercept ) 1 s(year, 4) 1 3 1.1 0.35 s(age, 5) 1 4 32.4 <2e-16 *** education 4 --- Signif. codes: 0 ’***’ 0.001 ’**’ 0.01 ’*’ 0.05 ’.’ 0.1 ’ ’ 1 The p-values for yearand agecorrespond to a null hypothesis of a linear relationship versus the alternative of a non-linear relationship. The large p-value for yearreinforces our conclusion from the ANOVA test that a lin- ear function is adequate for this term. However,there is very clear evidence that a non-linear term is required for age. We can make predictions from gamobjects, just like from lmobjects, using the predict() method for the class gam.H e r ew em a k ep r e d i c t i o n so n the training set. > preds=predict(gam.m2,newdata=Wage) We can also use local regression ﬁts as building blocks in a GAM, using thelo()function.lo() > gam.lo=gam(wage ∼s(year,df=4)+lo(age,span=0.7)+education , data=Wage) > plot.gam(gam.lo, se=TRUE , col=\" green\") Here we have used local regression for the ageterm, with a span of 0 .7. We can also use the lo()function to create interactions before calling the gam()function. For example, > gam.lo.i=gam(wage ∼lo(year,age, span=0.5)+education , data=Wage) ﬁts a two-term model, in which the ﬁrst term is an interaction between yearand age, ﬁt by a local regression surface. We can plot the resulting two-dimensional surface if we ﬁrst install the akimapackage. > library(akima) > plot(gam.lo.i) In order to ﬁt a logistic regressionGAM, we once again use the I()func- tion in constructing the binary response variable, and set family=binomial . > gam.lr=gam(I(wage >250) ∼year+s(age,df=5)+education , family=binomial ,data=Wage) > par(mfrow=c(1,3)) > plot(gam.lr,se=T,col=\"green\") 7.9 Exercises 297 It is easy to see that there are no high earners in the <HScategory: > table(education ,I(wage >250)) education FALSE TRUE 1. < HS Grad 268 0 2. HS Grad 966 5 3. Some College 643 7 4. College Grad 663 22 5. Advanced Degree 381 45 Hence, we ﬁt a logistic regression GAM using all but this category. This provides more sensible results. > gam.lr.s=gam(I(wage >250) ∼year+s(age,df=5)+education ,family= binomial ,data= Wage, subset=(education !=\"1. < HS Grad\")) > plot(gam.lr.s,se=T,col=\"green\") 7.9 Exercises Conceptual 1. It was mentioned in the chapter that a cubic regression spline with one knot at ξcan be obtained using a basis of the form x,x2,x3, (x−ξ)3 +,w h e r e( x−ξ)3 +=(x−ξ)3ifx>ξand equals 0 otherwise. We will now show that a function of the form f(x)=β0+β1x+β2x2+β3x3+β4(x−ξ)3 + isindeedacubicregressionspline,regardlessofthevaluesof β0,β1,β2, β3,β4. (a) Find a cubic polynomial f1(x)=a1+b1x+c1x2+d1x3 such that f(x)=f1(x) for all x≤ξ.E x p r e s s a1,b1,c1,d1in terms of β0,β1,β2,β3,β4. (b) Find a cubic polynomial f2(x)=a2+b2x+c2x2+d2x3 such that f(x)=f2(x) for all x>ξ.E x p r e s s a2,b2,c2,d2in terms of β0,β1,β2,β3,β4. We have now established that f(x)i s a piecewise polynomial. (c) Show that f1(ξ)=f2(ξ). That is, f(x) is continuous at ξ. (d) Show that f/prime 1(ξ)=f/prime 2(ξ). That is, f/prime(x) is continuous at ξ. 298 7. Moving Beyond Linearity (e) Show that f/prime/prime 1(ξ)=f/prime/prime 2(ξ). That is, f/prime/prime(x) is continuous at ξ. Therefore, f(x) is indeed a cubic spline. Hint: Parts (d) and (e) of this problem require knowledge of single- variable calculus. As a reminder, given a cubic polynomial f1(x)=a1+b1x+c1x2+d1x3, the ﬁrst derivative takes the form f/prime 1(x)=b1+2c1x+3d1x2 and the second derivative takes the form f/prime/prime 1(x)=2c1+6d1x. 2. Suppose that a curve ˆ gis computed to smoothly ﬁt a set of npoints using the following formula: ˆg=a r gm i n g/parenleftBiggn/summationdisplay i=1(yi−g(xi))2+λ/integraldisplay/bracketleftBig g(m)(x)/bracketrightBig2 dx/parenrightBigg , whereg(m)represents the mth derivative of g(andg(0)=g). Provide example sketches of ˆ gin each of the following scenarios. (a)λ=∞,m=0 . (b)λ=∞,m=1 . (c)λ=∞,m=2 . (d)λ=∞,m=3 . (e)λ=0,m=3 . 3. Suppose we ﬁt a curve with basis functions b1(X)=X,b2(X)= (X−1)2I(X≥1). (Note that I(X≥1) equals 1 for X≥1a n d0 otherwise.) We ﬁt the linear regression model Y=β0+β1b1(X)+β2b2(X)+/epsilon1, and obtain coeﬃcient estimates ˆβ0=1,ˆβ1=1,ˆβ2=−2. Sketch the estimated curve between X=−2a n dX= 2. Note the intercepts, slopes, and other relevant information. 4. Suppose we ﬁt a curve with basis functions b1(X)=I(0≤X≤2)− (X−1)I(1≤X≤2),b2(X)=(X−3)I(3≤X≤4)+I(4<X≤5). We ﬁt the linear regression model Y=β0+β1b1(X)+β2b2(X)+/epsilon1, and obtain coeﬃcient estimates ˆβ0=1,ˆβ1=1,ˆβ2=3 .S k e t c ht h e estimated curve between X=−2a n dX= 2. Note the intercepts, slopes, and other relevant information. 7.9 Exercises 299 5. Consider two curves, ˆ g1and ˆg2, deﬁned by ˆg1=a r gm i n g/parenleftBiggn/summationdisplay i=1(yi−g(xi))2+λ/integraldisplay/bracketleftBig g(3)(x)/bracketrightBig2 dx/parenrightBigg , ˆg2=a r gm i n g/parenleftBiggn/summationdisplay i=1(yi−g(xi))2+λ/integraldisplay/bracketleftBig g(4)(x)/bracketrightBig2 dx/parenrightBigg , whereg(m)represents the mth derivative of g. (a) Asλ→∞, will ˆg1or ˆg2have the smaller training RSS? (b) Asλ→∞, will ˆg1or ˆg2have the smaller test RSS? (c) Forλ= 0, will ˆ g1or ˆg2have the smaller training and test RSS? Applied 6. In this exercise, you will further analyze the Wagedata set considered throughout this chapter. (a) Perform polynomial regression to predict wageusing age.U s e cross-validation to sel ect the optimal degree dfor the polyno- mial. What degree was chosen, and how does this compare to the results of hypothesis testing using ANOVA? Make a plot of the resulting polynomial ﬁt to the data. (b) Fit a step function to predict wageusing age, and perform cross- validation to choose the optimal number of cuts. Make a plot of the ﬁt obtained. 7. The Wagedata set contains a number of other features not explored in this chapter, such as marital status ( maritl), job class ( jobclass ), and others. Explore the relation ships between some of these other predictors and wage, and use non-linear ﬁtting techniques in order to ﬁt ﬂexible models to the data. Create plots of the results obtained, and write a summary of your ﬁndings. 8. Fit some of the non-linear models investigated in this chapter to the Autodata set. Is there evidence for non-linear relationships in this data set? Create some informative plots to justify your answer. 9. This question uses the variables dis(the weighted mean of distances to ﬁve Boston employment centers) and nox(nitrogen oxides concen- tration in parts per 10 million) from the Bostondata. We will treat disas the predictor and noxas the response. (a) Use the poly()function to ﬁt a cubic polynomial regression to predict noxusing dis. Report the regression output, and plot the resulting data and polynomial ﬁts. 300 7. Moving Beyond Linearity (b) Plot the polynomial ﬁts for a range of diﬀerent polynomial degrees (say, from 1 to 10), and report the associated residual sum of squares. (c) Perform cross-validation or a nother approach to select the opti- mal degree for the polynomial, and explain your results. (d) Use the bs()function to ﬁt a regression spline to predict nox using dis. Report the output for the ﬁt using four degrees of freedom. How did you choose the knots? Plot the resulting ﬁt. (e) Now ﬁt a regressionspline for a range of degrees of freedom, and plot the resulting ﬁts and report the resulting RSS. Describe the results obtained. (f) Perform cross-validation or a nother approach in order to select the best degrees of freedom for a regression spline on this data. Describe your results. 10. This question relates to the Collegedata set. (a) Splitthedataintoatrainingsetandatestset.Usingout-of-state tuition as the response and the other variables as the predictors, perform forward stepwise selection on the training set in order to identify a satisfactory model that uses just a subset of the predictors. (b) Fit a GAM on the training data, using out-of-state tuition as the response and the features selected in the previous step as the predictors. Plot the results, and explain your ﬁndings. (c) Evaluate the model obtained on the test set, and explain the results obtained. (d) For which variables, if any, i s there evidence of a non-linear relationship with the response? 11. In Section 7.7, it was mentioned that GAMs are generally ﬁt using abackﬁtting approach. The idea behind backﬁtting is actually quite simple. We will now explore backﬁtting in the context of multiple linear regression. Suppose that we would like to perform multiple linear regression, but we do not have software to do so. Instead, we only have software to perform simple linear regression. Therefore, we take the following iterative approach: we repeatedly hold all but one coeﬃcient esti- mate ﬁxed at its current value, and update only that coeﬃcient estimateusingasimplelinearregre ssion.Theprocessiscontinuedun- tilconvergence —that is, until the coeﬃcien t estimates stop changing. We now try this out on a toy example. 7.9 Exercises 301 (a) Generate a response Yand two predictors X1andX2, with n= 100. (b) Initialize ˆβ1to take on a value of your choice. It does not matter what value you choose. (c) Keeping ˆβ1ﬁxed, ﬁt the model Y−ˆβ1X1=β0+β2X2+/epsilon1. You can do this as follows: > a=y-beta1*x1 > beta2=lm(a ∼x2)$coef[2] (d) Keeping ˆβ2ﬁxed, ﬁt the model Y−ˆβ2X2=β0+β1X1+/epsilon1. You can do this as follows: > a=y-beta2*x2 > beta1=lm(a ∼x1)$coef[2] (e) Write a for loop to repeat (c) and (d) 1,000 times. Report the estimates of ˆβ0,ˆβ1,a n dˆβ2at each iteration of the for loop. Create a plot in which each of th ese values is displayed, with ˆβ0, ˆβ1,a n dˆβ2each shown in a diﬀerent color. (f) Compare your answer in (e) to the results of simply performing multiple linear regression to predict YusingX1andX2.U s e theabline() function to overlay those multiple linear regression coeﬃcient estimates on th e plot obtained in (e). (g) On this data set, how many backﬁtting iterations were required in order to obtain a “good” approximation to the multiple re- gression coeﬃci ent estimates? 12. This problem is a continuation of the previous exercise. In a toy example with p= 100, show that one can approximate the multiple linearregressioncoeﬃci entestimatesbyrepeat edlyperformingsimple linear regression in a backﬁtting procedure. How many backﬁtting iterations are required in order to obtain a “good” approximation to the multiple regression coeﬃcient e stimates? Create a plot to justify your answer. 8 Tree-Based Methods In this chapter, we describe tree-based methods for regression and classiﬁcation. These involve stratifying orsegmenting the predictor space into a number of simple regions. In order to make a prediction for a given observation, we typically use the mean or the mode of the training observa- tions in the region to which it belongs. Since the set of splitting rules used to segment the predictor space can b e summarized in a tree, these types of approaches are known as decision tree methods.decision treeTree-based methods are simple and useful for interpretation. However, they typically are not competitive with the best supervised learning ap- proaches, such as those seen in Chapters 6 and 7, in terms of prediction accuracy. Hence in this chapter we also introduce bagging,random forests , andboosting. Each of these approaches involves producing multiple trees which are then combined to yield a si ngle consensus prediction. We will see that combining a large number of trees can often result in dramatic improvements in prediction accuracy , at the expense of some loss in inter- pretation. 8.1 The Basics of Decision Trees Decisiontreescanbe appliedtoboth reg ressionandclassiﬁcationproblems. We ﬁrst consider regression problems, and then move on to classiﬁcation. G. James et al., An Introduction to Statistical Learning: with Applications in R , Springer Texts in Statistics 103, DOI 10.1007/978-1-4614-7138-7 8, ©Springer Science+Business Media New York 2013303 304 8. Tree-Based Methods |Y ears < 4.5 Hits < 117.5 5.11 6.00 6.74 FIGURE 8.1. For the Hitters data, a regression tree for predicting the log salary of a baseball player, based on the number of years that he has played in the major leagues and the number of hits that he made in the previous year. At a given internal node, the label (of the form Xj<tk) indicates the left-hand branch emanating from that split, and the right-hand branch corresponds to Xj≥tk. For instance, the split at the top of the tree results in two large branches. The left-hand branch corresponds to Years<4.5 , and the right-hand branch corresponds toYears>=4.5 . The tree has two internal nodes and three terminal nodes, or leaves. The number in each leaf is the mean of the response for the observations that fall there. 8.1.1 Regression Trees In order to motivate regression trees , we begin with a simple example.regression tree Predicting Baseball Players’ Salaries Using Regression Trees We use the Hittersdata set to predict a baseball player’s Salarybased on Years(the number of years that he has played in the major leagues) and Hits(thenumberofhitsthathemadeinthepreviousyear).Weﬁrstremove observations that are missing Salaryvalues, and log-transform Salaryso that its distribution has more of a typical bell-shape. (Recall that Salary is measured in thousands of dollars.) Figure 8.1 shows a regression tree ﬁt to this data. It consists of a series of splitting rules, starting at the top of the tree. The top split assigns observations having Years<4.5 to the left branch.1The predicted salary 1Both YearsandHitsare integers in these data; the tree() function in Rlabels the splits at the midpoint between two adjacent values. 8.1 The Basics of Decision Trees 305 Y earsHits 1117.5238 14 . 5 2 4R1R3 R2 FIGURE 8.2. The three-region partition for the Hitters data set from the regression tree illustrated in Figure 8.1. for these players is given by the mean response value for the players in the data set with Years<4.5 . For such players, the mean log salary is 5 .107, and so we make a prediction of e5.107thousands of dollars,i.e. $165,174,for these players.Playerswith Years>=4.5 areassignedto the rightbranch,and then that group is further subdivided by Hits. Overall, the tree stratiﬁes or segments the players into three reg ions of predictor space: players who have playedfor four or fewer years,playerswho have playedfor ﬁve or more years and who made fewer than 118 hits last year, and players who have playedforﬁveormoreyearsandwhomadeatleast118hitslastyear.These three regionscan be written as R1={X|Years<4.5 },R2={X|Years>=4.5 , Hits<117.5 },a n dR3={X|Years>=4.5 ,Hits>=117.5 }. Figure 8.2 illustrates the regions as a function of Yearsand Hits. The predicted salaries for these three groups are $1,000 ×e5.107=$165,174, $1,000 ×e5.999=$402,834, and $1,000×e6.740=$845,346 respectively. In keeping with the treeanalogy, the regions R1,R2,a n dR3are known asterminal nodes orleavesofthetree.AsisthecaseforFigure8.1,decisionterminal node leaftrees are typically drawn upside down , in the sense that the leaves are at the bottom of the tree. The points along the tree where the predictor space is split are referred to as internal nodes . In Figure 8.1, the two internalinternal nodenodes are indicated by the text Years<4.5 and Hits<117.5 . We refer to the segments of the trees that connect the nodes as branches.branchWe might interpret the regression tree displayed in Figure 8.1 as follows: Yearsis the most important factor in determining Salary, and players with less experience earn lower salaries t han more experienced players. Given that a player is less experienced, the number of hits that he made in the previous year seems to play little role in his salary. But among players who 306 8. Tree-Based Methods have been in the major leagues for ﬁve or more years, the number of hits made in the previous year does aﬀect salary, and players who made more hits last year tend to have higher salaries. The regression tree shown in Figure 8.1 is likely an over-simpliﬁca tion of the true relationship between Hits,Years,a n d Salary. However, it has advantages over other types of regression models (such as those seen in Chapters 3 and 6): it is easier to interpret, and has a nice graphical representation. Prediction via Stratiﬁcation of the Feature Space We now discuss the processof building a regressiontree.Roughly speaking, there are two steps. 1. We divide the predictor space—that is, the set of possible values for X1,X2,...,X p—intoJdistinct and non-overlapping regions, R1,R2,...,R J. 2. For every observation that falls into the region Rj,w em a k et h es a m e prediction, which is simply the mean of the response values for the training observations in Rj. For instance, suppose that in Step 1 we obtain two regions, R1andR2, and that the response mean of the training observations in the ﬁrst region is 10, while the response mean of the training observations in the second region is 20. Then for a given observation X=x,i fx∈R1we will predict a value of 10, and if x∈R2we will predict a value of 20. We now elaborate on Step 1 above. How do we construct the regions R1,...,R J? In theory, the regions could have any shape. However, we choose to divide the predictor space into high-dimensional rectangles, or boxes, for simplicity and for ease of interpretation of the resulting predic- tive model. The goal is to ﬁnd boxes R1,...,R Jthat minimize the RSS, given by J/summationdisplay j=1/summationdisplay i∈Rj(yi−ˆyRj)2, (8.1) where ˆyRjis the mean response for the training observations within the jth box. Unfortunately, it is computationally infeasible to consider every possible partition of the feature space into Jboxes. For this reason, we take atop-down ,greedyapproachthatisknownas recursive binary splitting .Therecursive binary splittingapproachis top-down becauseitbeginsatthetopofthetree(atwhichpoint all observations belong to a single region) and then successively splits the predictor space; each split is indicated via two new branches further down on the tree. It is greedybecause at each step of the tree-building process, thebestsplit is made at that particular step, rather than looking ahead and picking a split that will lead to a better tree in some future step. 8.1 The Basics of Decision Trees 307 In order to perform recursive binar y splitting, we ﬁrst select the pre- dictorXjand the cutpoint ssuch that splitting the predictor space into the regions {X|Xj<s}and{X|Xj≥s}leads to the greatest possible reduction in RSS. (The notation {X|Xj<s}meansthe region of predictor space in which Xjtakes on a value less than s.) That is, we consider all predictors X1,...,X p, and all possible values of the cutpoint sfor each of the predictors, and then choose the predictor and cutpoint such that the resulting tree has the lowest RSS. In greater detail, for any jands,w e deﬁne the pair of half-planes R1(j,s)={X|Xj<s}andR2(j,s)={X|Xj≥s},(8.2) and we seek the value of jandsthat minimize the equation /summationdisplay i:xi∈R1(j,s)(yi−ˆyR1)2+/summationdisplay i:xi∈R2(j,s)(yi−ˆyR2)2, (8.3) where ˆyR1is the mean response for the training observations in R1(j,s), and ˆyR2is the mean response for the training observations in R2(j,s). Finding the values of jandsthat minimize (8.3) can be done quite quickly, especially when the number of features pis not too large. Next, we repeat the process, looking for the best predictor and best cutpoint in order to split the data further so as to minimize the RSS within each of the resulting regions. However, this time, instead of splitting the entire predictor space, we split one of t he two previously identiﬁed regions. Wenowhavethreeregions.Again,welooktosplitoneofthesethreeregions further, so as to minimize the RSS. The process continues until a stopping criterion is reached; for instance, we may continue until no region contains more than ﬁve observations. Once the regions R1,...,R Jhave been created, we predict the response for a given test observation using the mean of the training observations in the region to which that test observation belongs. A ﬁve-region example of this approach is shown in Figure 8.3. Tree Pruning The process described above may produce good predictions on the training set, but is likely to overﬁt the data, leading to poor test set performance. This is because the resulting tree might be too complex. A smaller tree with fewer splits (that is, fewer regions R1,...,R J) might lead to lower variance and better interpretation at the cost of a little bias. One possible alternative to the process described above is to build the tree only so long as the decrease in the RSS due to each sp lit exceeds some (high) threshold. This strategy will result in smaller trees, but is too short-sighted since a seemingly worthless split early on in the tree might be followed by a very good split—that is, a split that leads to a large reduction in RSS later on. 308 8. Tree-Based Methods |t1t2 t3t4 R1R1 R2R2 R3R3 R4R4 R5R5 X1X1 X1 X2X2X2 X1≤t1 X2≤t2 X1≤t3 X2≤t4 FIGURE 8.3. Top Left: A partition of two-dimensional feature space that could not result from recursive binary splitting. Top Right: The output of recursive binary splitting on a two-dimensional example. Bottom Left: A tree corresponding to the partition in the top right panel. Bottom Right: A perspective plot of the prediction surface corresponding to that tree. Therefore, a better strategy is to grow a very large tree T0,a n dt h e n pruneit back in order to obtain a subtree. How do we determine the bestprune subtree way to prune the tree? Intuitively, our goal is to select a subtree that leads to the lowest test error rate. Given a subtree, we can estimate its test error using cross-validation or the validation set approach. However, estimatingthe cross-validationerrorforeverypossiblesubtreewouldbe too cumbersome, since there is an extreme ly large number of possible subtrees. Instead, we need a way to select a small set of subtrees for consideration. Cost complexity pruning —also known as weakest link pruning —gives uscost complexity pruning weakest link pruninga way to do just this. Rather than considering every possible subtree, we consider a sequence of trees indexed by a nonnegative tuning parameter α. 8.1 The Basics of Decision Trees 309 Algorithm 8.1 Building a Regression Tree 1. Use recursive binary splitting to grow a large tree on the training data, stopping only when each terminal node has fewer than some minimum number of observations. 2. Apply cost complexity pruning to the large tree in order to obtain a sequence of best subtrees, as a function of α. 3. Use K-fold cross-validation to choose α. That is, divide the training observations into Kfolds. For each k=1,...,K: (a) Repeat Steps 1 and 2 on all but the kth fold of the training data. (b) Evaluate the mean squared prediction error on the data in the left-outkth fold, as a function of α. Average the results for each value of α, and pick αto minimize the average error. 4. Return the subtree from Step 2 that corresponds to the chosen value ofα. For each value of αthere corresponds a subtree T⊂T0such that |T|/summationdisplay m=1/summationdisplay i:xi∈Rm(yi−ˆyRm)2+α|T| (8.4) is as small as possible. Here |T|indicates the number of terminal nodes of the tree T,Rmis the rectangle (i.e. the subs et of predictor space) cor- responding to the mth terminal node, and ˆ yRmis the predicted response associated with Rm—that is, the mean of the training observations in Rm. The tuning parameter αcontrols a trade-oﬀ between the subtree’s com- plexity and its ﬁt to the training data. When α= 0, then the subtree T will simply equal T0, because then (8.4) just measures the training error. However, as αincreases, there is a price t o pay for having a tree with many terminal nodes, and so the quantity (8.4) will tend to be minimized for a smaller subtree. Equation 8.4 is reminiscent of the lasso (6.7) from Chapter 6, in which a similar formulation was used in order to control the complexity of a linear model. It turns out that as we increase αfrom zero in (8.4), branches get pruned from the tree in a nested and predictable fashion, so obtaining the whole sequence of subtrees as a function of αis easy. We can select a value of αusing a validation set or using cross-validation. We then return to the full data set and obtain the subtree corresponding to α. This process is summarized in Algorithm 8.1. 310 8. Tree-Based Methods |Y ears < 4.5 RBI < 60.5 Putouts < 82 Y ears < 3.5Y ears < 3.5Hits < 117.5 Walks < 43.5 Runs < 47.5Walks < 52.5 RBI < 80.5 Years < 6.55.487 6.4076.5494.622 5.1835.394 6.189 6.015 5.571 6.459 7.0077.289 FIGURE 8.4. Regression tree analysis for the Hitters data. The unpruned tree that results from top-down greedy splitting on the training data is shown. Figures 8.4 and 8.5 display the results of ﬁtting and pruning a regression tree on the Hittersdata, using nine of the features. First, we randomly divided the data set in half, yielding 132 observations in the training set and 131 observations in the test set. We then built a large regression tree on the training data and varied αin (8.4) in order to cr eate subtrees with diﬀerent numbers of terminal nodes. F inally, we performed six-fold cross- validation in order to estimate the cross-validated MSE of the trees as a function of α. (We chose to perform six-fold cross-validation because 132 is an exact multiple of six.) The unpruned regression tree is shown in Figure 8.4. The green curve in Figure 8.5 shows the CV error as a function of the number of leaves,2while the orange curve indicates the test error. Also shown are standard error bars around the estimated errors. For reference, the training error cur ve is shown in black. The CV error is a reasonable approximation of the test error: the CV error takes on its 2Although CV error is computed as a function of α, it is convenient to display the result as a function of |T|, the number of leaves; this is based on the relationship between αand|T|in the original tree grown to all the training data. 8.1 The Basics of Decision Trees 311 2468 1 00.0 0.2 0.4 0.6 0.8 1.0 Tree SizeMean Squared ErrorTraining Cross−Validation Test FIGURE 8.5. Regression tree analysis for the Hitters data. The training, cross-validation, and test MSE are shown as a function of the number of termi- nal nodes in the pruned tree. Standard error bands are displayed. The minimum cross-validation error occurs at a tree size of three. minimum for a three-node tree, while the test error also dips down at the three-node tree (though it takes on its lowest value at the ten-node tree). The pruned tree containing three terminal nodes is shown in Figure 8.1. 8.1.2 Classiﬁcation Trees Aclassiﬁcation tree is very similar to a regression tree, except that it isclassiﬁcation tree used to predict a qualitative response rather than a quantitative one. Re- call that for a regression tree, the pre dicted response for an observation is given by the mean response of the training observations that belong to the same terminal node. In contrast, for a classiﬁcation tree, we predict that each observation belongs to the most commonly occurring class of training observations in the region to which it belongs. In interpreting the results of a classiﬁcation tree, we are often intere sted not only in the class prediction corresponding to a particular terminal node region, but also in the class proportions among the training observations that fall into that region. The task of growing a classiﬁcation tree is quite similar to the task of growing a regressiontree. Just as in th e regressionsetting, we use recursive binary splitting to grow a classiﬁcation tree. However, in the classiﬁcation setting, RSS cannot be used as a criterion for making the binary splits. A natural alternative to RSS is the classiﬁcation error rate .S i n c ew ep l a nclassiﬁcation error rate to assign an observation in a given region to the most commonly occurring classof training observations in that region, the classiﬁcation error rate is simply the fraction of the training observations in that region that do not belong to the most common class: 312 8. Tree-Based Methods E=1−max k(ˆpmk). (8.5) Here ˆpmkrepresents the proportion of training observations in the mth region that are from the kth class. However, it turns out that classiﬁcation error is not suﬃciently sensitive for tree-growing, and in practice two other measures are preferable. TheGini index is deﬁned byGini index G=K/summationdisplay k=1ˆpmk(1−ˆpmk), (8.6) a measure of total variance across the Kclasses. It is not hard to see that the Gini index takes on a small value if all of the ˆ pmk’s are close to zero or one. For this reason the Gini index is referred to as a measure of nodepurity—a small value indicates that a node contains predominantly observations from a single class. An alternative to the Gini index is cross-entropy ,g i v e nb ycross- entropy D=−K/summationdisplay k=1ˆpmklog ˆpmk. (8.7) Since 0≤ˆpmk≤1, it follows that 0 ≤−ˆpmklog ˆpmk. One can show that the cross-entropy will take on a value near zero if the ˆ pmk’s are all near zero or near one. Therefore, like the Gini index, the cross-entropy will take on a small value if the mth node is pure. In fact, it turns out that the Gini index and the cross-entropy are quite similar numerically. When building a classiﬁcation tree, either the Gini index or the cross- entropy are typically used to evaluate the quality of a particular split, since these two approaches are more sensitive to node purity than is the classiﬁcation error rate. Any of these three approaches might be used when pruning the tree, but the classiﬁcation error rate is preferable if prediction accuracy of the ﬁnal pruned tree is the goal. Figure 8.6 shows an example on the Heartdata set. These data con- tain a binary outcome HDfor 303 patients who presented with chest pain. An outcome value of Yesindicates the presence of heart disease based on an angiographictest, while Nomeans no heart disease. There are 13 predic- tors including Age,Sex,Chol(a cholesterol measurement), and other heart and lung function measurements. Cross-validation results in a tree with six terminal nodes. In our discussion thus far, we have assumed that the predictor vari- ables take on continuous values. However,decisiontrees canbe constructed even in the presence of qualitative predictor variables. For instance, in the Heartdata, some of the predictors, such as Sex,Thal(Thalium stress test), and ChestPain , are qualitative. Therefore, a split on one of these variables amounts to assigning some of the qualitative values to one branch and 8.1 The Basics of Decision Trees 313 |Thal:a Ca < 0.5 MaxHR < 161.5 RestBP < 157 Chol < 244 MaxHR < 156 MaxHR < 145.5ChestPain:bc Chol < 244 Sex < 0.5Ca < 0.5 Slope < 1.5 Age < 52 Thal:b ChestPain:aOldpeak < 1.1 RestECG < 1 NoNoYe sNo No YesNo No No YesNo No YesYes NoYes YesYes 51 01 50.0 0.1 0.2 0.3 0.4 0.5 0.6 Tree SizeErrorTraining Cross−Validation Test|Thal:a Ca < 0.5 MaxHR < 161.5 ChestPain:bcCa < 0.5 No No No YesYes Ye s FIGURE 8.6. Heartdata.Top:The unpruned tree. Bottom Left: Cross -validation error, training, and test error, for diﬀerent sizes of the pruned tree. Bottom Right: The pruned tree corresponding to the minimal cross-validation error. assigning the remaining to the other branch. In Figure 8.6, some of the in- ternal nodes correspond to splitting qualitative variables. For instance, the top internal node corresponds to splitting Thal.T h et e x t Thal:aindicates that the left-hand branch coming out of that node consists of observations with the ﬁrst value of the Thalvariable (normal), and the right-hand node consistsofthe remainingobservations (ﬁxed orreversibledefects). The text ChestPain:bc twosplitsdownthetreeontheleftindicatesthattheleft-hand branch coming out of that node consists of observations with the second and third values of the ChestPain variable, where the possible values are typical angina, atypical angina, non-anginal pain, and asymptomatic. 314 8. Tree-Based Methods Figure 8.6 has a surprising characteristic: some of the splits yield two terminal nodes that have the same predicted value . For instance, consider the split RestECG<1 near the bottom right of the unpruned tree. Regardless of the value of RestECG, a response value of Yesis predicted for those ob- servations. Why, then, is the split performed at all? The split is performed because it leads to increased node purity . That is, all 9 of the observations corresponding to the right-hand leaf have a response value of Yes,w h e r e a s 7/11 of those corresponding to the left-hand leaf have a response value of Yes. Why is node purity important? Suppose that we have a test obser- vation that belongs to the region given by that right-hand leaf. Then we can be pretty certain that its response value is Yes. In contrast, if a test observation belongs to the region given by the left-hand leaf, then its re- sponse value is probably Yes, but we are much less certain. Even though the split RestECG<1 does not reduce the classiﬁcation error, it improves the Gini index and the cross-entropy, which are more sensitive to node purity. 8.1.3 Trees Versus Linear Models Regressionandclassiﬁcationtreeshaveaverydiﬀerentﬂavorfromthemore classicalapproachesforregressionandclassiﬁcationpresentedinChapters3 and 4. In particular, linear regression assumes a model of the form f(X)=β0+p/summationdisplay j=1Xjβj, (8.8) whereas regression trees a ssume a model of the form f(X)=M/summationdisplay m=1cm·1(X∈Rm) (8.9) whereR1,...,R Mrepresent a partition of fea ture space, as in Figure 8.3. Which model is better? It depends on the problem at hand. If the relationship between the features a nd the response is well approximated by a linear model as in (8.8), then an approach such as linear regression will likely work well, and will outperform a method such as a regression tree that does not exploit this linear structure. If instead there is a highly non-linear and complex relationship b etween the features and the response as indicated by model (8.9), then deci sion trees may outperform classical approaches. An illustrative example is displayed in Figure 8.7. The rela- tive performances of tree-basedand classicalapproachescan be assessedby estimating the test error, using either cross-validation or the validation set approach (Chapter 5). Of course, other consid erations beyond simply test error may come into play in selecting a statistical learning method; for instance, in certain set- tings, prediction using a tree may be preferred for the sake of interpretabil- ity and visualization. 8.1 The Basics of Decision Trees 315 X1X2 X1X2 X1X2 X1X2−2 −1 0 1 2 −2 −1 0 1 2 −2 −1 0 1 2 −2 −1 0 1 2 −2 −1 0 1 2 −2 −1 0 1 2 −2 −1 0 1 2 −2 −1 0 1 2 FIGURE 8.7. Top Row: A two-dimensional classiﬁcation example in which the true decision boundary is linear, and is indicated by the shaded regions. A classical approach that assumes a linear boundary (left) will outperform a de- cision tree that performs splits parallel to the axes (right). Bottom Row: Here the true decision boundary is non-linear. Here a linear model is unable to capture the true decision boundary (left), whereas a decision tree is successful (right). 8.1.4 Advantages and Disadvantages of Trees Decision trees for regressionand classiﬁcationhave a number of advantages over the more classical approaches seen in Chapters 3 and 4: ▲Trees are very easy to explain to people. In fact, they are even easier to explain than linear regression! ▲Some people believe that decision trees more closely mirror human decision-making than do the regression and classiﬁcation approaches seen in previous chapters. ▲Trees can be displayed graphically, and are easily interpreted even by a non-expert (especially if they are small). ▲Trees can easily handle qualitative predictors without the need to create dummy variables. 316 8. Tree-Based Methods ▼Unfortunately, treesgenerallydo not havethe same levelofpredictive accuracyas some ofthe otherregressionand classiﬁcationapproaches seen in this book. However,byaggregatingmanydecisiontrees,usingmethodslike bagging, random forests ,a n dboosting, the predictive perfor mance of trees can be substantially improved. We introduce these concepts in the next section. 8.2 Bagging, Random Forests, Boosting Bagging, random forests, and boosting use trees as building blocks to construct more powerfu l prediction models. 8.2.1 Bagging The bootstrap, introduced in Chapter 5, is an extremely powerful idea. It is used in many situations in which it is hard or even impossible to directly compute the standard deviation of a quantity of interest. We see here that the bootstrap can be used in a completely diﬀerent context, in order to improve statistical learning methods such as decision trees. The decision trees discussed in Section 8.1 suﬀer from high variance . This means that if we split the training data into two parts at random, and ﬁt a decision tree to both halves , the results that we get could be quite diﬀerent. In cont rast, a procedure with low variance will yield similar results if applied repeatedly to distinct data sets; linear regression tends to have low variance, if the ratio of ntopis moderately large. Bootstrap aggregation ,o rbagging, is a general-purpose procedure for reducing thebaggingvariance of a statistical learning method; we introduce it here because it is particularly useful and frequently u sed in the context of decision trees. Recall that given a set of nindependent observations Z1,...,Z n,e a c h with variance σ2, the variance of the mean ¯Zof the observations is given byσ2/n.I no t h e rw o r d s , averaging a set of observations reduces variance . Hence a natural way to reduce the vari ance and hence increase the predic- tion accuracy of a statistical learning method is to take many training sets from the population, build a separate prediction model using each training set, and average the resulting predictions. In other words, we could cal- culateˆf1(x),ˆf2(x),...,ˆfB(x)u s i n gBseparate training sets, and average them in order to obtain a single low-variance statistical learning model, given by ˆfavg(x)=1 BB/summationdisplay b=1ˆfb(x). Of course, this is not practical beca use we generally do not have access to multiple training sets. Instead, we can bootstrap, by taking repeated 8.2 Bagging, Random Forests, Boosting 317 samples from the (single) training data set. In this approach we generate Bdiﬀerent bootstrapped training data sets. We then train our method on thebth bootstrapped training set in order to get ˆf∗b(x), and ﬁnally average all the predictions, to obtain ˆfbag(x)=1 BB/summationdisplay b=1ˆf∗b(x). This is called bagging. While bagging can improve predictions for many regression methods, it is particularly useful for decision trees. To apply bagging to regression trees,wesimply construct Bregressiontreesusing Bbootstrappedtraining sets, and average the resulting predic tions. These trees are grown deep, and are not pruned. Hence each individual tree has high variance, but low bias. Averaging these Btrees reduces the variance. Bagging has been demonstrated to give impressive impr ovements in accuracy by combining together hundreds or even thousands of trees into a single procedure. Thus far, we have described the bagging procedure in the regression context,topredictaquantitativeoutcome Y.Howcanbaggingbeextended to a classiﬁcation problem where Yis qualitative? In that situation, there areafew possibleapproaches,butthe simplestisasfollows.Foragiventest observation, we can record the class predicted by each of the Btrees, and take amajority vote : the overallprediction is the most commonly occurringmajority vote class among the Bpredictions. Figure 8.8 shows the results from bagging trees on the Heartdata. The test error rate is shown as a function of B, the number of trees constructed using bootstrapped training data sets. We see that the bagging test error rate is slightly lower in this case than the test error rate obtained from a single tree. The number of trees Bis not a critical parameter with bagging; using a very large value of Bwill not lead to overﬁtting. In practice we use a value of Bsuﬃciently large that the error has settled down. Using B= 100 is suﬃcient to achieve good performance in this example. Out-of-Bag Error Estimation It turns out that there is a very straightforward way to estimate the test error of a bagged model, without the need to perform cross-validation or the validation set approach. Recall that the key to bagging is that trees are repeatedly ﬁt to bootstrapped subsets of the observations. One can show that on average, each bagged tree makes use of around two-thirds of the observations.3The remaining one-third of the observations not used to ﬁt a given bagged tree are referred to as the out-of-bag (OOB) observations. Weout-of-bagcan predict the response for the ith observation using each of the trees in 3This relates to Exercise 2 of Chapter 5. 318 8. Tree-Based Methods 0 50 100 150 200 250 3000.10 0.15 0.20 0.25 0.30 Number of TreesError Test: Bagging Test: RandomForest OOB: Bagging OOB: RandomForest FIGURE 8.8. Bagging and random forest results for the Heartdata. The test error (black and orange) is shown as a function of B, the number of bootstrapped training sets used. Random forests were applied with m=√p. The dashed line indicates the test error resulting from a single classiﬁcation tree. The green and blue traces show the OOB error, which in this case is considerably lower. which that observation was OOB. This will yield around B/3 predictions for theith observation. In order to obtain a single prediction for the ith observation, we can average these predicted responses (if regression is the goal) or can take a majority vote (if classiﬁcation is the goal). This leads to a single OOB prediction for the ith observation. An OOB prediction can be obtained in this way for each of the nobservations, from which the overall OOB MSE (for a regression problem) or classiﬁcation error (for a classiﬁcationproblem)canbe computed. TheresultingOOBerrorisavalid estimate of the test error for the bagged model, since the response for each observation is predicted using only the trees that were not ﬁt using that observation. Figure 8.8 displays the OOB error on the Heartdata. It can be shown that with Bsuﬃciently large, OOB error is virtually equivalent to leave-one-out cross-validation error. The OOB approach for estimating the test error is particularly convenient when performing bagging on large data sets for which cross-validation would be computationally onerous. Variable Importance Measures As we have discussed, bagging typically results in improved accuracy over prediction using a single tree. Unfortunately, however, it can be diﬃcult to interpret the resulting model. Recall that one of the advantages of decision 8.2 Bagging, Random Forests, Boosting 319 ThalCaChestPainOldpeakMaxHRRestBPAgeCholSlopeSexExAngRestECGFbs 0 2 04 06 08 0 1 0 0 Variable Importance FIGURE 8.9. A variable importance plot for the Heartdata. Variable impor- tance is computed using the mean decrease in Gini index, and expressed relative to the maximum. trees is the attractive and easily interpreted diagram that results, such as the one displayed in Figure 8.1. However, when we bag a large number of trees, it is no longer possible to represe nt the resulting statistical learning procedure using a single tree, and it is no longer clear which variables are most important to the procedure. Thus, bagging improves prediction accuracy at the expense of interpretability. Althoughthecollectionofbaggedtreesismuchmorediﬃculttointerpret than a single tree, one can obtain an overall summary of the importance of eachpredictorusingtheRSS(forbaggingregressiontrees)ortheGiniindex (for bagging classiﬁcation trees). In the case of bagging regression trees, we can record the total amount that the RSS (8.1) is decreased due to splits over a given predictor, averaged over all Btrees. A large value indicates an important predictor. Similarly, in the context of bagging classiﬁcation trees, wecan add up the total amountthat the Gini index (8.6) is decreased by splits over a given predictor, averaged over all Btrees. A graphical representation of the variable importances in the Heartdatavariable importance isshownin Figure8.9.We seethemeand ecreaseinGiniindex foreachvari- able, relative to the largest. The variables with the largest mean decrease in Gini index are Thal,Ca,a n d ChestPain . 320 8. Tree-Based Methods 8.2.2 Random Forests Random forests provide an improvement over bagged trees by way of arandom forest small tweak that decorrelates the trees. As in bagging, we build a number ofdecisiontreesonbootstrappedtrainingsamples.Butwhenbuildingthese decision trees, each time a split in a tree is considered, a random sample of mpredictors is chosen as split candidates from the full set of ppredictors. The split is allowedto use only one of those mpredictors. A fresh sample of mpredictors is taken at each split, and typically we choose m≈√p—that is, the number of predictors consider ed at each split is approximately equal to the square root of the total number of predictors (4 out of the 13 for the Heartdata). In other words, in building a random forest, at each split in the tree, the algorithm is not even allowed to consider a majority of the available predictors. This may sound crazy, but it has a clever rationale. Suppose that there is one very strong predictor in the data set, along with a num- ber of other moderately strong predictors. Then in the collection of bagged trees, most or all of the trees will use this strong predictor in the top split. Consequently, all of the bagged trees will look quite similar to each other. Hence the predictions from the bagged trees will be highly correlated. Un- fortunately, averaging many highly correlated quantities does not lead to as large of a reduction in variance as averaging many uncorrelated quanti- ties. In particular, this means that bagging will not lead to a substantial reduction in variance over a single tree in this setting. Random forests over come this problem by forci ng each split to consider only a subset of the predictors. Therefore, on average ( p−m)/pof the splits will not even consider the strong predictor, and so other predictors will have more of a chance. We can think of this process as decorrelating the trees, thereby making the average of the resulting trees less variable and hence more reliable. The main diﬀerence between bagging and random forests is the choice of predictor subset size m. For instance, if a random forest is built using m=p, then this amounts simply to bagging. On the Heartdata, random forests using m=√pleads to a reductionin both test errorand OOB error over bagging (Figure 8.8). Using a small value of min building a random forest will typically be helpful when we have a large number of correlated predictors. We applied random forests to a high-dimensional biological data set consisting of ex- pression measurements of 4,718 genes measured on tissue samples from 349 patients. There are around 20,000 genes in humans, and individual genes have diﬀerent levels of activity, or expression, in particular cells, tissues, and biological conditions. In this data set, each of the patient samples has a qualitative label with 15 diﬀerent levels: either normal or 1 of 14 diﬀerent types of cancer. Our goal was to use random forests to predict cancer type based on the 500 genes that have the largest variance in the training set. 8.2 Bagging, Random Forests, Boosting 321 0 100 200 300 400 5000.2 0.3 0.4 0.5 Number of TreesTest Classification Errorm=p m=p/2 m=p FIGURE 8.10. Results from random forests for the 15-class gene expression data set with p= 500predictors. The test error is displayed as a function of the number of trees. Each colored line corresponds to a diﬀerent value of m,t h e number of predictors available for splitting at each interior tree node. Random forests ( m<p) lead to a slight improvement over bagging ( m=p). A single classiﬁcation tree has an error rate of 45.7%. We randomly divided the observations into a training and a test set, and applied random forests to the training set for three diﬀerent values of the number of splitting variables m. The results are shown in Figure 8.10. The error rate of a single tree is 45 .7%, and the null rate is 75 .4%.4We see that using 400 trees is suﬃcient to give good performance, and that the choice m=√pgave a small improvement in test error over bagging ( m=p)i n this example.As with bagging,randomforestswill notoverﬁtif we increase B,s oi np r a c t i c ew eu s eav a l u eo f Bsuﬃciently large for the error rate to have settled down. 8.2.3 Boosting We now discuss boosting, yet another approach for improving the predic-boostingtions resulting from a decision tree. Like bagging, boosting is a general approach that can be applied to many statistical learning methods for re- gression or classiﬁcation. Here we restrict our discussion of boosting to the context of decision trees. Recallthatbagginginvolvescreatingmultiple copiesoftheoriginaltrain- ing data set using the bootstrap, ﬁ tting a separate decision tree to each copy, and then combining all of the trees in order to create a single predic- tive model. Notably, each tree is built on a bootstrap data set, independent 4The null rate results from simply classifying each observation to the dominant class overall, which is in this case the normal class. 322 8. Tree-Based Methods of the other trees. Boostingworksin a s imilarway, exceptthat the trees are grownsequentially : each tree is grown using information from previously grown trees. Boosting does not involve bootstrap sampling; instead each tree is ﬁt on a modiﬁed version of the original data set. Algorithm 8.2 Boosting for Regression Trees 1. Setˆf(x)=0a n d ri=yifor alliin the training set. 2. Forb=1,2,...,B, repeat: (a) Fit a tree ˆfbwithdsplits (d+1 terminal nodes) to the training data (X,r). (b) Update ˆfby adding in a shrunken version of the new tree: ˆf(x)←ˆf(x)+λˆfb(x). (8.10) (c) Update the residuals, ri←ri−λˆfb(xi). (8.11) 3. Output the boosted model, ˆf(x)=B/summationdisplay b=1λˆfb(x). (8.12) Considerﬁrsttheregressionsetting.Likebagging,boostinginvolvescom- bining a large number of decision trees, ˆf1,...,ˆfB. Boosting is described in Algorithm 8.2. What is the idea behind this procedure? Unlike ﬁtting a single large deci- siontree tothe data,which amountsto ﬁtting the data hard andpotentially overﬁtting, the boosting approach instead learns slowly . Given the current model, we ﬁt a decision tree to the residuals from the model. That is, we ﬁt a tree using the current residuals, rather than the outcome Y,a st h er e - sponse. We then add this new decision tree into the ﬁtted function in order to update the residuals. Each of these trees can be rather small, with just a few terminal nodes, dete rmined by the parameter din the algorithm. By ﬁtting small trees to the residuals, we slowly improve ˆfin areas where it does not perform well. The shrinkage parameter λslows the process down even further, allowing more and diﬀer ent shaped trees to attack the resid- uals. In general, statistical learning approaches that learn slowly tend to perform well. Note that in boosting, unlike in bagging, the construction of each tree depends strongly on the trees that have already been grown. 8.2 Bagging, Random Forests, Boosting 323 0 1000 2000 3000 4000 50000.05 0.10 0.15 0.20 0.25 Number of TreesTest Classification ErrorBoosting: depth=1 Boosting: depth=2 RandomForest: m= p FIGURE 8.11. Results from performing boosting and random forests on the 15-class gene expression data set in order to predict cancerversusnormal.T h e test error is displayed as a function of the number of trees. For the two boosted models,λ=0.01. Depth-1 trees slightly outperform depth-2 trees, and both out- perform the random forest, although the standard errors are around 0.02, making none of these diﬀerences signiﬁcant. The test error rate for a single tree is 24%. We have just described the process of boosting regressiontrees. Boosting classiﬁcationtrees proceeds in a sim ilarbut slightly mo re complex way,and the details are omitted here. Boosting has three tuning parameters: 1. The number of trees B. Unlike bagging and random forests, boosting can overﬁt if Bis too large, although this overﬁtting tends to occur slowly if at all. We use cross-validation to select B. 2. Theshrinkageparameter λ,asmallpositivenumber.Thiscontrolsthe rate at which boosting learns. Typical values are 0 .01 or 0.001, and the right choice can depend on the problem. Very small λcan require using a very large value of Bin order to achieve good performance. 3. The number dof splits in each tree, which controls the complexity of the boosted ensemble. Often d= 1 works well, in which case each tree is a stump, consisting of a single split. In this case, the boostedstumpensemble is ﬁtting an additive model, since each term involves only a single variable. Moregenerally dis theinteraction depth ,a n dc o n t r o l sinteraction depth the interaction order of the boosted model, since dsplits can involve at mostdvariables. InFigure8.11,we appliedboostingto the 15-classcancergeneexpression data set, in order to develop a classiﬁer that can distinguish the normal class from the 14 cancer classes. We display the test error as a function of the total number of trees and the interaction depth d.W es e et h a ts i m p l e 324 8. Tree-Based Methods stumps with an interaction depth of one perform well if enough of them are included. This model outperforms the depth-two model, and both out- perform a random forest. This highlights one diﬀerence between boosting and random forests: in boosting, because the growth of a particular tree takes into account the other trees that have already been grown, smaller trees are typically suﬃcient. Using smaller trees can aid in interpretability as well; for instance, using stumps leads to an additive model. 8.3 Lab: Decision Trees 8.3.1 Fitting Classiﬁcation Trees The treelibrary is used to construct classiﬁcation and regression trees. > library(tree) We ﬁrst use classiﬁcation trees to analyze the Carseats data set. In these data, Salesis a continuous variable, and so we begin by recoding it as a binary variable. We use the ifelse() function to create a variable, calledifelse()High, which takes on a value of Yesif the Salesvariable exceeds 8, and takes on a value of Nootherwise. > library(ISLR) > attach(Carseats) > High=ifelse(Sales <=8,\"No\",\"Yes\") Finally, we use the data.frame() function to merge Highwith the rest of theCarseats data. > Carseats=data.frame(Carseats ,High) We now use the tree()function toﬁt aclassiﬁcationtreein ordertopredicttree()Highusingallvariablesbut Sales.Thesyntaxofthe tree()function isquite similar to that of the lm()function. > tree.carseats=tree(High ∼.-Sales , Carseats) The summary() function lists the variables that are used as internal nodes in the tree, the number of terminal nodes, and the (training) error rate. > summary(tree.carseats) Classification tree: tree(formula = High ∼. - Sales , data = Carseats) Variables actually used in tree construction: [1] \"ShelveLoc \" \"Price\" \"Income\" \"CompPrice \" [5] \"Population \" \"Advertising \" \"Age\" \"US\" Number of terminal nodes: 27 Residual mean deviance: 0.4575 = 170.7 / 373 Misclassification error rate: 0.09 = 36 / 400 8.3 Lab: Decision Trees 325 We see that the training error rate is 9%. For classiﬁcation trees, the de- viance reported in the output of summary() is given by −2/summationdisplay m/summationdisplay knmklog ˆpmk, wherenmkis the number of observations in the mth terminal node that belong to the kth class. A small deviance i ndicates a tree that provides a good ﬁt to the (training) data. The residual mean deviance reported is simply the deviance divided by n−|T0|, which in this case is 400 −27= 373. One of the most attractive properties of trees is that they can be graphically displayed. We use the plot()function to display the tree struc- ture, and the text()function to display the node labels. The argument pretty=0 instructs Rto include the category names for any qualitative pre- dictors, rather than simply disp laying a letter for each category. > plot(tree.carseats) > text(tree.carseats ,pretty=0) The most important indicator of Salesappears to be shelving location, since the ﬁrst branch diﬀerentiates Goodlocations from Badand Medium locations. If we just type the name of the tree object, Rprints output corresponding toeachbranchofthetree. Rdisplaysthesplitcriterion(e.g. Price<92.5 ), the number of observations in that branch, the deviance, the overall prediction for the branch ( YesorNo), and the fraction of observations in that branch that take on values of Yesand No. Branches that lead to terminal nodes are indicated using asterisks. > tree.carseats node), split , n, deviance, yval, (yprob) * denotes terminal node 1) root 400 541.5 No ( 0.590 0.410 ) 2) ShelveLoc : Bad,Medium 315 390.6 No ( 0.689 0.311 ) 4) Price < 92.5 46 56.53 Yes ( 0.304 0.696 ) 8) Income < 57 10 12.22 No ( 0.700 0.300 ) In order to properly evaluate the performance of a classiﬁcation tree on these data, we must estimate the test error rather than simply computing the training error. We split the observations into a training set and a test set, build the tree using the training set, and evaluate its performance on the test data. The predict() function can be used for this purpose. In the caseofaclassiﬁcationtree,the argument type=\"class\" instructs Rto return the actual class prediction. This approach leads to correct predictions for around 71 .5% of the locations in the test data set. > set.seed(2) > train=sample(1:nrow(Carseats), 200) > Carseats.test=Carseats[-t rain ,] > High.test=High[-train] 326 8. Tree-Based Methods > tree.carseats=tree(High ∼.-Sales , Carseats,subset=train) > tree.pred=predict(tree.carseats ,Carseats. test, type=\"class\") > table(tree. pred , High.test) High.test tree.pred No Yes No 86 27 Yes 30 57 > (86+57) /200 [1] 0.715 Next, we consider whether pruning the tree might lead to improved results. The function cv.tree() performs cross-validation in order tocv.tree()determine the optimal level of tree complexity; cost complexity pruning is used in order to select a sequence of trees for consideration. We use the argument FUN=prune.misclass in order to indicate that we want the classiﬁcation error rate to guide the cross-validation and pruning process, rather than the default for the cv.tree() function, which is deviance. The cv.tree() function reports the number of terminal nodes of each tree con- sidered ( size) as well as the corresponding error rate and the value of the cost-complexity parameter used ( k, which corresponds to αin (8.4)). > set.seed(3) > cv.carseats=cv.tree(tree.carseats ,FUN=prune.misclass) > names(cv.carseats) [1] \"size\" \"dev\" \"k\" \"method\" > cv.carseats $size [ 1 ] 1 9 1 7 1 4 1 397321 $dev [1] 55 55 53 52 50 56 69 65 80 $k [1] -Inf 0.0000000 0.6666667 1.0000000 1.7500000 2.0000000 4.2500000 [8] 5.0000000 23.0000000 $method [1] \"misclass\" attr(,\"class\") [1] \"prune\" \"tree.sequence\" Note that, despite the name, devcorresponds to the cross-validation error rate in this instance. The tree with 9 terminal nodes results in the lowest cross-validationerrorrate,with50cross-validationerrors.Weplottheerror rate as a function of both sizeand k. > par(mfrow=c(1,2)) > plot(cv.carseats$size ,cv.carseats$dev ,type=\"b\") > plot(cv.carseats$k ,cv.carseats$dev ,type=\"b\") 8.3 Lab: Decision Trees 327 We now apply the prune.misclass() function in order to prune the tree toprune. misclass() obtain the nine-node tree. > prune.carseats=prune.misclass(tree.carseats,best=9) > plot(prune.carseats) > text(prune.carseats ,pretty=0) How well does this pruned tree perform on the test data set? Once again, we apply the predict() function. > tree.pred=predict(prune.carseats,Carseats. test, type=\"class\") > table(tree. pred , High.test) High.test tree.pred No Yes No 94 24 Yes 22 60 > (94+60) /200 [1] 0.77 Now 77% of the test observations are correctly classiﬁed, so not only has the pruning process produced a more interpretable tree, but it has also improved the classiﬁcation accuracy. If we increasethe value of best, we obtain a largerpruned tree with lower classiﬁcation accuracy: > prune.carseats=prune.misclass(tree.carseats,best=15) > plot(prune.carseats) > text(prune.carseats ,pretty=0) > tree.pred=predict(prune.carseats,Carseats. test, type=\"class\") > table(tree. pred , High.test) High.test tree.pred No Yes No 86 22 Yes 30 62 > (86+62) /200 [1] 0.74 8.3.2 Fitting Regression Trees Here we ﬁt a regression tree to the Bostondata set. First, we create a training set, and ﬁt the tree to the training data. > library(MASS) > set.seed(1) > train = sample(1:nrow(Boston), nrow(Boston)/2) > tree.boston=tree(medv ∼.,Boston , subset=train) > summary(tree.boston) Regression tree: tree(formula = medv ∼., data = Boston , subset = train) Variables actually used in tree construction: [1] \"lstat\" \"rm\" \"dis\" Number of terminal nodes: 8 328 8. Tree-Based Methods Residual mean deviance: 12.65 = 3099 / 245 Distribution of residuals : Min. 1st Qu. Median Mean 3rd Qu. Max. -14.1000 -2.0420 -0.0536 0.0000 1.9600 12.6000 Notice that the output of summary() indicates that only three of the vari- ables have been used in constructing th e tree. In the context of a regression tree, the deviance is simply the sum o f squared errors for the tree. We now plot the tree. > plot(tree.boston) > text(tree. boston , pretty=0) The variable lstatmeasures the percentage of individuals with lower socioeconomic status. The tre e indicates that lower values of lstatcor- respond to more expensive houses. The tree predicts a median house price of $46,400 for larger homes in suburbs in which residents have high socioe- conomic status ( rm>=7.437 and lstat<9.715 ). Now we use the cv.tree() function to see whether pruning the tree will improve performance. > cv.boston=cv.tree(tree.boston) > plot(cv.boston$size ,cv.boston$dev ,type=’b’) In this case, the most complex tree i s selected by cross-validation. How- ever, if we wish to prune the tree, we could do so as follows, using the prune.tree() function:prune.tree() > prune.boston=prune.tree(tree.boston ,best=5) > plot(prune.boston) > text(prune. boston , pretty=0) In keeping with the cross-validation results, we use the unpruned tree to make predictions on the test set. > yhat=predict(tree.boston ,newdata=Boston[- train ,]) > boston.test=Boston[-train ,\"medv\"] > plot(yhat,boston.test) > abline(0,1) > mean((yhat-boston.test)^2) [1] 25.05 In other words, the test set MSE associated with the regression tree is 25.05. The square root of the MSE is therefore around 5 .005, indicating that this model leads to test predictions that are within around $5 ,005 of the true median home value for the suburb. 8.3.3 Bagging and Random Forests Here we apply bagging and random forests to the Bostondata, using the randomForest package in R. The exact results obtained in this section may depend on the version of Rand the version of the randomForest package 8.3 Lab: Decision Trees 329 installed on your computer. Recall that bagging is simply a special case of a random forest with m=p. Therefore, the randomForest() function canrandom Forest() be used to perform both random forests and bagging. We perform bagging as follows: > library( randomForest) > set.seed(1) > bag.boston= randomForest( medv∼.,data=Bo ston , subset= train , mtry=13,importance =TRUE) > bag.boston Call: randomForest( formula = medv ∼., data = Boston , mtry = 13, importance = TRUE, subset = train) Type of random forest: regression Number of trees: 500 No. of variables tried at each split: 13 Mean of squared residuals : 10.77 % Var explained : 86.96 The argument mtry=13indicates that all 13 predic tors should be considered foreachsplitofthetree—inotherwords,thatbaggingshouldbedone.How well does this bagged model perform on the test set? > yhat.bag = predict(bag. boston , newdata=Boston[- train ,]) > plot(yhat.bag, boston.test) > abline(0,1) > mean((yhat.bag-boston.test)^2) [1] 13.16 ThetestsetMSEassociatedwiththebaggedregressiontreeis13 .16,almost half that obtained using an optimally-pruned single tree. We could change the number of trees grown by randomForest() using the ntreeargument: > bag.boston= randomForest( medv∼.,data=Bo ston , subset= train , mtry=13,ntree=25) > yhat.bag = predict(bag. boston , newdata=Boston[- train ,]) > mean((yhat.bag-boston.test)^2) [1] 13.31 Growing a random forest proceeds in e xactly the same way, except that we use a smaller value of the mtryargument. By default, randomForest() usesp/3 variables when building a rando m forest of regression trees, and√pvariables when building a random forest of classiﬁcation trees. Here we usemtry = 6 . > set.seed(1) > rf.boston= randomForest( medv∼.,data=Boston , subset= train , mtry=6,importance =TRUE) > yhat.rf = predict(rf.boston ,newdata=Boston[- train ,]) > mean((yhat.rf-boston.test)^2) [1] 11.31 330 8. Tree-Based Methods The test set MSE is 11 .31; this indicates that random forests yielded an improvement over bagging in this case. Using the importance() function, we can view the importance of eachimportance()variable. > importance (rf.boston) %IncMSE IncNodePurity crim 12.384 1051.54 zn 2.103 50.31 indus 8.390 1017.64 chas 2.294 56.32 nox 12.791 1107.31 rm 30.754 5917.26 age 10.334 552.27 dis 14.641 1223.93 rad 3.583 84.30 tax 8.139 435.71 ptratio 11.274 817.33 black 8.097 367.00 lstat 30.962 7713.63 Two measures of variable importance are reported. The former is based uponthemeandecreaseofaccuracyinpr edictionsontheoutofbagsamples when a given variable is excluded from the model. The latter is a measure of the total decrease in node impurity that results from splits over that variable, averaged over all trees (this was plotted in Figure 8.9). In the case of regression trees, the node impurity is measured by the training RSS, and for classiﬁcation trees by th e deviance. Plots of these importance measures can be produced using the varImpPlot() function.varImpPlot() > varImpPlot (rf.boston) The results indicate that across all o f the trees consider ed in the random forest, the wealth level of the community ( lstat) and the house size ( rm) are by far the two most important variables. 8.3.4 Boosting Herewe usethe gbmpackage,andwithin it the gbm()function, toﬁt boostedgbm()regression trees to the Bostondata set. We run gbm()with the option distribution=\"gaussian\" since this is a regression problem; if it were a bi- nary classiﬁcation problem, we would use distribution=\"bernoulli\" .T h e argument n.trees=5000 indicates that we want 5000 trees, and the option interaction.depth=4 limits the depth of each tree. > library(gbm) > set.seed(1) > boost.boston=gbm(medv ∼.,data=Boston[train ,], distribution= \"gaussian\",n.trees=5000, interaction .depth=4) The summary() function produces a relative inﬂuence plot and also outputs the relative inﬂuence statistics. 8.3 Lab: Decision Trees 331 > summary(boost.boston) var rel.inf 1 lstat 45.96 2 rm 31.22 3 dis 6.81 4 crim 4.07 5 nox 2.56 6 ptratio 2.27 7 black 1.80 8 age 1.64 9 tax 1.36 10 indus 1.27 11 chas 0.80 12 rad 0.20 13 zn 0.015 We see that lstatand rmare by far the most important variables. We can also produce partial dependence plots for these two variables. These plotspartial dependence plotillustrate the marginal eﬀect of the selected variables on the response after integrating out the other variables.In this case,as we mightexpect, median house prices are increasing with rmand decreasing with lstat. > par(mfrow=c(1,2)) > plot(boost. boston ,i=\"rm\") > plot(boost. boston ,i=\" lstat\") We now use the boosted model to predict medvon the test set: > yhat.boost=predict(boost.boston ,newdata=Boston[-train ,], n.trees=5000) > mean((yhat. boost - boston.test)^2) [1] 11.8 The test MSE obtained is 11 .8; similar to the test MSE for random forests and superior to that for bagging. If we want to, we can perform boosting with a diﬀerent value of the shrinkage parameter λin (8.10). The default value is 0 .001, but this is easily modiﬁed. Here we take λ=0.2. > boost.boston=gbm(medv ∼.,data=Boston[train ,], distribution= \"gaussian\",n.trees=5000,interaction .depth=4,shrinkage =0.2, verbose=F) > yhat.boost=predict(boost.boston ,newdata=Boston[-train ,], n.trees=5000) > mean((yhat. boost - boston.test)^2) [1] 11.5 Inthiscase,using λ=0.2leadstoaslightlylowertestMSEthan λ=0.001. 332 8. Tree-Based Methods 8.4 Exercises Conceptual 1. Draw an example (of your own invention) of a partition of two- dimensional feature space that could result from recursive binary splitting. Your example should co ntain at least six regions. Draw a decision tree corresponding to this partition. Be sure to label all as- pects of your ﬁgures, including the regions R1,R2,...,t h ec u t p o i n t s t1,t2,..., and so forth. Hint: Your result should look something like Figures 8.1 and 8.2. 2. It is mentioned in Section 8.2.3 that boosting using depth-one trees (orstumps)l e a d st oa n additive model: that is, a model of the form f(X)=p/summationdisplay j=1fj(Xj). Explain why this is the case. You can begin with (8.12) in Algorithm 8.2. 3. Consider the Gini index, classiﬁcation error, and cross-entropy in a simple classiﬁcation setting with two classes. Create a single plot that displays each of these quantities as a function of ˆ pm1.T h ex- axis should display ˆ pm1, ranging from 0 to 1, and the y-axis should display the value of the Gini index, classiﬁcation error, and entropy. Hint: In a setting with two classes, ˆpm1=1−ˆpm2. You could make this plot by hand, but it will be much easier to make in R. 4. This question relates to the plots in Figure 8.12. (a) Sketch the tree corresponding to the partition of the predictor space illustrated in the left-hand panel of Figure 8.12. The num- bers inside the boxes indicate the mean of Ywithin each region. (b) Create a diagram similar to the left-hand panel of Figure 8.12, using the tree illustrated in the right-hand panel of the same ﬁgure. You should divide up the predictor space into the correct regions, and indicate the mean for each region. 5. Suppose we produce ten bootstrapped samples from a data set containing red and green classes. We then apply a classiﬁcation tree to each bootstrapped sample and, for a speciﬁc value of X, produce 10 estimates of P(Class is Red |X): 0.1,0.15,0.2,0.2,0.55,0.6,0.6,0.65,0.7,and 0.75. 8.4 Exercises 333 515 01030 1 X1X21 0X2 < 1 X1 < 1 X1 < 0X2 < 2 2.49 0.21 0.63−1.06 −1.80 FIGURE 8.12. Left: A partition of the predictor space corresponding to Exer- cise 4a. Right: A tree corresponding to Exercise 4b. There are two common ways to combine these results together into a singleclassprediction. Oneis the majorityvoteapproachdiscussedin this chapter. The second approach is to classify based on the average probability.In this example,what isthe ﬁnalclassiﬁcationundereach of these two approaches? 6. Provide a detailed explanation of the algorithm that is used to ﬁt a regression tree. Applied 7. In the lab, we applied random forests to the Bostondata using mtry=6 and using ntree=25 and ntree=500 . Create a plot displaying the test error resulting from random forests on this data set for a more com- prehensive range of values for mtryand ntree. You can model your plot after Figure 8.10. Describe the results obtained. 8. Inthelab,aclassiﬁcationtreewasappliedtothe Carseats dataset af- ter converting Salesinto a qualitative response variable. Now we will seek to predict Salesusing regression trees and related approaches, treating the response as a quantitative variable. (a) Split the data set into a training set and a test set. (b) Fit a regression tree to the train ing set. Plot the tree, and inter- pret the results. What test error rate do you obtain? (c) Use cross-validation in order to determine the optimal level of tree complexity. Does pruning the tree improve the test error rate? (d) Use the bagging approach in order to analyze this data. What test error rate do you obtain? Use the importance() function to determine which variables are most important. 334 8. Tree-Based Methods (e) Use randomforests to analyze this data. What test error rate do you obtain? Use the importance() function to determine which variables aremost important. Describe the eﬀect of m,t h en u m - ber of variables considered at each split, on the error rate obtained. 9. This problem involves the OJdata set which is part of the ISLR package. (a) Create a training set containing a random sample of 800 obser- vations, and a test set containing the remaining observations. (b) Fit a tree to the training data, with Purchase as the response and the other variables except for Buyas predictors. Use the summary() function to produce summary statistics about the tree, and describe the results obtained. What is the training error rate? How many terminal nodes does the tree have? (c) Type in the name of the tree object in order to get a detailed text output. Pick one of the terminal nodes, and interpret the information displayed. (d) Create a plot of the tree, and interpret the results. (e) Predict the response on the test data, and produce a confusion matrix comparing the test labels to the predicted test labels. What is the test error rate? (f) Apply the cv.tree() function to the training set in order to determine the optimal tree size. (g) Produce a plot with tree size on the x-axis and cross-validated classiﬁcation error rate on the y-axis. (h) Which tree size corresponds to th e lowest cross-validated classi- ﬁcation error rate? (i) Produce a pruned tree corresponding to the optimal tree size obtained using cross-validation. If cross-validation does not lead to selection of a pruned tree, th en create a pruned tree with ﬁve terminal nodes. (j) Compare the training error rates between the pruned and un- pruned trees. Which is higher? (k) Compare the test error rates between the pruned and unpruned trees. Which is higher? 10. We now use boosting to predict Salaryin the Hittersdata set. (a) Remove the observations for whom the salary information is unknown, and then log-transform the salaries. 8.4 Exercises 335 (b) Create a training set consisting of the ﬁrst200 observations,and a test set consisting of the remaining observations. (c) Perform boosting on the training set with 1,000trees for a range of values of the shrinkage parameter λ. Produce a plot with diﬀerent shrinkage values on the x-axis and the corresponding training set MSE on the y-axis. (d) Produce a plot with diﬀerent shrinkage values on the x-axis and the corresponding test set MSE on the y-axis. (e) Compare the test MSE of boosting to the test MSE that results from applying two of the regression approaches seen in Chapters 3 and 6. (f) Which variables appear to be the most important predictors in the boosted model? (g) Now apply baggingto the training set. What is the test set MSE for this approach? 11. This question uses the Caravandata set. (a) Create a training set consisting of the ﬁrst 1,000 observations, and a test set consisting of the remaining observations. (b) Fit a boosting model to the training set with Purchase as the response and the other variables as predictors. Use 1,000 trees, and a shrinkage value of 0 .01. Which predictors appear to be the most important? (c) Use the boosting model to predict the response on the test data. Predictthatapersonwillmakeapurchaseiftheestimatedprob- ability of purchase is greater than 20%. Form a confusion ma- trix. What fraction of the people predicted to make a purchase do in fact make one? How does this compare with the results obtained from applying KNN or logistic regression to this data set? 12. Apply boosting, bagging, and random forests to a data set of your choice.Besuretoﬁtthe modelsonatrainingsetandto evaluatetheir performance on a test set. How accurate are the results compared to simple methods like linear or logistic regression? Which of these approaches yields the best performance? 9 Support Vector Machines In this chapter, we discuss the support vector machine (SVM), an approach for classiﬁcation that was developed in the computer science community in the 1990s and that has grown in popularity since then. SVMs have been shown to perform well in a variety of settings, and are often considered one of the best “out of the box” classiﬁers. The support vector machine is a generalization of a simple and intu- itive classiﬁer called the maximal margin classiﬁer , which we introduce in Section 9.1. Though it is elegant and simple, we will see that this classiﬁer unfortunately cannot be applied to most data sets, since it requires that the classes be separable by a linear boundary. In Section 9.2, we introduce thesupport vector classiﬁer , an extension of the maximal margin classiﬁer t h a tc a nb ea p p l i e di nab r o a d e rr a n g eo f cases. Section 9.3 introduces the support vector machine , which is a further extension of the support vec- tor classiﬁer in order to accommodate non-linear class boundaries. Support vector machines are intended for the binary classiﬁcation setting in which there are two classes; in Section 9.4 we discuss extensions of support vector machines to the case of more than two classes. In Section 9.5 we discuss the closeconnectionsbetw een supportvectormachines andotherstatistical methods such as logistic regression. People often loosely refer to the maximal margin classiﬁer, the support vector classiﬁer, and the support vector machine as “support vector machines”. To avoid confusion, we will carefully distinguish between these three notions in this chapter. G. James et al., An Introduction to Statistical Learning: with Applications in R , Springer Texts in Statistics 103, DOI 10.1007/978-1-4614-7138-7 9, ©Springer Science+Business Media New York 2013337 338 9. Support Vector Machines 9.1 Maximal Margin Classiﬁer In this section, we deﬁne a hyperplane and introduce the concept of an optimal separating hyperplane. 9.1.1 What Is a Hyperplane? In ap-dimensional space, a hyperplane is a ﬂat aﬃne subspace ofhyperplanedimension p−1.1For instance, in two dimensions, a hyperplane is a ﬂat one-dimensional subspace—in other words, a line. In three dimensions, a hyperplane is a ﬂat two-dimensional subspace—that is, a plane. In p>3 dimensions, it can be hard to visualize a hyperplane, but the notion of a (p−1)-dimensional ﬂat subspace still applies. The mathematical deﬁnition of a hyperplane is quite simple. In two di- mensions, a hyperplane is deﬁned by the equation β0+β1X1+β2X2= 0 (9.1) for parameters β0,β1,a n dβ2. When we say that (9.1) “deﬁnes” the hyper- plane, we mean that any X=(X1,X2)Tfor which (9.1) holds is a point on the hyperplane. Note that (9.1) is simply the equation of a line, since indeed in two dimensions a hyperplane is a line. Equation 9.1 can be easily extended to the p-dimensional setting: β0+β1X1+β2X2+...+βpXp= 0 (9.2) deﬁnes a p-dimensional hyperplane, again in the sense that if a point X= (X1,X2,...,X p)Tinp-dimensionalspace (i.e. a vector of length p) satisﬁes (9.2), then Xlies on the hyperplane. Now, suppose that Xdoes not satisfy (9.2); rather, β0+β1X1+β2X2+...+βpXp>0. (9.3) Then this tells us that Xlies to one side of the hyperplane. On the other hand, if β0+β1X1+β2X2+...+βpXp<0, (9.4) thenXlies on the other side of the hyperplane. So we can think of the hyperplane as dividing p-dimensional space into two halves. One can easily determine onwhich sideofthe hyperplaneapoint liesbysimply calculating the sign of the left hand side of (9.2). A hyperplane in two-dimensional space is shown in Figure 9.1. 1The word aﬃneindicates that the subspace need not pass through the origin. 9.1 Maximal Margin Classiﬁer 339 −1.5 −1.0 −0.5 0.0 0.5 1.0 1.5−1.5 −1.0 −0.5 0.0 0.5 1.0 1.5 X1X2 FIGURE 9.1. The hyperplane 1+2X1+3X2=0i ss h o w n .T h eb l u er e g i o ni s the set of points for which 1+2X1+3X2>0, and the purple region is the set of points for which 1+2X1+3X2<0. 9.1.2 Classiﬁcation Using a Separating Hyperplane Now suppose that we have a n×pdata matrix Xthat consists of ntraining observations in p-dimensional space, x1=⎛ ⎜⎝x11 ... x1p⎞ ⎟⎠,...,x n=⎛ ⎜⎝xn1 ... xnp⎞ ⎟⎠, (9.5) and that these observations fall into two classes—that is, y1,...,y n∈ {−1,1}where−1 represents one class and 1 the other class. We also have a test observation, a p-vector of observed features x∗=/parenleftbigx∗ 1... x∗ p/parenrightbigT.O u r goal is to develop a classiﬁer based on the training data that will correctly classify the test observation using i ts feature measurements. We have seen a number of approaches for this task, such as linear discriminant analysis and logistic regression in Chapter 4, and classiﬁcation trees, bagging, and boosting in Chapter 8. We will now see a new approach that is based upon the concept of a separating hyperplane .separating hyperplane Suppose that it is possible to construct a hyperplane that separates the training observations perfectly according to their class labels. Examples of three such separating hyperplanes are shown in the left-hand panel of Figure 9.2. We can label the observations from the blue class as yi=1a n d 340 9. Support Vector Machines − 1 0123− 1 0123 − 1 0123− 1 0123 X1 X1 X2X2 FIGURE 9.2. Left:There are two classes of observations, shown in blue and in purple, each of which has measurements on two variables. Three separating hyperplanes, out of many possible, are shown in black. Right:A separating hy- perplane is shown in black. The blue and purple grid indicates the decision rule made by a classiﬁer based on this separating hyperplane: a test observation that falls in the blue portion of the grid will be assigned to the blue class, and a test observation that falls into the purple portion of the grid will be assigned to the purple class. those from the purple class as yi=−1. Then a separating hyperplane has the property that β0+β1xi1+β2xi2+...+βpxip>0i fyi=1, (9.6) and β0+β1xi1+β2xi2+...+βpxip<0i fyi=−1. (9.7) Equivalently, a separating hyperplane has the property that yi(β0+β1xi1+β2xi2+...+βpxip)>0 (9.8) for alli=1,...,n. Ifaseparatinghyperplaneexists,we canuseittoconstructaverynatural classiﬁer: a test observation is assigned a class depending on which side of the hyperplane it is located. The right-hand panel of Figure 9.2 shows an example of such a classiﬁer. That is, we classify the test observation x∗ basedonthesignof f(x∗)=β0+β1x∗ 1+β2x∗ 2+...+βpx∗ p.Iff(x∗)ispositive, then we assign the test observation to class 1, and if f(x∗) is negative, then we assign it to class −1.We can also make use of the magnitude off(x∗). If f(x∗) is far from zero,then this means that x∗lies far from the hyperplane, and so we can be conﬁdent about our class assignment for x∗. On the other 9.1 Maximal Margin Classiﬁer 341 hand,iff(x∗)isclosetozero,then x∗islocatednearthe hyperplane,andso we are less certain about the class assignment for x∗. Not surprisingly, and as we see in Figure 9.2, a classiﬁer that is based on a separating hyperplane leads to a linear decision boundary. 9.1.3 The Maximal Margin Classiﬁer In general, if our data can be perfectly separated using a hyperplane, then there will in fact exist an inﬁnite number of such hyperplanes. This is becauseagivenseparatinghyperplanecanusuallybeshiftedatinybitupor down,orrotated,without comingintocontactwith anyofthe observations. Three possible separating hyperplanes are shown in the left-hand panel of Figure 9.2. In order to construct a classiﬁer based upon a separating hyperplane, we must have a reasonable way to decide which of the inﬁnite possible separating hyperplanes to use. A natural choice is the maximal margin hyperplane (also known as themaximal margin hyperplaneoptimal separating hyperplane ), which is the separating hyperplane that optimal separating hyperplaneis farthest from the training observations. That is, we can compute the (perpendicular) distance from each training observation to a given separat- ing hyperplane; the smallest such distance is the minimal distance from the observations to the hyperplane, and is known as the margin. The maximalmarginmargin hyperplane is the separating hyperplane for which the margin is largest—that is, it is the hyperplane that has the farthest minimum dis- tance to the training observations. We can then classify a test observation basedonwhichsideofthe maximalmarginhyperplaneitlies.Thisisknown as themaximal margin classiﬁer . We hope that a classiﬁer that has a largemaximal margin classiﬁermargin on the training data will also have a large margin on the test data, and hence will classify the test observa tions correctly. Although the maxi- mal margin classiﬁer is often successful , it can also lead to overﬁtting when pis large. Ifβ0,β1,...,β pare the coeﬃcients of the maximal margin hyperplane, then the maximal margin classiﬁer classiﬁes the test observation x∗based on the sign of f(x∗)=β0+β1x∗ 1+β2x∗ 2+...+βpx∗ p. Figure 9.3 shows the maximal margin hyperplane on the data set of Figure 9.2. Comparing the right-hand panel of Figure 9.2 to Figure 9.3, we see that the maximal margin hyperplane shown in Figure 9.3 does in- deed result in a greater minimal dista nce between the observations and the separating hyperplane—that is, a larger margin. In a sense, the maximal margin hyperplane represents the mid-line of the widest “slab” that we can insert between the two classes. ExaminingFigure9.3,weseethatthreetrainingobservationsareequidis- tant from the maximal margin hyperplane and lie along the dashed lines indicating the width of the margin. These three observations are known as 342 9. Support Vector Machines − 1 0123− 1 0123 X1X2 FIGURE 9.3. There are two classes of observations, shown in blue and in pur- ple. The maximal margin hyperplane is shown as a solid line. The margin is the distance from the solid line to either of the dashed lines. The two blue points and the purple point that lie on the dashed lines are the support vectors, and the distance from those points to the margin is indicated by arrows. The purple and blue grid indicates the decision rule made by a classiﬁer based on this separating hyperplane. support vectors , sincetheyarevectorsin p-dimensionalspace(inFigure9.3,support vector p= 2) and they “support” the maximal margin hyperplane in the sense that if these points were moved slightly then the maximal margin hyper- plane would move as well. Interestingly, the maximal margin hyperplane depends directly on the support vectors, but not on the other observations: amovementtoanyoftheotherobservationswouldnotaﬀecttheseparating hyperplane, provided that the observation’s movement does not cause it to cross the boundary set by the margin. The fact that the maximal margin hyperplane depends directly on only a small subset of the observations is an important property that will arise later in this chapter when we discuss the support vector classiﬁer and support vector machines. 9.1.4 Construction of the Maximal Margin Classiﬁer We now consider the task of constructing the maximal margin hyperplane based on a set of ntraining observations x1,...,x n∈Rpand associated class labels y1,...,y n∈{ −1,1}. Brieﬂy, the maximal margin hyperplane is the solution to the optimization problem 9.1 Maximal Margin Classiﬁer 343 maximize β0,β1,...,βpM (9.9) subject top/summationdisplay j=1β2 j=1, (9.10) yi(β0+β1xi1+β2xi2+...+βpxip)≥M∀i=1,...,n.(9.11) This optimization problem (9.9)–(9.11) is actually simpler than it looks. First of all, the constraint in (9.11) that yi(β0+β1xi1+β2xi2+...+βpxip)≥M∀i=1,...,n guarantees that each observation will be on the correct side of the hyper- plane, provided that Mis positive. (Actually, for each observation to be on the correct side of the hyperplane we would simply need yi(β0+β1xi1+ β2xi2+...+βpxip)>0,so the constraintin (9.11)in factrequiresthateach observation be on the correct side of the hyperplane, with some cushion, provided that Mis positive.) Second,notethat(9.10)isnotreallyaconstraintonthehyperplane,since ifβ0+β1xi1+β2xi2+...+βpxip= 0 deﬁnes a hyperplane, then so does k(β0+β1xi1+β2xi2+...+βpxip) = 0 for any k/negationslash= 0. However, (9.10) adds meaningto(9.11);onecanshowthat with this constraintthe perpendicular distance from the ith observation to the hyperplane is given by yi(β0+β1xi1+β2xi2+...+βpxip). Therefore, the constraints (9.10) and (9.11) ensure that each observation is on the correct side of the hyperplane and at least a distance Mfrom the hyperplane. Hence, Mrepresents the margin of our hyperplane, and the optimizationproblemchooses β0,β1,...,β ptomaximize M.T h i si se x a c t l y the deﬁnition of the maximal marginhyperplane! The problem (9.9)–(9.11) can be solved eﬃciently, but details of this optimization are outside of the scope of this book. 9.1.5 The Non-separable Case The maximal margin classiﬁer is a very natural way to perform classiﬁ- cation,if a separating hyperplane exists . However, as we have hinted, in many cases no separating hyperplane exists, and so there is no maximal margin classiﬁer.In this case,the optimization problem (9.9)–(9.11)has no solution with M>0. An example is shown in Figure 9.4. In this case, we cannotexactlyseparate the two classes. However, as we will see in the next section, we can extend the concept of a separating hyperplane in order to develop a hyperplane that almostseparates the classes, using a so-called soft margin . The generalization of the maximal margin classiﬁer to the non-separable case is known as the support vector classiﬁer . 344 9. Support Vector Machines 0123−1.0 −0.5 0.0 0.5 1.0 1.5 2.0 X1X2 FIGURE 9.4. There are two classes of observations, shown in blue and in pur- ple. In this case, the two classes are not separable by a hyperplane, and so the maximal margin classiﬁer cannot be used. 9.2 Support Vector Classiﬁers 9.2.1 Overview of the Support Vector Classiﬁer In Figure 9.4, we see that observations that belong to two classes are not necessarily separable by a hyperplane . In fact, even if a separating hyper- plane does exist, then there are instances in which a classiﬁer based on a separating hyperplane might not be desirable. A classiﬁer based on a separating hyperplane will necessarily perfectly classify all of the training observations; this can lead to sensitivity to individual observations. An ex- ample is shown in Figure 9.5. The addition of a single observation in the right-hand panel of Figure 9.5 leads to a dramatic change in the maxi- mal margin hyperplane. The resulting maximal margin hyperplane is not satisfactory—for one thing, it has only a tiny margin. This is problematic because as discussed previously, the distance of an observation from the hyperplane can be seen as a measure of our conﬁdence that the obser- vation was correctly classiﬁed. Moreover, the fact that the maximal mar- gin hyperplane is extremely sensitive to a change in a single observation suggests that it may have overﬁt the training data. In this case, we might be willing to consider a classiﬁer based on a hy- perplane that does notperfectly separate the two classes, in the interest of 9.2 Support Vector Classiﬁers 345 − 1 0123− 1 0123 −1 0 1 2 3− 1 0123 X1 X1 X2X2 FIGURE 9.5. Left:Two classes of observations are shown in blue and in purple, along with the maximal margin hyperplane. Right:An additional blue observation has been added, leading to a dramatic shift in the maximal margin hyperplane shown as a solid line. The dashed line indicates the maximal margin hyperplane that was obtained in the absence of this additional point. •Greater robustness to individual observations, and •Better classiﬁcation of mostof the training observations. That is, it could be worthwhile to misclassify a few training observations in order to do a better job in classifying the remaining observations. Thesupport vector classiﬁer , sometimes called a soft margin classiﬁer ,support vector classiﬁer soft margin classiﬁerdoes exactly this. Rather than seekin g the largest possible margin so that every observation is not only on the correct side of the hyperplane but also on the correct side of the margin, we instead allow some observations to be on the incorrect side of the margin, or even the incorrect side of the hyperplane. (The margin is softbecause it can be violated by some of the training observations.) An example is shown in the left-hand panel ofFigure9.6.Mostoftheobservationsareonthecorrectsideofthemargin. However, a small subset of the observations are on the wrong side of the margin. An observation can be not only on the wrong side of the margin, but also on the wrong side of the hyperplane. In fact, when there is no separating hyperplane,suchasituationisinevitable.Observationsonthewrongsideof thehyperplanecorrespondtotrainingobservationsthataremisclassiﬁedby the support vector classiﬁer. The right-hand panel of Figure 9.6 illustrates such a scenario. 9.2.2 Details of the Support Vector Classiﬁer The support vector classiﬁer classiﬁes a test observation depending on which side of a hyperplane it lies. The hyperplane is chosen to correctly 346 9. Support Vector Machines −0.5 0.0 0.5 1.0 1.5 2.0 2.5− 1 012341 23 45 67 8910 −0.5 0.0 0.5 1.0 1.5 2.0 2.5− 1 012341 23 45 67 8910 11 12 X1 X1 X2X2 FIGURE 9.6. Left:A support vector classiﬁer was ﬁt to a small data set. The hyperplane is shown as a solid line and the margins are shown as dashed lines. Purple observations: Observations 3,4,5,a n d6are on the correct side of the margin, observation 2is on the margin, and observation 1 is on the wrong side of the margin. Blue observations: Observations 7and10are on the correct side of the margin, observation 9is on the margin, and observation 8is on the wrong side of the margin. No observations are on the wrong side of the hyperplane. Right: Same as left panel with two additional points, 11and12. These two observations are on the wrong side of the hyperplane and the wrong side of the margin. separate most of the training observations into the two classes, but may misclassifyafewobservations.Itisthesolutiontotheoptimizationproblem maximize β0,β1,...,βp,/epsilon11,...,/epsilon1nM (9.12) subject top/summationdisplay j=1β2 j=1, (9.13) yi(β0+β1xi1+β2xi2+...+βpxip)≥M(1−/epsilon1i),(9.14) /epsilon1i≥0,n/summationdisplay i=1/epsilon1i≤C, (9.15) whereCis a nonnegative tuning parameter. As in (9.11), Mis the width of the margin; we seek to make this quantity as large as possible. In (9.14), /epsilon11,...,/epsilon1 nareslack variables that allow individual observations to be onslack variable the wrong side of the margin or the hyperplane; we will explain them in greater detail momentarily. Once we have solved (9.12)–(9.15), we classify a test observation x∗as before, by simply determining on which side of the hyperplane it lies. That is, we classify the test observation based on the sign off(x∗)=β0+β1x∗ 1+...+βpx∗ p. The problem (9.12)–(9.15) seems complex, but insight into its behavior can be made through a series of simple observations presented below. First of all, the slack variable /epsilon1itells us where the ith observation is located, relative to the hyperplane and relative to the margin. If /epsilon1i= 0 then the ith 9.2 Support Vector Classiﬁers 347 observation is on the correct side of the margin, as we saw in Section 9.1.4. If/epsilon1i>0 then the ith observation is on the wrong side of the margin, and we say that the ith observation has violated the margin. If /epsilon1i>1t h e ni t is on the wrong side of the hyperplane. We now consider the role of the tuning parameter C. In (9.14), Cbounds the sum of the /epsilon1i’s, and so it determines the number and severityof the vio- lations to the margin (and to the hyperplane) that we will tolerate. We can think of Cas abudgetfor the amount that the margin can be violated by thenobservations. If C= 0 then there is no budget for violations to the margin, and it must be the case that /epsilon11=...=/epsilon1n=0 ,i nw h i c hc a s e (9.12)–(9.15)simply amounts to the maximal margin hyperplane optimiza- tion problem (9.9)–(9.11). (Of course, a maximal margin hyperplane exists only if the two classes are separable.) For C>0n om o r et h a n Cobserva- tions can be on the wrong side of the hyperplane, because if an observation is on the wrong side of the hyperplane then /epsilon1i>1, and (9.14) requires that/summationtextn i=1/epsilon1i≤C. As the budget Cincreases, we become more tolerant of violations to the margin, and so the margin will widen. Conversely, as C decreases, we become less tolerant of violations to the margin and so the margin narrows. An example in shown in Figure 9.7. Inpractice, Cistreatedasatuningparameterthatisgenerallychosenvia cross-validation.As with the tuning parametersthat we have seen through- out this book, Ccontrols the bias-variancetrade-oﬀ of the statistical learn- ing technique. When Cis small, we seek narrow margins that are rarely violated; this amounts to a classiﬁer that is highly ﬁt to the data, which may have low bias but high variance. On the other hand, when Cis larger, the margin is wider and we allow more violations to it; this amounts to ﬁtting the data less hard and obtaining a classiﬁer that is potentially more biased but may have lower variance. The optimization problem (9.12)–(9.15) has a very interesting property: it turns out that only observations that either lie on the margin or that violate the margin will aﬀect the hyp erplane, and hence the classiﬁer ob- tained. In other words, an observation that lies strictly on the correct side of the margin does not aﬀect the support vector classiﬁer! Changing the position of that observation would not change the classiﬁer at all, provided that its position remains on the correct side of the margin. Observations that lie directly on the margin, or on the wrong side of the margin for their class, are known as support vectors . These observations do aﬀect the support vector classiﬁer. The fact that only support vectors aﬀect the classiﬁer is in line with our previousassertionthat Ccontrolsthebias-variancetrade-oﬀofthesupport vector classiﬁer. When the tuning parameter Cis large, then the margin is wide, many observationsviolatethe margin,and so there aremany support vectors. In this case, many observations are involved in determining the hyperplane. The top left panel in Figure 9.7 illustrates this setting: this classiﬁer has low variance (since many observations are support vectors) 348 9. Support Vector Machines −1 0 1 2− 3 − 2 − 1 0123 −1 0 1 2− 3 − 2 − 1 0123 −1 0 1 2−3 −2 −1 0 1 2 3 −1 0 1 2−3 −2 −1 0 1 2 3 X1 X1X1 X1 X2X2 X2X2 FIGURE 9.7. A support vector classiﬁer was ﬁt using four diﬀerent values of the tuning parameter Cin (9.12)–(9.15). The largest value of Cwas used in the top left panel, and smaller values were used in the top right, bottom left, and bottom right panels. When Cis large, then there is a high tolerance for observations being on the wrong side of the margin, and so the margin will be large. As Cdecreases, the tolerance for observations being on the wrong side of the margin decreases, and the margin narrows. but potentially high bias. In contrast, if Cis small, then there will be fewer support vectors and hence the resulting classiﬁer will have low bias but high variance. The bottom right panel in Figure 9.7 illustrates this setting, with only eight support vectors. The fact that the support vector classiﬁer’s decision rule is based only on a potentially small subset of the training observations (the support vec- tors) means that it is quite robust to the behavior of observations that are far away from the hyperplane. This property is distinct from some of the other classiﬁcation methods th at we have seen in preceding chapters, such as linear discriminant analysis. Recall that the LDA classiﬁcation rule 9.3 Support Vector Machines 349 −4 −2 0 2 4−4 −2 0 2 4 −4 −2 0 2 4−4 −2 0 2 4 X1 X1 X2X2 FIGURE 9.8. Left:The observations fall into two classes, with a non-linear boundary between them. Right:The support vector classiﬁer seeks a linear bound- ary, and consequently performs very poorly. depends on the mean of allof the observations within each class, as well as the within-class covariance matrix computed using allof the observations. In contrast, logistic regression, unlike LDA, has very low sensitivity to ob- servations far from the decision boundary. In fact we will see in Section 9.5 that the support vector classiﬁer and logistic regression are closely related. 9.3 Support Vector Machines We ﬁrst discuss a general mechanism for converting a linear classiﬁer into one that produces non-linear decision boundaries. We then introduce the support vector machine, which does this in an automatic way. 9.3.1 Classiﬁcation with Non-linear Decision Boundaries The support vector classiﬁer is a natural approach for classiﬁcation in the two-class setting, if the boundary between the two classes is linear. How- ever, in practice we are sometimes faced with non-linear class boundaries. For instance, consider the data in the left-hand panel of Figure 9.8. It is clear that a support vector classiﬁe r or any linear classiﬁer will perform poorly here. Indeed, the support vector classiﬁer shown in the right-hand panel of Figure 9.8 is useless here. In Chapter 7, we are faced with an analogous situation. We see there that the performance of linear regre ssion can suﬀer when there is a non- linear relationship between the predi ctors and the outcome. In that case, we consider enlarging the feature space using functions of the predictors, 350 9. Support Vector Machines such as quadratic and cubic terms, in order to address this non-linearity. In the case of the support vector classiﬁer, we could address the prob- lem of possibly non-linear boundaries between classes in a similar way, by enlarging the feature space using quadratic, cubic, and even higher-order polynomial functions of the predictors. For instance, rather than ﬁtting a support vector classiﬁer using pfeatures X1,X2,...,X p, we could instead ﬁt a support vector classiﬁer using 2 pfeatures X1,X2 1,X2,X2 2,...,X p,X2 p. Then (9.12)–(9.15) would become maximize β0,β11,β12....,βp1,βp2,/epsilon11,...,/epsilon1nM (9.16) subject to yi⎛ ⎝β0+p/summationdisplay j=1βj1xij+p/summationdisplay j=1βj2x2 ij⎞ ⎠≥M(1−/epsilon1i), n/summationdisplay i=1/epsilon1i≤C, /epsilon1i≥0,p/summationdisplay j=12/summationdisplay k=1β2 jk=1. Why does this lead to a non-linear decision boundary? In the enlarged feature space, the decision boundary that results from (9.16) is in fact lin- ear. But in the original feature space, the decision boundary is of the form q(x)=0 ,w h e r e qis a quadratic polynomial, and its solutions are gener- ally non-linear. One might additionally want to enlarge the feature space with higher-order polynomial terms, or with interaction terms of the form XjXj/primeforj/negationslash=j/prime. Alternatively, other functions of the predictors could be considered rather than polynomi als. It is not hard to see that there are many possible ways to enlarge the feature space, and that unless we are careful, we could end up with a huge number of features. Then compu- tations would become unmanageable. The support vector machine, which we present next, allows us to enlarge the feature space used by the support vector classiﬁer in a way that l eads to eﬃcient computations. 9.3.2 The Support Vector Machine Thesupport vector machine (SVM) is an extension of the support vectorsupport vector machineclassiﬁer that results from enlarging the feature space in a speciﬁc way, usingkernels. We will now discuss this extension, the details of which are kernelsomewhat complex and beyond the sco pe of this book. However, the main idea is described in Section 9.3.1: we may want to enlarge our feature space 9.3 Support Vector Machines 351 in order to accommodate a non-linear boundary between the classes. The kernel approach that we describe here is simply an eﬃcient computational approach for enacting this idea. We have not discussed exactly how the support vector classiﬁer is com- puted because the details become somewhat technical. However, it turns out that the solution to the support vector classiﬁer problem (9.12)–(9.15) involves only the inner products of the observations (as opposed to the observations themselves). The inner product of two r-vectors aandbis deﬁned as /angbracketlefta,b/angbracketright=/summationtextr i=1aibi. Thus the inner product of two observations xi,xi/primeis given by /angbracketleftxi,xi/prime/angbracketright=p/summationdisplay j=1xijxi/primej. (9.17) It can be shown that •The linear support vector classiﬁer can be represented as f(x)=β0+n/summationdisplay i=1αi/angbracketleftx,xi/angbracketright, (9.18) where there are nparameters αi,i=1,...,n, one per training observation. •To estimate the parameters α1,...,α nandβ0, all we need are the/parenleftbign 2/parenrightbig inner products /angbracketleftxi,xi/prime/angbracketrightbetween all pairs of training observations. (The notation/parenleftbign 2/parenrightbig meansn(n−1)/2, and gives the number of pairs among a set of nitems.) Notice that in (9.18), in order to evaluate the function f(x), we need to computetheinnerproductbetweenthenewpoint xandeachofthetraining pointsxi. However, it turns out that αiis nonzero only for the support vectors in the solution—that is, if a training observation is not a support vector, then its αiequals zero. So if Sis the collection of indices of these support points, we can rewrite any solution function of the form (9.18) as f(x)=β0+/summationdisplay i∈Sαi/angbracketleftx,xi/angbracketright, (9.19) which typically involves far fewer terms than in (9.18).2 Tosummarize,inrepresenti ngthelinearclassiﬁer f(x),andincomputing its coeﬃcients, all we need are inner products. Now suppose that every time the inner product (9.17) appears in the representation (9.18), or in a calculation of the solution for the support 2By expanding each of the inner products in (9.19), it is easy to see that f(x)i s a linear function of the coordinates of x. Doing so also establishes the correspondence between the αiand the original parameters βj. 352 9. Support Vector Machines vector classiﬁer, we replace it with a generalization of the inner product of the form K(xi,xi/prime), (9.20) whereKis some function that we will refer to as a kernel. A kernel is akernelfunction that quantiﬁes the similarity of two observations. For instance, we could simply take K(xi,xi/prime)=p/summationdisplay j=1xijxi/primej, (9.21) which would just give us back the support vector classiﬁer. Equation 9.21 is known as a linearkernel because the support vector classiﬁer is linear in the features; the linear kernel essentially quantiﬁes the similarity of a pair of observations using Pearson (standard) correlation. But one could instead choose another form for (9.20). For instance, one could replace every instance of/summationtextp j=1xijxi/primejwith the quantity K(xi,xi/prime)=( 1+p/summationdisplay j=1xijxi/primej)d. (9.22) This is known as a polynomial kernel of degree d,w h e r edis a positivepolynomial kernel integer. Using such a kernel with d>1, instead of the standard linear kernel(9.21),inthesupportvectorclassiﬁeralgorithmleadstoamuchmore ﬂexible decisionboundary.It essentiallyamountsto ﬁtting asupport vector classiﬁer in a higher-dimensional space involving polynomials of degree d, rather than in the originalfeature sp ace. When the supportvector classiﬁer is combinedwith anon-linearkernelsuchas(9.22),theresultingclassiﬁeris known as a support vector machine. Note that in this case the (non-linear) function has the form f(x)=β0+/summationdisplay i∈SαiK(x,xi). (9.23) The left-hand panel of Figure 9.9 shows an example of an SVM with a polynomial kernel applied to the non-linear data from Figure 9.8. The ﬁt is a substantial improvement over the linear support vector classiﬁer. When d= 1, then the SVM reduces to the suppor t vector classiﬁer seen earlier in this chapter. The polynomial kernel shown in (9.22) is one example of a possible non-linear kernel, but alternatives abound. Another popular choice is the radial kernel , which takes the formradial kernel K(xi,xi/prime)=e x p (−γp/summationdisplay j=1(xij−xi/primej)2). (9.24) 9.3 Support Vector Machines 353 −4 −2 0 2 4−4 −2 0 2 4 −4 −2 0 2 4−4 −2 0 2 4 X1 X1 X2X2 FIGURE 9.9. Left:An SVM with a polynomial kernel of degree 3 is applied to the non-linear data from Figure 9.8, resulting in a far more appropriate decision rule.Right:An SVM with a radial kernel is applied. In this example, either kernel is capable of capturing the decision boundary. In (9.24), γis a positive constant. The right-handpanel of Figure9.9 shows an example of an SVM with a radial kernel on this non-linear data; it also does a good job in separating the two classes. How does the radial kernel (9.24) actually work? If a given test obser- vationx∗=(x∗ 1...x∗ p)Tis far from a training observation xiin terms of Euclidean distance, then/summationtextp j=1(x∗ j−xij)2will be large, and so K(x∗,xi)= exp(−γ/summationtextp j=1(x∗ j−xij)2) will be very tiny. This means that in (9.23), xi will play virtually no role in f(x∗). Recall that the predicted class label for the test observation x∗is based on the sign of f(x∗). In other words, training observations that are far from x∗will play essentially no role in the predicted class label for x∗. This means that the radial kernel has very localbehavior, in the sense that only nearby training observations have an eﬀect on the class label of a test observation. What is the advantage of using a kernel rather than simply enlarging the feature space using functions of the original features, as in (9.16)? One advantage is computational, and it amounts to the fact that using kernels, one need only compute K(xi,x/prime i) for all/parenleftbign 2/parenrightbig distinct pairs i, i/prime.T h i sc a nb e done without explicitly working in the enlarged feature space. This is im- portant because in many applications of SVMs, the enlarged feature space is so large that computations are intractable. For some kernels, such as the radial kernel (9.24), the feature space is implicitand inﬁnite-dimensional, so we could never do the computations there anyway! 354 9. Support Vector Machines False positive rateTrue positive rate 0.0 0.2 0.4 0.6 0.8 1.00.0 0.2 0.4 0.6 0.8 1.0Support Vector Classifier LDA False positive rateTrue positive rate 0.0 0.2 0.4 0.6 0.8 1.00.0 0.2 0.4 0.6 0.8 1.0Support Vector Classifier SVM: γ=10−3 SVM: γ=10−2 SVM: γ=10−1 FIGURE 9.10. ROC curves for the Heartdata training set. Left:The support vector classiﬁer and LDA are compared. Right:The support vector classiﬁer is compared to an SVM using a radial basis kernel with γ=1 0−3,10−2,a n d10−1. 9.3.3 An Application to the Heart Disease Data In Chapter 8 we apply decision trees and related methods to the Heart data. The aim is to use 13 predictors such as Age,Sex,a n d Cholin order to predict whether an individual has heart disease. We now investigate how an SVM compares to LDA on this data. The data consist of 297 subjects, which we randomly split into 207 training and 90 test observations. We ﬁrst ﬁt LDA and the support vector classiﬁer to the training data. Note that the support vector classiﬁer is equivalent to a SVM using a poly- nomial kernel of degree d= 1. The left-hand panel of Figure 9.10 displays ROC curves (described in Section 4.4.3) for the training set predictions for both LDA and the support vector classiﬁer. Both classiﬁers compute scores of the form ˆf(X)=ˆβ0+ˆβ1X1+ˆβ2X2+...+ˆβpXpfor each observation. For any given cutoﬀ t, we classify observations into the heart disease or no heart disease categories depending on whether ˆf(X)<torˆf(X)≥t. The ROC curve is obtained by forming these predictions and computing the false positive and true positive rates for a range of values of t.A no p t i - mal classiﬁer will hug the top left corner of the ROC plot. In this instance LDA and the support vector classiﬁer both perform well, though there is a suggestion that the support vector cl assiﬁer may be slightly superior. The right-handpanel ofFigure9.10displays ROCcurves for SVMs using a radialkernel,with various values of γ.A sγincreasesand the ﬁt becomes more non-linear, the ROC curves improve. Using γ=1 0−1appears to give an almost perfect ROC curve. However, these curves represent training error rates, which can be misleadin g in terms of performance on new test data. Figure 9.11 displays ROC curv es computed on the 90 test observa- tions. We observe some diﬀerences fr om the training ROC curves. In the 9.4 SVMs with More than Two Classes 355 False positive rateTrue positive rate 0.0 0.2 0.4 0.6 0.8 1.00.0 0.2 0.4 0.6 0.8 1.0Support Vector Classifier LDA False positive rateTrue positive rate 0.0 0.2 0.4 0.6 0.8 1.00.0 0.2 0.4 0.6 0.8 1.0Support Vector Classifier SVM: γ=10−3 SVM: γ=10−2 SVM: γ=10−1 FIGURE 9.11. ROC curves for the test set of the Heartdata.Left:The support vector classiﬁer and LDA are compared. Right:The support vector classiﬁer is compared to an SVM using a radial basis kernel with γ=1 0−3,10−2,a n d10−1. left-hand panel of Figure 9.11, the support vector classiﬁer appears to have a small advantage over LDA (although these diﬀerences are not statisti- cally signiﬁcant). In the right-hand panel, the SVM using γ=1 0−1,w h i c h showed the best results on the training data, produces the worst estimates on the test data. This is once again evidence that while a more ﬂexible method will often produce lower training error rates, this does not neces- sarilylead toimprovedperformanceontest data.The SVMs with γ=1 0−2 andγ=1 0−3perform comparably to the support vector classiﬁer, and all three outperform the SVM with γ=1 0−1. 9.4 SVMs with More than Two Classes So far, our discussion has been limited to the case of binary classiﬁcation: that is, classiﬁcation in the two-class setting. How can we extend SVMs to the more general case where we hav e some arbitrary number of classes? It turns out that the concept of separating hyperplanes upon which SVMs are based does not lend itself naturally to more than two classes. Though a number of proposals for extending SVMs to the K-class case have been made, the two most popular are the one-versus-one andone-versus-all approaches. We brieﬂy discuss those two approaches here. 9.4.1 One-Versus-One Classiﬁcation Suppose that we would like to perform classiﬁcationusing SVMs, and there areK>2 classes. A one-versus-one orall-pairs approach constructs/parenleftbigK 2/parenrightbig one-versus- one SVMs, each of which compares a pair of classes. For example, one such 356 9. Support Vector Machines SVM might compare the kth class, coded as +1, to the k/primeth class, coded as−1. We classify a test observation using each of the/parenleftbigK 2/parenrightbig classiﬁers, and we tally the number of times that the test observation is assigned to each of theKclasses. The ﬁnal classiﬁcation i s performed by assigning the test observation to the class to which it was most frequently assigned in these/parenleftbigK 2/parenrightbig pairwise classiﬁcations. 9.4.2 One-Versus-All Classiﬁcation Theone-versus-all approach is an alternative procedure for applying SVMsone-versus- all in the case of K>2 classes. We ﬁt KSVMs, each time comparing one of theKclasses to the remaining K−1 classes. Let β0k,β1k,...,β pkdenote the parameters that result from ﬁtting an SVM comparing the kth class (coded as+1)tothe others(coded as −1).Letx∗denote atest observation. We assign the observation to the class for which β0k+β1kx∗ 1+β2kx∗ 2+...+ βpkx∗ pis largest, as this amounts to a high level of conﬁdence that the test observation belongs to the kth class rather than to any of the other classes. 9.5 Relationship to Logistic Regression When SVMs were ﬁrst introduced in the mid-1990s, they made quite a splash in the statistical and machine learning communities. This was due in part to their good performance, g ood marketing, and also to the fact that the underlying approach seemed both novel and mysterious. The idea of ﬁnding a hyperplane that separates the data as well as possible, while al- lowing some violations to this separation, seemed distinctly diﬀerent from classical approaches for classiﬁcation, such as logistic regression and lin- ear discriminant analysis. Moreover, the idea of using a kernel to expand the feature space in order to accommodate non-linear class boundaries ap- peared to be a unique and valuable characteristic. However, since that time, deep connections between SVMs and other more classical statistical methods have emerged. It turns out that one can rewrite the criterion (9.12)–(9.15) for ﬁtting the support vector classiﬁer f(X)=β0+β1X1+...+βpXpas minimize β0,β1,...,βp⎧ ⎨ ⎩n/summationdisplay i=1max[0,1−yif(xi)]+λp/summationdisplay j=1β2 j⎫ ⎬ ⎭,(9.25) 9.5 Relationship to Logistic Regression 357 whereλis a nonnegative tuning parameter.When λis largethen β1,...,β p are small, more violations to the margin are tolerated, and a low-variance but high-bias classiﬁer will result. When λis small then few violations to the margin will occur; this amounts to a high-variance but low-bias classiﬁer. Thus, a small value of λin (9.25) amounts to a small value of C in (9.15). Note that the λ/summationtextp j=1β2 jterm in (9.25) is the ridge penalty term from Section 6.2.1, and plays a similar role in controlling the bias-variance trade-oﬀ for the support vector classiﬁer. Now(9.25)takesthe“Loss+Penalty”formthatwehaveseenrepeatedly throughout this book: minimize β0,β1,...,βp{L(X,y,β)+λP(β)}. (9.26) In (9.26), L(X,y,β) is some loss function quantifying the extent to which the model, parametrized by β, ﬁts the data ( X,y), andP(β) is a penalty function on the parameter vector βwhose eﬀect is controlled by a nonneg- ative tuning parameter λ. For instance, ridge regression and the lasso both take this form with L(X,y,β)=n/summationdisplay i=1⎛ ⎝yi−β0−p/summationdisplay j=1xijβj⎞ ⎠2 and with P(β)=/summationtextp j=1β2 jfor ridge regression and P(β)=/summationtextp j=1|βj|for the lasso. In the case of (9.25) the loss function instead takes the form L(X,y,β)=n/summationdisplay i=1max[0,1−yi(β0+β1xi1+...+βpxip)]. This is known as hinge loss , and is depicted in Figure 9.12. However, ithinge lossturns out that the hinge loss function is closely related to the loss function used in logistic regression, also shown in Figure 9.12. An interesting characteristic of the support vector classiﬁer is that only support vectors play a role in the classiﬁer obtained; observations on the correct side of the margin do not aﬀect it. This is due to the fact that the loss function shown in Figure 9.12 is exactly zero for observationsfor which yi(β0+β1xi1+...+βpxip)≥1; these correspond to observations that are on the correct side of the margin.3In contrast, the loss function for logistic regression shown in Figure 9.12 is not exactly zero anywhere. But it is very small for observations that are far from the decision boundary. Due to the similarities between their loss functions, logistic regressionand the support vector classiﬁer often give very sim ilar results. When the classes are well separated, SVMs tend to behave better than logistic regression; in more overlapping regimes, logistic regression is often preferred. 3With this hinge-loss + penalty representation, the margin corresponds to the value one, and the width of the margin is determined by/summationtextβ2 j. 358 9. Support Vector Machines −6 −4 −2 0 202468LossSVM Loss Logistic Regression Loss yi(β0+β1xi1+...+βpxip) FIGURE 9.12. The SVM and logistic regression loss functions are compared, as a function of yi(β0+β1xi1+...+βpxip).W h e nyi(β0+β1xi1+...+βpxip)is greater than 1, then the SVM loss is zero, since this corresponds to an observation that is on the correct side of the margin. Overall, the two loss functions have quite similar behavior. When the support vector classiﬁer a nd SVM were ﬁrst introduced, it was thought that the tuning parameter Cin (9.15) was an unimportant “nui- sance” parameter that could be set to s ome default value, like 1. However, the “Loss + Penalty” formulation (9.25) for the support vector classiﬁer indicates that this is not the case. The choice of tuning parameter is very important and determines the extent to which the model underﬁts or over- ﬁts the data, as illustrated, for example, in Figure 9.7. We have established that the support vector classiﬁer is closely related to logistic regression and other preexisting statistical methods. Is the SVM unique in its use of kernels to enlarge the feature space to accommodate non-linear class boundaries? The answer to this question is “no”. We could just as well perform logistic regression or many of the other classiﬁcation methods seen in this book using non-linear kernels; this is closely related to some of the non-linear approaches seen in Chapter 7. However, for his- torical reasons, the use of non-linear kernels is much more widespread in the context of SVMs than in the context of logistic regression or other methods. Though we have not addressed it her e, there is in fact an extension of the SVM for regression (i.e. for a quantitative rather than a qualita- tive response), called support vector regression . In Chapter 3, we saw thatsupport vector regressionleast squares regression seeks coeﬃcients β0,β1,...,β psuch that the sum of squared residuals is as small as possible. (Recall from Chapter 3 that residuals are deﬁned as yi−β0−β1xi1−···−βpxip.) Support vector regression instead seeks coeﬃcients that minimize a diﬀerent type of loss, where only residuals larger in absolute value than some positive constant 9.6 Lab: Support Vector Machines 359 contribute to the loss function. This is an extension of the margin used in support vector classiﬁers to the regression setting. 9.6 Lab: Support Vector Machines We use the e1071library in Rto demonstrate the support vector classiﬁer and the SVM. Another option is the LiblineaR library, which is useful for very large linear problems. 9.6.1 Support Vector Classiﬁer The e1071library contains implementations for a number of statistical learning methods. In particular, the svm()function can be used to ﬁt asvm()support vector classiﬁer when the argument kernel=\"linear\" is used. This function uses a slightly diﬀerent formulation from (9.14) and (9.25) for the support vector classiﬁer. A costargument allows us to specify the cost of a violation to the margin. When the costargument is small, then the mar- gins will be wide and many support vectors will be on the margin or will violate the margin. When the costargument is large, then the margins will be narrow and there will be few support vectors on the margin or violating the margin. We now use the svm()function to ﬁt the support vector classiﬁer for a given value of the costparameter. Here we demonstrate the use of this function on a two-dimensional example so that we can plot the resulting decision boundary. We begin by generating the observations, which belong to two classes. > set.seed(1) > x=matrix(rnorm(20*2), ncol=2) > y=c(rep(-1,10), rep(1,10)) > x[y==1,]=x[y==1,] + 1 We begin by checking whether the classes are linearly separable. > plot(x, col=(3-y)) They are not. Next, we ﬁt the support vector classiﬁer. Note that in order for the svm()function to perform classiﬁcation (as opposed to SVM-based regression), we must encode the res ponse as a factor variable. We now create a data frame with the response coded as a factor. > dat=data.frame(x=x, y=as.factor(y)) > library(e1071) > svmfit=svm(y ∼., data=dat, kernel=\"linear\", cost=10, scale=FALSE) 360 9. Support Vector Machines The argument scale=FALSE tells the svm()function not to scale each feature to havemean zero orstandard deviation one; depending on the application, one might prefer to use scale=TRUE . We can now plot the support vector classiﬁer obtained: > plot(svmfit , dat) Note that the two arguments to the plot.svm() function are the output of the call to svm(), as well as the data used in the call to svm().T h e region of feature space that will be assigned to the −1 class is shown in light blue, and the region that will be assigned to the +1 class is shown in purple.Thedecisionboundarybetweenthe twoclassesislinear(becausewe used the argument kernel=\"linear\" ), though due to the way in which the plotting function is implemented in this librarythe decisionboundarylooks somewhat jagged in the plot. We see that in this case only one observation is misclassiﬁed. (Note that here the second feature is plotted on the x-axis and the ﬁrst feature is plotted on the y-axis, in contrast to the behavior of the usual plot()function in R.) The support vectors are plotted as crosses and the remainingobservationsareplo tted ascircles; wesee here thatthere are seven support vectors. We can deter mine their identities as follows: > svmfit$index [1] 1 2 5 7 14 16 17 We can obtain some basic information about the support vector classiﬁer ﬁt using the summary() command: > summary(svmfit) Call: svm(formula = y ∼., data = dat, kernel = \"linear\", cost = 10, scale = FALSE) Parameters : SVM-Type: C- classification SVM-Kernel: linear cost: 10 gamma: 0.5 Number of Support Vectors: 7 (43) Number of Classes: 2 Levels: -1 1 This tells us, for instance, that a linear kernel was used with cost=10,a n d that there were seven support vector s, four in one class and three in the other. What if we instead used a smaller value of the cost parameter? > svmfit=svm(y ∼., data=dat, kernel=\"linear\", cost =0.1, scale=FALSE) > plot(svmfit , dat) > svmfit$index [ 1 ]1234579 1 0 1 2 1 3 1 4 1 5 1 6 1 7 1 8 2 0 9.6 Lab: Support Vector Machines 361 Now that a smaller value of the cost parameter is being used, we obtain a larger number of support vectors, beca use the margin is now wider. Unfor- tunately, the svm()function does not explicitly output the coeﬃcients of the linear decision boundary obtained when the support vector classiﬁer is ﬁt, nor does it output the width of the margin. The e1071library includes a built-in function, tune(), to perform cross-tune()validation. By default, tune()performs ten-fold cross-validation on a set of models of interest. In order to use this function, we pass in relevant information about the set of models that are under consideration. The following command indicates that we want to compare SVMs with a linear kernel, using a range of values of the costparameter. > set.seed(1) > tune.out=tune(svm,y ∼.,data=dat,kernel=\"linear\", ranges=list(cost=c (0.001, 0.01, 0.1, 1,5,10,100) )) We can easily access the cross-validat ion errors for each of these models using the summary() command: > summary(tune.out) Parameter tuning of ’svm’: - sampling method: 10-fold cross validation - best parameters : cost 0.1 - best performance : 0.1 - Detailed performance results: cost error dispersion 1 1e-03 0.70 0.422 2 1e-02 0.70 0.422 3 1e-01 0.10 0.211 4 1e+00 0.15 0.242 5 5e+00 0.15 0.242 6 1e+01 0.15 0.242 7 1e+02 0.15 0.242 We see that cost=0.1 results in the lowest cross-validation error rate. The tune()function stores the best model obtained, which can be accessed as follows: > bestmod=tune.out$best.model > summary(bestmod) The predict() function can be used to predict the class label on a set of test observations, at any given value of the cost parameter. We begin by generating a test data set. > xtest=matrix(rnorm(20*2), ncol=2) > ytest=sample(c(-1,1), 20, rep=TRUE) > xtest[ytest==1,]=xtest[ytest==1,] + 1 > testdat=data.frame(x= xtest , y=as. factor(ytest)) Now we predict the class labels of thes e test observations. Here we use the best model obtained through cross-validation in order to make predictions. 362 9. Support Vector Machines > ypred=predict(bestmod ,testdat) > table(predict=ypred , truth=testdat$y ) truth predict -1 1 -1 11 1 10 8 Thus, with this value of cost, 19 of the test observations are correctly classiﬁed. What if we had instead used cost=0.01 ? > svmfit=svm(y ∼., data=dat, kernel=\"linear\", cost =.01, scale=FALSE) > ypred=predict(svmfit ,testdat) > table(predict=ypred , truth=testdat$y ) truth predict -1 1 -1 11 2 10 7 In this case one additional observation is misclassiﬁed. Now consider a situation in which the two classes are linearly separable. Then we can ﬁnd a separating hyperplane using the svm()function. We ﬁrst further separate the two classes in our simulated data so that they are linearly separable: > x[y==1,]=x[y==1,]+0.5 > plot(x, col=(y+5)/2, pch=19) Now the observations are just barely linearly separable. We ﬁt the support vector classiﬁer and plot the resulting hyperplane, using a very large value ofcostso that no observations are misclassiﬁed. > dat=data.frame(x=x,y=as.factor(y)) > svmfit=svm(y ∼., data=dat, kernel=\"linear\", cost=1e5) > summary(svmfit) Call: svm(formula = y ∼., data = dat, kernel = \"linear\", cost = 1e +05) Parameters : SVM-Type: C- classification SVM-Kernel: linear cost: 1e+05 gamma: 0.5 Number of Support Vectors: 3 (12) Number of Classes: 2 Levels: -1 1 > plot(svmfit , dat) No training errors were made and only three support vectors were used. However,wecanseefromtheﬁgurethatthemarginisverynarrow(because the observations that are not support vectors, indicated as circles, are very 9.6 Lab: Support Vector Machines 363 close to the decision boundary). It seems likely that this model will perform poorly on test data. We now try a smaller value of cost: > svmfit=svm(y ∼., data=dat, kernel=\"linear\", cost=1) > summary(svmfit) > plot(svmfit ,dat) Using cost=1, we misclassify a training observation, but we also obtain a much wider margin and make use of seven support vectors. It seems likely that this model will perform better on test data than the model with cost=1e5 . 9.6.2 Support Vector Machine InordertoﬁtanSVMusinganon-linearkernel,weonceagainusethe svm() function. However, now we use a diﬀerent value of the parameter kernel. To ﬁt an SVM with a polynomial kernel we use kernel=\"polynomial\" ,a n d to ﬁt an SVM with a radial kernel we use kernel=\"radial\" .I nt h ef o r m e r case we also use the degreeargument to specify a degree for the polynomial kernel (this is din (9.22)), and in the latter case we use gammato specify a value ofγfor the radial basis kernel (9.24). We ﬁrst generate some data with a non-linear class boundary, as follows: > set.seed(1) > x=matrix(rnorm(200*2), ncol=2) > x[1:100,]=x[1:100,]+2 > x[101:150,]=x[101:150,]-2 > y=c(rep(1,150) ,rep(2,50)) > dat=data.frame(x=x,y=as.factor(y)) Plotting the data makes it clear that the class boundary is indeed non- linear: > plot(x, col=y) The data is randomly split into training and testing groups. We then ﬁt the training data using the svm()function with a radial kernel and γ=1 : > train=sample(200,100) > svmfit=svm(y ∼., data=dat[train ,], kernel=\"radial\", gamma=1, cost=1) > plot(svmfit , dat[train ,]) The plot shows that the resulting SVM has a decidedly non-linear boundary. The summary() f u n c t i o nc a nb eu s e dt oo b t a i ns o m e information about the SVM ﬁt: > summary(svmfit) Call: svm(formula = y ∼., data = dat, kernel = \"radial\", gamma = 1, cost = 1) Parameters : SVM-Type: C- classification 364 9. Support Vector Machines SVM-Kernel: radial cost: 1 gamma: 1 Number of Support Vectors: 37 (1 72 0) Number of Classes: 2 Levels: 12 We can see from the ﬁgure that there are a fair number of training errors in this SVM ﬁt. If we increase the value of cost, we can reduce the number of training errors. However, this comes at the price of a more irregular decision boundary that seems to be at risk of overﬁtting the data. > svmfit=svm(y ∼., data=dat[train ,], kernel=\"radial\",gamma=1, cost=1e5) > plot(svmfit ,dat[train ,]) We can perform cross-validation using tune()to select the best choice of γand costfor an SVM with a radial kernel: > set.seed(1) > tune.out=tune(svm, y ∼., data=dat[train ,], kernel=\"radial\", ranges=list(cost=c(0.1,1,10,100,1000), gamma=c(0.5,1,2,3,4))) > summary(tune.out) Parameter tuning of ’svm’: - sampling method: 10-fold cross validation - best parameters : cost gamma 12 - best performance : 0.12 - Detailed performance results: cost gamma error dispersion 1 1e-01 0.5 0.27 0.1160 2 1e+00 0.5 0.13 0.0823 3 1e+01 0.5 0.15 0.0707 4 1e+02 0.5 0.17 0.0823 5 1e+03 0.5 0.21 0.0994 6 1e-01 1.0 0.25 0.1354 7 1e+00 1.0 0.13 0.0823 ... Therefore, the best choic e of parameters involves cost=1and gamma=2.W e can view the test set predictions for this model by applying the predict() function to the data. Notice that to do this we subset the dataframe dat using -trainas an index set. > table(true=dat[-train ,\"y\"], pred=predict(tune.out$best. model , newx=dat[-train ,])) 39% of test observations are misclassiﬁed by this SVM. 9.6 Lab: Support Vector Machines 365 9.6.3 ROC Curves The ROCRpackage can be used to produce ROC curves such as those in Figures 9.10 and 9.11. We ﬁrst write a short function to plot an ROC curve given a vector containing a numerical score for each observation, pred,a n d a vector containing the class label for each observation, truth. > library(ROCR) > rocplot=function(pred, truth , ...){ + predob = prediction (pred, truth) + perf = performance (predob , \"tpr\", \"fpr\") + plot(perf ,...)} SVMs and support vector classiﬁers output class labels for each observa- tion.However,itis alsopossible to obtain ﬁtted values foreachobservation, which are the numerical scores used to obtain the class labels. For instance, in the case of a support vector classiﬁer, the ﬁtted value for an observation X=(X1,X2,...,X p)Ttakes the form ˆβ0+ˆβ1X1+ˆβ2X2+...+ˆβpXp. For an SVM with a non-linear kernel, the equation that yields the ﬁtted value is given in (9.23). In essence, the sign of the ﬁtted value determines on which side of the decision boundary the observation lies. Therefore, the relationship between the ﬁtted value and the class prediction for a given observation is simple: if the ﬁtted val ue exceeds zero then the observation is assigned to one class, and if it is less than zero than it is assigned to the other. In order to obtain the ﬁtted values for a given SVM model ﬁt, we usedecision.values=TRUE when ﬁtting svm(). Then the predict() function will output the ﬁtted values. > svmfit.opt=svm(y ∼., data=dat[train ,], kernel=\"radial\", gamma=2, cost=1,decision.values=T) > fitted=attributes (predict(svmfit.opt,dat[ train ,], decision. values=TRUE))$decision .values Now we can produce the ROC plot. > par(mfrow=c(1,2)) > rocplot(fi tted ,dat[train ,\"y\"], main=\"Training Data\") SVM appears to be producing accurate predictions. By increasing γwe can produce a more ﬂexible ﬁt and generate further improvements in accuracy. > svmfit.flex=svm(y ∼., data=dat[train ,], kernel=\"radial\", gamma=50, cost=1, decision.values=T) > fitted=attributes (predict(svmfit.flex,dat[ train ,], decision. values=T))$decision .values > rocplot(fi tted ,dat[train ,\"y\"],add=T,col=\"red\") However, these ROC curves are all on the training data. We are really more interested in the level of predic tion accuracy on the test data. When wecomputethe ROCcurvesonthetest data,themodel with γ= 2appears to provide the most accurate results. 366 9. Support Vector Machines > fitted=attributes (predict(svmfit.opt,dat[- train ,], decision. values=T))$decision .values > rocplot(fi tted ,dat[-train ,\"y\"], main=\"Test Data\") > fitted=attributes (predict(svmfit.flex,dat[- train ,], decision. values=T))$decision .values > rocplot(fi tted ,dat[-train ,\"y\"],add=T,col=\"red\") 9.6.4 SVM with Multiple Classes If the response is a factor containing more than two levels, then the svm() function will perform multi-class classiﬁcation using the one-versus-oneap- proach. We explore that setting here by generating a third class of obser- vations. > set.seed(1) > x=rbind(x, matrix(rnorm(50*2), ncol=2)) > y=c(y, rep(0,50)) > x[y==0,2]= x[y==0 ,2]+2 > dat=data.frame(x=x, y=as.factor(y)) > par(mfrow=c(1,1)) > plot(x,col=(y+1)) We now ﬁt an SVM to the data: > svmfit=svm(y ∼., data=dat, kernel=\"radial\", cost=10, gamma=1) > plot(svmfit , dat) The e1071library can also be used to perform support vector regression, if the response vector that is passed in to svm()is numerical rather than a factor. 9.6.5 Application to Gene Expression Data We now examine the Khandata set, which consists of a number of tissue samples corresponding to four distinct types of small round blue cell tu- mors. For each tissue sample, gene expr ession measurements are available. The data set consists of training data, xtrainand ytrain, and testing data, xtestand ytest. We examine the dimension of the data: > library(ISLR) > names(Khan) [1] \"xtrain\" \"xtest\" \"ytrain\" \"ytest\" > dim(Khan$xtrain ) [1] 63 2308 > dim(Khan$xtest ) [1] 20 2308 > length(Khan$ytrain ) [1] 63 > length(Khan$ytest ) [1] 20 9.6 Lab: Support Vector Machines 367 This data set consists of expression measurements for 2 ,308 genes. The training and test sets consist of 63 and 20 observations respectively. > table(Khan$ytrain ) 1234 82 31 22 0 > table(Khan$ytest ) 1234 3665 We will use a supportvector approachto predictcancer subtype using gene expression measurements. In this data set, there are a very large number of features relative to the number of observations. This suggests that we should use a linear kernel, because the additional ﬂexibility that will result from using a polynomial or radial kernel is unnecessary. > dat=data.frame(x=Khan$xtrain , y=as.factor(Khan$ytrain )) > out=svm(y ∼., data=dat, kernel=\"linear\",cost=10) > summary(out) Call: svm(formula = y ∼., data = dat, kernel = \"linear\", cost = 10) Parameters : SVM-Type: C- classification SVM-Kernel: linear cost: 10 gamma: 0.000433 Number of Support Vectors: 58 (2 02 01 17) Number of Classes: 4 Levels: 1234 > table(out$fitted , dat$y) 1234 18000 20 2 300 300 1 20 4000 2 0 We see that there are notraining errors. In fact, this is not surprising, becausethelargenumberofvariablesrelativetothenumberofobservations implies that it iseasyto ﬁnd hyperplanesthat fully separatetheclasses.We aremostinterestednotinthe supportvectorclassiﬁer’sperformanceonthe training observations, but rather its performance on the test observations. > dat.te=data.frame(x=Khan$xtest , y=as.factor(Khan$ytest )) > pred.te=predict(out, newdata=dat.te) > table(pred.te, dat.te$y) pred.te 1 2 3 4 13000 20620 30040 40005 368 9. Support Vector Machines We see that using cost=10yields two test set errors on this data. 9.7 Exercises Conceptual 1. This problem involves hyperplanes in two dimensions. (a) Sketch the hyperplane 1 + 3 X1−X2= 0. Indicate the set of poin tsforwhic h1+3 X1−X2>0, as well as the set of points forwhich1+3 X1−X2<0. (b) On the same plot, sketch the hyperplane −2+X1+2X2=0 . Indicate the set of points for which −2+X1+2X2>0, as well as the set of points for which −2+X1+2X2<0. 2. We have seen that in p= 2 dimensions, a linear decision boundary takesthe form β0+β1X1+β2X2= 0. We now investigatea non-linear decision boundary. (a) Sketch the curve (1+X1)2+(2−X2)2=4. (b) On your sketch, indicate the set of points for which (1+X1)2+(2−X2)2>4, as well as the set of points for which (1+X1)2+(2−X2)2≤4. (c) Suppose that a classiﬁer assigns an observation to the blue class if (1+X1)2+(2−X2)2>4, and to the red class otherwise. To what class is the observation (0,0) classiﬁed? ( −1,1)? (2,2)? (3,8)? (d) Argue that while the decision boundary in (c) is not linear in terms of X1andX2, it is linear in terms of X1,X2 1,X2,a n d X2 2. 3. Here we explore the maximal margin classiﬁer on a toy data set. (a) We are given n= 7 observations in p= 2 dimensions. For each observation, there is an associated class label. 9.7 Exercises 369 Obs.X1X2Y 13 4 R e d 22 2 R e d 34 4 R e d 41 4 R e d 5 2 1 Blue 6 4 3 Blue 7 4 1 Blue Sketch the observations. (b) Sketchtheoptimalseparatinghyperplane,andprovidetheequa- tion for this hyperplane (of the form (9.1)). (c) Describe the classiﬁcationrule for the maximalmarginclassiﬁer. It should be something along the lines of “Classify to Red if β0+β1X1+β2X2>0, and classify to Blue otherwise.” Provide the values for β0,β1,a n dβ2. (d) On your sketch, indicate the margin for the maximal margin hyperplane. (e) Indicate the support vectors for the maximal margin classiﬁer. (f) Argue that a slight movement of the seventh observation would not aﬀect the maximal margin hyperplane. (g) Sketch a hyperplane that is notthe optimal separating hyper- plane, and provide the equation for this hyperplane. (h) Draw an additional observation on the plot so that the two classes are no longer separable by a hyperplane. Applied 4. Generate a simulated two-class data set with 100 observations and two features in which there is a visible but non-linear separation be- tween the two classes. Show that in this setting, a support vector machine with a polynomial kernel (with degree greater than 1) or a radial kernel will outperform a support vector classiﬁer on the train- ing data. Which technique performs best on the test data? Make plots and report training and test error rates in order to back up your assertions. 5. We haveseenthatwecanﬁtanSVM with anon-linearkernelin order toperformclassiﬁcationusinganon-lineardecisionboundary.Wewill now see that we can also obtain a non-linear decision boundary by performing logistic regressionusing non-linear transformations of the features. 370 9. Support Vector Machines (a) Generateadatasetwith n= 500and p= 2,suchthat the obser- vations belongto twoclasseswith aquadraticdecisionboundary between them. For instance, you can do this as follows: > x1=runif(500) -0.5 > x2=runif(500) -0.5 > y=1*(x1^2-x2^2 > 0) (b) Plot the observations, colored according to their class labels. Your plot should display X1on thex-axis, and X2on they- axis. (c) Fit a logistic regression model to the data, using X1andX2as predictors. (d) Apply this model to the training data in order to obtain a pre- dicted class label for each train ing observation. Plot the ob- servations, colored according to the predicted class labels. The decision boundary should be linear. (e) Now ﬁt a logistic regression model to the data using non-linear functions of X1andX2as predictors (e.g. X2 1,X1×X2,l og(X2), and so forth). (f) Apply this model to the training data in order to obtain a pre- dicted class label for each train ing observation. Plot the ob- servations, colored according to the predicted class labels. The decision boundary should be obviously non-linear. If it is not, then repeat (a)-(e) until you come up with an example in which the predicted class labels are obviously non-linear. (g) Fit a support vector classiﬁer to the data with X1andX2as predictors. Obtain a class prediction for each training observa- tion. Plot the observations, colored according to the predicted class labels . (h) Fit a SVM using a non-linear kernel to the data. Obtain a class prediction for each training observation. Plot the observations, colored according to the predicted class labels . (i) Comment on your results. 6. At the end of Section 9.6.1, it is claimed that in the case of data that is just barely linearly separable, a support vector classiﬁer with a small value of costthat misclassiﬁes a couple of training observations may perform better on test data than one with a huge value of cost that does not misclassify any training observations. You will now investigate this claim. (a) Generatetwo-classdatawith p= 2insuchawaythattheclasses are just barely linearly separable. 9.7 Exercises 371 (b) Compute the cross-validation error rates for support vector classiﬁers with a range of costvalues. How many training er- rors are misclassiﬁed for each value of costconsidered, and how does this relate to the cross-validation errors obtained? (c) Generate an appropriate tes t data set, and compute the test errors corresponding to each of the values of costconsidered. Which value of costleads to the fewest test errors, and how does this compare to the values of costthat yield the fewest training errors and the fewest cross-validation errors? (d) Discuss your results. 7. In this problem, you will use support vector approaches in order to predict whether a given car gets high or low gas mileage based on the Autodata set. (a) Create a binary variable that takes on a 1 for cars with gas mileage above the median, and a 0 for cars with gas mileage below the median. (b) Fit a support vector classiﬁer to the data with various values ofcost, in order to predict whether a car gets high or low gas mileage. Report the cross-validation errors associated with dif- ferent values of this parameter. Comment on your results. (c) Now repeat (b), this time using SVMs with radial and polyno- mial basis kernels, with diﬀerent values of gammaand degreeand cost. Comment on your results. (d) Make some plots to back up your assertions in (b) and (c). Hint: In the lab, we used the plot()function for svmobjects only in cases with p=2.W h e np>2,y o uc a nu s et h e plot() function to create plots displaying pairs of variables at a time. Essentially, instead of typing > plot(svmfit , dat) where svmfitcontains your ﬁtted model and datis a data frame containing your data, you can type > plot(svmfit , dat, x1 ∼x4) in order to plot just the ﬁrst and fourth variables. However, you must replace x1and x4with the correct variable names. To ﬁnd out more, type ?plot.svm . 8. This problem involves the OJdata set which is part of the ISLR package. 372 9. Support Vector Machines (a) Create a training set containing a random sample of 800 observations, and a test set containing the remaining observations. (b) Fit a support vector classiﬁer to the training data using cost=0.01 , with Purchase as the response and the other variables as predictors. Use the summary() function to produce summary statistics, and describe the results obtained. (c) What are the training and test error rates? (d) Use the tune()function to select an optimal cost. Consider val- ues in the range 0 .01 to 10. (e) Compute the training and test error rates using this new value forcost. (f) Repeat parts (b) through (e) using a support vector machine with a radial kernel. Use the default value for gamma. (g) Repeat parts (b) through (e) using a support vector machine with a polynomial kernel. Set degree=2 . (h) Overall, which approach seems to give the best results on this data? 10 Unsupervised Learning Most of this book concerns supervised learning methods such as regressionandclassiﬁcation.In the supervisedlearningsetting,wetypically have access to a set of pfeatures X1,X2,...,X p,m e a s u r e do n nobser- vations, and a response Yalso measured on those same nobservations. The goal is then to predict YusingX1,X2,...,X p. This chapter will instead focus on unsupervised learning ,as e to fs t a - tistical tools intended for the setting in which we have only a set of fea- turesX1,X2,...,X pmeasured on nobservations. We are not interested in prediction, because we do not have an associated response variable Y. Rather, the goal is to discover interesting things about the measurements onX1,X2,...,X p. Is there an informative way to visualize the data? Can we discover subgroups among the variables or among the observations? Unsupervised learning refers to a diverse set of techniques for answering questions such as these. In this chapter, we will focus on two particu- lar types of unsupervised learning: principal components analysis ,at o o l used for data visualization or data pre-processing before supervised tech- niques are applied, and clustering , a broad class of methods for discovering unknown subgroups in data. 10.1 The Challenge of Unsupervised Learning Supervised learning is a well-understood area. In fact, if you have read the preceding chapters in this boo k, then you should by now have a good G. James et al., An Introduction to Statistical Learning: with Applications in R , Springer Texts in Statistics 103, DOI 10.1007/978-1-4614-7138-7 10, ©Springer Science+Business Media New York 2013373 374 10. Unsupervised Learning grasp of supervised learning. For instance, if you are asked to predict a binary outcome from a data set, you have a very well developed set of tools at your disposal (such as logistic regression, linear discriminant analysis, classiﬁcation trees, support vector ma chines, and more) as well as a clear understanding of how to assess the quality of the results obtained (using cross-validation, validation on an independent test set, and so forth). In contrast, unsupervised learning i s often much more challenging. The exercise tends to be more subjective, and there is no simple goal for the analysis, such as prediction of a response. Unsupervised learning is often performed as part of an exploratory data analysis .F u r t h e r m o r e ,i tc a nb eexploratory data analysis hard to assess the results obtained from unsupervised learning methods, since there is no universally accepte d mechanism for performing cross- validation or validating results on an independent data set. The reason for this diﬀerence is simple. If we ﬁt a predictive model using a supervised learning technique, then it is possible to check our work by seeing how well our model predicts the response Yon observations not used in ﬁtting the model. However, in unsupervised l earning, there is no way to check our workbecause wedon’tknowthe trueanswer—theproblemisunsupervised. Techniques for unsupervised learning are of growing importance in a number of ﬁelds. A cancer researcher might assay gene expression levels in 100 patients with breast cancer. He or she might then look for subgroups among the breast cancer samples, or among the genes, in order to obtain a better understanding of the disease. An online shopping site might try to identify groups of shoppers with similar browsing and purchase histo- ries, as well as items that are of parti cular interest to the shoppers within each group. Then an individual shopper can be preferentially shown the items in which he or she is particularl y likely to be interested, based on the purchase histories of similar shoppers. A search engine might choose what search results to display to a particular individual based on the click histories of other individuals with similar search patterns. These statistical learningtasks,andmanymore,canbe p erformedviaunsupervisedlearning techniques. 10.2 Principal Components Analysis Principal components are discussed in Section 6.3.1 in the context of principal components regression. When faced with a large set of corre- lated variables, principal components allow us to summarize this set with a smaller number of representative variables that collectively explain most of the variability in the original set. The principal component directions are presented in Section 6.3.1 as directions in feature space along which the original data are highly variable . These directions also deﬁne lines and subspaces that are as close as possible to the data cloud. To perform 10.2 Principal Components Analysis 375 principal components regression, we simply use principal components as predictors in a regression model in place of the original larger set of vari- ables. Principal component analysis (PCA) refers to the process by which prin-principal component analysiscipal components are computed, and the subsequent use of these compo- nents in understanding the data. PCA is an unsupervised approach, since it involvesonly a set of features X1,X2,...,X p, andno associatedresponse Y. Apart from producing derived variables for use in supervised learning problems, PCA also serves as a tool for data visualization (visualization of the observations or visualization of the variables). We now discuss PCA in greater detail, focusing on the use of PCA as a tool for unsupervised data exploration, in keeping with the topic of this chapter. 10.2.1 What Are Principal Components? Suppose that we wish to visualize nobservations with measurements on a set ofpfeatures, X1,X2,...,X p, as part of an exploratory data analysis. We could do this by examining two-dimensional scatterplots of the data, each of which contains the nobservations’ measurements on two of the features.However,there are/parenleftbigp 2/parenrightbig =p(p−1)/2such scatterplots;for example, withp=1 0t h e r ea r e4 5p l o t s !I f pis large, then it will certainly not be possible to look at all of them; moreover, most likely none of them will be informative since they each contai nj u s tas m a l lf r a c t i o no ft h et o t a l information present in the data set. Clearly, a better method is required to visualize the nobservations when pis large. In particular, we would like to ﬁnd a low-dimensional representation of the data that captures as much of theinformationaspossible.Forinstance,ifwecanobtainatwo-dimensional representation of the data that captures most of the information, then we can plot the observations in this low-dimensional space. PCA provides a tool to do just this. It ﬁnds a low-dimensional represen- tation of a data set that contains as much as possible of the variation. The idea is that each of the nobservations lives in p-dimensional space, but not all of these dimensions are equally interesting. PCA seeks a small number of dimensions that are as interesting as possible, where the concept of in- teresting is measured by the amount that the observations vary along each dimension. Each of the dimensions found by PCA is a linear combination of thepfeatures. We now explain the manner in which these dimensions, orprincipal components , are found. Theﬁrst principal component of a set of features X1,X2,...,X pis the normalized linear combination of the features Z1=φ11X1+φ21X2+...+φp1Xp (10.1) that has the largest variance. By normalized ,w em e a nt h a t/summationtextp j=1φ2 j1=1 . We refer to the elements φ11,...,φ p1as theloadings of the ﬁrst principalloading 376 10. Unsupervised Learning component; together, the loadings make up the principal component load- ing vector, φ1=(φ11φ21... φp1)T. We constrain the loadings so that their sum of squares is equal to one, since otherwise setting these elements to be arbitrarily large in absolute value could result in an arbitrarily large variance. Given a n×pdata set X, how do we compute the ﬁrst principal com- ponent? Since we are only intereste d in variance, we assume that each of the variables in Xhas been centered to have mean zero (that is, the col- umn means of Xare zero). We then look for the linear combination of the sample feature values of the form zi1=φ11xi1+φ21xi2+...+φp1xip (10.2) thathaslargestsamplevariance,subjecttotheconstraintthat/summationtextp j=1φ2 j1=1. In other words, the ﬁrst principal component loading vector solves the op- timization problem maximize φ11,...,φp1⎧ ⎪⎨ ⎪⎩1 nn/summationdisplay i=1⎛ ⎝p/summationdisplay j=1φj1xij⎞ ⎠2⎫ ⎪⎬ ⎪⎭subject top/summationdisplay j=1φ2 j1=1.(10.3) From (10.2) we can write the objective in (10.3) as1 n/summationtextn i=1z2 i1.S i n c e 1 n/summationtextn i=1xij= 0, the average of the z11,...,z n1will be zero as well. Hence the objectivethat wearemaximizingin(10.3)is justthe sample varianceof thenvalues of zi1. We refer to z11,...,z n1as thescoresof the ﬁrst princi-score pal component. Problem (10.3) can be solved via an eigen decomposition, a standard technique in linear algebra, but details are outside of the scope of this book. Thereis anicegeometrici nterpretationforthe ﬁrstprincipalcomponent. The loading vector φ1with elements φ11,φ21,...,φ p1deﬁnes a direction in feature space along which the data vary the most. If we project the ndata pointsx1,...,x nonto this direction, the proj ected values are the princi- pal component scores z11,...,z n1themselves. For instance, Figure 6.14 on page 230 displays the ﬁrst principal component loading vector (green solid line) on an advertising data set. In these data, there are only two features, and so the observations as well as the ﬁrst principal component loading vector can be easily displayed. As can be seen from (6.19), in that data set φ11=0.839 and φ21=0.544. After the ﬁrst principal component Z1of the features has been deter- mined, we can ﬁnd the second principal component Z2. The second prin- cipal component is the linear combination of X1,...,X pthat has maximal variance out of all linear combinations that are uncorrelated withZ1.T h e second principal component scores z12,z22,...,z n2take the form zi2=φ12xi1+φ22xi2+...+φp2xip, (10.4) 10.2 Principal Components Analysis 377 PC1 PC2 Murder 0.5358995 −0.4181809 Assault 0.5831836 −0.1879856 UrbanPop 0.2781909 0.8728062 Rape 0.5434321 0.1673186 TABLE 10.1. The principal component loading vectors, φ1andφ2,f o rt h e USArrests data. These are also displayed in Figure 10.1. whereφ2is the second principal component loading vector, with elements φ12,φ22,...,φ p2. It turns out that constraining Z2to be uncorrelated with Z1is equivalent to constraining the direction φ2to be orthogonal (perpen- dicular) to the direction φ1. In the example in Figure 6.14,the observations lie in two-dimensional space (since p= 2), and so once we have found φ1, there is only one possibility for φ2, which is shown as a blue dashed line. (From Section 6.3.1, we know that φ12=0.544 and φ22=−0.839.) But in a larger data set with p>2 variables, there are multiple distinct principal components, and they are deﬁned in a similar manner. To ﬁnd φ2,w es o l v e a problem similar to (10.3) with φ2replacing φ1, and with the additional constraint that φ2is orthogonal to φ1.1 Once we have computed the princip al components, we can plot them against each other in order to produce low-dimensional views of the data. For instance, we can plot the score vector Z1againstZ2,Z1againstZ3, Z2againstZ3, and so forth. Geometrically, this amounts to projecting the original data down onto the subspace spanned by φ1,φ2,a n dφ3,a n d plotting the projected points. We illustrate the use of PCA on the USArrests data set. For each of the 50 states in the United States, the data set contains the number of arrests per 100,000 residents for each of three crimes: Assault,Murder,a n d Rape. We also record UrbanPop (the percent of the population in each state living in urban areas).The principal comp onent scorevectorshave length n= 50, and the principal component loading vectors have length p=4 .P C Aw a s performedafterstandardizingeachvariabletohavemeanzeroandstandard deviation one. Figure 10.1 plots the ﬁrst two principal components of these data. The ﬁgure represents both the principal component scores and the loading vectors in a single biplotdisplay. The loadings are also given inbiplotTable 10.1. In Figure 10.1, we see that the ﬁrst loading vector places approximately equal weight on Assault,Murder,a n d Rape, with much less weight on 1On a technical note, the principal component directions φ1,φ2,φ3,...are the ordered sequence of eigenvectors of the matrix XTX, and the variances of the compo- nents are the eigenvalues. There are at most min( n−1,p) principal components. 378 10. Unsupervised Learning First Principal ComponentSecond Principal ComponentAlabamaAlaskaArizona ArkansasCalifornia ColoradoConnecticut Delaware Florida GeorgiaHawaii IdahoIllinois IndianaIowaKansas KentuckyLouisianaMaine MarylandMassachusetts MichiganMinnesota MississippiMissouri MontanaNebraskaNevada New HampshireNew Jersey New MexicoNew Y ork North CarolinaOhio OklahomaOregon PennsylvaniaRhode Island South CarolinaSouth Dakota TennesseeTexasUtah VermontVirginiaWashington West VirginiaWisconsin Wyoming −3 −2 −1 0 1 2 3−3 −2 −1 0 1 2 3−0.5 0.0 0.5 −0.5 0.0 0.5rth Dakota MurderAssaultUrbanPop Rape FIGURE 10.1. The ﬁrst two principal components for the USArrests data. The blue state names represent the scores for the ﬁrst two principal components. The orange arrows indicate the ﬁrst two principal component loading vectors (with axes on the top and right). For example, the loading for Rapeon the ﬁrst com- ponent is 0.54, and its loading on the second principal component 0.17(the word Rapeis centered at the point (0.54,0.17)). This ﬁgure is known as a biplot, be- cause it displays both the principal component scores and the principal component loadings. UrbanPop . Hencethiscomponentroughlyco rrespondstoameasureofoverall rates of serious crimes. T he second loading vector pl aces most of its weight onUrbanPop and much less weight on the other three features. Hence, this component roughly corresponds to the level of urbanization of the state. Overall, we see that the crime-related variables ( Murder,Assault,a n d Rape) are located close to each other, and that the UrbanPop variable is far from the other three. This indicates that the crime-related variables are corre- lated with each other—states with high murder rates tend to have high assault and rape rates—and that the UrbanPop variable is less correlated with the other three. 10.2 Principal Components Analysis 379 We can examinediﬀerences betweenth e statesviathe twoprincipalcom- ponent score vectors shown in Figure 10.1. Our discussion of the loading vectors suggests that states with large positive scores on the ﬁrst compo- nent, such as California, Nevada and Florida, have high crime rates, while states like North Dakota, with negative scores on the ﬁrst component, have low crime rates. California also has a high score on the second component, indicating a high level of urbanization, while the opposite is true for states like Mississippi. States close to zero o n both components, such as Indiana, have approximately average levels of both crime and urbanization. 10.2.2 Another Interpretation of Principal Components The ﬁrst two principal component loading vectors in a simulated three- dimensional data set are shown in the left-hand panel of Figure 10.2; these two loading vectors span a plane along which the observations have the highest variance. In the previoussection, we describe the principalcomponent loadingvec- tors as the directions in feature space along which the data vary the most, and the principal component scores as projections along these directions. However,analternativeinterpretationforprincipalcomponents canalsobe useful: principal components provid e low-dimensional linear surfaces that areclosestto the observations. We expand upon that interpretation here. The ﬁrst principal component loading vector has a very special property: it is the line in p-dimensional space that is closestto thenobservations (using average squared Euclidean distance as a measure of closeness). This interpretation can be seen in the left-hand panel of Figure 6.15; the dashed lines indicate the distance between ea ch observation and the ﬁrst principal component loading vector. The appeal of this interpretation is clear: we seek a single dimension of the data that lies as close as possible to all of the data points, since such a line will likely provide a good summary of the data. The notion of principal components as the dimensions that are clos- est to the nobservations extends beyond just the ﬁrst principal com- ponent. For instance, the ﬁrst two principal components of a data set span the plane that is closest to the nobservations, in terms of average squared Euclidean distance. An example is shown in the left-hand panel of Figure 10.2. The ﬁrst three principal components of a data set span the three-dimensional hyperplane that is closest to the nobservations, and so forth. Using this interpretation, together the ﬁrst Mprincipal component score vectors and the ﬁrst Mprincipal component loading vectors provide the bestM-dimensional approximation (in terms of Euclidean distance) to theith observation xij. This representation can be written 380 10. Unsupervised Learning First principal componentSecond principal component −1.0 −0.5 0.0 0.5 1.0−1.0 −0.5 0.0 0.5 1.0 FIGURE 10.2. Ninety observations simulated in three dimensions. Left:the ﬁrst two principal component directions span the plane that best ﬁts the data. It minimizes the sum of squared distances from each point to the plane. Right:the ﬁrst two principal component score vectors give the coordinates of the projection of the 90 observations onto the plane. The variance in the plane is maximized. xij≈M/summationdisplay m=1zimφjm (10.5) (assuming the original data matrix Xis column-centered). In other words, together the Mprincipal component score vectors and Mprincipal com- ponent loading vectors can give a good approximation to the data when Mis suﬃciently large. When M= min(n−1,p), then the representation is exact: xij=/summationtextM m=1zimφjm. 10.2.3 More on PCA Scaling the Variables We have already mentioned that before PCA is performed, the variables should be centered to have mean zero. Furthermore, the results obtained when we perform PCA will also depend on whether the variables have been individually scaled (each multiplied by a diﬀerent constant). This is in contrast to some other supervised and unsupervised learning techniques, such as linear regression, in which scaling the variables has no eﬀect. (In linear regression, multiplying a variable by a factor of cwill simply lead to multiplication of the corresponding coeﬃcient estimat e by a factor of 1 /c, and thus will have no substantive eﬀect on the model obtained.) For instance, Figure 10.1 was obtained after scaling each of the variables to have standard deviation one. This is reproduced in the left-hand plot in Figure10.3.Why doesit matterthatwescaledthevariables?Inthesedata, 10.2 Principal Components Analysis 381 First Principal ComponentSecond Principal Component* ** ** ** * * ** ** * ** * ** ** ** ** *** ** ** *** ** ** ** *** *** ** * −0.5 0.0 0.5MurderAssaultUrbanPop RapeScaled−3 −2 −1 0 1 2 3 −100 −50 0 50 100 150 First Principal ComponentSecond Principal Component*** *** *** ** ***** ***** * * ** *** ** ** ******* ***** *** *** −3 −2 −1 0 1 2 3−0.5 0.0 0.5 −100 −50 0 50 100 150−0.5 0.0 0.5 1.0 −0.5 0.0 0.5 1.0Murder Assa uUrbanPop RapeUnscaled FIGURE 10.3. Two principal component biplots for the USArrests data.Left: the same as Figure 10.1, with the variables scaled to have unit standard deviations. Right:principal components using unscaled data. Assault has by far the largest loading on the ﬁrst principal component because it has the highest variance among the four variables. In general, scaling the variables to have standard deviation one is recommended. the variables are measu red in diﬀerent units; Murder,Rape,a n d Assaultare reported as the number of occurrences per 100 ,000 people, and UrbanPop is the percentage of the state’s population that lives in an urban area. These four variables have variance 18 .97,87.73, 6945.16,and 209 .5, respec- tively. Consequently, if we perform PCA on the unscaled variables, then the ﬁrst principal component loading vector will have a very large loading forAssault, since that variable has by far the highest variance. The right- hand plot in Figure 10.3 displays the ﬁrst two principal components for the USArrests data set, without scaling the variables to have standard devia- tion one. As predicted, the ﬁrst principal component loading vector places almost all of its weight on Assault, while the second principal component loading vector places almost all of its weight on UrpanPop . Comparing this to the left-hand plot, we see that scaling does indeed have a substantial eﬀect on the results obtained. However, this result is simply a consequence of the scales on which the variables were measured. For instance, if Assaultwere measured in units of the number of occurrences per 100 people (rather than number of oc- currences per 100 ,000 people), then this would amount to dividing all of the elements of that variable by 1 ,000. Then the variance of the variable would be tiny, and so the ﬁrst principal component loading vector would have a very small value for that variable. Because it is undesirable for the principal components obtained to depend on an arbitrary choice of scaling, we typically scale each variable to have standard deviation one before we perform PCA. 382 10. Unsupervised Learning In certain settings, however, the variables may be measured in the same units. In this case, we might not wish to scale the variables to have stan- dard deviation one before performing PCA. For instance, suppose that the variables in a given data set correspond to expression levels for pgenes. Then since expression is measured in the same “units” for each gene, we might choose not to scale the genes to each have standard deviation one. Uniqueness of the Principal Components Each principal component loading vector is unique, up to a sign ﬂip. This means that two diﬀerent software packages will yield the same principal component loading vectors, although the signs of those loading vectors may diﬀer. The signs may diﬀer because each principal component loading vector speciﬁes a direction in p-dimensional space: ﬂipping the sign has no eﬀectasthedirectiondoesnotchange.(ConsiderFigure6.14—theprincipal component loading vector is a line tha t extends in either direction, and ﬂippingitssignwouldhavenoeﬀect.)Similarly,thescorevectorsareunique up to a sign ﬂip, since the variance of Zis the same as the variance of −Z. It is worth noting that when we use (10.5) to approximate xijwe multiply zimbyφjm. Hence, if the sign is ﬂipped on both the loading and score vectors, the ﬁnal product of the two quantities is unchanged. The Proportion of Variance Explained In Figure 10.2, we performed PCA on a three-dimensional data set (left- hand panel) and projected the data onto the ﬁrst two principal component loading vectors in order to obtain a two-dimensional view of the data (i.e. the principal component score vector s; right-hand panel). We see that this two-dimensional representation of the three-dimensional data does success- fully capture the major pattern in the data: the orange, green, and cyan observations that are near each other in three-dimensional space remain nearby in the two-dimensional representation. Similarly, we have seen on theUSArrests data set that we can summarize the 50 observations and 4 variables using just the ﬁrst two principal component score vectors and the ﬁrst two principal component loading vectors. We can now ask a natural question: how much of the information in a given data set is lost by projecting the observations onto the ﬁrst few principal components? That is, how much of the variance in the data is not contained in the ﬁrst few principal components? More generally, we are interested in knowing the proportion of variance explained (PVE) by eachproportion of variance explainedprincipal component. The total variance present in a data set (assuming that the variables have been centered to have mean zero) is deﬁned as p/summationdisplay j=1Var(Xj)=p/summationdisplay j=11 nn/summationdisplay i=1x2 ij, (10.6) 10.2 Principal Components Analysis 383 Principal ComponentProp. Variance Explained Principal Component1.0 1.5 2.0 2.5 3.0 3.5 4.0 1.0 1.5 2.0 2.5 3.0 3.5 4.00.0 0.2 0.4 0.6 0.8 1.0 0.0 0.2 0.4 0.6 0.8 1.0Cumulative Prop. Variance Explained FIGURE 10.4. Left:a scree plot depicting the proportion of variance explained by each of the four principal components in the USArrests data.Right:the cu- mulative proportion of variance explained by the four principal components in the USArrests data. and the variance explained by the mth principal component is 1 nn/summationdisplay i=1z2 im=1 nn/summationdisplay i=1⎛ ⎝p/summationdisplay j=1φjmxij⎞ ⎠2 . (10.7) Therefore, the PVE of the mth principal component is given by /summationtextn i=1/parenleftBig/summationtextp j=1φjmxij/parenrightBig2 /summationtextp j=1/summationtextn i=1x2 ij. (10.8) The PVE of each principal component is a positive quantity. In order to compute the cumulative PVE of the ﬁrst Mprincipal components, we can simply sum (10.8) over each of the ﬁrst MPVEs. In total, there are min(n−1,p) principal components, and their PVEs sum to one. In the USArrests data, the ﬁrst principal component explains 62.0% of the variance in the data, and the next principal component explains 24.7% ofthe variance.Together,theﬁrsttwoprincipalcomponentsexplainalmost 87% of the variance in the data, and the last two principal components explain only 13% of the variance. This means that Figure 10.1 provides a pretty accurate summary of the data u sing just two dimensions. The PVE of each principal component, as well as the cumulative PVE, is shown in Figure 10.4. The left-hand panel is known as a scree plot , and will bescree plotdiscussed next. Deciding How Many Principal Components to Use In general, a n×pdata matrix Xhas min( n−1,p) distinct principal components. However, we usually are n ot interested in all of them; rather, 384 10. Unsupervised Learning we would like to use just the ﬁrst few principal components in order to visualize or interpret the data. In fact, we would like to use the smallest numberofprincipalcomponentsrequiredtogeta goodunderstandingofthe data. How many principal components are needed? Unfortunately, there is no single (or simple!) answer to this question. We typically decide on the number of principal components required to visualize the data by examining a scree plot , such as the one shown in the left-hand panel of Figure 10.4. We choose the smallest number of principal componentsthat arerequiredin orderto explain asizable amount of the variation in the data. This is done by eyeballing the scree plot, and looking for a point at which the proportion of variance explained by each subsequent principal component drops oﬀ. This is often referred to as an elbowin the scree plot. For instance, by inspection of Figure 10.4, one might conclude that a fair amount of variance is explained by the ﬁrst two principal components, and that there is an elbow after the second component. After all, the third principal component explains less than ten percent of the variance in the data, and the fourth principal component explains less than half that and so is essentially worthless. However, this type of visual analysis is inherently ad hoc. Unfortunately, there is no well-accepted objective way to decide how many principal com- ponents are enough. In fact, the question of how many principal compo- nents are enough is inherently ill-deﬁned, and will depend on the speciﬁc area of application and the speciﬁc data set. In practice, we tend to look at the ﬁrst few principal components in order to ﬁnd interesting patterns in the data. If no interesting patterns are found in the ﬁrst few principal components, then further principal components are unlikely to be of inter- est. Conversely, if the ﬁrst few princip al components are interesting, then we typically continue to look at subsequent principal components until no further interesting patterns are found. This is admittedly a subjective ap- proach, and is reﬂective of the fact that PCA is generally used as a tool for exploratory data analysis. On the other hand, if we compute principal components for use in a supervised analysis, such as the principal components regression presented in Section 6.3.1, then there is a simple and objective way to determine how many principal components to use: we can treat the number of principal component score vectors to be used in t he regression as a tuning parameter to be selected via cross-validation or a related approach. The comparative simplicity of selecting the number of principal components for a supervised analysis is one manifestation of the fact that supervised analyses tend to be more clearly deﬁned and more object ively evaluated than unsupervised analyses. 10.3 Clustering Methods 385 10.2.4 Other Uses for Principal Components We saw in Section 6.3.1 that we can perform regression using the principal component score vectors as features. In fact, many statistical techniques, such as regression, classiﬁcation, and clustering, can be easily adapted to use then×Mmatrix whose columns are the ﬁrst M/lessmuchpprincipal com- ponent score vectors, rather than using the full n×pdata matrix. This can lead to less noisy results, since it is often the case that the signal (as opposed to the noise) in a data set is co ncentrated in its ﬁrst few principal components. 10.3 Clustering Methods Clustering refers to a very broad set of techniques for ﬁnding subgroups ,o rclusteringclusters, in a data set. When we cluster the observations of a data set, we seek to partition them into distinct groups so that the observations within each group are quite similar to each other, while observations in diﬀerent groupsarequite diﬀerentfromeachother.Of course,to makethis concrete, we must deﬁne what it means for two or more observations to be similar ordiﬀerent. Indeed, this is often a domain-speciﬁc consideration that must be made based on knowledge of the data being studied. For instance, suppose that we have a set of nobservations, each with p features.The nobservationscouldcorrespondtotissuesamplesforpatients with breast cancer, and the pfeatures could correspond to measurements collected for each tissue sample; these c ould be clinical measurements, such as tumor stage or grade, or they could be gene expression measurements. We may have a reason to believe that there is some heterogeneity among thentissue samples; for instance, perhaps there are a few diﬀerent un- knownsubtypes of breast cancer. Clust ering could be used to ﬁnd these subgroups. This is an unsupervised problem because we are trying to dis- cover structure—in this case, distinct clusters—on the basis of a data set. The goal in supervised problems, on the other hand, is to try to predict some outcome vector such as survival time or response to drug treatment. Both clustering and PCA seek to simplify the data via a small number of summaries, but their mechanisms are diﬀerent: •PCA looks to ﬁnd a low-dimensional representation of the observa- tions that explain a good fraction of the variance; •Clustering looks to ﬁnd homogeneous subgroups among the observa- tions. Another application of clustering arises in marketing. We may have ac- cess to a large number of measurements (e.g. median household income, occupation, distance from nearest urban area, and so forth) for a large 386 10. Unsupervised Learning number of people. Our goal is to perform market segmentation by identify- ing subgroups of people who might be mo re receptive to a particular form of advertising, or more likely to purchase a particular product. The task of performing market segmentation amounts to clustering the people in the data set. Since clustering is popular in many ﬁelds, there exist a great number of clustering methods. In this section we focus on perhaps the two best-known clustering approaches: K-means clustering andhierarchical clustering .I nK-means clustering hierarchical clusteringK-meansclustering,weseektopartitiontheobservationsintoapre-speciﬁed number of clusters. On the other hand, in hierarchical clustering, we do not know in advance how many clusters we want; in fact, we end up with a tree-like visual representation of the observations, called a dendrogram ,dendrogramthat allows us to view at once the clusterings obtained for each possible number of clusters, from 1 to n. There are advantages and disadvantages to each of these clustering approaches, which we highlight in this chapter. In general, we can cluster observations on the basis of the features in order to identify subgroups among the observations, or we can cluster fea- tures on the basis of the observations in order to discover subgroups among the features. In what follows, for simplicity we will discuss clustering obser- vations on the basis of the features, though the converse can be performed by simply transposing the data matrix. 10.3.1K-Means Clustering K-means clustering is a simple and elegant approach for partitioning a data set into Kdistinct, non-overlapping clusters. To perform K-means clustering, we must ﬁrst specify the desired number of clusters K; then the K-means algorithm will assign each observation to exactly one of the K clusters. Figure 10.5 shows the results obtained from performing K-means clustering on a simulated example consisting of 150 observations in two dimensions, using three diﬀerent values of K. TheK-means clustering procedure results from a simple and intuitive mathematicalproblem.Webeginbydeﬁningsomenotation.Let C1,...,C K denote sets containing the indices of the observationsin each cluster. These sets satisfy two properties: 1.C1∪C2∪...∪CK={1,...,n}. In other words, each observation belongs to at least one of the Kclusters. 2.Ck∩Ck/prime=∅for allk/negationslash=k/prime. In other words, the clusters are non- overlapping: no observation belongs to more than one cluster. For instance, if the ith observation is in the kth cluster, then i∈Ck.T h e ideabehind K-meansclusteringisthata goodclusteringisoneforwhichthe within-cluster variation is as small as possible. The within-cluster variation 10.3 Clustering Methods 387 K=2 K=3 K=4 FIGURE 10.5. A simulated data set with 150 observations in two-dimensional space. Panels show the results of applying K-means clustering with diﬀerent val- ues ofK, the number of clusters. The color of each observation indicates the clus- ter to which it was assigned using the K-means clustering algorithm. Note that there is no ordering of the clusters, so the cluster coloring is arbitrary. These cluster labels were not used in clustering; instead, they are the outputs of the clustering procedure. for cluster Ckis a measure W(Ck) of the amountby which the observations within a cluster diﬀer from each other. Hence we want to solve the problem minimize C1,...,CK/braceleftBiggK/summationdisplay k=1W(Ck)/bracerightBigg . (10.9) In words, this formula says that we want to partition the observations into Kclusters such that the total within-cluster variation, summed over all K clusters, is as small as possible. Solving (10.9) seems like a reasonable idea, but in order to make it actionable we need to deﬁne the within-cluster variation. There are many possible ways to deﬁne this concept, but by far the most common choice involves squared Euclidean distance . That is, we deﬁne W(Ck)=1 |Ck|/summationdisplay i,i/prime∈Ckp/summationdisplay j=1(xij−xi/primej)2, (10.10) where|Ck|denotes the number of observations in the kth cluster. In other words, the within-cluster variation for the kth cluster is the sum of all of the pairwise squared Euclidean dista nces between the observations in the kth cluster, divided by the total number of observations in the kth cluster. Combining (10.9) and (10.10) gives the optimization problem that deﬁnes K-means clustering, minimize C1,...,CK⎧ ⎨ ⎩K/summationdisplay k=11 |Ck|/summationdisplay i,i/prime∈Ckp/summationdisplay j=1(xij−xi/primej)2⎫ ⎬ ⎭.(10.11) 388 10. Unsupervised Learning Now, we would like to ﬁnd an algorithm to solve (10.11)—that is, a method topartitiontheobservationsinto Kclusterssuchthattheobjective of (10.11) is minimized. This is in fact a very diﬃcult problem to solve precisely,since therearealmost Knwaystopartition nobservationsinto K clusters. This is a huge number unless Kandnare tiny! Fortunately, a very simple algorithm can be shown to provide a local optimum—a pretty good solution—to the K-means optimization problem (10.11). This approach is laid out in Algorithm 10.1. Algorithm 10.1 K-Means Clustering 1. Randomly assign a number, from 1 to K, to each of the observations. These serve as initial cluster assignments for the observations. 2. Iterate until the cluster assignments stop changing: (a) For each of the Kclusters, compute the cluster centroid.T h e kth cluster centroid is the vector of the pfeature means for the observations in the kth cluster. (b) Assign each observation to the cluster whose centroid is closest (whereclosestis deﬁned using Euclidean distance). Algorithm 10.1 is guaranteed to decr ease the value of the objective (10.11) at each step. To understand why, the following identity is illu- minating: 1 |Ck|/summationdisplay i,i/prime∈Ckp/summationdisplay j=1(xij−xi/primej)2=2/summationdisplay i∈Ckp/summationdisplay j=1(xij−¯xkj)2,(10.12) where ¯xkj=1 |Ck|/summationtext i∈Ckxijis the mean for feature jin cluster Ck. In Step 2(a) the cluster means for each feature are the constants that minimize the sum-of-squared deviations, and in Step 2(b), reallocating the observations can only improve (10.12). This means that as the algorithm is run, the clustering obtained will continually improve until the result no longer changes;the objective of(10.11)willnever increase.When the result no longer changes, a local optimum has been reached. Figure 10.6 shows the progression of the algorithm on the toy example from Figure 10.5. K-means clustering derives its name from the fact that in Step 2(a), the cluster centroids are computed as the mean of the observations assigned to each cluster. Because the K-means algorithm ﬁnds a local rather than a global opti- mum, the results obtained will depend on the initial (random) cluster as- signment of each observation in Step 1 of Algorithm 10.1. For this reason, it is important to run the algorithm multiple times from diﬀerent random 10.3 Clustering Methods 389 Data Step 1 Iteration 1, Step 2a Iteration 1, Step 2b Iteration 2, Step 2a Final Results FIGURE 10.6. The progress of the K-means algorithm on the example of Fig- ure 10.5 with K=3.Top left: the observations are shown. Top center: in Step 1 of the algorithm, each observation is randomly assigned to a cluster. Top right: in Step 2(a), the cluster centroids are computed. These are shown as large col- ored disks. Initially the centroids are almost completely overlapping because the initial cluster assignments were chosen at random. Bottom left: in Step 2(b), each observation is assigned to the nearest centroid. Bottom center: Step 2(a) is once again performed, leading to new cluster centroids. Bottom right: the results obtained after ten iterations. initial conﬁgurations. Then one selects the bestsolution, i.e. that for which the objective (10.11) is smallest. Figure 10.7 shows the local optima ob- tained by running K-means clustering six times using six diﬀerent initial cluster assignments, using the toy data from Figure 10.5. In this case, the best clustering is the one with an objective value of 235.8. As we have seen, to perform K-means clustering, we must decide how many clusters we expect in the d ata.The problemofselecting Kis far from simple. This issue, along with other practical considerations that arise in performing K-means clustering, is addressed in Section 10.3.3. 390 10. Unsupervised Learning 320.9 235.8 235.8 235.8 235.8 310.9 FIGURE 10.7. K-means clustering performed six times on the data from Fig- ure 10.5 with K=3, each time with a diﬀerent random assignment of the ob- servations in Step 1 of the K-means algorithm. Above each plot is the value of the objective (10.11). Three diﬀerent local optima were obtained, one of which resulted in a smaller value of the objective and provides better separation between the clusters. Those labeled in red all achieved the same best solution, with an objective value of 235.8. 10.3.2 Hierarchical Clustering One potential disadvantage of K-means clustering is that it requires us to pre-specify the number of clusters K.Hierarchical clustering is an alter- native approach which does not require that we commit to a particular choice of K. Hierarchical clustering has an added advantage over K-means clustering in that it results in an attractive tree-based representation of the observations, called a dendrogram . In this section, we describe bottom-up oragglomerative clustering.bottom-up agglomerativeThis is the most common type of hierarchical clustering, and refers to the fact that a dendrogram (generally depicted as an upside-down tree; see 10.3 Clustering Methods 391 −6 −4 −2 0 2−2 0 2 4 X1X2 FIGURE 10.8. Forty-ﬁve observations generated in two-dimensional space. In reality there are three distinct classes, shown in separate colors. However, we will treat these class labels as unknown and will seek to cluster the observations in order to discover the classes from the data. Figure 10.9) is built starting from the leaves and combining clusters up to the trunk. We willbegin with adiscussionofhowtointerpretadendrogram and then discuss how hierarchicalclustering is actually performed—that is, how the dendrogram is built. Interpreting a Dendrogram We begin with the simulated data set shown in Figure 10.8, consisting of 45 observations in two-dimensional space. The data were generated from a three-class model; the true class lab els for each observation are shown in distinct colors. However, suppose that the data were observed without the class labels, and that we wanted to perform hierarchical clustering of the data. Hierarchical clustering (with complete linkage, to be discussed later) yields the result shown in the left-hand panel of Figure 10.9. How can we interpret this dendrogram? In the left-hand panel of Figure 10.9, each leafof the dendrogram rep- resents one of the 45 observations in Figure 10.8. However, as we move up the tree, some leaves begin to fuseinto branches. These correspond to observations that are similar to each other. As we move higher up the tree, branches themselves fuse, either with l eaves or other branches. The earlier (lower in the tree) fusions occur, the more similar the groups of observa- tions are to each other. On the other hand, observations that fuse later (near the top of the tree) can be quite diﬀerent. In fact, this statement can be made precise: for any two observations, we can look for the point in the tree where branches containing those two observations are ﬁrst fused. The height of this fusion, as measured on the vertical axis, indicates how 392 10. Unsupervised Learning 02468 1 0 02468 1 0 02468 1 0 FIGURE 10.9. Left:dendrogram obtained from hierarchically clustering the data from Figure 10.8 with complete linkage and Euclidean distance. Center:the den- drogram from the left-hand panel, cut at a height of nine (indicated by the dashed line). This cut results in two distinct clusters, shown in diﬀerent colors. Right: the dendrogram from the left-hand panel, now cut at a height of ﬁve. This cut results in three distinct clusters, shown in diﬀerent colors. Note that the colors were not used in clustering, but are simply used for display purposes in this ﬁgure. diﬀerent the two observations are. Thus, observations that fuse at the very bottom of the tree are quite similar to each other, whereas observations that fuse close to the top of the tree will tend to be quite diﬀerent. This highlights a very important point in interpreting dendrograms that is often misunderstood. Consider the left-hand panel of Figure 10.10,which shows a simple dendrogram obtained from hierarchically clustering nine observations. One can see that observations 5 and 7 are quite similar to each other, since they fuse at the lowest point on the dendrogram. Obser- vations 1 and 6 are also quite similar to each other. However,it is tempting but incorrect to conclude from the ﬁgure that observations 9 and 2 are quite similar to each other on the basis that they are located near each other on the dendrogram. In fact, based on the information contained in the dendrogram, observation 9 is no more similar to observation 2 than it is to observations 8 ,5,and 7. (This can be seen from the right-hand panel of Figure 10.10, in which the raw data are displayed.) To put it mathe- matically, there are 2n−1possible reorderings of the dendrogram, where n is the number of leaves. This is because at each of the n−1p o i n t sw h e r e fusions occur, the positions of the two fused branches could be swapped without aﬀecting the meaning of the dendrogram. Therefore, we cannot draw conclusions about the similarity of two observations based on their proximity along the horizontal axis . Rather, we draw conclusions about the similarity of two observations based on the location on the vertical axis where branches containing those two observations ﬁrst are fused. 10.3 Clustering Methods 3933 4 1 6 9 2 8 5 70.0 0.5 1.0 1.5 2.0 2.5 3.0123 45 67 89 −1.5 −1.0 −0.5 0.0 0.5 1.0−1.5 −1.0 −0.5 0.0 0.5 X1X2 FIGURE 10.10. An illustration of how to properly interpret a dendrogram with nine observations in two-dimensional space. Left:a dendrogram generated using Euclidean distance and complete linkage. Observations 5and7are quite similar to each other, as are observations 1and6. However, observation 9isno more similar to observation 2than it is to observations 8,5,and7, even though obser- vations9and2are close together in terms of horizontal distance. This is because observations 2,8,5,and7all fuse with observation 9at the same height, approx- imately1.8.Right:the raw data used to generate the dendrogram can be used to conﬁrm that indeed, observation 9is no more similar to observation 2than it is to observations 8,5,and7. Now that we understand how to interpret the left-hand panel of Fig- ure 10.9, we can move on to the issue of identifying clusters on the basis of a dendrogram. In order to do this, we make a horizontal cut across the dendrogram, as shown in the center and right-hand panels of Figure 10.9. The distinct sets ofobservationsbenea th the cut can be interpreted as clus- ters. In the center panel of Figure 10.9, cutting the dendrogram at a height of nine results in two clusters, shown in distinct colors. In the right-hand panel, cutting the dendrogram at a height of ﬁve results in three clusters. Further cuts can be made as one descends the dendrogram in order to ob- tain any number of clusters, between 1 (corresponding to no cut) and n (corresponding to a cut at height 0, so that each observation is in its own cluster). In other words, the height of the cut to the dendrogram serves the same role as the KinK-means clustering: it controls the number of clusters obtained. Figure 10.9 therefore highlights a very attractive aspect of hierarchical clustering: one single dendrogram can be used to obtain any number of clusters. In practice, people often look at the dendrogramand select by eye a sensible number of clusters, based on the heights of the fusion and the number of clusters desired. In the case of Figure 10.9, one might choose to select either two or three clusters. However, often the choice of where to cut the dendrogram is not so clear. 394 10. Unsupervised Learning The term hierarchical refers to the fact that clusters obtained by cutting the dendrogram at a given height are necessarily nested within the clusters obtained by cutting the dendrogram at any greater height. However, on an arbitrary data set, this assumption of hierarchical structure might be unrealistic. For instance, suppose that our observations correspond to a group of people with a 50–50split of males and females, evenly split among Americans, Japanese, and French. We can imagine a scenario in which the best division into two groups might split these people by gender, and the best division into three groups might split them by nationality. In this case, thetrueclustersarenotnested,inthesensethatthebestdivisionintothree groups does not result from taking the best division into two groups and splitting up one of those groups. Consequently, this situation could not be well-represented by hierarchical clustering. Due to situations such as this one, hierarchical cluste ring can sometimes yield worse(i.e. less accurate) results than K-means clustering for a given number of clusters. The Hierarchical Clustering Algorithm The hierarchicalclusteringdendrogramis obtained viaan extremely simple algorithm.We beginbydeﬁningsomesortof dissimilarity measurebetween each pair of observations. Most often, Euclidean distance is used; we will discuss the choice of dissimilarity measure later in this chapter. The algo- rithm proceeds iteratively. Startin g out at the bottom of the dendrogram, each of the nobservations is treated as its own cluster. The two clusters that are most similar to each other are then fusedso that there now are n−1 clusters. Next the two clusters that are most similar to each other are fused again, so that there now are n−2 clusters. The algorithm proceeds in this fashion until all of the observations belong to one single cluster, and the dendrogram is complete. Figure 10.11 depicts the ﬁrst few steps of the algorithm, for the data from Figure 10.9. To summarize, the hierarchical clustering algorithm is given in Algorithm 10.2. This algorithm seems simple enough, but one issue has not been ad- dressed. Consider the bottom right panel in Figure 10.11. How did we determine that the cluster {5,7}should be fused with the cluster {8}? We have a concept of the dissimilarity between pairs of observations, but how do we deﬁne the dissimilarity between two clusters if one or both of the clusters contains multiple observations? The concept of dissimilarity between a pair of observations needs to be extended to a pair of groups of observations . This extension is achieved by developing the notion of linkage, which deﬁnes the dissimilarity between two groups of observa-linkagetions. The four most common types of linkage— complete,average,single, andcentroid—are brieﬂy described in Table 10.2. Average, complete, and single linkage are most popular among statisticians. Average and complete 10.3 Clustering Methods 395 Algorithm 10.2 Hierarchical Clustering 1. Begin with nobservations and a measure (such as Euclidean dis- tance) of all the/parenleftbign 2/parenrightbig =n(n−1)/2 pairwise dissimilarities. Treat each observation as its own cluster. 2. Fori=n,n−1,...,2: (a) Examine all pairwise inter-cluster dissimilarities among the i clusters and identify the pair of clusters that are least dissimilar (that is, most similar). Fuse these two clusters. The dissimilarity between these two clusters indicates the height in the dendro- gram at which the fusion should be placed. (b) Compute the new pairwise inter-cluster dissimilarities among thei−1 remaining clusters. Linkage Description CompleteMaximalinterclusterdissimilarity.Computeallpairwisedis- similarities between the observations in cluster A and the observations in cluster B, and record the largestof these dissimilarities. SingleMinimal intercluster dissimilarity. Compute all pairwise dis- similarities between the observations in cluster A and the observations in cluster B, and record the smallest of these dissimilarities. Single linkage can result in extended, trailing clustersinwhich singleobservationsarefused one-at-a-time. AverageMean intercluster dissimilarity. Compute all pairwise dis- similarities between the observations in cluster A and the observations in cluster B, and record the averageof these dissimilarities. CentroidDissimilarity between the centroid for cluster A (a mean vector of length p) and the centroid for cluster B. Centroid linkage can result in undesirable inversions . TABLE 10.2. A summary of the four most commonly-used types of linkage in hierarchical clustering. linkage are generally preferred over single linkage, as they tend to yield more balanced dendrograms. Centroid linkage is often used in genomics, but suﬀers from a major drawback in that an inversion can occur, wherebyinversiontwo clusters are fused at a height beloweither of the individual clusters in the dendrogram.Thiscanleadtodiﬃcultiesinvisualizationaswellasinin- terpretation of the dendrogram. The dissimilarities computed in Step 2(b) of the hierarchical clustering algorithm will depend on the type of linkage used, as well as on the choice of dissimilarity measure. Hence, the resulting 396 10. Unsupervised Learning 123 45 67 89 −1.5 −1.0 −0.5 0.0 0.5 1.0−1.5 −1.0 −0.5 0.0 0.5123 45 67 89 −1.5 −1.0 −0.5 0.0 0.5 1.0−1.5 −1.0 −0.5 0.0 0.5 123 45 67 89 −1.5 −1.0 −0.5 0.0 0.5 1.0−1.5 −1.0 −0.5 0.0 0.5123 45 67 89 −1.5 −1.0 −0.5 0.0 0.5 1.0−1.5 −1.0 −0.5 0.0 0.5 X1 X1X1 X1 X2X2 X2X2 FIGURE 10.11. An illustration of the ﬁrst few steps of the hierarchical clustering algorithm, using the data from Figure 10.10, with complete linkage and Euclidean distance. Top Left: initially, there are nine distinct clusters, {1},{2},...,{9}.Top Right: the two clusters that are closest together, {5}and {7}, are fused into a single cluster. Bottom Left: the two clusters that are closest together, {6}and{1},a r ef u s e di n t oas i n g l ec l u s t e r . Bottom Right: the two clus- ters that are closest together using complete linkage ,{8}and the cluster {5,7}, are fused into a single cluster. dendrogram typically depends quite strongly on the type of linkage used, as is shown in Figure 10.12. Choice of Dissimilarity Measure Thus far, the examples in this chapter have used Euclidean distance as the dissimilarity measure. But sometimes other dissimilarity measures might be preferred. For example, correlation-based distance considers two obser- vations to be similar if their features are highly correlated, even though the observed values may be far apart in t erms of Euclidean distance. This is 10.3 Clustering Methods 397 Average Linkage Complete Linkage Single Linkage FIGURE 10.12. Average, complete, and single linkage applied to an example data set. Average and complete linkage tend to yield more balanced clusters. an unusual use of correlation, which is normally computed between vari- ables; here it is computed between th e observation proﬁles for each pair of observations. Figure 10.13 illustrates the diﬀerence between Euclidean and correlation-based distance. Correlation-based distance focuses on the shapes of observation proﬁles rather than their magnitudes. The choice of dissimilarity measure is very important, as it has a strong eﬀect on the resulting dendrogram. In general, careful attention should be paid to the type of data being clustered and the scientiﬁc question at hand. These considerations should determine what type of dissimilarity measure is used for hierarchical clustering. For instance, consider an online retaile r interested in clu stering shoppers based on their past shopping histories. The goal is to identify subgroups ofsimilarshoppers, so that shoppers within each subgroup can be shown items and advertisements that are particularly likely to interest them. Sup- pose the data takes the form of a matrix where the rows are the shoppers and the columns are the items available for purchase; the elements of the data matrix indicate the number of times a given shopper has purchased a given item (i.e. a 0 if the shopper has never purchased this item, a 1 if the shopper has purchased it once, etc.) What type of dissimilarity measure should be used to cluster the shoppers? If Euclidean distance is used, then shoppers who have bought very few item s overall (i.e. infrequent users of the online shopping site) will be clustered together. This may not be desir- able.Onthe otherhand,ifcorrelation-baseddistanceisused,thenshoppers with similar preferences (e.g. shoppers who have bought items A and B but 398 10. Unsupervised Learning 51 0 1 5 2 00 5 10 15 20 Variable IndexObservation 1 Observation 2 Observation 3 12 3 FIGURE 10.13. Three observations with measurements on 20 variables are shown. Observations 1 and 3 have similar values for each variable and so there is a small Euclidean distance between them. But they are very weakly correlated, so they have a large correlation-based distance. On the other hand, observations 1 and 2 have quite diﬀerent values for each variable, and so there is a large Euclidean distance between them. But they are highly correlated, so there is a small correlation-based distance between them. never items C or D) will be clustered together, even if some shoppers with these preferences are higher-volume shoppers than others. Therefore, for this application, correlation-based distance may be a better choice. Inadditiontocarefullyselectingthedissimilaritymeasureused,onemust also consider whether or not the variables should be scaled to have stan- dard deviation one before the dissimilarity between the observations is computed. To illustrate this point, we continue with the online shopping examplejustdescribed.Someitemsma ybepurchasedmorefrequentlythan others; for instance, a shopper might buy ten pairs of socks a year, but a computer very rarely. High-frequenc y purchases like socks therefore tend to have a much larger eﬀect on the inter-shopper dissimilarities, and hence on the clustering ultimately obtained, than rare purchases like computers. This may not be desirable. If the variables are scaled to have standard de- viation one before the inter-observation dissimilarities are computed, then each variable will in eﬀect be given equal importance in the hierarchical clustering performed. We might also want to scale the variables to have standard deviation one if they are mea sured on diﬀerent scales; otherwise, the choice of units (e.g. centimeters versus kilometers) for a particular vari- able will greatly aﬀect the dissimilarity measure obtained. It should come as nosurprisethat whether ornotitis a gooddecisionto scalethe variables before computing the dissimilarity measure depends on the application at hand. An example is shown in Figure 10.14. We note that the issue of whether or not to scale the variables before performing clustering applies toK-means clustering as well. 10.3 Clustering Methods 399 Socks Computers02468 1 0 Socks Computers0.0 0.2 0.4 0.6 0.8 1.0 1.2 Socks Computers0 500 1000 1500 FIGURE 10.14. An eclectic online retailer sells two items: socks and computers. Left:the number of pairs of socks, and computers, purchased by eight online shop- pers is displayed. Each shopper is shown in a diﬀerent color. If inter-observation dissimilarities are computed using Euclidean distance on the raw variables, then the number of socks purchased by an individual will drive the dissimilarities ob- tained, and the number of computers purchased will have little eﬀect. This might be undesirable, since (1) computers are more expensive than socks and so the online retailer may be more interested in encouraging shoppers to buy computers than socks, and (2) a large diﬀerence in the number of socks purchased by two shoppers may be less informative about the shoppers’ overall shopping preferences than a small diﬀerence in the number of computers purchased. Center:the same data is shown, after scaling each variable by its standard deviation. Now the number of computers purchased will have a much greater eﬀect on the inter-observation dissimilarities obtained. Right:the same data are displayed, but now the y-axis represents the number of dollars spent by each online shopper on socks and on computers. Since computers are much more expensive than socks, now computer purchase history will drive the inter-observation dissimilarities obtained. 10.3.3 Practical Issues in Clustering Clustering can be a very useful tool for data analysis in the unsupervised setting. However, there are a number of issues that arise in performing clustering. We describe some of these issues here. Small Decisions with Big Consequences In order to perform clustering , some decisions must be made. •Shouldtheobservationsorfeaturesﬁrstbestandardizedinsomeway? For instance, maybe the variables should be centered to have mean zero and scaled to have standard deviation one. 400 10. Unsupervised Learning •In the case of hierarchical clustering, –What dissimilarity measure should be used? –What type of linkage should be used? –Whereshouldwecutthedendrograminordertoobtainclusters? •In the case of K-means clustering, how many clusters should we look for in the data? Each of these decisions can have a strong impact on the results obtained. In practice, we try several diﬀerent choices, and look for the one with the most useful or interpretable solution. With these methods, there is no single right answer—any solution that exposes some interesting aspects of the data should be considered. Validating the Clusters Obtained Any time clustering is performed on a data set we will ﬁnd clusters. But we really want to know whether the clusters that have been found represent true subgroupsin the data, orwhether they aresimply a resultof clustering the noise . For instance, if we were to obtain an independent set of observa- tions, then would those observations also display the same set of clusters? This is a hard question to answer. There exist a number of techniques for assigning a p-value to a cluster in order to assess whether there is more evidence for the cluster than one would expect due to chance. However, there has been no consensus on a single best approach. More details can be found in Hastie et al. (2009). Other Considerations in Clustering BothK-means and hierarchical clustering will assign each observation to a cluster. However, sometimes this mi ght not be appropriate. For instance, suppose that most of the observations truly belong to a small number of (unknown) subgroups, and a small subset of the observations are quite diﬀerent from each other and from all other observations. Then since K- means and hierarchicalclustering force everyobservationinto a cluster,the clusters found may be heavily distorted due to the presence of outliers that do not belong to any cluster. Mixture models are an attractive approach for accommodating the presence of such outliers. These amount to a soft version of K-means clustering, and are described in Hastie et al. (2009). In addition, clustering methods generally are not very robust to pertur- bations to the data. For instance, suppose that we cluster nobservations, and then cluster the observations again after removing a subset of the n observations at random. One would hope that the two sets of clusters ob- tained would be quite similar, but often this is not the case! 10.4 Lab 1: Principal Components Analysis 401 A Tempered Approach to Interpreting the Results of Clustering We have described some of the issues associated with clustering. However, clustering can be a veryuseful and valid statistical tool ifused properly.We mentioned that small decisions in how clustering is performed, such as how the data arestandardizedand whattype of linkageis used, canhavea large eﬀect on the results. Therefore, we recommend performing clustering with diﬀerent choices of these parameters, and looking at the full set of results in order to see what patterns consistently emerge. Since clustering can be non-robust, we recommend clustering subsets of the data in order to get a sense of the robustness of the clusters obtained. Most importantly, we must be careful about how the resultsof a clusteringanalysisare reported. These results should not be taken as the absolute truth about a data set. Rather, they should constitute a starting point for the development of a scientiﬁc hypothesis and further study, preferably on an independent data set. 10.4 Lab 1: Principal Components Analysis In this lab, we perform PCA on the USArrests data set, which is part of the base Rpackage. The rows of the data set contain the 50 states, in alphabetical order. > states=row.names(USArrests ) > states The columns of the data set contain the four variables. > names(USArrests ) [1] \"Murder\" \"Assault\" \"UrbanPop\" \"Rape\" We ﬁrst brieﬂy examine the data. We notice that the variables have vastly diﬀerent means. > apply(USArrests , 2, mean) Murder Assault UrbanPop Rape 7.79 170.76 65.54 21.23 Note that the apply()function allows us to apply a function—in this case, the mean()function—to each row or column of the data set. The second input here denotes whether we wish to compute the mean of the rows, 1, or the columns, 2. We see that there are on average three times as many rapes as murders, and more than eight times as many assaults as rapes. We can also examine the variances of the four variables using the apply() function. > apply(USArrests , 2, var) Murder Assault UrbanPop Rape 19.0 6945.2 209.5 87.7 402 10. Unsupervised Learning Not surprisingly, the variables also have vastly diﬀerent variances: the UrbanPop variable measures the percentage of the population in each state living in an urban area, which is not a comparable number to the num- ber of rapes in each state per 100,000 individuals. If we failed to scale the variables before performing PCA, then most of the principal components that we observed would be driven by the Assaultvariable, since it has by far the largest mean and variance. Thus, it is important to standardize the variables to have mean zero and standard deviation one before performing PCA. We now perform principal components analysis using the prcomp() func-prcomp()tion, which is one of several functions in Rthat perform PCA. > pr.out=prcomp(USArrests , scale=TRUE) By default, the prcomp() function centers the variables to have mean zero. By using the option scale=TRUE , we scale the variables to have standard deviation one. The output from prcomp() contains a number of useful quan- tities. > names(pr.out) [1] \"sdev\" \"rotation\" \"center\" \"scale\" \"x\" The centerand scalecomponents correspond to the means and standard deviations of the variables that were used for scaling prior to implementing PCA. > pr.out$center Murder Assault UrbanPop Rape 7.79 170.76 65.54 21.23 > pr.out$scale Murder Assault UrbanPop Rape 4.36 83.34 14.47 9.37 The rotation matrix provides the principal component loadings; each col- umn of pr.out$rotation contains the corresponding principal component loading vector.2 > pr.out$rotation PC1 PC2 PC3 PC4 Murder -0.536 0.418 -0 .341 0.649 Assault -0.583 0.188 -0 .268 -0.743 UrbanPop -0.278 -0.873 -0.378 0.134 Rape -0.543 -0.167 0.818 0.089 We see that there are four distinct principal components. This is to be expected because there are in general min( n−1,p) informative principal components in a data set with nobservations and pvariables. 2This function names it the rotation matrix, because when we matrix-multiply the Xmatrix by pr.out$rotation , it gives us the coordinates of the data in the rotated coordinate system. These coordinates are the principal component scores. 10.4 Lab 1: Principal Components Analysis 403 Using the prcomp() function, we do not need to explicitly multiply the data by the principal component loading vectors in order to obtain the principal component scor e vectors. Rather the 50 ×4m a t r i x xhas as its columns the principal component score vectors. That is, the kth column is thekth principal component score vector. > dim(pr.out$x) [1] 50 4 We can plot the ﬁrst two principal components as follows: > biplot(pr.out, scale=0) The scale=0argument to biplot() ensures that the arrows are scaled tobiplot()represent the loadings; other values for scalegive slightly diﬀerent biplots with diﬀerent interpretations. Notice that this ﬁgure is a mirror image of Figure 10.1. Recall that the principal components are only unique up to a sign change, so we can reproduce Figure 10.1 by making a few small changes: > pr.out$rotation=-pr.out$rotation > pr.out$x=-pr.out$x > biplot(pr.out, scale=0) The prcomp() function also outputs the standard deviation of each prin- cipal component. For instance, on the USArrests data set, we can access these standard deviations as follows: > pr.out$sdev [1] 1.575 0.995 0.597 0.416 The variance explained by each principal component is obtained by squar- ing these: > pr.var=pr.out$sdev ^2 >p r . v a r [1] 2.480 0.990 0.357 0.173 To compute the proportion of variance explained by each principal compo- nent, we simply divide the variance explained by each principal component by the total variance explained by all four principal components: > pve=pr.var/sum(pr.var) > pve [1] 0.6201 0.2474 0.0891 0.0434 We see that the ﬁrst principal component explains 62.0% of the variance in the data, the next principal component explains 24.7% of the variance, and so forth. We can plot the PVE explained by each component, as well as the cumulative PVE, as follows: > plot(pve, xlab=\"Principal Component \", ylab=\"Proportion of Variance Explained \", ylim=c(0,1),type=’b’) > plot(cumsum(pve), xlab=\"Principal Component \", ylab=\" Cumulative Proportion of Variance Explained \", ylim=c(0,1), type=’b’) 404 10. Unsupervised Learning The result is shown in Figure 10.4. Note that the function cumsum() com-cumsum()putes the cumulative sum ofthe elements of a numeric vector.For instance: > a=c(1,2,8,-3) > cumsum(a) [1] 1 3 11 8 10.5 Lab 2: Clustering 10.5.1K-Means Clustering The function kmeans() performs K-means clustering in R.W eb e g i nw i t hkmeans()a simple simulated example in which there truly are two clusters in the data: the ﬁrst 25 observations have a mean shift relative to the next 25 observations. > set.seed(2) > x=matrix(rnorm(50*2), ncol=2) > x[1:25,1]=x[1:25,1]+3 > x[1:25,2]=x [1:25,2]-4 We now perform K-means clustering with K=2 . > km.out=kmeans(x,2,nstart=20) The cluster assignments of the 50 observations are contained in km.out$cluster . > km.out$cluster [ 1 ]22222222222222222222222221111 [30] 111111111111111111111 TheK-means clustering perfectly separated the observations into two clus- ters even though we did not supply any group information to kmeans() .W e can plot the data, with each observati on colored according to its cluster assignment. > plot(x, col=(km.out$cluster +1), main=\"K-Means Clustering Results with K=2\", xlab=\"\", ylab=\"\", pch=20, cex=2) Heretheobservationscanbeeasilyplottedbecausetheyaretwo-dimensional. If there were more than two variable s then we could instead perform PCA and plot the ﬁrst two principal components score vectors. In this example, we knew that ther e really were two clusters because we generated the data. However, for real data, in general we do not know the true number of clusters. We could instead have performed K-means clustering on this example with K=3 . > set.seed(4) > km.out=kmeans(x,3,nstart=20) >k m . o u t K-means clustering with 3 clusters of sizes 10, 23, 17 10.5 Lab 2: Clustering 405 Cluster means: [,1] [,2] 1 2.3001545 -2.69622023 2 -0.3820397 -0.08740753 3 3.7789567 -4.56200798 Clustering vector: [ 1 ]31313331313131313333313332222 222222222222221212222 Within cluster sum of squares by cluster: [1] 19.56137 52.67700 25.74089 (between_SS / total_SS = 79.3 %) Available components : [1] \"cluster\" \"centers\" \"totss\" \"withinss\" \"tot.withinss\" \"betweenss \" \"size\" > plot(x, col=(km.out$cluster +1), main=\"K-Means Clustering Results with K=3\", xlab=\"\", ylab=\"\", pch=20, cex=2) WhenK=3 ,K-means clustering splits up the two clusters. To run the kmeans() function in Rwith multiple initial cluster assign- ments, we use the nstartargument. If a value of nstartgreater than one is used, then K-means clustering will be performed using multiple random assignments in Step 1 of Algorithm 10.1, and the kmeans() function will report only the best results. Here we compare using nstart=1 tonstart=20 . > set.seed(3) > km.out=kmeans(x,3,nstart=1) > km.out$tot.withinss [1] 104.3319 > km.out=kmeans(x,3,nstart=20) > km.out$tot.withinss [1] 97.9793 Note that km.out$tot.withinss is the total within-cluster sum of squares, which we seek to minimize by performing K-means clustering (Equation 10.11). The individual within-cluster sum-of-squares are contained in the vector km.out$withinss . Westronglyrecommend always running K-means clustering with a large value of nstart, such as 20 or 50, since otherwise an undesirable local optimum may be obtained. When performing K-means clustering, in addition to using multiple ini- tial cluster assignments, it is also important to set a random seed using the set.seed() function. This way, the initial cluster assignments in Step 1 can be replicated, and the K-means output will be fully reproducible. 406 10. Unsupervised Learning 10.5.2 Hierarchical Clustering The hclust() function implements hierarchical clustering in R.I nt h ef o l -hclust()lowing example we use the data from Section 10.5.1 to plot the hierarchical clustering dendrogram using complete, single, and average linkage cluster- ing, with Euclidean distance as the dissimilarity measure. We begin by clustering observations using complete linkage. The dist()function is useddist()to compute the 50 ×50 inter-observation Euclidean distance matrix. > hc.complete=hclust(dist(x), method=\"complete \") We could just as easily perform hierarchical clustering with average or single linkage instead: > hc.average=hclust(dist(x), method=\"average\") > hc.single=hclust(dist(x), method=\"single\") Wecannowplotthedendrogramsobtainedusingtheusual plot()function. The numbers at the bottom of the plot identify each observation. > par(mfrow=c(1,3)) > plot(hc.complete ,main=\"Complete Linkage\", xlab=\"\", sub=\"\", cex=.9) > plot(hc.av erage , main=\"Average Linkage\", xlab=\"\", sub=\"\", cex=.9) > plot(hc.si ngle , main=\"Single Linkage\", xlab=\"\", sub=\"\", cex=.9) To determine the cluster labels for each observation associated with a given cut of the dendrogram, we can use the cutree() function:cutree() > cutree(hc.complete , 2) [ 1 ]11111111111111111111111112222 [30] 222222222222222222222 > cutree(hc. average , 2) [ 1 ]11111111111111111111111112222 [30] 222122222222221212222 > cutree(hc. single , 2) [ 1 ]11111111111111121111111111111 [30] 111111111111111111111 For this data, complete and averagelinkage generally separatethe observa- tions into their correct groups. However, single linkage identiﬁes one point as belonging to its own cluster. A more sensible answer is obtained when four clusters are selected, althoug h there are still two singletons. > cutree(hc. single , 4) [ 1 ]11111111111111121111111113333 [30] 333333333333433333333 To scale the variables before performing hierarchical clustering of the observations, we use the scale()function:scale() > xsc=scale(x) > plot(hclust(dist(xsc), method=\"complete \"), main=\" Hierarchical Clustering with Scaled Features \") 10.6 Lab 3: NCI60 Data Example 407 Correlation-based distance can be computed using the as.dist() func-as.dist()tion, which converts an arbitrarysquaresymmetric matrix into a form that thehclust() function recognizes as a distance matrix. However, this only makes sense for data with at least thre e features since the absolute corre- lation between any two observations with measurements on two features is always 1. Hence, we will cluster a three-dimensional data set. > x=matrix(rnorm(30*3), ncol=3) > dd=as.dist(1-cor(t(x))) > plot(hclust(dd, method=\"complete \"), main=\"Complete Linkage with Correlation -Based Distance\", xlab=\"\", sub=\"\") 10.6 Lab 3: NCI60 Data Example Unsupervised techniques are often us ed in the analysis of genomic data. In particular, PCA and hierarchical clustering are popular tools. We illus- trate these techniques on the NCI60cancer cell line microarray data, which consists of 6 ,830 gene expression measurements on 64 cancer cell lines. > library(ISLR) > nci.labs=NCI60$labs > nci.data=NCI60$data Each cell line is labeled with a cancer type. We do not make use of the cancer types in performing PCA and clu stering, as these are unsupervised techniques. But after performing PCA and clustering, we will check to see the extent to which these cancer types agree with the results of these unsupervised techniques. The data has 64 rows and 6 ,830 columns. > dim(nci.data) [1] 64 6830 We begin by examining the cancer types for the cell lines. > nci.labs[1:4] [1] \"CNS\" \"CNS\" \"CNS\" \"RENAL\" > table(nci.labs) nci.labs BREAST CNS COLON K 562A - repro K562B - repro 75711 LEUKEMIA MCF7A -repro MCF7D -repro MELANOMA NSCLC 61189 OVARIAN PROSTATE RENAL UNKNOWN 6291 408 10. Unsupervised Learning 10.6.1 PCA on the NCI60 Data We ﬁrst perform PCA on the data after scaling the variables (genes) to have standard deviation one, although one could reasonably argue that it is better not to scale the genes. > pr.out=prcomp(nci.data, scale=TRUE) We now plot the ﬁrst few principal component score vectors, in order to visualize the data. The observations (cell lines) corresponding to a given cancer type will be plotted in the sa me color, so that we can see to what extent the observations within a can cer type are similar to each other. We ﬁrst create a simple function that assigns a distinct color to each element of a numeric vector. The function will be used to assign a color to each of the 64 cell lines, based on the cancer type to which it corresponds. Cols=function(vec){ + cols=rainbow(length(unique(vec))) + return(cols[as.numeric(as.factor(vec))]) +} Note that the rainbow() function takes as its argument a positive integer,rainbow()and returns a vector containing that nu mber of distinct colors. We now can plot the principal comp onent score vectors. > par(mfrow=c(1,2)) > plot(pr.out$x[,1:2], col=Cols(nci.labs), pch=19, xlab=\"Z1\",ylab=\"Z2\") > plot(pr.out$x[,c(1,3)], col=Cols(nci.labs), pch=19, xlab=\"Z1\",ylab=\"Z3\") The resulting plots are shown in Figure 10.15. On the whole, cell lines corresponding to a single cancer type do tend to have similar values on the ﬁrst few principal component score v ectors. This indicates that cell lines from the same cancer type tend to have pretty similar gene expression levels. We can obtain a summary of the proportion of variance explained (PVE) of the ﬁrst few principal components using the summary() method for a prcompobject (we have truncated the printout): > summary(pr.out) Importance of components : PC1 PC2 PC3 PC4 PC5 Standard deviation 27.853 21.4814 19.8205 17.0326 15.9718 Proportion of Variance 0.114 0.0676 0.0575 0.0425 0.0374 Cumulative Proportion 0.114 0.1812 0.2387 0.2812 0.3185 Using the plot()function, we can also plot the variance explained by the ﬁrst few principal components. > plot(pr.out) Note that the height of each bar in the bar plot is given by squaring the corresponding element of pr.out$sdev . However, it is more informative to 10.6 Lab 3: NCI60 Data Example 409 −40 −20 0 20 40 60−60 −40 −20 0 20 −40 −20 0 20 40 60−40 −20 0 20 40 Z1 Z1Z2 Z3 FIGURE 10.15. Projections of the NCI60cancer cell lines onto the ﬁrst three principal components (in other words, the scores for the ﬁrst three principal com- ponents). On the whole, observations belonging to a single cancer type tend to lie near each other in this low-dimensional space. It would not have been possible to visualize the data without using a dimension reduction method such as PCA, since based on the full data set there are/parenleftbig6,830 2/parenrightbig possible scatterplots, none of which would have been particularly informative. plot the PVE of each principal component (i.e. a scree plot) and the cu- mulative PVE of each principal component. This can be done with just a little work. > pve=100*pr.out$sdev ^2/sum(pr.out$sdev ^2) > par(mfrow=c(1,2)) > plot(pve, type=\"o\", ylab=\"PVE\", xlab=\"Principal Component \", col=\"blue\") > plot(cumsum(pve), type=\"o\", ylab=\"Cumulative PVE\", xlab=\" Principal Component \", col=\"brown3\") (Note that the elements of pvecan also be computed directly from the sum- mary, summary(pr.out)$importance[2,] , and the elements of cumsum(pve) aregivenby summary(pr.out)$importance[3,] .) Theresultingplotsareshown in Figure 10.16. We see that together, the ﬁrst seven principal components explain around 40% of the variance in the data. This is not a huge amount of the variance. However, looking at the scree plot, we see that while each of the ﬁrst seven principal components explain a substantial amount of variance, there is a marked decrease in the variance explained by further principal components. That is, there is an elbowin the plot after approx- imately the seventh principal component. This suggests that there may be little beneﬁt to examining more than seven or so principal components (though even examining seven principal components may be diﬃcult). 410 10. Unsupervised Learning 0 1 02 03 04 05 06 002468 1 0 Principal ComponentPVE 0 1 02 03 04 05 06 020 40 60 80 100 Principal ComponentCumulative PVE FIGURE 10.16. The PVE of the principal components of the NCI60cancer cell line microarray data set. Left:the PVE of each principal component is shown. Right:the cumulative PVE of the principal components is shown. Together, all principal components explain 100% of the variance. 10.6.2 Clustering the Observations of the NCI60 Data We now proceed to hierarchically cluster the cell lines in the NCI60data, with the goal of ﬁnding out whether or not the observations cluster into distinct types of cancer. To begin, we standardize the variables to have mean zero and standard deviation one . As mentioned earlier, this step is optional and should be performed only if we want each gene to be on the samescale. > sd.data=scale(nci.data) We now perform hierarchical clustering of the observations using complete, single, and average linkage. Euclidean distance is used as the dissimilarity measure. > par(mfrow=c(1,3)) > data.dist=dist(sd.data) > plot(hclust(data.dist), labels=nci. labs, main=\"Complete Linkage\", xlab=\"\", sub=\"\",ylab=\"\") > plot(hclust(data.dist, method=\"average\"), labels=nci.labs, main=\"Average Linkage\", xlab=\"\", sub=\"\",ylab=\"\") > plot(hclust(data.dist, method=\"single\"), labels=nci. labs , main=\"Single Linkage\", xlab=\"\", sub=\"\",ylab=\"\") The results are shown in Figure 10.17. We see that the choice of linkage certainly does aﬀect the results obtained. Typically, single linkage will tend to yieldtrailingclusters: very large clusters onto which individual observa- tions attach one-by-one. On the other hand, complete and average linkage tend to yield more balanced, attractive clusters. For this reason, complete and average linkage are generally preferred to single linkage. Clearly cell lines within a single cancer type do tend to cluster together, although the 10.6 Lab 3: NCI60 Data Example 411BREAST BREAST CNS CNS RENAL BREAST NSCLC RENAL MELANOMA OVARIAN OVARIAN NSCLC OVARIAN COLON COLON OVARIAN PROSTATE NSCLC NSCLC NSCLC PROSTATE NSCLC MELANOMA RENAL RENAL RENAL OVARIAN UNKNOWN OVARIAN NSCLC CNS CNS CNS NSCLC RENAL RENAL RENAL RENAL NSCLC MELANOMA MELANOMA MELANOMA MELANOMA MELANOMA MELANOMA BREAST BREAST COLON COLON COLON COLON COLON BREAST MCF7A−repro BREAST MCF7D−repro LEUKEMIA LEUKEMIA LEUKEMIA LEUKEMIA K562B−repro K562A−repro LEUKEMIA LEUKEMIA40 80 120 160Complete LinkageLEUKEMIA LEUKEMIA LEUKEMIA LEUKEMIA LEUKEMIA LEUKEMIA K562B−repro K562A−repro RENAL NSCLC BREAST NSCLC BREAST MCF7A−repro BREAST MCF7D−repro COLON COLON COLON RENAL MELANOMA MELANOMA BREAST BREAST MELANOMA MELANOMA MELANOMA MELANOMA MELANOMA OVARIAN OVARIAN NSCLC OVARIAN UNKNOWN OVARIAN NSCLC MELANOMA CNS CNS CNS RENAL RENAL RENAL RENAL RENAL RENAL RENAL PROSTATE NSCLC NSCLC NSCLC NSCLC OVARIAN PROSTATE NSCLC COLON COLON OVARIAN COLON COLON CNS CNS BREAST BREAST40 60 80 100 120Average LinkageLEUKEMIA RENAL BREAST LEUKEMIA LEUKEMIA CNS LEUKEMIA LEUKEMIA K562B−repro K562A−repro NSCLC LEUKEMIA OVARIAN NSCLC CNS BREAST NSCLC OVARIAN COLON BREAST MELANOMA RENAL MELANOMA BREAST BREAST MELANOMA MELANOMA MELANOMA MELANOMA MELANOMA BREAST OVARIAN COLON MCF7A−repro BREAST MCF7D−repro UNKNOWN OVARIAN NSCLC NSCLC PROSTATE MELANOMA COLON OVARIAN NSCLC RENAL COLON PROSTATE COLON OVARIAN COLON COLON NSCLC NSCLC RENAL NSCLC RENAL RENAL RENAL RENAL RENAL CNS CNS CNS40 60 80 100Single Linkage FIGURE 10.17. The NCI60cancer cell line microarray data, clustered with av- erage, complete, and single linkage, and using Euclidean distance as the dissim- ilarity measure. Complete and average linkage tend to yield evenly sized clusters whereas single linkage tends to yield extended clusters to which single leaves are fused one by one. 412 10. Unsupervised Learning clustering is not perfect. We will use complete linkage hierarchical cluster- ing for the analysis that follows. We can cut the dendrogram at the height that will yield a particular number of clusters, say four: > hc.out=hclust(dist(sd.data)) > hc.clusters=cutree(hc.out ,4) > table(hc.clusters,nci.labs) There are some clear patterns. All the leukemia cell lines fall in cluster 3, while the breastcancercell lines arespr eadoutoverthree diﬀerentclusters. We can plot the cut on the dendrogram that produces these four clusters: > par(mfrow=c(1,1)) > plot(hc.out, labels=nci.labs) > abline(h=139, col=\"red\") The abline() function draws a straight line on top of any existing plot inR. The argument h=139plots a horizontal line at height 139 on the den- drogram; this is the height that results in four distinct clusters. It is easy to verify that the resulting clusters are the same as the ones we obtained using cutree(hc.out,4) . Printing the output of hclustgives a useful brief summary of the object: >h c . o u t Call: hclust(d = dist(dat)) Cluster method : complete Distance : euclidean Number of objects: 64 We claimed earlier in Section 10.3.2 that K-means clustering and hier- archical clustering with the dendrogram cut to obtain the same number of clusters can yield very diﬀerent results. How do these NCI60hierarchical clusteringresultscomparetowhatwegetifweperform K-meansclustering withK=4 ? > set.seed(2) > km.out=kmeans(sd.data, 4, nstart=20) > km.clusters=km.out$cluster > table(km.clusters,hc.clusters) hc.clusters km.clusters 1234 1 1 1009 20080 39000 4 2 0700 We see that the four clusters obtained using hierarchical clustering and K- meansclusteringaresomewhatdiﬀerent.Cluster2 in K-meansclusteringis identical to cluster 3 in hierarchical c lustering. However, the other clusters 10.7 Exercises 413 diﬀer: for instance, cluster 4 in K-means clustering contains a portion of the observations assigned to cluster 1 by hierarchical clustering, as well as all of the observations assigned to cluster 2 by hierarchical clustering. Rather thanperforminghierarchicalclusteringontheentiredata matrix, we can simply perform hierarchical cl ustering on the ﬁrst few principal component score vectors, as follows: > hc.out=hclust(dist(pr.out$x[,1:5])) > plot(hc.out, labels=nci. labs, main=\"Hier. Clust. on First Five Score Vectors\") > table(cutree(hc.out ,4), nci.labs) Not surprisingly, these results are d iﬀerent from the ones that we obtained when we performed hierarchical clustering on the full data set. Sometimes performing clustering on the ﬁrst few principal component score vectors can give better results than performing clustering on the full data. In this situation, we might view the principal component step as one of denois- ing the data. We could also perform K-means clustering on the ﬁrst few principal component score vectors rather than the full data set. 10.7 Exercises Conceptual 1. This problem involves the K-means clustering algorithm. (a) Prove (10.12). (b) On the basis of this identity, argue that the K-means clustering algorithm (Algorithm 10.1) decreases the objective (10.11) at each iteration. 2. Suppose that we have four observations, for which we compute a dissimilarity matrix, given by ⎡ ⎢⎢⎣0.30.40.7 0.30 .50.8 0.40.50 .45 0.70.80.45⎤ ⎥⎥⎦. For instance, the dissimilarity between the ﬁrst and second obser- vations is 0.3, and the dissimilarity between the second and fourth observations is 0.8. (a) On the basis of this dissimilarity matrix, sketch the dendrogram that results from hierarchically clustering these four observa- tions using complete linkage. Be sure to indicate on the plot the height at which each fusion occurs, as well as the observations corresponding to each leaf in the dendrogram. 414 10. Unsupervised Learning (b) Repeat (a), this time using single linkage clustering. (c) Suppose that we cut the dendogram obtained in (a) such that two clusters result. Which obs ervations are in each cluster? (d) Suppose that we cut the dendogram obtained in (b) such that two clusters result. Which obs ervations are in each cluster? (e) It is mentioned in the chapter that at each fusion in the den- drogram, the position of the two clusters being fused can be swappedwithoutchangingthemeaningofthedendrogram.Draw a dendrogram that is equivalent to the dendrogram in (a), for which two or more of the leaves are repositioned, but for which the meaning of the dendrogram is the same. 3. In this problem, you will perform K-means clustering manually, with K=2 ,o nas m a l le x a m p l ew i t h n= 6 observations and p=2 features. The observations are as follows. Obs.X1X2 114 213 304 451 562 640 (a) Plot the observations. (b) Randomly assign a cluster label to each observation. You can use the sample() command in Rto do this. Report the cluster labels for each observation. (c) Compute the centroid for each cluster. (d) Assign each observation to the centroid to which it is closest, in terms of Euclidean distance. Report the cluster labels for each observation. (e) Repeat (c) and (d) until the answers obtained stop changing. (f) In your plot from (a), color the observations according to the cluster labels obtained. 4. Suppose that for a particular data set, we perform hierarchical clus- tering using single linkage and using complete linkage. We obtain two dendrograms. (a) At a certain point on the single linkage dendrogram, the clus- ters{1,2,3}and{4,5}fuse. On the complete linkage dendro- gram,theclusters {1,2,3}and{4,5}alsofuse atacertainpoint. Which fusion will occur higher on the tree, or will they fuse at the same height, or is there not enough information to tell? 10.7 Exercises 415 (b) At a certain point on the single linkage dendrogram,the clusters {5}and{6}fuse. On the complete linkage dendrogram,the clus- ters{5}and{6}also fuse at a certain point. Which fusion will occur higher on the tree, or will they fuse at the same height, or is there not enough information to tell? 5. In words, describe the results that you would expect if you performed K-means clustering of the eight shoppers in Figure 10.14, on the basis of their sock and computer purchases, with K=2 .G i v et h r e e answers, one for each of the variable scalings displayed. Explain. 6. A researcher collects expression measurements for 1,000 genes in 100 tissue samples. The data can be written as a 1 ,000×100 matrix, which we call X, in which each row represents a gene and each col- umn a tissue sample. Each tissue sample was processed on a diﬀerent day, and the columns of Xare ordered so that the samples that were processedearliestareonthe left, andthe samplesthatwereprocessed later are on the right. The tissue samples belong to two groups: con- trol (C) and treatment (T). The C and T samples were processed in a random order across the days. The researcher wishes to deter- minewhethereachgene’sexpression measurementsdiﬀerbetweenthe treatment and co ntrol groups. As a pre-analysis (before comparing T versus C), the researcher per- forms a principal component analysis of the data, and ﬁnds that the ﬁrst principal component (a vector of length 100) has a strong linear trend from left to right, and explains 10% of the variation. The re- searcher now remembers that each patient sample was run on one of two machines, A and B, and machine A was used more often in the earlier times while B was used more often later. The researcher has a record of which sample was run on which machine. (a) Explain what it means that the ﬁrst principal component “ex- plains 10% of the variation”. (b) The researcher decides to replace the ( i,j)th element of Xwith xij−zi1φj1 wherezi1is theith score, and φj1is thejth loading, for the ﬁrst principal component. He will then perform a two-sample t-test on each gene in this new data set in order to determine whether its expression diﬀers between the two conditions. Critique this idea, and suggest a better approach. (c) Design and run a small simulation experiment to demonstrate the superiority of your idea. 416 10. Unsupervised Learning Applied 7. In the chapter, we mentioned the use of correlation-based distance andEuclideandistance asdissimilaritymeasuresforhierarchicalclus- tering. It turns out that these two measures are almost equivalent: if each observation has been centered to have mean zero and standard deviation one, and if we let rijdenote the correlation between the ith andjth observations, then the quantity 1 −rijis proportional to the squared Euclidean distance between the ith andjth observations. On the USArrests data, show that this proportionality holds. Hint: The Euclidean distance can be calculated using the dist()func- tion, and correlations can be calculated using the cor()function. 8. In Section 10.2.3, a formula for calculating PVE was given in Equa- tion 10.8. We also saw that the PVE can be obtained using the sdev output of the prcomp() function. On the USArrests data, calculate PVE in two ways: (a) Using the sdevoutput of the prcomp() function, as was done in Section 10.2.3. (b) By applying Equation 10.8 directly. That is, use the prcomp() function to compute the principal component loadings. Then, use those loadings in Equation 10.8 to obtain the PVE. These two approaches should give the same results. Hint: You will only obtain the same results in (a) and (b) if the same data is used in both cases. For instance, if in (a) you performed prcomp() using centered and scaled variables, then you must center and scale the variables before applying Equation 10.3 in (b). 9. Consider the USArrests data. We will now perform hierarchical clus- tering on the states. (a) Using hierarchical clustering with complete linkage and Euclidean distance, cluster the states. (b) Cut the dendrogram at a height that results in three distinct clusters. Which states belong to which clusters? (c) Hierarchically cluster the states using complete linkage and Eu- clidean distance, after scaling the variables to have standard de- viation one . (d) What eﬀect does scaling the variables have on the hierarchical clustering obtained? In your opinion, should the variables be scaled before the inter-observati ondissimilarities are computed? Provide a justiﬁcation for your answer. 10.7 Exercises 417 10. In this problem, you will generate simulated data, and then perform PCA and K-means clustering on the data. (a) Generate a simulated data set with 20 observations in each of three classes (i.e. 60 observations total), and 50 variables. Hint: There are a number of functions in Rthat you can use to generate data. One example is the rnorm()function; runif()is another option. Be sure to add a mean shift to the observations in each class so that there are three distinct classes. (b) Perform PCA on the 60 observations and plot the ﬁrst two prin- cipal component score vectors. Use a diﬀerent color to indicate the observations in each of the three classes. If the three classes appear separated in this plot, then continue on to part (c). If not, then return to part (a) and modify the simulation so that there is greater separation be tween the three classes. Do not continue to part (c) until the three classes show at least some separation in the ﬁrst two principal component score vectors. (c) Perform K-means clustering of the observations with K=3 . How well do the clusters that you obtained in K-means cluster- ing compare to the true class labels? Hint: You can use the table()function in Rto compare the true class labels to the class labels obtained by clustering. Be careful how you interpret the results: K-means clustering will arbitrarily number the clusters, so you cannot simply check whether the true class labels and clustering labels are the same. (d) Perform K-means clustering with K= 2. Describe your results. (e) Now perform K-meansclusteringwith K= 4,and describe your results. (f) Now perform K-means clustering with K=3o nt h eﬁ r s tt w o principal component score vectors, rather than on the raw data. That is, perform K-means clustering on the 60 ×2m a t r i xo f which the ﬁrst column is the ﬁrst principal component score vector,andthesecondcolumnis thesecondprincipalcomponent score vector. Comment on the results. (g) Using the scale()function, perform K-means clustering with K= 3 on the data after scaling each variable to have standard deviation one . How do these results co mpare to those obtained in (b)? Explain. 11. On the book website, www.StatLearning.com, there is a gene expres- sion data set ( Ch10Ex11.csv ) that consists of 40 tissue samples with measurements on 1,000 genes. The ﬁrst 20 samples are from healthy patients, while the second 20 are from a diseased group. 418 10. Unsupervised Learning (a) Load in the data using read.csv() . You will need to select header=F . (b) Apply hierarchical clustering to the samples using correlation- based distance, and plot the dendrogram. Do the genes separate the samples into the two groups? Do your results depend on the type of linkage used? (c) Your collaborator wants to know which genes diﬀer the most across the two groups. Suggest a way to answer this question, and apply it here. Index Cp, 78, 205, 206, 210–213 R2, 68–71, 79–80, 103, 212 /lscript2norm, 216 /lscript1norm, 219 additive, 12, 86–90, 104 additivity, 282, 283 adjusted R2, 78, 205, 206, 210–213 Advertising data set, 15, 16, 20, 59, 61–63, 68, 69, 71–76, 79, 81, 82, 87, 88, 102–104 agglomerative clustering, 390 Akaike information criterion, 78, 205, 206, 210–213 alternative hypothesis, 67 analysis of variance, 290 area under the curve, 147 argument, 42 AUC, 147 Autodata set, 14, 48, 49, 56, 90–93, 121, 122, 171, 176–178, 180, 182, 191, 193–195, 299, 371backﬁtting, 284, 300 backward stepwise selection, 79, 208–209, 247 bagging, 12, 26, 303, 316–319, 328–330 baseline, 86 basis function, 270, 273 Bayes classiﬁer, 37–40, 139 decision boundary, 140 error, 37–40 Bayes’ theorem, 138, 139, 226 Bayesian, 226–227 Bayesian information criterion, 78, 205, 206, 210–213 best subset selection, 205, 221, 244–247 bias, 33–36, 65, 82 bias-variance decomposition, 34 trade-oﬀ, 33–37, 42, 105, 149, 217, 230, 239, 243, 278, 307, 347, 357 binary, 28, 130 biplot, 377, 378 G. James et al., An Introduction to Statistical Learning: with Applications in R , Springer Texts in Statistics 103, DOI 10.1007/978-1-4614-7138-7, ©Springer Science+Business Media New York 2013419 420 Index Boolean, 159 boosting, 12, 25, 26, 303, 316, 321–324, 330–331 bootstrap, 12, 175, 187–190, 316 Bostondata set, 14, 56, 110, 113, 126, 173, 201, 264, 299, 327, 328, 330, 333 bottom-up clustering, 390 boxplot, 50 branch, 305 Caravan data set, 14, 164, 335 Carseats data set, 14, 117, 123, 324, 333 categorical, 3, 28 classiﬁcation, 3, 12, 28–29, 37–42, 127–173, 337–353 error rate, 311 tree, 311–314, 324–327 classiﬁer, 127 cluster analysis, 26–28 clustering, 4, 26–28, 385–401 K-means, 12, 386–389 agglomerative, 390 bottom-up, 390 hierarchical, 386, 390–401 coeﬃcient, 61 College data set, 14, 54, 263, 300 collinearity, 99–103 conditional probability, 37 conﬁdence interval, 66–67, 81, 82, 103, 268 confounding, 136 confusion matrix, 145, 158 continuous, 3 contour plot, 46 contrast, 86 correlation, 70, 74, 396 Creditdata set, 83, 84, 86, 89, 90, 99–102 cross-entropy, 311–312, 332cross-validation, 12, 33, 36, 175–186, 205, 227, 248–251 k-fold, 181–184 leave-one-out, 178–181 curse of dimensionality, 108, 168, 242–243 data frame, 48 Data sets Advertising , 15, 16, 20, 59, 61–63, 68, 69, 71–76, 79, 81, 82, 87, 88, 102–104 Auto, 14, 48, 49, 56, 90–93, 121, 122, 171, 176–178, 180, 182, 191, 193–195, 299, 371 Boston, 14, 56, 110, 113, 126, 173, 201, 264, 299, 327, 328, 330, 333 Caravan, 14, 164, 335 Carseats , 14, 117, 123, 324, 333 College, 14, 54, 263, 300 Credit, 83, 84, 86, 89, 90, 99–102 Default, 14, 128–137, 144–148, 198, 199 Heart, 312, 313, 317–320, 354, 355 Hitters, 14, 244, 251, 255, 256, 304, 305, 310, 311, 334 Income, 16–18, 22–24 Khan, 14, 366 NCI60, 4, 5, 14, 407, 409–412 OJ, 14, 334, 371 Portfolio , 14, 194 Smarket, 3, 14, 154, 161, 162, 171 USArrests , 14, 377, 378, 381–383 Index 421 Wage, 1, 2, 9, 10, 14, 267, 269, 271, 272, 274–277, 280, 281, 283, 284, 286, 287, 299 Weekly, 14, 171, 200 decision tree, 12, 303–316 Default data set, 14, 128–137, 144–148, 198, 199 degrees of freedom, 32, 241, 271, 272, 278 dendrogram, 386, 390–396 density function, 138 dependent variable, 15 derivative, 272, 278 deviance, 206 dimension reduction, 204, 228–238 discriminant function, 141 dissimilarity, 396–398 distance correlation-based, 396–398, 416 Euclidean, 379, 387, 388, 394, 396–398 double-exponential distribution, 227 dummy variable, 82–86, 130, 134, 269 eﬀective degrees of freedom, 278 elbow, 409 error irreducible, 18, 32 rate, 37 reducible, 18 term, 16 Euclidean distance, 379, 387, 388, 394, 396–398, 416 expected value, 19 exploratory data analysis, 374 F-statistic, 75 factor, 84 false discovery proportion, 147 false negative, 147false positive, 147 false positive rate, 147, 149, 354 feature, 15 feature selection, 204 Fisher’s linear discriminant, 141 ﬁt, 21 ﬁtted value, 93 ﬂexible, 22 for loop, 193 forward stepwise selection, 78, 207–208, 247 function, 42 Gaussian (normal) distribution, 138, 139, 142–143 generalized additive model, 6, 26, 265, 266, 282–287, 294 generalized linear model, 6, 156, 192 Gini index, 311–312, 319, 332 Heartdata set, 312, 313, 317–320, 354, 355 heatmap, 47 heteroscedasticity, 95–96 hierarchical clustering, 390–396 dendrogram, 390–394 inversion, 395 linkage, 394–396 hierarchical principle, 89 high-dimensional, 78, 208, 239 hinge loss, 357 histogram, 50 Hitters data set, 14, 244, 251, 255, 256, 304, 305, 310, 311, 334 hold-out set, 176 hyperplane, 338–343 hypothesis test, 67–68, 75, 95 Incomedata set, 16–18, 22–24 independent variable, 15 indicator function, 268 inference, 17, 19 422 Index inner product, 351 input variable, 15 integral, 278 interaction, 60, 81, 87–90, 104, 286 intercept, 61, 63 interpretability, 203 inversion, 395 irreducible error, 18, 39, 82, 103 K-means clustering, 12, 386–389 K-nearest neighbors classiﬁer, 12, 38–40, 127 regression, 104–109 kernel, 350–353, 356, 367 linear, 352 non-linear, 349–353 polynomial, 352, 354 radial, 352–354, 363 kernel trick, 351 Khandata set, 14, 366 knot, 266, 271, 273–275 Laplace distribution, 227 lasso, 12, 25, 219–227, 241–242, 309, 357 leaf, 305, 391 least squares, 6, 21, 61–63, 133, 203 line, 63 weighted, 96 level, 84 leverage, 97–99 likelihood function, 133 linear, 2, 86 linear combination, 121, 204, 229, 375 linear discriminant analysis, 6, 12, 127, 130, 138–147, 348, 354 linear kernel, 352 linear model, 20, 21, 59 linear regression, 6, 12 multiple, 71–82 simple, 61–71linkage, 394–396, 410 average, 394–396 centroid, 394–396 complete, 391, 394–396 single, 394–396 local regression, 266, 294 logistic function, 132 logistic regression, 6, 12, 26, 127, 131–137, 286–287, 349, 356–357 multiple, 135–137 logit, 132, 286, 291 loss function, 277, 357 low-dimensional, 238 main eﬀects, 88, 89 majority vote, 317 Mallow’s Cp, 78, 205, 206, 210–213 margin, 341, 357 matrix multiplication, 12 maximal margin classiﬁer, 337–343 hyperplane, 341 maximum likelihood, 132–133, 135 mean squared error, 29 misclassiﬁcation error, 37 missing data, 49 mixed selection, 79 model assessment, 175 model selection, 175 multicollinearity, 243 multivariate Gaussian, 142–143 multivariate normal, 142–143 natural spline, 274, 278, 293 NCI60data set, 4, 5, 14, 407, 409–412 negative predictive value, 147, 149 node internal, 305 purity, 311–312 terminal, 305 Index 423 noise, 22, 228 non-linear, 2, 12, 265–301 decision boundary, 349–353 kernel, 349–353 non-parametric, 21, 23–24, 104–109, 168 normal (Gaussian) distribution, 138, 139, 142–143 null, 145 hypothesis, 67 model, 78, 205, 220 odds, 132, 170 OJdata set, 14, 334, 371 one-standard-error rule, 214 one-versus-all, 356 one-versus-one, 355 optimal separating hyperplane, 341 optimism of training error, 32 ordered categorical variable, 292 orthogonal, 233, 377 basis, 288 out-of-bag, 317–318 outlier, 96–97 output variable, 15 overﬁtting, 22, 24, 26, 32, 80, 144, 207, 341 p-value, 67–68, 73 parameter, 61 parametric, 21–23, 104–109 partial least squares, 12, 230, 237–238, 258, 259 path algorithm, 224 perpendicular, 233 polynomial kernel, 352, 354 regression, 90–92, 265–268, 271 population regression line, 63 Portfolio data set, 14, 194 positive predictive value, 147, 149posterior distribution, 226 mode, 226 probability, 139 power, 101, 147 precision, 147 prediction, 17 interval, 82, 103 predictor, 15 principal components, 375 analysis, 12, 230–236, 374–385 loading vector, 375, 376 proportion of variance explained, 382–384, 408 regression, 12, 230–236, 256–257, 374–375, 385 score vector, 376 scree plot, 383–384 prior distribution, 226 probability, 138 projection, 204 pruning, 307–309 cost complexity, 307–309 weakest link, 307–309 quadratic, 91 quadratic discriminant analysis, 4, 149–150 qualitative, 3, 28, 127, 176 variable, 82–86 quantitative, 3, 28, 127, 176 R functions x2, 125 abline() , 112, 122, 301, 412 anova(), 116, 290, 291 apply(), 250, 401 as.dist() , 407 as.factor() ,5 0 attach() ,5 0 biplot() , 403 boot(), 194–196, 199 424 Index bs(), 293, 300 c(),4 3 cbind(), 164, 289 coef(), 111, 157, 247, 251 confint() , 111 contour() ,4 6 contrasts() , 118, 157 cor(), 44, 122, 155, 416 cumsum() , 404 cut(), 292 cutree() , 406 cv.glm() , 192, 193, 199 cv.glmnet() , 254 cv.tree() , 326, 328, 334 data.frame() , 171, 201, 262, 324 dev.off() ,4 6 dim(), 48, 49 dist(), 406, 416 fix(), 48, 54 for(), 193 gam(), 284, 294, 296 gbm(), 330 glm(), 156, 161, 192, 199, 291 glmnet() , 251, 253–255 hatvalues() , 113 hclust() , 406, 407 hist(), 50, 55 I(), 115, 289, 291, 296 identify() ,5 0 ifelse() , 324 image(),4 6 importance() , 330, 333, 334 is.na(), 244 jitter() , 292 jpeg(),4 6 kmeans() , 404, 405 knn(), 163, 164 lda(), 161, 162 legend() , 125 length() ,4 3 library() , 109, 110 lines(), 112lm(), 110, 112, 113, 115, 116, 121, 122, 156, 161, 191, 192, 254, 256, 288, 294, 324 lo(), 296 loadhistory() ,5 1 loess(), 294 ls(),4 3 matrix() ,4 4 mean(), 45, 158, 191, 401 median() , 171 model.matrix() ,251 na.omit() , 49, 244 names(), 49, 111 ns(), 293 pairs(), 50, 55 par(), 112, 289 pcr(), 256, 258 pdf(),4 6 persp(),4 7 plot(), 45, 46, 49, 55, 112, 122, 246, 295, 325, 360, 371, 406, 408 plot.gam() , 295 plot.svm() , 360 plsr(), 258 points() , 246 poly(), 116, 191, 288–290, 299 prcomp() , 402, 403, 416 predict() , 111, 157, 160, 162, 163, 191, 249, 250, 252, 253, 289, 291, 292, 296, 325, 327, 361, 364, 365 print(), 172 prune.misclass() , 327 prune.tree() , 328 q(),5 1 qda(), 162 quantile() , 201 rainbow() , 408 randomForest() ,329 range(),5 6 read.csv() , 49, 54, 418 Index 425 read.table() , 48, 49 regsubsets() ,244–249,262 residuals() , 112 return() , 172 rm(),4 3 rnorm(), 44, 45, 124, 262, 417 rstudent() , 112 runif(), 417 s(), 294 sample() , 191, 194, 414 savehistory() ,5 1 scale(), 165, 406, 417 sd(),4 5 seq(),4 6 set.seed() , 45, 191, 405 smooth.spline() , 293, 294 sqrt(), 44, 45 sum(), 244 summary() , 51, 55, 113, 121, 122, 157, 196, 199, 244, 245, 256, 257, 295, 324, 325, 328, 330, 334, 360, 361, 363, 372, 408 svm(), 359–363, 365, 366 table(), 158, 417 text(), 325 title(), 289 tree(), 304, 324 tune(), 361, 364, 372 update() , 114 var(),4 5 varImpPlot() , 330 vif(), 114 which.max() , 113, 246 which.min() , 246 write.table() ,4 8 radial kernel, 352–354, 363 random forest, 12, 303, 316, 320–321, 328–330 recall, 147 receiver operating characteristic (ROC), 147, 354–355 recursive binary splitting, 306, 309, 311reducible error, 18, 81 regression, 3, 12, 28–29 local, 265, 266, 280–282 piecewise polynomial, 271 polynomial, 265–268, 276–277 spline, 266, 270, 293 tree, 304–311, 327–328 regularization, 204, 215 replacement, 189 resampling, 175–190 residual, 62, 72 plot, 92 standard error, 66, 68–69, 79–80, 102 studentized, 97 sum of squares, 62, 70, 72 residuals, 239, 322 response, 15 ridge regression, 12, 215–219, 357 robust, 345, 348, 400 ROC curve, 147, 354–355 rug plot, 292 scale invariant, 217 scatterplot, 49 scatterplot matrix, 50 scree plot, 383–384, 409 elbow, 384 seed, 191 semi-supervised learning, 28 sensitivity, 145, 147 separating hyperplane, 338–343 shrinkage, 204, 215 penalty, 215 signal, 228 slack variable, 346 slope, 61, 63 Smarket data set, 3, 14, 154, 161, 162, 171 smoother, 286 smoothing spline, 266, 277–280, 293 soft margin classiﬁer, 343–345 426 Index soft-thresholding, 225 sparse, 219, 228 sparsity, 219 speciﬁcity, 145, 147, 148 spline, 265, 271–280 cubic, 273 linear, 273 natural, 274, 278 regression, 266, 271–277 smoothing, 31, 266, 277–280 thin-plate, 23 standard error, 65, 93 standardize, 165 statistical model, 1 step function, 105, 265, 268–270 stepwise model selection, 12, 205, 207 stump, 323 subset selection, 204–214 subtree, 308 supervised learning, 26–28, 237 support vector, 342, 347, 357 classiﬁer, 337, 343–349 machine, 12, 26, 349–359 regression, 358 synergy, 60, 81, 87–90, 104 systematic, 16 t-distribution, 67, 153 t-statistic, 67 test error, 37, 40, 158 MSE, 29–34 observations, 30 set, 32 time series, 94 total sum of squares, 70 tracking, 94 train, 21 training data, 21 error, 37, 40, 158 MSE, 29–33tree, 303–316 tree-based method, 303 true negative, 147 true positive, 147 true positive rate, 147, 149, 354 truncated power basis, 273 tuning parameter, 215 Type I error, 147 Type II error, 147 unsupervised learning, 26–28, 230, 237, 373–413 USArrests data set, 14, 377, 378, 381–383 validation set, 176 approach, 176–178 variable, 15 dependent, 15 dummy, 82–86, 89–90 importance, 319, 330 independent, 15 indicator, 37 input, 15 output, 15 qualitative, 82–86, 89–90 selection, 78, 204, 219 variance, 19, 33–36 inﬂation factor, 101–103, 114 varying coeﬃcient model, 282 vector, 43 Wagedata set, 1, 2, 9, 10, 14, 267, 269, 271, 272, 274–277, 280, 281, 283, 284, 286, 287, 299 weakest link pruning, 308 Weeklydata set, 14, 171, 200 weighted least squares, 96, 282 within class covariance, 143 workspace, 51 wrapper, 289"
}